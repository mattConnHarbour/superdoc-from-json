var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _a, _DocxExporter_instances, generate_xml_as_list_fn, replaceSpecialCharacters_fn, generateXml_fn, _SuperConverter_instances, exportNumberingFile_fn, prepareCommentsXmlFilesForExport_fn, exportProcessHeadersFooters_fn, exportProcessNewRelationships_fn, exportProcessMediaFiles_fn;
import { createElementBlock, openBlock, createElementVNode } from "vue";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code.length; i$1 < len; ++i$1) {
  lookup[i$1] = code[i$1];
  revLookup[code.charCodeAt(i$1)] = i$1;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s = buffer2[offset + i];
  i += d2;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset + i], i += d2, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e, m2, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
  }
  buffer2[offset + i - d2] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer3;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b2 = fromObject(value);
    if (b2) return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer3, GlobalUint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy2 = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new GlobalUint8Array(array);
    } else if (length === void 0) {
      buf = new GlobalUint8Array(array, byteOffset);
    } else {
      buf = new GlobalUint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a, b2) {
    if (isInstance(a, GlobalUint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
    if (isInstance(b2, GlobalUint8Array)) b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
    if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b2) return 0;
    let x = a.length;
    let y2 = b2.length;
    for (let i = 0, len = Math.min(x, y2); i < len; ++i) {
      if (a[i] !== b2[i]) {
        x = a[i];
        y2 = b2[i];
        break;
      }
    }
    if (x < y2) return -1;
    if (y2 < x) return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b2, n, m2) {
    const i = b2[n];
    b2[n] = b2[m2];
    b2[m2] = i;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b2) {
    if (!Buffer3.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
    if (this === b2) return true;
    return Buffer3.compare(this, b2) === 0;
  };
  Buffer3.prototype.inspect = function inspect() {
    let str = "";
    const max2 = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, GlobalUint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y2 = end - start;
    const len = Math.min(x, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x < y2) return -1;
    if (y2 < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found2 = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read(arr, i + j2) !== read(val, j2)) {
            found2 = false;
            break;
          }
        }
        if (found2) return i;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i;
    for (i = 0; i < length; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while (i < end) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    let val = this[offset + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max2, min2) {
    if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength3;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max2, min2) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy2(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      GlobalUint8Array.prototype.set.call(
        target,
        this.subarray(start, end),
        targetStart
      );
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range2}. Received ${received}`;
      return msg;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i >= start + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset, byteLength3) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength3] === void 0) {
      boundsError(offset, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf, offset, byteLength3) {
    if (value > max2 || value < min2) {
      const n = typeof min2 === "bigint" ? "n" : "";
      let range2;
      {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range2 = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i;
    for (i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = (function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i] + alphabet[j2];
      }
    }
    return table;
  })();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const Buffer2 = buffer.Buffer;
var sax = {};
var events = { exports: {} };
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events.exports;
  hasRequiredEvents = 1;
  var R2 = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R2 && typeof R2.ownKeys === "function") {
    ReflectOwnKeys = R2.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
    return value !== value;
  };
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  events.exports = EventEmitter;
  events.exports.once = once;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = void 0;
  EventEmitter.prototype._eventsCount = 0;
  EventEmitter.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    }
    this._maxListeners = n;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter.prototype.emit = function emit(type2) {
    var args = [];
    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
    var doError = type2 === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err.context = er;
      throw err;
    }
    var handler = events2[type2];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        ReflectApply(listeners[i], this, args);
    }
    return true;
  };
  function _addListener(target, type2, listener, prepend) {
    var m2;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit(
          "newListener",
          type2,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type2];
    }
    if (existing === void 0) {
      existing = events2[type2] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type2] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m2 = _getMaxListeners(target);
      if (m2 > 0 && existing.length > m2 && !existing.warned) {
        existing.warned = true;
        var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w2.name = "MaxListenersExceededWarning";
        w2.emitter = target;
        w2.type = type2;
        w2.count = existing.length;
        ProcessEmitWarning(w2);
      }
    }
    return target;
  }
  EventEmitter.prototype.addListener = function addListener(type2, listener) {
    return _addListener(this, type2, listener, false);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.prependListener = function prependListener(type2, listener) {
    return _addListener(this, type2, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type2, listener) {
    var state2 = { fired: false, wrapFn: void 0, target, type: type2, listener };
    var wrapped = onceWrapper.bind(state2);
    wrapped.listener = listener;
    state2.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter.prototype.once = function once2(type2, listener) {
    checkListener(listener);
    this.on(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
    checkListener(listener);
    this.prependListener(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter.prototype.removeListener = function removeListener(type2, listener) {
    var list, events2, position, i, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list = events2[type2];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type2];
        if (events2.removeListener)
          this.emit("removeListener", type2, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i = list.length - 1; i >= 0; i--) {
        if (list[i] === listener || list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne(list, position);
      }
      if (list.length === 1)
        events2[type2] = list[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type2, originalListener || listener);
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type2) {
    var listeners, events2, i;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type2] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type2];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys2 = Object.keys(events2);
      var key;
      for (i = 0; i < keys2.length; ++i) {
        key = keys2[i];
        if (key === "removeListener") continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type2];
    if (typeof listeners === "function") {
      this.removeListener(type2, listeners);
    } else if (listeners !== void 0) {
      for (i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(type2, listeners[i]);
      }
    }
    return this;
  };
  function _listeners(target, type2, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type2];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter.prototype.listeners = function listeners(type2) {
    return _listeners(this, type2, true);
  };
  EventEmitter.prototype.rawListeners = function rawListeners(type2) {
    return _listeners(this, type2, false);
  };
  EventEmitter.listenerCount = function(emitter, type2) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type2);
    } else {
      return listenerCount.call(emitter, type2);
    }
  };
  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type2) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type2];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr, n) {
    var copy2 = new Array(n);
    for (var i = 0; i < n; ++i)
      copy2[i] = arr[i];
    return copy2;
  }
  function spliceOne(list, index) {
    for (; index + 1 < list.length; index++)
      list[index] = list[index + 1];
    list.pop();
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  function once(emitter, name) {
    return new Promise(function(resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  return events.exports;
}
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser$1 = { exports: {} };
var process = browser$1.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
  return [];
};
process.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$1.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var streamBrowser;
var hasRequiredStreamBrowser;
function requireStreamBrowser() {
  if (hasRequiredStreamBrowser) return streamBrowser;
  hasRequiredStreamBrowser = 1;
  streamBrowser = requireEvents().EventEmitter;
  return streamBrowser;
}
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports) {
    Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    var buffer2 = {};
    var base64Js2 = {};
    base64Js2.byteLength = byteLength2;
    base64Js2.toByteArray = toByteArray2;
    base64Js2.fromByteArray = fromByteArray2;
    var lookup2 = [];
    var revLookup2 = [];
    var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code2.length; i < len; ++i) {
      lookup2[i] = code2[i];
      revLookup2[code2.charCodeAt(i)] = i;
    }
    revLookup2["-".charCodeAt(0)] = 62;
    revLookup2["_".charCodeAt(0)] = 63;
    function getLens2(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength2(b64) {
      var lens = getLens2(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength2(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens2(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr2(_byteLength2(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 18 | revLookup2[b64.charCodeAt(i2 + 1)] << 12 | revLookup2[b64.charCodeAt(i2 + 2)] << 6 | revLookup2[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 2 | revLookup2[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 10 | revLookup2[b64.charCodeAt(i2 + 1)] << 4 | revLookup2[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase642(num) {
      return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
    }
    function encodeChunk2(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase642(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk2(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    var ieee7542 = {};
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    ieee7542.read = function(buffer3, offset, isLE, mLen, nBytes) {
      var e, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s = buffer3[offset + i2];
      i2 += d2;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer3[offset + i2], i2 += d2, nBits -= 8) {
      }
      m2 = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer3[offset + i2], i2 += d2, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m2 ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
    };
    ieee7542.write = function(buffer3, value, offset, isLE, mLen, nBytes) {
      var e, m2, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m2 = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m2 = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer3[offset + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
      }
      e = e << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer3[offset + i2] = e & 255, i2 += d2, e /= 256, eLen -= 8) {
      }
      buffer3[offset + i2 - d2] |= s * 128;
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    (function(exports2) {
      const base64 = base64Js2;
      const ieee754$1 = ieee7542;
      const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports2.Buffer = Buffer4;
      exports2.SlowBuffer = SlowBuffer;
      exports2.INSPECT_MAX_BYTES = 50;
      const K_MAX_LENGTH = 2147483647;
      exports2.kMaxLength = K_MAX_LENGTH;
      const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer4.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer4.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length) {
        if (length > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length);
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function Buffer4(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from(arg, encodingOrOffset, length);
      }
      Buffer4.poolSize = 8192;
      function from(value, encodingOrOffset, length) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer4.from(valueOf, encodingOrOffset, length);
        }
        const b2 = fromObject(value);
        if (b2) return b2;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer4.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer4.from = function(value, encodingOrOffset, length) {
        return from(value, encodingOrOffset, length);
      };
      Object.setPrototypeOf(Buffer4.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer4, GlobalUint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer4.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer4.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer4.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length = byteLength3(string, encoding) | 0;
        let buf = createBuffer(length);
        const actual = buf.write(string, encoding);
        if (actual !== length) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length);
        for (let i2 = 0; i2 < length; i2 += 1) {
          buf[i2] = array[i2] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy2 = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length);
        }
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer4.isBuffer(obj)) {
          const len2 = checked(obj.length) | 0;
          const buf = createBuffer(len2);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len2);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length) {
        if (length >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length | 0;
      }
      function SlowBuffer(length) {
        if (+length != length) {
          length = 0;
        }
        return Buffer4.alloc(+length);
      }
      Buffer4.isBuffer = function isBuffer(b2) {
        return b2 != null && b2._isBuffer === true && b2 !== Buffer4.prototype;
      };
      Buffer4.compare = function compare(a, b2) {
        if (isInstance(a, GlobalUint8Array)) a = Buffer4.from(a, a.offset, a.byteLength);
        if (isInstance(b2, GlobalUint8Array)) b2 = Buffer4.from(b2, b2.offset, b2.byteLength);
        if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b2)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b2) return 0;
        let x = a.length;
        let y2 = b2.length;
        for (let i2 = 0, len2 = Math.min(x, y2); i2 < len2; ++i2) {
          if (a[i2] !== b2[i2]) {
            x = a[i2];
            y2 = b2[i2];
            break;
          }
        }
        if (x < y2) return -1;
        if (y2 < x) return 1;
        return 0;
      };
      Buffer4.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer4.concat = function concat(list, length) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer4.alloc(0);
        }
        let i2;
        if (length === void 0) {
          length = 0;
          for (i2 = 0; i2 < list.length; ++i2) {
            length += list[i2].length;
          }
        }
        const buffer3 = Buffer4.allocUnsafe(length);
        let pos = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          let buf = list[i2];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer3.length) {
              if (!Buffer4.isBuffer(buf)) buf = Buffer4.from(buf);
              buf.copy(buffer3, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer3,
                buf,
                pos
              );
            }
          } else if (!Buffer4.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer3, pos);
          }
          pos += buf.length;
        }
        return buffer3;
      };
      function byteLength3(string, encoding) {
        if (Buffer4.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len2 = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len2 === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len2;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len2 * 2;
            case "hex":
              return len2 >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.byteLength = byteLength3;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.prototype._isBuffer = true;
      function swap(b2, n, m2) {
        const i2 = b2[n];
        b2[n] = b2[m2];
        b2[m2] = i2;
      }
      Buffer4.prototype.swap16 = function swap16() {
        const len2 = this.length;
        if (len2 % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 2) {
          swap(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer4.prototype.swap32 = function swap32() {
        const len2 = this.length;
        if (len2 % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 4) {
          swap(this, i2, i2 + 3);
          swap(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer4.prototype.swap64 = function swap64() {
        const len2 = this.length;
        if (len2 % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 8) {
          swap(this, i2, i2 + 7);
          swap(this, i2 + 1, i2 + 6);
          swap(this, i2 + 2, i2 + 5);
          swap(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer4.prototype.toString = function toString() {
        const length = this.length;
        if (length === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length);
        return slowToString.apply(this, arguments);
      };
      Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
      Buffer4.prototype.equals = function equals(b2) {
        if (!Buffer4.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
        if (this === b2) return true;
        return Buffer4.compare(this, b2) === 0;
      };
      Buffer4.prototype.inspect = function inspect() {
        let str = "";
        const max2 = exports2.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max2) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
      }
      Buffer4.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer4.from(target, target.offset, target.byteLength);
        }
        if (!Buffer4.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x = thisEnd - thisStart;
        let y2 = end - start;
        const len2 = Math.min(x, y2);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i2 = 0; i2 < len2; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x = thisCopy[i2];
            y2 = targetCopy[i2];
            break;
          }
        }
        if (x < y2) return -1;
        if (y2 < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer3, val, byteOffset, encoding, dir) {
        if (buffer3.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer3.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer3.length + byteOffset;
        if (byteOffset >= buffer3.length) {
          if (dir) return -1;
          else byteOffset = buffer3.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer4.from(val, encoding);
        }
        if (Buffer4.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer3, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer3, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read(buf, i3) {
          if (indexSize === 1) {
            return buf[i3];
          } else {
            return buf.readUInt16BE(i3 * indexSize);
          }
        }
        let i2;
        if (dir) {
          let foundIndex = -1;
          for (i2 = byteOffset; i2 < arrLength; i2++) {
            if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
              if (foundIndex === -1) foundIndex = i2;
              if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i2 -= i2 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i2 = byteOffset; i2 >= 0; i2--) {
            let found2 = true;
            for (let j2 = 0; j2 < valLength; j2++) {
              if (read(arr, i2 + j2) !== read(val, j2)) {
                found2 = false;
                break;
              }
            }
            if (found2) return i2;
          }
        }
        return -1;
      }
      Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset, length) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = Number(length);
          if (length > remaining) {
            length = remaining;
          }
        }
        const strLen = string.length;
        if (length > strLen / 2) {
          length = strLen / 2;
        }
        let i2;
        for (i2 = 0; i2 < length; ++i2) {
          const parsed = parseInt(string.substr(i2 * 2, 2), 16);
          if (numberIsNaN(parsed)) return i2;
          buf[offset + i2] = parsed;
        }
        return i2;
      }
      function utf8Write(buf, string, offset, length) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
      }
      function asciiWrite(buf, string, offset, length) {
        return blitBuffer(asciiToBytes(string), buf, offset, length);
      }
      function base64Write(buf, string, offset, length) {
        return blitBuffer(base64ToBytes(string), buf, offset, length);
      }
      function ucs2Write(buf, string, offset, length) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
      }
      Buffer4.prototype.write = function write(string, offset, length, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length = this.length;
          offset = 0;
        } else if (length === void 0 && typeof offset === "string") {
          encoding = offset;
          length = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length;
            length = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset;
        if (length === void 0 || length > remaining) length = remaining;
        if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset, length);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset, length);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset, length);
            case "base64":
              return base64Write(this, string, offset, length);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset, length);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer4.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i2 = start;
        while (i2 < end) {
          const firstByte = buf[i2];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i2 + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i2 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                fourthByte = buf[i2 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i2 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      const MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len2 = codePoints.length;
        if (len2 <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i2 = 0;
        while (i2 < len2) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i2 = start; i2 < end; ++i2) {
          ret += String.fromCharCode(buf[i2]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len2 = buf.length;
        if (!start || start < 0) start = 0;
        if (!end || end < 0 || end > len2) end = len2;
        let out = "";
        for (let i2 = start; i2 < end; ++i2) {
          out += hexSliceLookupTable[buf[i2]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
          res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
        }
        return res;
      }
      Buffer4.prototype.slice = function slice(start, end) {
        const len2 = this.length;
        start = ~~start;
        end = end === void 0 ? len2 : ~~end;
        if (start < 0) {
          start += len2;
          if (start < 0) start = 0;
        } else if (start > len2) {
          start = len2;
        }
        if (end < 0) {
          end += len2;
          if (end < 0) end = 0;
        } else if (end > len2) {
          end = len2;
        }
        if (end < start) end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer4.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length) {
        if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
        if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength4, this.length);
        let val = this[offset];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength4 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength4, this.length);
        }
        let val = this[offset + --byteLength4];
        let mul = 1;
        while (byteLength4 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength4] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer4.prototype.readIntLE = function readIntLE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength4, this.length);
        let val = this[offset];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength4 && (mul *= 256)) {
          val += this[offset + i2] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
        return val;
      };
      Buffer4.prototype.readIntBE = function readIntBE(offset, byteLength4, noAssert) {
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset, byteLength4, this.length);
        let i2 = byteLength4;
        let mul = 1;
        let val = this[offset + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val += this[offset + --i2] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
        return val;
      };
      Buffer4.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128)) return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer4.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer4.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer4.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer4.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + // Overflow
        this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer4.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, true, 23, 4);
      };
      Buffer4.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 4, this.length);
        return ieee754$1.read(this, offset, false, 23, 4);
      };
      Buffer4.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, true, 52, 8);
      };
      Buffer4.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert) checkOffset(offset, 8, this.length);
        return ieee754$1.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max2, min2) {
        if (!Buffer4.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength4) - 1;
          checkInt(this, value, offset, byteLength4, maxBytes, 0);
        }
        let mul = 1;
        let i2 = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength4 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength4;
      };
      Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength4) - 1;
          checkInt(this, value, offset, byteLength4, maxBytes, 0);
        }
        let i2 = byteLength4 - 1;
        let mul = 1;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset + i2] = value / mul & 255;
        }
        return offset + byteLength4;
      };
      Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer4.prototype.writeIntLE = function writeIntLE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength4 - 1);
          checkInt(this, value, offset, byteLength4, limit - 1, -limit);
        }
        let i2 = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i2 < byteLength4 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength4;
      };
      Buffer4.prototype.writeIntBE = function writeIntBE(value, offset, byteLength4, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength4 - 1);
          checkInt(this, value, offset, byteLength4, limit - 1, -limit);
        }
        let i2 = byteLength4 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength4;
      };
      Buffer4.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max2, min2) {
        if (offset + ext > buf.length) throw new RangeError("Index out of range");
        if (offset < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8);
        }
        ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer4.prototype.copy = function copy2(target, targetStart, start, end) {
        if (!Buffer4.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start) start = 0;
        if (!end && end !== 0) end = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end > 0 && end < start) end = start;
        if (end === start) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
        if (end < 0) throw new RangeError("sourceEnd out of bounds");
        if (end > this.length) end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len2 = end - start;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start, end),
            targetStart
          );
        }
        return len2;
      };
      Buffer4.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code3 = val.charCodeAt(0);
            if (encoding === "utf8" && code3 < 128 || encoding === "latin1") {
              val = code3;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val) val = 0;
        let i2;
        if (typeof val === "number") {
          for (i2 = start; i2 < end; ++i2) {
            this[i2] = val;
          }
        } else {
          const bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
          const len2 = bytes.length;
          if (len2 === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i2 = 0; i2 < end - start; ++i2) {
            this[i2 + start] = bytes[i2 % len2];
          }
        }
        return this;
      };
      const errors = {};
      function E2(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E2(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E2(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E2(
        "ERR_OUT_OF_RANGE",
        function(str, range2, input) {
          let msg = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg += ` It must be ${range2}. Received ${received}`;
          return msg;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i2 = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i2 >= start + 4; i2 -= 3) {
          res = `_${val.slice(i2 - 3, i2)}${res}`;
        }
        return `${val.slice(0, i2)}${res}`;
      }
      function checkBounds(buf, offset, byteLength4) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength4] === void 0) {
          boundsError(offset, buf.length - (byteLength4 + 1));
        }
      }
      function checkIntBI(value, min2, max2, buf, offset, byteLength4) {
        if (value > max2 || value < min2) {
          const n = typeof min2 === "bigint" ? "n" : "";
          let range2;
          {
            if (min2 === 0 || min2 === BigInt(0)) {
              range2 = `>= 0${n} and < 2${n} ** ${(byteLength4 + 1) * 8}${n}`;
            } else {
              range2 = `>= -(2${n} ** ${(byteLength4 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength4 + 1) * 8 - 1}${n}`;
            }
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
        }
        checkBounds(buf, offset, byteLength4);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length, type2) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type2);
          throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
        }
        if (length < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          "offset",
          `>= ${0} and <= ${length}`,
          value
        );
      }
      const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i2 = 0; i2 < length; ++i2) {
          codePoint = string.charCodeAt(i2);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i2 + 1 === length) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          byteArray.push(str.charCodeAt(i2) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          if ((units -= 2) < 0) break;
          c = str.charCodeAt(i2);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset, length) {
        let i2;
        for (i2 = 0; i2 < length; ++i2) {
          if (i2 + offset >= dst.length || i2 >= src.length) break;
          dst[i2 + offset] = src[i2];
        }
        return i2;
      }
      function isInstance(obj, type2) {
        return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      const hexSliceLookupTable = (function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i2 = 0; i2 < 16; ++i2) {
          const i16 = i2 * 16;
          for (let j2 = 0; j2 < 16; ++j2) {
            table[i16 + j2] = alphabet[i2] + alphabet[j2];
          }
        }
        return table;
      })();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    })(buffer2);
    const Buffer3 = buffer2.Buffer;
    exports.Blob = buffer2.Blob;
    exports.BlobOptions = buffer2.BlobOptions;
    exports.Buffer = buffer2.Buffer;
    exports.File = buffer2.File;
    exports.FileOptions = buffer2.FileOptions;
    exports.INSPECT_MAX_BYTES = buffer2.INSPECT_MAX_BYTES;
    exports.SlowBuffer = buffer2.SlowBuffer;
    exports.TranscodeEncoding = buffer2.TranscodeEncoding;
    exports.atob = buffer2.atob;
    exports.btoa = buffer2.btoa;
    exports.constants = buffer2.constants;
    exports.default = Buffer3;
    exports.isAscii = buffer2.isAscii;
    exports.isUtf8 = buffer2.isUtf8;
    exports.kMaxLength = buffer2.kMaxLength;
    exports.kStringMaxLength = buffer2.kStringMaxLength;
    exports.resolveObjectURL = buffer2.resolveObjectURL;
    exports.transcode = buffer2.transcode;
  })(dist);
  return dist;
}
var util = {};
var types = {};
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _2 in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b2) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j2 = 0; j2 < b2.length; j2 += 1) {
      arr[j2 + a.length] = b2[j2];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j2 = 0; i < arrLike.length; i += 1, j2 += 1) {
      arr[j2] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind2 = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind2([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O2) {
    return reflectGetProto(O2);
  } : originalGetProto ? function getProto2(O2) {
    if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O2);
  } : getDunderProto ? function getProto2(O2) {
    return getDunderProto(O2);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? (function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  })() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void undefined$1;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var $toString = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = (function() {
    return isStandardArguments(arguments);
  })();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments;
}
var isRegex;
var hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var hasToStringTag = requireShams()();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var fn;
  if (hasToStringTag) {
    var $exec = callBound2("RegExp.prototype.exec");
    var isRegexMarker = {};
    var throwRegexMarker = function() {
      throw isRegexMarker;
    };
    var badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
    fn = function isRegex2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = (
        /** @type {NonNullable<typeof gOPD>} */
        gOPD2(
          /** @type {{ lastIndex?: unknown }} */
          value,
          "lastIndex"
        )
      );
      var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(
          value,
          /** @type {string} */
          /** @type {unknown} */
          badStringifier
        );
      } catch (e) {
        return e === isRegexMarker;
      }
    };
  } else {
    var $toString = callBound2("Object.prototype.toString");
    var regexClass = "[object RegExp]";
    fn = function isRegex2(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
  isRegex = fn;
  return isRegex;
}
var safeRegexTest;
var hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var isRegex2 = requireIsRegex();
  var $exec = callBound2("RegExp.prototype.exec");
  var $TypeError = /* @__PURE__ */ requireType();
  safeRegexTest = function regexTester(regex) {
    if (!isRegex2(regex)) {
      throw new $TypeError("`regex` must be a RegExp");
    }
    return function test(s) {
      return $exec(regex, s) !== null;
    };
  };
  return safeRegexTest;
}
var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var safeRegexTest2 = /* @__PURE__ */ requireSafeRegexTest();
  var isFnRegex = safeRegexTest2(/^\s*(?:function)?\*/);
  var hasToStringTag = requireShams()();
  var getProto2 = requireGetProto();
  var toStr = callBound2("Object.prototype.toString");
  var fnToStr = callBound2("Function.prototype.toString");
  var getGeneratorFunc = function() {
    if (!hasToStringTag) {
      return false;
    }
    try {
      return Function("return function*() {}")();
    } catch (e) {
    }
  };
  var GeneratorFunction;
  isGeneratorFunction = function isGeneratorFunction2(fn) {
    if (typeof fn !== "function") {
      return false;
    }
    if (isFnRegex(fnToStr(fn))) {
      return true;
    }
    if (!hasToStringTag) {
      var str = toStr(fn);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto2) {
      return false;
    }
    if (typeof GeneratorFunction === "undefined") {
      var generatorFunc = getGeneratorFunc();
      GeneratorFunction = generatorFunc ? (
        /** @type {GeneratorFunctionConstructor} */
        getProto2(generatorFunc)
      ) : false;
    }
    return getProto2(fn) === GeneratorFunction;
  };
  return isGeneratorFunction;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply2 = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply2 === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply2(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_2) {
      if (_2 !== isCallableMarker) {
        reflectApply2 = null;
      }
    }
  } else {
    reflectApply2 = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) {
      isDDA = function isDocumentDotAll(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
          } catch (e) {
          }
        }
        return false;
      };
    }
  }
  isCallable = reflectApply2 ? function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply2(value, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
  return isCallable;
}
var forEach;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var isCallable2 = requireIsCallable();
  var toStr = Object.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (hasOwnProperty.call(array, i)) {
        if (receiver == null) {
          iterator(array[i], i, array);
        } else {
          iterator.call(receiver, array[i], i, array);
        }
      }
    }
  };
  var forEachString = function forEachString2(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
      if (receiver == null) {
        iterator(string.charAt(i), i, string);
      } else {
        iterator.call(receiver, string.charAt(i), i, string);
      }
    }
  };
  var forEachObject = function forEachObject2(object, iterator, receiver) {
    for (var k in object) {
      if (hasOwnProperty.call(object, k)) {
        if (receiver == null) {
          iterator(object[k], k, object);
        } else {
          iterator.call(receiver, object[k], k, object);
        }
      }
    }
  };
  function isArray(x) {
    return toStr.call(x) === "[object Array]";
  }
  forEach = function forEach2(list, iterator, thisArg) {
    if (!isCallable2(iterator)) {
      throw new TypeError("iterator must be a function");
    }
    var receiver;
    if (arguments.length >= 3) {
      receiver = thisArg;
    }
    if (isArray(list)) {
      forEachArray(list, iterator, receiver);
    } else if (typeof list === "string") {
      forEachString(list, iterator, receiver);
    } else {
      forEachObject(list, iterator, receiver);
    }
  };
  return forEach;
}
var possibleTypedArrayNames;
var hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  if (hasRequiredPossibleTypedArrayNames) return possibleTypedArrayNames;
  hasRequiredPossibleTypedArrayNames = 1;
  possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  return possibleTypedArrayNames;
}
var availableTypedArrays;
var hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var possibleNames = /* @__PURE__ */ requirePossibleTypedArrayNames();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  availableTypedArrays = function availableTypedArrays2() {
    var out = [];
    for (var i = 0; i < possibleNames.length; i++) {
      if (typeof g[possibleNames[i]] === "function") {
        out[out.length] = possibleNames[i];
      }
    }
    return out;
  };
  return availableTypedArrays;
}
var callBind = { exports: {} };
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var gopd2 = /* @__PURE__ */ requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var define = /* @__PURE__ */ requireDefineDataProperty();
  var hasDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var $TypeError = /* @__PURE__ */ requireType();
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD2) {
      var desc = gOPD2(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length,
          true,
          true
        );
      } else {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length
        );
      }
    }
    return fn;
  };
  return setFunctionLength;
}
var applyBind;
var hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var actualApply2 = requireActualApply();
  applyBind = function applyBind2() {
    return actualApply2(bind2, $apply, arguments);
  };
  return applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind) return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module) {
    var setFunctionLength2 = /* @__PURE__ */ requireSetFunctionLength();
    var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
    var callBindBasic = requireCallBindApplyHelpers();
    var applyBind2 = requireApplyBind();
    module.exports = function callBind2(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength2(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind2 });
    } else {
      module.exports.apply = applyBind2;
    }
  })(callBind);
  return callBind.exports;
}
var whichTypedArray;
var hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var forEach2 = requireForEach();
  var availableTypedArrays2 = /* @__PURE__ */ requireAvailableTypedArrays();
  var callBind2 = requireCallBind();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var getProto2 = requireGetProto();
  var $toString = callBound2("Object.prototype.toString");
  var hasToStringTag = requireShams()();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays2();
  var $slice = callBound2("String.prototype.slice");
  var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for (var i = 0; i < array.length; i += 1) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  };
  var cache = { __proto__: null };
  if (hasToStringTag && gOPD2 && getProto2) {
    forEach2(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr && getProto2) {
        var proto = getProto2(arr);
        var descriptor = gOPD2(proto, Symbol.toStringTag);
        if (!descriptor && proto) {
          var superProto = getProto2(proto);
          descriptor = gOPD2(superProto, Symbol.toStringTag);
        }
        cache["$" + typedArray] = callBind2(descriptor.get);
      }
    });
  } else {
    forEach2(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      var fn = arr.slice || arr.set;
      if (fn) {
        cache[
          /** @type {`$${import('.').TypedArrayName}`} */
          "$" + typedArray
        ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
        // @ts-expect-error TODO FIXME
        callBind2(fn);
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var found2 = false;
    forEach2(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      cache,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, typedArray) {
        if (!found2) {
          try {
            if ("$" + getter(value) === typedArray) {
              found2 = /** @type {import('.').TypedArrayName} */
              $slice(typedArray, 1);
            }
          } catch (e) {
          }
        }
      }
    );
    return found2;
  };
  var trySlices = function tryAllSlices(value) {
    var found2 = false;
    forEach2(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      cache,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, name) {
        if (!found2) {
          try {
            getter(value);
            found2 = /** @type {import('.').TypedArrayName} */
            $slice(name, 1);
          } catch (e) {
          }
        }
      }
    );
    return found2;
  };
  whichTypedArray = function whichTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag) {
      var tag = $slice($toString(value), 8, -1);
      if ($indexOf(typedArrays, tag) > -1) {
        return tag;
      }
      if (tag !== "Object") {
        return false;
      }
      return trySlices(value);
    }
    if (!gOPD2) {
      return null;
    }
    return tryTypedArrays(value);
  };
  return whichTypedArray;
}
var isTypedArray;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
  isTypedArray = function isTypedArray2(value) {
    return !!whichTypedArray2(value);
  };
  return isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  (function(exports) {
    var isArgumentsObject = /* @__PURE__ */ requireIsArguments();
    var isGeneratorFunction2 = requireIsGeneratorFunction();
    var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
    var isTypedArray2 = /* @__PURE__ */ requireIsTypedArray();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction2;
    exports.isTypedArray = isTypedArray2;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray2(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray2(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray2(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray2(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray2(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray2(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray2(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray2(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray2(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray2(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray2(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  })(types);
  return types;
}
var isBufferBrowser;
var hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  if (hasRequiredIsBufferBrowser) return isBufferBrowser;
  hasRequiredIsBufferBrowser = 1;
  isBufferBrowser = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
  };
  return isBufferBrowser;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function(exports) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys2 = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys2.length; i++) {
        descriptors[keys2[i]] = Object.getOwnPropertyDescriptor(obj, keys2[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%") return "%";
        if (i >= len) return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_2) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports.deprecate = function(fn, msg) {
      if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
        return fn;
      }
      if (typeof process$1 === "undefined") {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process$1.throwDeprecation) {
            throw new Error(msg);
          } else if (process$1.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var debugEnv = process$1.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process$1.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys2 = Object.keys(value);
      var visibleKeys = arrayToHash(keys2);
      if (ctx.showHidden) {
        keys2 = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys2.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp2(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base = " [Function" + n + "]";
      }
      if (isRegExp2(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys2.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp2(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys2);
      } else {
        output = keys2.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys2) {
      var output = [];
      for (var i = 0, l3 = value.length; i < l3; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys2.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = requireTypes();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp2(re2) {
      return isObject(re2) && objectToString(re2) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp2;
    exports.types.isRegExp = isRegExp2;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d2) {
      return isObject(d2) && objectToString(d2) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = requireIsBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d2 = /* @__PURE__ */ new Date();
      var time = [
        pad(d2.getHours()),
        pad(d2.getMinutes()),
        pad(d2.getSeconds())
      ].join(":");
      return [d2.getDate(), months[d2.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = requireInherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject(add)) return origin;
      var keys2 = Object.keys(add);
      var i = keys2.length;
      while (i--) {
        origin[keys2[i]] = add[keys2[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process$1.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  })(util);
  return util;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  var _require = requireDist(), Buffer3 = _require.Buffer;
  var _require2 = requireUtil(), inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer3.prototype.copy.call(src, target, offset);
  }
  buffer_list = /* @__PURE__ */ (function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v2) {
        var entry = {
          data: v2,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v2) {
        var entry = {
          data: v2,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer3.alloc(0);
        var ret = Buffer3.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer3.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  })();
  return buffer_list;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
  }
  destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
var errorsBrowser = {};
var hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes = {};
  function createErrorType(code2, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ (function(_Base) {
      _inheritsLoose(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    })(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code2;
    codes[code2] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i) {
        return String(i);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name, " argument")) {
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type2 = includes(name, ".") ? "property" : "argument";
      msg = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(typeof actual);
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errorsBrowser.codes = codes;
  return errorsBrowser;
}
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = deprecate;
  function deprecate(fn, msg) {
    if (config("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function config(name) {
    try {
      if (!commonjsGlobal.localStorage) return false;
    } catch (_2) {
      return false;
    }
    var val = commonjsGlobal.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
  }
  return browser;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireBrowser()
  };
  var Stream = requireStreamBrowser();
  var Buffer3 = requireDist().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  requireInherits_browser()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer3.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer3.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state2.onwrite);
    else stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state2, finished, cb);
      } else {
        afterWrite(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream, state2, finished, cb) {
    if (!finished) onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l3 = state2.bufferedRequestCount;
      var buffer2 = new Array(l3);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process$1.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished) process$1.nextTick(cb);
      else stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys3 = [];
    for (var key in obj) keys3.push(key);
    return keys3;
  };
  _stream_duplex = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  requireInherits_browser()(Duplex, Readable);
  {
    var keys2 = objectKeys(Writable.prototype);
    for (var v2 = 0; v2 < keys2.length; v2++) {
      var method = keys2[v2];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer2 = requireDist();
    var Buffer3 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module.exports = buffer2;
    } else {
      copyProps(buffer2, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer3 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer3.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer3.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j2 = buf.length - 1;
    if (j2 < i) return 0;
    var nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j2 < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j2 < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop2);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  endOfStream = eos;
  return endOfStream;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = requireEndOfStream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  requireEvents().EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStreamBrowser();
  var Buffer3 = requireDist().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = requireUtil();
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = requireBuffer_list();
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  requireInherits_browser()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable)) return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer3.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);
            else maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process$1.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var index = indexOf(state2.pipes, dest);
    if (index === -1) return this;
    state2.pipes.splice(index, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading) stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = /* @__PURE__ */ (function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        })(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process$1.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFromBrowser();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l3 = xs.length; i < l3; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform2;
  var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  requireInherits_browser()(Transform2, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2)) return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough;
  var Transform2 = require_stream_transform();
  requireInherits_browser()(PassThrough, Transform2);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform2.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err) throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop2;
    if (typeof streams[streams.length - 1] !== "function") return noop2;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
var streamBrowserify;
var hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1;
  streamBrowserify = Stream;
  var EE = requireEvents().EventEmitter;
  var inherits = requireInherits_browser();
  inherits(Stream, EE);
  Stream.Readable = require_stream_readable();
  Stream.Writable = require_stream_writable();
  Stream.Duplex = require_stream_duplex();
  Stream.Transform = require_stream_transform();
  Stream.PassThrough = require_stream_passthrough();
  Stream.finished = requireEndOfStream();
  Stream.pipeline = requirePipeline();
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return streamBrowserify;
}
var hasRequiredSax;
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  (function(exports) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S2.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        if (parser.opt.unquotedAttributeValues === void 0) {
          parser.opt.unquotedAttributeValues = !strict;
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F2() {
          }
          F2.prototype = o;
          var newf = new F2();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l3 = buffers.length; i < l3; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m2 = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m2 + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l3 = buffers.length; i < l3; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = requireStreamBrowserify().Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      if (!Stream) Stream = function() {
      };
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h2) {
              if (!h2) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h2;
                return h2;
              }
              me.on(ev, h2);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer2 === "function" && typeof Buffer2.isBuffer === "function" && Buffer2.isBuffer(data)) {
          if (!this._decoder) {
            var SD = requireString_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S2 = 0;
      sax2.STATE = {
        BEGIN: S2++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S2++,
        // leading whitespace
        TEXT: S2++,
        // general stuff
        TEXT_ENTITY: S2++,
        // &amp and such.
        OPEN_WAKA: S2++,
        // <
        SGML_DECL: S2++,
        // <!BLARG
        SGML_DECL_QUOTED: S2++,
        // <!BLARG foo "bar
        DOCTYPE: S2++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S2++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S2++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S2++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S2++,
        // <!-
        COMMENT: S2++,
        // <!--
        COMMENT_ENDING: S2++,
        // <!-- blah -
        COMMENT_ENDED: S2++,
        // <!-- blah --
        CDATA: S2++,
        // <![CDATA[ something
        CDATA_ENDING: S2++,
        // ]
        CDATA_ENDING_2: S2++,
        // ]]
        PROC_INST: S2++,
        // <?hi
        PROC_INST_BODY: S2++,
        // <?hi there
        PROC_INST_ENDING: S2++,
        // <?hi "there" ?
        OPEN_TAG: S2++,
        // <strong
        OPEN_TAG_SLASH: S2++,
        // <strong /
        ATTRIB: S2++,
        // <a
        ATTRIB_NAME: S2++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S2++,
        // <a foo _
        ATTRIB_VALUE: S2++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S2++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S2++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S2++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S2++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S2++,
        // <foo bar=&quot
        CLOSE_TAG: S2++,
        // </a
        CLOSE_TAG_SAW_WHITE: S2++,
        // </a   >
        SCRIPT: S2++,
        // <script> ...
        SCRIPT_ENDING: S2++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax2.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e = sax2.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax2.ENTITIES[key] = s2;
      });
      for (var s in sax2.STATE) {
        sax2.STATE[sax2.STATE[s]] = s;
      }
      S2 = sax2.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l3 = parser.attribList.length; i < l3; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri2 = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri: uri2
            };
            if (prefix && prefix !== "xmlns" && !uri2) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S2.SCRIPT;
          } else {
            parser.state = S2.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S2.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S2.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close2 = parser.tags[t];
          if (close2.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S2.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S2.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S2.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S2.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S2.BEGIN:
              parser.state = S2.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S2.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S2.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S2.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S2.SCRIPT:
              if (c === "<") {
                parser.state = S2.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S2.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S2.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S2.SCRIPT;
              }
              continue;
            case S2.OPEN_WAKA:
              if (c === "!") {
                parser.state = S2.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) ;
              else if (isMatch(nameStart, c)) {
                parser.state = S2.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S2.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S2.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S2.TEXT;
              }
              continue;
            case S2.SGML_DECL:
              if (parser.sgmlDecl + c === "--") {
                parser.state = S2.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
                continue;
              }
              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                parser.state = S2.DOCTYPE_DTD;
                parser.doctype += "<!" + parser.sgmlDecl + c;
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S2.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S2.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S2.TEXT;
              } else if (isQuote(c)) {
                parser.state = S2.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S2.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S2.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S2.DOCTYPE:
              if (c === ">") {
                parser.state = S2.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S2.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S2.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S2.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S2.DOCTYPE;
              }
              continue;
            case S2.DOCTYPE_DTD:
              if (c === "]") {
                parser.doctype += c;
                parser.state = S2.DOCTYPE;
              } else if (c === "<") {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (isQuote(c)) {
                parser.doctype += c;
                parser.state = S2.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              } else {
                parser.doctype += c;
              }
              continue;
            case S2.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S2.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S2.COMMENT:
              if (c === "-") {
                parser.state = S2.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S2.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S2.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S2.COMMENT;
              }
              continue;
            case S2.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S2.COMMENT;
              } else if (parser.doctype && parser.doctype !== true) {
                parser.state = S2.DOCTYPE_DTD;
              } else {
                parser.state = S2.TEXT;
              }
              continue;
            case S2.CDATA:
              if (c === "]") {
                parser.state = S2.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S2.CDATA_ENDING:
              if (c === "]") {
                parser.state = S2.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S2.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.PROC_INST:
              if (c === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S2.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S2.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S2.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S2.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S2.PROC_INST_BODY;
              }
              continue;
            case S2.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S2.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S2.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser.opt.unquotedAttributeValues) {
                  error(parser, "Unquoted attribute value");
                }
                parser.state = S2.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S2.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S2.ATTRIB_VALUE_CLOSED;
              continue;
            case S2.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S2.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S2.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S2.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S2.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S2.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S2.TEXT_ENTITY:
            case S2.ATTRIB_VALUE_ENTITY_Q:
            case S2.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer2;
              switch (parser.state) {
                case S2.TEXT_ENTITY:
                  returnState = S2.TEXT;
                  buffer2 = "textNode";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S2.ATTRIB_VALUE_QUOTED;
                  buffer2 = "attribValue";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_U:
                  returnState = S2.ATTRIB_VALUE_UNQUOTED;
                  buffer2 = "attribValue";
                  break;
              }
              if (c === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.opt.unparsedEntities && !Object.values(sax2.XML_ENTITIES).includes(parsedEntity)) {
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer2] += parsedEntity;
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer2] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor2 = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor2(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports);
  })(sax);
  return sax;
}
var arrayHelper;
var hasRequiredArrayHelper;
function requireArrayHelper() {
  if (hasRequiredArrayHelper) return arrayHelper;
  hasRequiredArrayHelper = 1;
  arrayHelper = {
    isArray: function(value) {
      if (Array.isArray) {
        return Array.isArray(value);
      }
      return Object.prototype.toString.call(value) === "[object Array]";
    }
  };
  return arrayHelper;
}
var optionsHelper;
var hasRequiredOptionsHelper;
function requireOptionsHelper() {
  if (hasRequiredOptionsHelper) return optionsHelper;
  hasRequiredOptionsHelper = 1;
  var isArray = requireArrayHelper().isArray;
  optionsHelper = {
    copyOptions: function(options) {
      var key, copy2 = {};
      for (key in options) {
        if (options.hasOwnProperty(key)) {
          copy2[key] = options[key];
        }
      }
      return copy2;
    },
    ensureFlagExists: function(item, options) {
      if (!(item in options) || typeof options[item] !== "boolean") {
        options[item] = false;
      }
    },
    ensureSpacesExists: function(options) {
      if (!("spaces" in options) || typeof options.spaces !== "number" && typeof options.spaces !== "string") {
        options.spaces = 0;
      }
    },
    ensureAlwaysArrayExists: function(options) {
      if (!("alwaysArray" in options) || typeof options.alwaysArray !== "boolean" && !isArray(options.alwaysArray)) {
        options.alwaysArray = false;
      }
    },
    ensureKeyExists: function(key, options) {
      if (!(key + "Key" in options) || typeof options[key + "Key"] !== "string") {
        options[key + "Key"] = options.compact ? "_" + key : key;
      }
    },
    checkFnExists: function(key, options) {
      return key + "Fn" in options;
    }
  };
  return optionsHelper;
}
var xml2js;
var hasRequiredXml2js;
function requireXml2js() {
  if (hasRequiredXml2js) return xml2js;
  hasRequiredXml2js = 1;
  var sax2 = requireSax();
  var helper = requireOptionsHelper();
  var isArray = requireArrayHelper().isArray;
  var options;
  var currentElement;
  function validateOptions(userOptions) {
    options = helper.copyOptions(userOptions);
    helper.ensureFlagExists("ignoreDeclaration", options);
    helper.ensureFlagExists("ignoreInstruction", options);
    helper.ensureFlagExists("ignoreAttributes", options);
    helper.ensureFlagExists("ignoreText", options);
    helper.ensureFlagExists("ignoreComment", options);
    helper.ensureFlagExists("ignoreCdata", options);
    helper.ensureFlagExists("ignoreDoctype", options);
    helper.ensureFlagExists("compact", options);
    helper.ensureFlagExists("alwaysChildren", options);
    helper.ensureFlagExists("addParent", options);
    helper.ensureFlagExists("trim", options);
    helper.ensureFlagExists("nativeType", options);
    helper.ensureFlagExists("nativeTypeAttributes", options);
    helper.ensureFlagExists("sanitize", options);
    helper.ensureFlagExists("instructionHasAttributes", options);
    helper.ensureFlagExists("captureSpacesBetweenElements", options);
    helper.ensureAlwaysArrayExists(options);
    helper.ensureKeyExists("declaration", options);
    helper.ensureKeyExists("instruction", options);
    helper.ensureKeyExists("attributes", options);
    helper.ensureKeyExists("text", options);
    helper.ensureKeyExists("comment", options);
    helper.ensureKeyExists("cdata", options);
    helper.ensureKeyExists("doctype", options);
    helper.ensureKeyExists("type", options);
    helper.ensureKeyExists("name", options);
    helper.ensureKeyExists("elements", options);
    helper.ensureKeyExists("parent", options);
    helper.checkFnExists("doctype", options);
    helper.checkFnExists("instruction", options);
    helper.checkFnExists("cdata", options);
    helper.checkFnExists("comment", options);
    helper.checkFnExists("text", options);
    helper.checkFnExists("instructionName", options);
    helper.checkFnExists("elementName", options);
    helper.checkFnExists("attributeName", options);
    helper.checkFnExists("attributeValue", options);
    helper.checkFnExists("attributes", options);
    return options;
  }
  function nativeType(value) {
    var nValue = Number(value);
    if (!isNaN(nValue)) {
      return nValue;
    }
    var bValue = value.toLowerCase();
    if (bValue === "true") {
      return true;
    } else if (bValue === "false") {
      return false;
    }
    return value;
  }
  function addField(type2, value) {
    var key;
    if (options.compact) {
      if (!currentElement[options[type2 + "Key"]] && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type2 + "Key"]) !== -1 : options.alwaysArray)) {
        currentElement[options[type2 + "Key"]] = [];
      }
      if (currentElement[options[type2 + "Key"]] && !isArray(currentElement[options[type2 + "Key"]])) {
        currentElement[options[type2 + "Key"]] = [currentElement[options[type2 + "Key"]]];
      }
      if (type2 + "Fn" in options && typeof value === "string") {
        value = options[type2 + "Fn"](value, currentElement);
      }
      if (type2 === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            if ("instructionFn" in options) {
              value[key] = options.instructionFn(value[key], key, currentElement);
            } else {
              var temp = value[key];
              delete value[key];
              value[options.instructionNameFn(key, temp, currentElement)] = temp;
            }
          }
        }
      }
      if (isArray(currentElement[options[type2 + "Key"]])) {
        currentElement[options[type2 + "Key"]].push(value);
      } else {
        currentElement[options[type2 + "Key"]] = value;
      }
    } else {
      if (!currentElement[options.elementsKey]) {
        currentElement[options.elementsKey] = [];
      }
      var element = {};
      element[options.typeKey] = type2;
      if (type2 === "instruction") {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            break;
          }
        }
        element[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement) : key;
        if (options.instructionHasAttributes) {
          element[options.attributesKey] = value[key][options.attributesKey];
          if ("instructionFn" in options) {
            element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
          }
        } else {
          if ("instructionFn" in options) {
            value[key] = options.instructionFn(value[key], key, currentElement);
          }
          element[options.instructionKey] = value[key];
        }
      } else {
        if (type2 + "Fn" in options) {
          value = options[type2 + "Fn"](value, currentElement);
        }
        element[options[type2 + "Key"]] = value;
      }
      if (options.addParent) {
        element[options.parentKey] = currentElement;
      }
      currentElement[options.elementsKey].push(element);
    }
  }
  function manipulateAttributes(attributes) {
    if ("attributesFn" in options && attributes) {
      attributes = options.attributesFn(attributes, currentElement);
    }
    if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          if (options.trim) attributes[key] = attributes[key].trim();
          if (options.nativeTypeAttributes) {
            attributes[key] = nativeType(attributes[key]);
          }
          if ("attributeValueFn" in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
          if ("attributeNameFn" in options) {
            var temp = attributes[key];
            delete attributes[key];
            attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
          }
        }
      }
    }
    return attributes;
  }
  function onInstruction(instruction) {
    var attributes = {};
    if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
      var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
      var match;
      while ((match = attrsRegExp.exec(instruction.body)) !== null) {
        attributes[match[1]] = match[2] || match[3] || match[4];
      }
      attributes = manipulateAttributes(attributes);
    }
    if (instruction.name.toLowerCase() === "xml") {
      if (options.ignoreDeclaration) {
        return;
      }
      currentElement[options.declarationKey] = {};
      if (Object.keys(attributes).length) {
        currentElement[options.declarationKey][options.attributesKey] = attributes;
      }
      if (options.addParent) {
        currentElement[options.declarationKey][options.parentKey] = currentElement;
      }
    } else {
      if (options.ignoreInstruction) {
        return;
      }
      if (options.trim) {
        instruction.body = instruction.body.trim();
      }
      var value = {};
      if (options.instructionHasAttributes && Object.keys(attributes).length) {
        value[instruction.name] = {};
        value[instruction.name][options.attributesKey] = attributes;
      } else {
        value[instruction.name] = instruction.body;
      }
      addField("instruction", value);
    }
  }
  function onStartElement(name, attributes) {
    var element;
    if (typeof name === "object") {
      attributes = name.attributes;
      name = name.name;
    }
    attributes = manipulateAttributes(attributes);
    if ("elementNameFn" in options) {
      name = options.elementNameFn(name, currentElement);
    }
    if (options.compact) {
      element = {};
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = {};
        var key;
        for (key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            element[options.attributesKey][key] = attributes[key];
          }
        }
      }
      if (!(name in currentElement) && (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
        currentElement[name] = [];
      }
      if (currentElement[name] && !isArray(currentElement[name])) {
        currentElement[name] = [currentElement[name]];
      }
      if (isArray(currentElement[name])) {
        currentElement[name].push(element);
      } else {
        currentElement[name] = element;
      }
    } else {
      if (!currentElement[options.elementsKey]) {
        currentElement[options.elementsKey] = [];
      }
      element = {};
      element[options.typeKey] = "element";
      element[options.nameKey] = name;
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = attributes;
      }
      if (options.alwaysChildren) {
        element[options.elementsKey] = [];
      }
      currentElement[options.elementsKey].push(element);
    }
    element[options.parentKey] = currentElement;
    currentElement = element;
  }
  function onText(text) {
    if (options.ignoreText) {
      return;
    }
    if (!text.trim() && !options.captureSpacesBetweenElements) {
      return;
    }
    if (options.trim) {
      text = text.trim();
    }
    if (options.nativeType) {
      text = nativeType(text);
    }
    if (options.sanitize) {
      text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    addField("text", text);
  }
  function onComment(comment) {
    if (options.ignoreComment) {
      return;
    }
    if (options.trim) {
      comment = comment.trim();
    }
    addField("comment", comment);
  }
  function onEndElement(name) {
    var parentElement = currentElement[options.parentKey];
    if (!options.addParent) {
      delete currentElement[options.parentKey];
    }
    currentElement = parentElement;
  }
  function onCdata(cdata) {
    if (options.ignoreCdata) {
      return;
    }
    if (options.trim) {
      cdata = cdata.trim();
    }
    addField("cdata", cdata);
  }
  function onDoctype(doctype) {
    if (options.ignoreDoctype) {
      return;
    }
    doctype = doctype.replace(/^ /, "");
    if (options.trim) {
      doctype = doctype.trim();
    }
    addField("doctype", doctype);
  }
  function onError(error) {
    error.note = error;
  }
  xml2js = function(xml, userOptions) {
    var parser = sax2.parser(true, {});
    var result = {};
    currentElement = result;
    options = validateOptions(userOptions);
    {
      parser.opt = { strictEntities: true };
      parser.onopentag = onStartElement;
      parser.ontext = onText;
      parser.oncomment = onComment;
      parser.onclosetag = onEndElement;
      parser.onerror = onError;
      parser.oncdata = onCdata;
      parser.ondoctype = onDoctype;
      parser.onprocessinginstruction = onInstruction;
    }
    {
      parser.write(xml).close();
    }
    if (result[options.elementsKey]) {
      var temp = result[options.elementsKey];
      delete result[options.elementsKey];
      result[options.elementsKey] = temp;
      delete result.text;
    }
    return result;
  };
  return xml2js;
}
var xml2json;
var hasRequiredXml2json;
function requireXml2json() {
  if (hasRequiredXml2json) return xml2json;
  hasRequiredXml2json = 1;
  var helper = requireOptionsHelper();
  var xml2js2 = requireXml2js();
  function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureSpacesExists(options);
    return options;
  }
  xml2json = function(xml, userOptions) {
    var options, js, json, parentKey;
    options = validateOptions(userOptions);
    js = xml2js2(xml, options);
    parentKey = "compact" in options && options.compact ? "_parent" : "parent";
    if ("addParent" in options && options.addParent) {
      json = JSON.stringify(js, function(k, v2) {
        return k === parentKey ? "_" : v2;
      }, options.spaces);
    } else {
      json = JSON.stringify(js, null, options.spaces);
    }
    return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  };
  return xml2json;
}
var js2xml;
var hasRequiredJs2xml;
function requireJs2xml() {
  if (hasRequiredJs2xml) return js2xml;
  hasRequiredJs2xml = 1;
  var helper = requireOptionsHelper();
  var isArray = requireArrayHelper().isArray;
  var currentElement, currentElementName;
  function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureFlagExists("ignoreDeclaration", options);
    helper.ensureFlagExists("ignoreInstruction", options);
    helper.ensureFlagExists("ignoreAttributes", options);
    helper.ensureFlagExists("ignoreText", options);
    helper.ensureFlagExists("ignoreComment", options);
    helper.ensureFlagExists("ignoreCdata", options);
    helper.ensureFlagExists("ignoreDoctype", options);
    helper.ensureFlagExists("compact", options);
    helper.ensureFlagExists("indentText", options);
    helper.ensureFlagExists("indentCdata", options);
    helper.ensureFlagExists("indentAttributes", options);
    helper.ensureFlagExists("indentInstruction", options);
    helper.ensureFlagExists("fullTagEmptyElement", options);
    helper.ensureFlagExists("noQuotesForNativeAttributes", options);
    helper.ensureSpacesExists(options);
    if (typeof options.spaces === "number") {
      options.spaces = Array(options.spaces + 1).join(" ");
    }
    helper.ensureKeyExists("declaration", options);
    helper.ensureKeyExists("instruction", options);
    helper.ensureKeyExists("attributes", options);
    helper.ensureKeyExists("text", options);
    helper.ensureKeyExists("comment", options);
    helper.ensureKeyExists("cdata", options);
    helper.ensureKeyExists("doctype", options);
    helper.ensureKeyExists("type", options);
    helper.ensureKeyExists("name", options);
    helper.ensureKeyExists("elements", options);
    helper.checkFnExists("doctype", options);
    helper.checkFnExists("instruction", options);
    helper.checkFnExists("cdata", options);
    helper.checkFnExists("comment", options);
    helper.checkFnExists("text", options);
    helper.checkFnExists("instructionName", options);
    helper.checkFnExists("elementName", options);
    helper.checkFnExists("attributeName", options);
    helper.checkFnExists("attributeValue", options);
    helper.checkFnExists("attributes", options);
    helper.checkFnExists("fullTagEmptyElement", options);
    return options;
  }
  function writeIndentation(options, depth, firstLine) {
    return (!firstLine && options.spaces ? "\n" : "") + Array(depth + 1).join(options.spaces);
  }
  function writeAttributes(attributes, options, depth) {
    if (options.ignoreAttributes) {
      return "";
    }
    if ("attributesFn" in options) {
      attributes = options.attributesFn(attributes, currentElementName, currentElement);
    }
    var key, attr, attrName, quote, result = [];
    for (key in attributes) {
      if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {
        quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
        attr = "" + attributes[key];
        attr = attr.replace(/"/g, "&quot;");
        attrName = "attributeNameFn" in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
        result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : " ");
        result.push(attrName + "=" + quote + ("attributeValueFn" in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
      }
    }
    if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
      result.push(writeIndentation(options, depth, false));
    }
    return result.join("");
  }
  function writeDeclaration(declaration, options, depth) {
    currentElement = declaration;
    currentElementName = "xml";
    return options.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + "?>";
  }
  function writeInstruction(instruction, options, depth) {
    if (options.ignoreInstruction) {
      return "";
    }
    var key;
    for (key in instruction) {
      if (instruction.hasOwnProperty(key)) {
        break;
      }
    }
    var instructionName = "instructionNameFn" in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
    if (typeof instruction[key] === "object") {
      currentElement = instruction;
      currentElementName = instructionName;
      return "<?" + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + "?>";
    } else {
      var instructionValue = instruction[key] ? instruction[key] : "";
      if ("instructionFn" in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
      return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
    }
  }
  function writeComment(comment, options) {
    return options.ignoreComment ? "" : "<!--" + ("commentFn" in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
  }
  function writeCdata(cdata, options) {
    return options.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
  }
  function writeDoctype(doctype, options) {
    return options.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
  }
  function writeText(text, options) {
    if (options.ignoreText) return "";
    text = "" + text;
    text = text.replace(/&amp;/g, "&");
    text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return "textFn" in options ? options.textFn(text, currentElementName, currentElement) : text;
  }
  function hasContent(element, options) {
    var i;
    if (element.elements && element.elements.length) {
      for (i = 0; i < element.elements.length; ++i) {
        switch (element.elements[i][options.typeKey]) {
          case "text":
            if (options.indentText) {
              return true;
            }
            break;
          // skip to next key
          case "cdata":
            if (options.indentCdata) {
              return true;
            }
            break;
          // skip to next key
          case "instruction":
            if (options.indentInstruction) {
              return true;
            }
            break;
          // skip to next key
          case "doctype":
          case "comment":
          case "element":
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElement(element, options, depth) {
    currentElement = element;
    currentElementName = element.name;
    var xml = [], elementName = "elementNameFn" in options ? options.elementNameFn(element.name, element) : element.name;
    xml.push("<" + elementName);
    if (element[options.attributesKey]) {
      xml.push(writeAttributes(element[options.attributesKey], options, depth));
    }
    var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
    if (!withClosingTag) {
      if ("fullTagEmptyElementFn" in options) {
        withClosingTag = options.fullTagEmptyElementFn(element.name, element);
      } else {
        withClosingTag = options.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml.push(">");
      if (element[options.elementsKey] && element[options.elementsKey].length) {
        xml.push(writeElements(element[options.elementsKey], options, depth + 1));
        currentElement = element;
        currentElementName = element.name;
      }
      xml.push(options.spaces && hasContent(element, options) ? "\n" + Array(depth + 1).join(options.spaces) : "");
      xml.push("</" + elementName + ">");
    } else {
      xml.push("/>");
    }
    return xml.join("");
  }
  function writeElements(elements, options, depth, firstLine) {
    return elements.reduce(function(xml, element) {
      var indent = writeIndentation(options, depth, firstLine && !xml);
      switch (element.type) {
        case "element":
          return xml + indent + writeElement(element, options, depth);
        case "comment":
          return xml + indent + writeComment(element[options.commentKey], options);
        case "doctype":
          return xml + indent + writeDoctype(element[options.doctypeKey], options);
        case "cdata":
          return xml + (options.indentCdata ? indent : "") + writeCdata(element[options.cdataKey], options);
        case "text":
          return xml + (options.indentText ? indent : "") + writeText(element[options.textKey], options);
        case "instruction":
          var instruction = {};
          instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
          return xml + (options.indentInstruction ? indent : "") + writeInstruction(instruction, options, depth);
      }
    }, "");
  }
  function hasContentCompact(element, options, anyContent) {
    var key;
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        switch (key) {
          case options.parentKey:
          case options.attributesKey:
            break;
          // skip to next key
          case options.textKey:
            if (options.indentText || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.cdataKey:
            if (options.indentCdata || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.instructionKey:
            if (options.indentInstruction || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.doctypeKey:
          case options.commentKey:
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElementCompact(element, name, options, depth, indent) {
    currentElement = element;
    currentElementName = name;
    var elementName = "elementNameFn" in options ? options.elementNameFn(name, element) : name;
    if (typeof element === "undefined" || element === null || element === "") {
      return "fullTagEmptyElementFn" in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
    }
    var xml = [];
    if (name) {
      xml.push("<" + elementName);
      if (typeof element !== "object") {
        xml.push(">" + writeText(element, options) + "</" + elementName + ">");
        return xml.join("");
      }
      if (element[options.attributesKey]) {
        xml.push(writeAttributes(element[options.attributesKey], options, depth));
      }
      var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
      if (!withClosingTag) {
        if ("fullTagEmptyElementFn" in options) {
          withClosingTag = options.fullTagEmptyElementFn(name, element);
        } else {
          withClosingTag = options.fullTagEmptyElement;
        }
      }
      if (withClosingTag) {
        xml.push(">");
      } else {
        xml.push("/>");
        return xml.join("");
      }
    }
    xml.push(writeElementsCompact(element, options, depth + 1, false));
    currentElement = element;
    currentElementName = name;
    if (name) {
      xml.push((indent ? writeIndentation(options, depth, false) : "") + "</" + elementName + ">");
    }
    return xml.join("");
  }
  function writeElementsCompact(element, options, depth, firstLine) {
    var i, key, nodes, xml = [];
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        nodes = isArray(element[key]) ? element[key] : [element[key]];
        for (i = 0; i < nodes.length; ++i) {
          switch (key) {
            case options.declarationKey:
              xml.push(writeDeclaration(nodes[i], options, depth));
              break;
            case options.instructionKey:
              xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : "") + writeInstruction(nodes[i], options, depth));
              break;
            case options.attributesKey:
            case options.parentKey:
              break;
            // skip
            case options.textKey:
              xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : "") + writeText(nodes[i], options));
              break;
            case options.cdataKey:
              xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : "") + writeCdata(nodes[i], options));
              break;
            case options.doctypeKey:
              xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
              break;
            case options.commentKey:
              xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
              break;
            default:
              xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
          }
          firstLine = firstLine && !xml.length;
        }
      }
    }
    return xml.join("");
  }
  js2xml = function(js, options) {
    options = validateOptions(options);
    var xml = [];
    currentElement = js;
    currentElementName = "_root_";
    if (options.compact) {
      xml.push(writeElementsCompact(js, options, 0, true));
    } else {
      if (js[options.declarationKey]) {
        xml.push(writeDeclaration(js[options.declarationKey], options, 0));
      }
      if (js[options.elementsKey] && js[options.elementsKey].length) {
        xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
      }
    }
    return xml.join("");
  };
  return js2xml;
}
var json2xml;
var hasRequiredJson2xml;
function requireJson2xml() {
  if (hasRequiredJson2xml) return json2xml;
  hasRequiredJson2xml = 1;
  var js2xml2 = requireJs2xml();
  json2xml = function(json, options) {
    if (json instanceof Buffer2) {
      json = json.toString();
    }
    var js = null;
    if (typeof json === "string") {
      try {
        js = JSON.parse(json);
      } catch (e) {
        throw new Error("The JSON structure is invalid");
      }
    } else {
      js = json;
    }
    return js2xml2(js, options);
  };
  return json2xml;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var xml2js2 = requireXml2js();
  var xml2json2 = requireXml2json();
  var js2xml2 = requireJs2xml();
  var json2xml2 = requireJson2xml();
  lib = {
    xml2js: xml2js2,
    xml2json: xml2json2,
    js2xml: js2xml2,
    json2xml: json2xml2
  };
  return lib;
}
var libExports = requireLib();
const xmljs = /* @__PURE__ */ getDefaultExportFromCjs$1(libExports);
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return stringify(rnds);
}
var he$3 = { exports: {} };
/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
var he$2 = he$3.exports;
var hasRequiredHe;
function requireHe() {
  if (hasRequiredHe) return he$3.exports;
  hasRequiredHe = 1;
  (function(module, exports) {
    (function(root) {
      var freeExports = exports;
      var freeModule = module && module.exports == freeExports && module;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "": "shy", "": "zwnj", "": "zwj", "": "lrm", "": "ic", "": "it", "": "af", "": "rlm", "": "ZeroWidthSpace", "": "NoBreak", "": "DownBreve", "": "tdot", "": "DotDot", "	": "Tab", "\n": "NewLine", "": "puncsp", "": "MediumSpace", "": "thinsp", "": "hairsp", "": "emsp13", "": "ensp", "": "emsp14", "": "emsp", "": "numsp", "": "nbsp", "": "ThickSpace", "": "oline", "_": "lowbar", "": "dash", "": "ndash", "": "mdash", "": "horbar", ",": "comma", ";": "semi", "": "bsemi", ":": "colon", "": "Colone", "!": "excl", "": "iexcl", "?": "quest", "": "iquest", ".": "period", "": "nldr", "": "mldr", "": "middot", "'": "apos", "": "lsquo", "": "rsquo", "": "sbquo", "": "lsaquo", "": "rsaquo", '"': "quot", "": "ldquo", "": "rdquo", "": "bdquo", "": "laquo", "": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "": "lceil", "": "rceil", "": "lfloor", "": "rfloor", "": "lopar", "": "ropar", "": "lbrke", "": "rbrke", "": "lbrkslu", "": "rbrksld", "": "lbrksld", "": "rbrkslu", "": "langd", "": "rangd", "": "lparlt", "": "rpargt", "": "gtlPar", "": "ltrPar", "": "lobrk", "": "robrk", "": "lang", "": "rang", "": "Lang", "": "Rang", "": "loang", "": "roang", "": "lbbrk", "": "rbbrk", "": "Vert", "": "sect", "": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "": "permil", "": "pertenk", "": "dagger", "": "Dagger", "": "bull", "": "hybull", "": "prime", "": "Prime", "": "tprime", "": "qprime", "": "bprime", "": "caret", "`": "grave", "": "acute", "": "tilde", "^": "Hat", "": "macr", "": "breve", "": "dot", "": "die", "": "ring", "": "dblac", "": "cedil", "": "ogon", "": "circ", "": "caron", "": "deg", "": "copy", "": "reg", "": "copysr", "": "wp", "": "rx", "": "mho", "": "iiota", "": "larr", "": "nlarr", "": "rarr", "": "nrarr", "": "uarr", "": "darr", "": "harr", "": "nharr", "": "varr", "": "nwarr", "": "nearr", "": "searr", "": "swarr", "": "rarrw", "": "nrarrw", "": "Larr", "": "Uarr", "": "Rarr", "": "Darr", "": "larrtl", "": "rarrtl", "": "mapstoleft", "": "mapstoup", "": "map", "": "mapstodown", "": "larrhk", "": "rarrhk", "": "larrlp", "": "rarrlp", "": "harrw", "": "lsh", "": "rsh", "": "ldsh", "": "rdsh", "": "crarr", "": "cularr", "": "curarr", "": "olarr", "": "orarr", "": "lharu", "": "lhard", "": "uharr", "": "uharl", "": "rharu", "": "rhard", "": "dharr", "": "dharl", "": "rlarr", "": "udarr", "": "lrarr", "": "llarr", "": "uuarr", "": "rrarr", "": "ddarr", "": "lrhar", "": "rlhar", "": "lArr", "": "nlArr", "": "uArr", "": "rArr", "": "nrArr", "": "dArr", "": "iff", "": "nhArr", "": "vArr", "": "nwArr", "": "neArr", "": "seArr", "": "swArr", "": "lAarr", "": "rAarr", "": "zigrarr", "": "larrb", "": "rarrb", "": "duarr", "": "loarr", "": "roarr", "": "hoarr", "": "forall", "": "comp", "": "part", "": "npart", "": "exist", "": "nexist", "": "empty", "": "Del", "": "in", "": "notin", "": "ni", "": "notni", "": "bepsi", "": "prod", "": "coprod", "": "sum", "+": "plus", "": "pm", "": "div", "": "times", "<": "lt", "": "nlt", "<": "nvlt", "=": "equals", "": "ne", "=": "bne", "": "Equal", ">": "gt", "": "ngt", ">": "nvgt", "": "not", "|": "vert", "": "brvbar", "": "minus", "": "mp", "": "plusdo", "": "frasl", "": "setmn", "": "lowast", "": "compfn", "": "Sqrt", "": "prop", "": "infin", "": "angrt", "": "ang", "": "nang", "": "angmsd", "": "angsph", "": "mid", "": "nmid", "": "par", "": "npar", "": "and", "": "or", "": "cap", "": "caps", "": "cup", "": "cups", "": "int", "": "Int", "": "tint", "": "qint", "": "oint", "": "Conint", "": "Cconint", "": "cwint", "": "cwconint", "": "awconint", "": "there4", "": "becaus", "": "ratio", "": "Colon", "": "minusd", "": "mDDot", "": "homtht", "": "sim", "": "nsim", "": "nvsim", "": "bsim", "": "race", "": "ac", "": "acE", "": "acd", "": "wr", "": "esim", "": "nesim", "": "sime", "": "nsime", "": "cong", "": "ncong", "": "simne", "": "ap", "": "nap", "": "ape", "": "apid", "": "napid", "": "bcong", "": "CupCap", "": "NotCupCap", "": "nvap", "": "bump", "": "nbump", "": "bumpe", "": "nbumpe", "": "doteq", "": "nedot", "": "eDot", "": "efDot", "": "erDot", "": "colone", "": "ecolon", "": "ecir", "": "cire", "": "wedgeq", "": "veeeq", "": "trie", "": "equest", "": "equiv", "": "nequiv", "": "bnequiv", "": "le", "": "nle", "": "nvle", "": "ge", "": "nge", "": "nvge", "": "lE", "": "nlE", "": "gE", "": "ngE", "": "lvnE", "": "lnE", "": "gnE", "": "gvnE", "": "ll", "": "nLtv", "": "nLt", "": "gg", "": "nGtv", "": "nGt", "": "twixt", "": "lsim", "": "nlsim", "": "gsim", "": "ngsim", "": "lg", "": "ntlg", "": "gl", "": "ntgl", "": "pr", "": "npr", "": "sc", "": "nsc", "": "prcue", "": "nprcue", "": "sccue", "": "nsccue", "": "prsim", "": "scsim", "": "NotSucceedsTilde", "": "sub", "": "nsub", "": "vnsub", "": "sup", "": "nsup", "": "vnsup", "": "sube", "": "nsube", "": "supe", "": "nsupe", "": "vsubne", "": "subne", "": "vsupne", "": "supne", "": "cupdot", "": "uplus", "": "sqsub", "": "NotSquareSubset", "": "sqsup", "": "NotSquareSuperset", "": "sqsube", "": "nsqsube", "": "sqsupe", "": "nsqsupe", "": "sqcap", "": "sqcaps", "": "sqcup", "": "sqcups", "": "oplus", "": "ominus", "": "otimes", "": "osol", "": "odot", "": "ocir", "": "oast", "": "odash", "": "plusb", "": "minusb", "": "timesb", "": "sdotb", "": "vdash", "": "nvdash", "": "dashv", "": "top", "": "bot", "": "models", "": "vDash", "": "nvDash", "": "Vdash", "": "nVdash", "": "Vvdash", "": "VDash", "": "nVDash", "": "prurel", "": "vltri", "": "nltri", "": "vrtri", "": "nrtri", "": "ltrie", "": "nltrie", "": "nvltrie", "": "rtrie", "": "nrtrie", "": "nvrtrie", "": "origof", "": "imof", "": "mumap", "": "hercon", "": "intcal", "": "veebar", "": "barvee", "": "angrtvb", "": "lrtri", "": "Wedge", "": "Vee", "": "xcap", "": "xcup", "": "diam", "": "sdot", "": "Star", "": "divonx", "": "bowtie", "": "ltimes", "": "rtimes", "": "lthree", "": "rthree", "": "bsime", "": "cuvee", "": "cuwed", "": "Sub", "": "Sup", "": "Cap", "": "Cup", "": "fork", "": "epar", "": "ltdot", "": "gtdot", "": "Ll", "": "nLl", "": "Gg", "": "nGg", "": "lesg", "": "leg", "": "gel", "": "gesl", "": "cuepr", "": "cuesc", "": "lnsim", "": "gnsim", "": "prnsim", "": "scnsim", "": "vellip", "": "ctdot", "": "utdot", "": "dtdot", "": "disin", "": "isinsv", "": "isins", "": "isindot", "": "notindot", "": "notinvc", "": "notinvb", "": "isinE", "": "notinE", "": "nisd", "": "xnis", "": "nis", "": "notnivc", "": "notnivb", "": "barwed", "": "Barwed", "": "drcrop", "": "dlcrop", "": "urcrop", "": "ulcrop", "": "bnot", "": "profline", "": "profsurf", "": "telrec", "": "target", "": "ulcorn", "": "urcorn", "": "dlcorn", "": "drcorn", "": "frown", "": "smile", "": "cylcty", "": "profalar", "": "topbot", "": "ovbar", "": "solbar", "": "angzarr", "": "lmoust", "": "rmoust", "": "tbrk", "": "bbrk", "": "bbrktbrk", "": "OverParenthesis", "": "UnderParenthesis", "": "OverBrace", "": "UnderBrace", "": "trpezium", "": "elinters", "": "blank", "": "boxh", "": "boxv", "": "boxdr", "": "boxdl", "": "boxur", "": "boxul", "": "boxvr", "": "boxvl", "": "boxhd", "": "boxhu", "": "boxvh", "": "boxH", "": "boxV", "": "boxdR", "": "boxDr", "": "boxDR", "": "boxdL", "": "boxDl", "": "boxDL", "": "boxuR", "": "boxUr", "": "boxUR", "": "boxuL", "": "boxUl", "": "boxUL", "": "boxvR", "": "boxVr", "": "boxVR", "": "boxvL", "": "boxVl", "": "boxVL", "": "boxHd", "": "boxhD", "": "boxHD", "": "boxHu", "": "boxhU", "": "boxHU", "": "boxvH", "": "boxVh", "": "boxVH", "": "uhblk", "": "lhblk", "": "block", "": "blk14", "": "blk12", "": "blk34", "": "squ", "": "squf", "": "EmptyVerySmallSquare", "": "rect", "": "marker", "": "fltns", "": "xutri", "": "utrif", "": "utri", "": "rtrif", "": "rtri", "": "xdtri", "": "dtrif", "": "dtri", "": "ltrif", "": "ltri", "": "loz", "": "cir", "": "tridot", "": "xcirc", "": "ultri", "": "urtri", "": "lltri", "": "EmptySmallSquare", "": "FilledSmallSquare", "": "starf", "": "star", "": "phone", "": "female", "": "male", "": "spades", "": "clubs", "": "hearts", "": "diams", "": "sung", "": "check", "": "cross", "": "malt", "": "sext", "": "VerticalSeparator", "": "bsolhsub", "": "suphsol", "": "xlarr", "": "xrarr", "": "xharr", "": "xlArr", "": "xrArr", "": "xhArr", "": "xmap", "": "dzigrarr", "": "nvlArr", "": "nvrArr", "": "nvHarr", "": "Map", "": "lbarr", "": "rbarr", "": "lBarr", "": "rBarr", "": "RBarr", "": "DDotrahd", "": "UpArrowBar", "": "DownArrowBar", "": "Rarrtl", "": "latail", "": "ratail", "": "lAtail", "": "rAtail", "": "larrfs", "": "rarrfs", "": "larrbfs", "": "rarrbfs", "": "nwarhk", "": "nearhk", "": "searhk", "": "swarhk", "": "nwnear", "": "toea", "": "tosa", "": "swnwar", "": "rarrc", "": "nrarrc", "": "cudarrr", "": "ldca", "": "rdca", "": "cudarrl", "": "larrpl", "": "curarrm", "": "cularrp", "": "rarrpl", "": "harrcir", "": "Uarrocir", "": "lurdshar", "": "ldrushar", "": "LeftRightVector", "": "RightUpDownVector", "": "DownLeftRightVector", "": "LeftUpDownVector", "": "LeftVectorBar", "": "RightVectorBar", "": "RightUpVectorBar", "": "RightDownVectorBar", "": "DownLeftVectorBar", "": "DownRightVectorBar", "": "LeftUpVectorBar", "": "LeftDownVectorBar", "": "LeftTeeVector", "": "RightTeeVector", "": "RightUpTeeVector", "": "RightDownTeeVector", "": "DownLeftTeeVector", "": "DownRightTeeVector", "": "LeftUpTeeVector", "": "LeftDownTeeVector", "": "lHar", "": "uHar", "": "rHar", "": "dHar", "": "luruhar", "": "ldrdhar", "": "ruluhar", "": "rdldhar", "": "lharul", "": "llhard", "": "rharul", "": "lrhard", "": "udhar", "": "duhar", "": "RoundImplies", "": "erarr", "": "simrarr", "": "larrsim", "": "rarrsim", "": "rarrap", "": "ltlarr", "": "gtrarr", "": "subrarr", "": "suplarr", "": "lfisht", "": "rfisht", "": "ufisht", "": "dfisht", "": "vzigzag", "": "vangrt", "": "angrtvbd", "": "ange", "": "range", "": "dwangle", "": "uwangle", "": "angmsdaa", "": "angmsdab", "": "angmsdac", "": "angmsdad", "": "angmsdae", "": "angmsdaf", "": "angmsdag", "": "angmsdah", "": "bemptyv", "": "demptyv", "": "cemptyv", "": "raemptyv", "": "laemptyv", "": "ohbar", "": "omid", "": "opar", "": "operp", "": "olcross", "": "odsold", "": "olcir", "": "ofcir", "": "olt", "": "ogt", "": "cirscir", "": "cirE", "": "solb", "": "bsolb", "": "boxbox", "": "trisb", "": "rtriltri", "": "LeftTriangleBar", "": "NotLeftTriangleBar", "": "RightTriangleBar", "": "NotRightTriangleBar", "": "iinfin", "": "infintie", "": "nvinfin", "": "eparsl", "": "smeparsl", "": "eqvparsl", "": "lozf", "": "RuleDelayed", "": "dsol", "": "xodot", "": "xoplus", "": "xotime", "": "xuplus", "": "xsqcup", "": "fpartint", "": "cirfnint", "": "awint", "": "rppolint", "": "scpolint", "": "npolint", "": "pointint", "": "quatint", "": "intlarhk", "": "pluscir", "": "plusacir", "": "simplus", "": "plusdu", "": "plussim", "": "plustwo", "": "mcomma", "": "minusdu", "": "loplus", "": "roplus", "": "Cross", "": "timesd", "": "timesbar", "": "smashp", "": "lotimes", "": "rotimes", "": "otimesas", "": "Otimes", "": "odiv", "": "triplus", "": "triminus", "": "tritime", "": "iprod", "": "amalg", "": "capdot", "": "ncup", "": "ncap", "": "capand", "": "cupor", "": "cupcap", "": "capcup", "": "cupbrcap", "": "capbrcup", "": "cupcup", "": "capcap", "": "ccups", "": "ccaps", "": "ccupssm", "": "And", "": "Or", "": "andand", "": "oror", "": "orslope", "": "andslope", "": "andv", "": "orv", "": "andd", "": "ord", "": "wedbar", "": "sdote", "": "simdot", "": "congdot", "": "ncongdot", "": "easter", "": "apacir", "": "apE", "": "napE", "": "eplus", "": "pluse", "": "Esim", "": "eDDot", "": "equivDD", "": "ltcir", "": "gtcir", "": "ltquest", "": "gtquest", "": "les", "": "nles", "": "ges", "": "nges", "": "lesdot", "": "gesdot", "": "lesdoto", "": "gesdoto", "": "lesdotor", "": "gesdotol", "": "lap", "": "gap", "": "lne", "": "gne", "": "lnap", "": "gnap", "": "lEg", "": "gEl", "": "lsime", "": "gsime", "": "lsimg", "": "gsiml", "": "lgE", "": "glE", "": "lesges", "": "gesles", "": "els", "": "egs", "": "elsdot", "": "egsdot", "": "el", "": "eg", "": "siml", "": "simg", "": "simlE", "": "simgE", "": "LessLess", "": "NotNestedLessLess", "": "GreaterGreater", "": "NotNestedGreaterGreater", "": "glj", "": "gla", "": "ltcc", "": "gtcc", "": "lescc", "": "gescc", "": "smt", "": "lat", "": "smte", "": "smtes", "": "late", "": "lates", "": "bumpE", "": "pre", "": "npre", "": "sce", "": "nsce", "": "prE", "": "scE", "": "prnE", "": "scnE", "": "prap", "": "scap", "": "prnap", "": "scnap", "": "Pr", "": "Sc", "": "subdot", "": "supdot", "": "subplus", "": "supplus", "": "submult", "": "supmult", "": "subedot", "": "supedot", "": "subE", "": "nsubE", "": "supE", "": "nsupE", "": "subsim", "": "supsim", "": "vsubnE", "": "subnE", "": "vsupnE", "": "supnE", "": "csub", "": "csup", "": "csube", "": "csupe", "": "subsup", "": "supsub", "": "subsub", "": "supsup", "": "suphsub", "": "supdsub", "": "forkv", "": "topfork", "": "mlcp", "": "Dashv", "": "Vdashl", "": "Barv", "": "vBar", "": "vBarv", "": "Vbar", "": "Not", "": "bNot", "": "rnmid", "": "cirmid", "": "midcir", "": "topcir", "": "nhpar", "": "parsim", "": "parsl", "": "nparsl", "": "flat", "": "natur", "": "sharp", "": "curren", "": "cent", "$": "dollar", "": "pound", "": "yen", "": "euro", "": "sup1", "": "half", "": "frac13", "": "frac14", "": "frac15", "": "frac16", "": "frac18", "": "sup2", "": "frac23", "": "frac25", "": "sup3", "": "frac34", "": "frac35", "": "frac38", "": "frac45", "": "frac56", "": "frac58", "": "frac78", "": "ascr", "": "aopf", "": "afr", "": "Aopf", "": "Afr", "": "Ascr", "": "ordf", "": "aacute", "": "Aacute", "": "agrave", "": "Agrave", "": "abreve", "": "Abreve", "": "acirc", "": "Acirc", "": "aring", "": "angst", "": "auml", "": "Auml", "": "atilde", "": "Atilde", "": "aogon", "": "Aogon", "": "amacr", "": "Amacr", "": "aelig", "": "AElig", "": "bscr", "": "bopf", "": "bfr", "": "Bopf", "": "Bscr", "": "Bfr", "": "cfr", "": "cscr", "": "copf", "": "Cfr", "": "Cscr", "": "Copf", "": "cacute", "": "Cacute", "": "ccirc", "": "Ccirc", "": "ccaron", "": "Ccaron", "": "cdot", "": "Cdot", "": "ccedil", "": "Ccedil", "": "incare", "": "dfr", "": "dd", "": "dopf", "": "dscr", "": "Dscr", "": "Dfr", "": "DD", "": "Dopf", "": "dcaron", "": "Dcaron", "": "dstrok", "": "Dstrok", "": "eth", "": "ETH", "": "ee", "": "escr", "": "efr", "": "eopf", "": "Escr", "": "Efr", "": "Eopf", "": "eacute", "": "Eacute", "": "egrave", "": "Egrave", "": "ecirc", "": "Ecirc", "": "ecaron", "": "Ecaron", "": "euml", "": "Euml", "": "edot", "": "Edot", "": "eogon", "": "Eogon", "": "emacr", "": "Emacr", "": "ffr", "": "fopf", "": "fscr", "": "Ffr", "": "Fopf", "": "Fscr", "": "fflig", "": "ffilig", "": "ffllig", "": "filig", "fj": "fjlig", "": "fllig", "": "fnof", "": "gscr", "": "gopf", "": "gfr", "": "Gscr", "": "Gopf", "": "Gfr", "": "gacute", "": "gbreve", "": "Gbreve", "": "gcirc", "": "Gcirc", "": "gdot", "": "Gdot", "": "Gcedil", "": "hfr", "": "planckh", "": "hscr", "": "hopf", "": "Hscr", "": "Hfr", "": "Hopf", "": "hcirc", "": "Hcirc", "": "hbar", "": "hstrok", "": "Hstrok", "": "iopf", "": "ifr", "": "iscr", "": "ii", "": "Iopf", "": "Iscr", "": "Im", "": "iacute", "": "Iacute", "": "igrave", "": "Igrave", "": "icirc", "": "Icirc", "": "iuml", "": "Iuml", "": "itilde", "": "Itilde", "": "Idot", "": "iogon", "": "Iogon", "": "imacr", "": "Imacr", "": "ijlig", "": "IJlig", "": "imath", "": "jscr", "": "jopf", "": "jfr", "": "Jscr", "": "Jfr", "": "Jopf", "": "jcirc", "": "Jcirc", "": "jmath", "": "kopf", "": "kscr", "": "kfr", "": "Kscr", "": "Kopf", "": "Kfr", "": "kcedil", "": "Kcedil", "": "lfr", "": "lscr", "": "ell", "": "lopf", "": "Lscr", "": "Lfr", "": "Lopf", "": "lacute", "": "Lacute", "": "lcaron", "": "Lcaron", "": "lcedil", "": "Lcedil", "": "lstrok", "": "Lstrok", "": "lmidot", "": "Lmidot", "": "mfr", "": "mopf", "": "mscr", "": "Mfr", "": "Mopf", "": "Mscr", "": "nfr", "": "nopf", "": "nscr", "": "Nopf", "": "Nscr", "": "Nfr", "": "nacute", "": "Nacute", "": "ncaron", "": "Ncaron", "": "ntilde", "": "Ntilde", "": "ncedil", "": "Ncedil", "": "numero", "": "eng", "": "ENG", "": "oopf", "": "ofr", "": "oscr", "": "Oscr", "": "Ofr", "": "Oopf", "": "ordm", "": "oacute", "": "Oacute", "": "ograve", "": "Ograve", "": "ocirc", "": "Ocirc", "": "ouml", "": "Ouml", "": "odblac", "": "Odblac", "": "otilde", "": "Otilde", "": "oslash", "": "Oslash", "": "omacr", "": "Omacr", "": "oelig", "": "OElig", "": "pfr", "": "pscr", "": "popf", "": "Popf", "": "Pfr", "": "Pscr", "": "qopf", "": "qfr", "": "qscr", "": "Qscr", "": "Qfr", "": "Qopf", "": "kgreen", "": "rfr", "": "ropf", "": "rscr", "": "Rscr", "": "Re", "": "Ropf", "": "racute", "": "Racute", "": "rcaron", "": "Rcaron", "": "rcedil", "": "Rcedil", "": "sopf", "": "sscr", "": "sfr", "": "Sopf", "": "Sfr", "": "Sscr", "": "oS", "": "sacute", "": "Sacute", "": "scirc", "": "Scirc", "": "scaron", "": "Scaron", "": "scedil", "": "Scedil", "": "szlig", "": "tfr", "": "tscr", "": "topf", "": "Tscr", "": "Tfr", "": "Topf", "": "tcaron", "": "Tcaron", "": "tcedil", "": "Tcedil", "": "trade", "": "tstrok", "": "Tstrok", "": "uscr", "": "uopf", "": "ufr", "": "Uopf", "": "Ufr", "": "Uscr", "": "uacute", "": "Uacute", "": "ugrave", "": "Ugrave", "": "ubreve", "": "Ubreve", "": "ucirc", "": "Ucirc", "": "uring", "": "Uring", "": "uuml", "": "Uuml", "": "udblac", "": "Udblac", "": "utilde", "": "Utilde", "": "uogon", "": "Uogon", "": "umacr", "": "Umacr", "": "vfr", "": "vopf", "": "vscr", "": "Vfr", "": "Vopf", "": "Vscr", "": "wopf", "": "wscr", "": "wfr", "": "Wscr", "": "Wopf", "": "Wfr", "": "wcirc", "": "Wcirc", "": "xfr", "": "xscr", "": "xopf", "": "Xopf", "": "Xfr", "": "Xscr", "": "yfr", "": "yscr", "": "yopf", "": "Yscr", "": "Yfr", "": "Yopf", "": "yacute", "": "Yacute", "": "ycirc", "": "Ycirc", "": "yuml", "": "Yuml", "": "zscr", "": "zfr", "": "zopf", "": "Zfr", "": "Zopf", "": "Zscr", "": "zacute", "": "Zacute", "": "zcaron", "": "Zcaron", "": "zdot", "": "Zdot", "": "imped", "": "thorn", "": "THORN", "": "napos", "": "alpha", "": "Alpha", "": "beta", "": "Beta", "": "gamma", "": "Gamma", "": "delta", "": "Delta", "": "epsi", "": "epsiv", "": "Epsilon", "": "gammad", "": "Gammad", "": "zeta", "": "Zeta", "": "eta", "": "Eta", "": "theta", "": "thetav", "": "Theta", "": "iota", "": "Iota", "": "kappa", "": "kappav", "": "Kappa", "": "lambda", "": "Lambda", "": "mu", "": "micro", "": "Mu", "": "nu", "": "Nu", "": "xi", "": "Xi", "": "omicron", "": "Omicron", "": "pi", "": "piv", "": "Pi", "": "rho", "": "rhov", "": "Rho", "": "sigma", "": "Sigma", "": "sigmaf", "": "tau", "": "Tau", "": "upsi", "": "Upsilon", "": "Upsi", "": "phi", "": "phiv", "": "Phi", "": "chi", "": "Chi", "": "psi", "": "Psi", "": "omega", "": "ohm", "": "acy", "": "Acy", "": "bcy", "": "Bcy", "": "vcy", "": "Vcy", "": "gcy", "": "Gcy", "": "gjcy", "": "GJcy", "": "dcy", "": "Dcy", "": "djcy", "": "DJcy", "": "iecy", "": "IEcy", "": "iocy", "": "IOcy", "": "jukcy", "": "Jukcy", "": "zhcy", "": "ZHcy", "": "zcy", "": "Zcy", "": "dscy", "": "DScy", "": "icy", "": "Icy", "": "iukcy", "": "Iukcy", "": "yicy", "": "YIcy", "": "jcy", "": "Jcy", "": "jsercy", "": "Jsercy", "": "kcy", "": "Kcy", "": "kjcy", "": "KJcy", "": "lcy", "": "Lcy", "": "ljcy", "": "LJcy", "": "mcy", "": "Mcy", "": "ncy", "": "Ncy", "": "njcy", "": "NJcy", "": "ocy", "": "Ocy", "": "pcy", "": "Pcy", "": "rcy", "": "Rcy", "": "scy", "": "Scy", "": "tcy", "": "Tcy", "": "tshcy", "": "TSHcy", "": "ucy", "": "Ucy", "": "ubrcy", "": "Ubrcy", "": "fcy", "": "Fcy", "": "khcy", "": "KHcy", "": "tscy", "": "TScy", "": "chcy", "": "CHcy", "": "dzcy", "": "DZcy", "": "shcy", "": "SHcy", "": "shchcy", "": "SHCHcy", "": "hardcy", "": "HARDcy", "": "ycy", "": "Ycy", "": "softcy", "": "SOFTcy", "": "ecy", "": "Ecy", "": "yucy", "": "YUcy", "": "yacy", "": "YAcy", "": "aleph", "": "beth", "": "gimel", "": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless its part of a tag or an
        // unquoted attribute value. Were only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer  8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = { "aacute": "", "Aacute": "", "abreve": "", "Abreve": "", "ac": "", "acd": "", "acE": "", "acirc": "", "Acirc": "", "acute": "", "acy": "", "Acy": "", "aelig": "", "AElig": "", "af": "", "afr": "", "Afr": "", "agrave": "", "Agrave": "", "alefsym": "", "aleph": "", "alpha": "", "Alpha": "", "amacr": "", "Amacr": "", "amalg": "", "amp": "&", "AMP": "&", "and": "", "And": "", "andand": "", "andd": "", "andslope": "", "andv": "", "ang": "", "ange": "", "angle": "", "angmsd": "", "angmsdaa": "", "angmsdab": "", "angmsdac": "", "angmsdad": "", "angmsdae": "", "angmsdaf": "", "angmsdag": "", "angmsdah": "", "angrt": "", "angrtvb": "", "angrtvbd": "", "angsph": "", "angst": "", "angzarr": "", "aogon": "", "Aogon": "", "aopf": "", "Aopf": "", "ap": "", "apacir": "", "ape": "", "apE": "", "apid": "", "apos": "'", "ApplyFunction": "", "approx": "", "approxeq": "", "aring": "", "Aring": "", "ascr": "", "Ascr": "", "Assign": "", "ast": "*", "asymp": "", "asympeq": "", "atilde": "", "Atilde": "", "auml": "", "Auml": "", "awconint": "", "awint": "", "backcong": "", "backepsilon": "", "backprime": "", "backsim": "", "backsimeq": "", "Backslash": "", "Barv": "", "barvee": "", "barwed": "", "Barwed": "", "barwedge": "", "bbrk": "", "bbrktbrk": "", "bcong": "", "bcy": "", "Bcy": "", "bdquo": "", "becaus": "", "because": "", "Because": "", "bemptyv": "", "bepsi": "", "bernou": "", "Bernoullis": "", "beta": "", "Beta": "", "beth": "", "between": "", "bfr": "", "Bfr": "", "bigcap": "", "bigcirc": "", "bigcup": "", "bigodot": "", "bigoplus": "", "bigotimes": "", "bigsqcup": "", "bigstar": "", "bigtriangledown": "", "bigtriangleup": "", "biguplus": "", "bigvee": "", "bigwedge": "", "bkarow": "", "blacklozenge": "", "blacksquare": "", "blacktriangle": "", "blacktriangledown": "", "blacktriangleleft": "", "blacktriangleright": "", "blank": "", "blk12": "", "blk14": "", "blk34": "", "block": "", "bne": "=", "bnequiv": "", "bnot": "", "bNot": "", "bopf": "", "Bopf": "", "bot": "", "bottom": "", "bowtie": "", "boxbox": "", "boxdl": "", "boxdL": "", "boxDl": "", "boxDL": "", "boxdr": "", "boxdR": "", "boxDr": "", "boxDR": "", "boxh": "", "boxH": "", "boxhd": "", "boxhD": "", "boxHd": "", "boxHD": "", "boxhu": "", "boxhU": "", "boxHu": "", "boxHU": "", "boxminus": "", "boxplus": "", "boxtimes": "", "boxul": "", "boxuL": "", "boxUl": "", "boxUL": "", "boxur": "", "boxuR": "", "boxUr": "", "boxUR": "", "boxv": "", "boxV": "", "boxvh": "", "boxvH": "", "boxVh": "", "boxVH": "", "boxvl": "", "boxvL": "", "boxVl": "", "boxVL": "", "boxvr": "", "boxvR": "", "boxVr": "", "boxVR": "", "bprime": "", "breve": "", "Breve": "", "brvbar": "", "bscr": "", "Bscr": "", "bsemi": "", "bsim": "", "bsime": "", "bsol": "\\", "bsolb": "", "bsolhsub": "", "bull": "", "bullet": "", "bump": "", "bumpe": "", "bumpE": "", "bumpeq": "", "Bumpeq": "", "cacute": "", "Cacute": "", "cap": "", "Cap": "", "capand": "", "capbrcup": "", "capcap": "", "capcup": "", "capdot": "", "CapitalDifferentialD": "", "caps": "", "caret": "", "caron": "", "Cayleys": "", "ccaps": "", "ccaron": "", "Ccaron": "", "ccedil": "", "Ccedil": "", "ccirc": "", "Ccirc": "", "Cconint": "", "ccups": "", "ccupssm": "", "cdot": "", "Cdot": "", "cedil": "", "Cedilla": "", "cemptyv": "", "cent": "", "centerdot": "", "CenterDot": "", "cfr": "", "Cfr": "", "chcy": "", "CHcy": "", "check": "", "checkmark": "", "chi": "", "Chi": "", "cir": "", "circ": "", "circeq": "", "circlearrowleft": "", "circlearrowright": "", "circledast": "", "circledcirc": "", "circleddash": "", "CircleDot": "", "circledR": "", "circledS": "", "CircleMinus": "", "CirclePlus": "", "CircleTimes": "", "cire": "", "cirE": "", "cirfnint": "", "cirmid": "", "cirscir": "", "ClockwiseContourIntegral": "", "CloseCurlyDoubleQuote": "", "CloseCurlyQuote": "", "clubs": "", "clubsuit": "", "colon": ":", "Colon": "", "colone": "", "Colone": "", "coloneq": "", "comma": ",", "commat": "@", "comp": "", "compfn": "", "complement": "", "complexes": "", "cong": "", "congdot": "", "Congruent": "", "conint": "", "Conint": "", "ContourIntegral": "", "copf": "", "Copf": "", "coprod": "", "Coproduct": "", "copy": "", "COPY": "", "copysr": "", "CounterClockwiseContourIntegral": "", "crarr": "", "cross": "", "Cross": "", "cscr": "", "Cscr": "", "csub": "", "csube": "", "csup": "", "csupe": "", "ctdot": "", "cudarrl": "", "cudarrr": "", "cuepr": "", "cuesc": "", "cularr": "", "cularrp": "", "cup": "", "Cup": "", "cupbrcap": "", "cupcap": "", "CupCap": "", "cupcup": "", "cupdot": "", "cupor": "", "cups": "", "curarr": "", "curarrm": "", "curlyeqprec": "", "curlyeqsucc": "", "curlyvee": "", "curlywedge": "", "curren": "", "curvearrowleft": "", "curvearrowright": "", "cuvee": "", "cuwed": "", "cwconint": "", "cwint": "", "cylcty": "", "dagger": "", "Dagger": "", "daleth": "", "darr": "", "dArr": "", "Darr": "", "dash": "", "dashv": "", "Dashv": "", "dbkarow": "", "dblac": "", "dcaron": "", "Dcaron": "", "dcy": "", "Dcy": "", "dd": "", "DD": "", "ddagger": "", "ddarr": "", "DDotrahd": "", "ddotseq": "", "deg": "", "Del": "", "delta": "", "Delta": "", "demptyv": "", "dfisht": "", "dfr": "", "Dfr": "", "dHar": "", "dharl": "", "dharr": "", "DiacriticalAcute": "", "DiacriticalDot": "", "DiacriticalDoubleAcute": "", "DiacriticalGrave": "`", "DiacriticalTilde": "", "diam": "", "diamond": "", "Diamond": "", "diamondsuit": "", "diams": "", "die": "", "DifferentialD": "", "digamma": "", "disin": "", "div": "", "divide": "", "divideontimes": "", "divonx": "", "djcy": "", "DJcy": "", "dlcorn": "", "dlcrop": "", "dollar": "$", "dopf": "", "Dopf": "", "dot": "", "Dot": "", "DotDot": "", "doteq": "", "doteqdot": "", "DotEqual": "", "dotminus": "", "dotplus": "", "dotsquare": "", "doublebarwedge": "", "DoubleContourIntegral": "", "DoubleDot": "", "DoubleDownArrow": "", "DoubleLeftArrow": "", "DoubleLeftRightArrow": "", "DoubleLeftTee": "", "DoubleLongLeftArrow": "", "DoubleLongLeftRightArrow": "", "DoubleLongRightArrow": "", "DoubleRightArrow": "", "DoubleRightTee": "", "DoubleUpArrow": "", "DoubleUpDownArrow": "", "DoubleVerticalBar": "", "downarrow": "", "Downarrow": "", "DownArrow": "", "DownArrowBar": "", "DownArrowUpArrow": "", "DownBreve": "", "downdownarrows": "", "downharpoonleft": "", "downharpoonright": "", "DownLeftRightVector": "", "DownLeftTeeVector": "", "DownLeftVector": "", "DownLeftVectorBar": "", "DownRightTeeVector": "", "DownRightVector": "", "DownRightVectorBar": "", "DownTee": "", "DownTeeArrow": "", "drbkarow": "", "drcorn": "", "drcrop": "", "dscr": "", "Dscr": "", "dscy": "", "DScy": "", "dsol": "", "dstrok": "", "Dstrok": "", "dtdot": "", "dtri": "", "dtrif": "", "duarr": "", "duhar": "", "dwangle": "", "dzcy": "", "DZcy": "", "dzigrarr": "", "eacute": "", "Eacute": "", "easter": "", "ecaron": "", "Ecaron": "", "ecir": "", "ecirc": "", "Ecirc": "", "ecolon": "", "ecy": "", "Ecy": "", "eDDot": "", "edot": "", "eDot": "", "Edot": "", "ee": "", "efDot": "", "efr": "", "Efr": "", "eg": "", "egrave": "", "Egrave": "", "egs": "", "egsdot": "", "el": "", "Element": "", "elinters": "", "ell": "", "els": "", "elsdot": "", "emacr": "", "Emacr": "", "empty": "", "emptyset": "", "EmptySmallSquare": "", "emptyv": "", "EmptyVerySmallSquare": "", "emsp": "", "emsp13": "", "emsp14": "", "eng": "", "ENG": "", "ensp": "", "eogon": "", "Eogon": "", "eopf": "", "Eopf": "", "epar": "", "eparsl": "", "eplus": "", "epsi": "", "epsilon": "", "Epsilon": "", "epsiv": "", "eqcirc": "", "eqcolon": "", "eqsim": "", "eqslantgtr": "", "eqslantless": "", "Equal": "", "equals": "=", "EqualTilde": "", "equest": "", "Equilibrium": "", "equiv": "", "equivDD": "", "eqvparsl": "", "erarr": "", "erDot": "", "escr": "", "Escr": "", "esdot": "", "esim": "", "Esim": "", "eta": "", "Eta": "", "eth": "", "ETH": "", "euml": "", "Euml": "", "euro": "", "excl": "!", "exist": "", "Exists": "", "expectation": "", "exponentiale": "", "ExponentialE": "", "fallingdotseq": "", "fcy": "", "Fcy": "", "female": "", "ffilig": "", "fflig": "", "ffllig": "", "ffr": "", "Ffr": "", "filig": "", "FilledSmallSquare": "", "FilledVerySmallSquare": "", "fjlig": "fj", "flat": "", "fllig": "", "fltns": "", "fnof": "", "fopf": "", "Fopf": "", "forall": "", "ForAll": "", "fork": "", "forkv": "", "Fouriertrf": "", "fpartint": "", "frac12": "", "frac13": "", "frac14": "", "frac15": "", "frac16": "", "frac18": "", "frac23": "", "frac25": "", "frac34": "", "frac35": "", "frac38": "", "frac45": "", "frac56": "", "frac58": "", "frac78": "", "frasl": "", "frown": "", "fscr": "", "Fscr": "", "gacute": "", "gamma": "", "Gamma": "", "gammad": "", "Gammad": "", "gap": "", "gbreve": "", "Gbreve": "", "Gcedil": "", "gcirc": "", "Gcirc": "", "gcy": "", "Gcy": "", "gdot": "", "Gdot": "", "ge": "", "gE": "", "gel": "", "gEl": "", "geq": "", "geqq": "", "geqslant": "", "ges": "", "gescc": "", "gesdot": "", "gesdoto": "", "gesdotol": "", "gesl": "", "gesles": "", "gfr": "", "Gfr": "", "gg": "", "Gg": "", "ggg": "", "gimel": "", "gjcy": "", "GJcy": "", "gl": "", "gla": "", "glE": "", "glj": "", "gnap": "", "gnapprox": "", "gne": "", "gnE": "", "gneq": "", "gneqq": "", "gnsim": "", "gopf": "", "Gopf": "", "grave": "`", "GreaterEqual": "", "GreaterEqualLess": "", "GreaterFullEqual": "", "GreaterGreater": "", "GreaterLess": "", "GreaterSlantEqual": "", "GreaterTilde": "", "gscr": "", "Gscr": "", "gsim": "", "gsime": "", "gsiml": "", "gt": ">", "Gt": "", "GT": ">", "gtcc": "", "gtcir": "", "gtdot": "", "gtlPar": "", "gtquest": "", "gtrapprox": "", "gtrarr": "", "gtrdot": "", "gtreqless": "", "gtreqqless": "", "gtrless": "", "gtrsim": "", "gvertneqq": "", "gvnE": "", "Hacek": "", "hairsp": "", "half": "", "hamilt": "", "hardcy": "", "HARDcy": "", "harr": "", "hArr": "", "harrcir": "", "harrw": "", "Hat": "^", "hbar": "", "hcirc": "", "Hcirc": "", "hearts": "", "heartsuit": "", "hellip": "", "hercon": "", "hfr": "", "Hfr": "", "HilbertSpace": "", "hksearow": "", "hkswarow": "", "hoarr": "", "homtht": "", "hookleftarrow": "", "hookrightarrow": "", "hopf": "", "Hopf": "", "horbar": "", "HorizontalLine": "", "hscr": "", "Hscr": "", "hslash": "", "hstrok": "", "Hstrok": "", "HumpDownHump": "", "HumpEqual": "", "hybull": "", "hyphen": "", "iacute": "", "Iacute": "", "ic": "", "icirc": "", "Icirc": "", "icy": "", "Icy": "", "Idot": "", "iecy": "", "IEcy": "", "iexcl": "", "iff": "", "ifr": "", "Ifr": "", "igrave": "", "Igrave": "", "ii": "", "iiiint": "", "iiint": "", "iinfin": "", "iiota": "", "ijlig": "", "IJlig": "", "Im": "", "imacr": "", "Imacr": "", "image": "", "ImaginaryI": "", "imagline": "", "imagpart": "", "imath": "", "imof": "", "imped": "", "Implies": "", "in": "", "incare": "", "infin": "", "infintie": "", "inodot": "", "int": "", "Int": "", "intcal": "", "integers": "", "Integral": "", "intercal": "", "Intersection": "", "intlarhk": "", "intprod": "", "InvisibleComma": "", "InvisibleTimes": "", "iocy": "", "IOcy": "", "iogon": "", "Iogon": "", "iopf": "", "Iopf": "", "iota": "", "Iota": "", "iprod": "", "iquest": "", "iscr": "", "Iscr": "", "isin": "", "isindot": "", "isinE": "", "isins": "", "isinsv": "", "isinv": "", "it": "", "itilde": "", "Itilde": "", "iukcy": "", "Iukcy": "", "iuml": "", "Iuml": "", "jcirc": "", "Jcirc": "", "jcy": "", "Jcy": "", "jfr": "", "Jfr": "", "jmath": "", "jopf": "", "Jopf": "", "jscr": "", "Jscr": "", "jsercy": "", "Jsercy": "", "jukcy": "", "Jukcy": "", "kappa": "", "Kappa": "", "kappav": "", "kcedil": "", "Kcedil": "", "kcy": "", "Kcy": "", "kfr": "", "Kfr": "", "kgreen": "", "khcy": "", "KHcy": "", "kjcy": "", "KJcy": "", "kopf": "", "Kopf": "", "kscr": "", "Kscr": "", "lAarr": "", "lacute": "", "Lacute": "", "laemptyv": "", "lagran": "", "lambda": "", "Lambda": "", "lang": "", "Lang": "", "langd": "", "langle": "", "lap": "", "Laplacetrf": "", "laquo": "", "larr": "", "lArr": "", "Larr": "", "larrb": "", "larrbfs": "", "larrfs": "", "larrhk": "", "larrlp": "", "larrpl": "", "larrsim": "", "larrtl": "", "lat": "", "latail": "", "lAtail": "", "late": "", "lates": "", "lbarr": "", "lBarr": "", "lbbrk": "", "lbrace": "{", "lbrack": "[", "lbrke": "", "lbrksld": "", "lbrkslu": "", "lcaron": "", "Lcaron": "", "lcedil": "", "Lcedil": "", "lceil": "", "lcub": "{", "lcy": "", "Lcy": "", "ldca": "", "ldquo": "", "ldquor": "", "ldrdhar": "", "ldrushar": "", "ldsh": "", "le": "", "lE": "", "LeftAngleBracket": "", "leftarrow": "", "Leftarrow": "", "LeftArrow": "", "LeftArrowBar": "", "LeftArrowRightArrow": "", "leftarrowtail": "", "LeftCeiling": "", "LeftDoubleBracket": "", "LeftDownTeeVector": "", "LeftDownVector": "", "LeftDownVectorBar": "", "LeftFloor": "", "leftharpoondown": "", "leftharpoonup": "", "leftleftarrows": "", "leftrightarrow": "", "Leftrightarrow": "", "LeftRightArrow": "", "leftrightarrows": "", "leftrightharpoons": "", "leftrightsquigarrow": "", "LeftRightVector": "", "LeftTee": "", "LeftTeeArrow": "", "LeftTeeVector": "", "leftthreetimes": "", "LeftTriangle": "", "LeftTriangleBar": "", "LeftTriangleEqual": "", "LeftUpDownVector": "", "LeftUpTeeVector": "", "LeftUpVector": "", "LeftUpVectorBar": "", "LeftVector": "", "LeftVectorBar": "", "leg": "", "lEg": "", "leq": "", "leqq": "", "leqslant": "", "les": "", "lescc": "", "lesdot": "", "lesdoto": "", "lesdotor": "", "lesg": "", "lesges": "", "lessapprox": "", "lessdot": "", "lesseqgtr": "", "lesseqqgtr": "", "LessEqualGreater": "", "LessFullEqual": "", "LessGreater": "", "lessgtr": "", "LessLess": "", "lesssim": "", "LessSlantEqual": "", "LessTilde": "", "lfisht": "", "lfloor": "", "lfr": "", "Lfr": "", "lg": "", "lgE": "", "lHar": "", "lhard": "", "lharu": "", "lharul": "", "lhblk": "", "ljcy": "", "LJcy": "", "ll": "", "Ll": "", "llarr": "", "llcorner": "", "Lleftarrow": "", "llhard": "", "lltri": "", "lmidot": "", "Lmidot": "", "lmoust": "", "lmoustache": "", "lnap": "", "lnapprox": "", "lne": "", "lnE": "", "lneq": "", "lneqq": "", "lnsim": "", "loang": "", "loarr": "", "lobrk": "", "longleftarrow": "", "Longleftarrow": "", "LongLeftArrow": "", "longleftrightarrow": "", "Longleftrightarrow": "", "LongLeftRightArrow": "", "longmapsto": "", "longrightarrow": "", "Longrightarrow": "", "LongRightArrow": "", "looparrowleft": "", "looparrowright": "", "lopar": "", "lopf": "", "Lopf": "", "loplus": "", "lotimes": "", "lowast": "", "lowbar": "_", "LowerLeftArrow": "", "LowerRightArrow": "", "loz": "", "lozenge": "", "lozf": "", "lpar": "(", "lparlt": "", "lrarr": "", "lrcorner": "", "lrhar": "", "lrhard": "", "lrm": "", "lrtri": "", "lsaquo": "", "lscr": "", "Lscr": "", "lsh": "", "Lsh": "", "lsim": "", "lsime": "", "lsimg": "", "lsqb": "[", "lsquo": "", "lsquor": "", "lstrok": "", "Lstrok": "", "lt": "<", "Lt": "", "LT": "<", "ltcc": "", "ltcir": "", "ltdot": "", "lthree": "", "ltimes": "", "ltlarr": "", "ltquest": "", "ltri": "", "ltrie": "", "ltrif": "", "ltrPar": "", "lurdshar": "", "luruhar": "", "lvertneqq": "", "lvnE": "", "macr": "", "male": "", "malt": "", "maltese": "", "map": "", "Map": "", "mapsto": "", "mapstodown": "", "mapstoleft": "", "mapstoup": "", "marker": "", "mcomma": "", "mcy": "", "Mcy": "", "mdash": "", "mDDot": "", "measuredangle": "", "MediumSpace": "", "Mellintrf": "", "mfr": "", "Mfr": "", "mho": "", "micro": "", "mid": "", "midast": "*", "midcir": "", "middot": "", "minus": "", "minusb": "", "minusd": "", "minusdu": "", "MinusPlus": "", "mlcp": "", "mldr": "", "mnplus": "", "models": "", "mopf": "", "Mopf": "", "mp": "", "mscr": "", "Mscr": "", "mstpos": "", "mu": "", "Mu": "", "multimap": "", "mumap": "", "nabla": "", "nacute": "", "Nacute": "", "nang": "", "nap": "", "napE": "", "napid": "", "napos": "", "napprox": "", "natur": "", "natural": "", "naturals": "", "nbsp": "", "nbump": "", "nbumpe": "", "ncap": "", "ncaron": "", "Ncaron": "", "ncedil": "", "Ncedil": "", "ncong": "", "ncongdot": "", "ncup": "", "ncy": "", "Ncy": "", "ndash": "", "ne": "", "nearhk": "", "nearr": "", "neArr": "", "nearrow": "", "nedot": "", "NegativeMediumSpace": "", "NegativeThickSpace": "", "NegativeThinSpace": "", "NegativeVeryThinSpace": "", "nequiv": "", "nesear": "", "nesim": "", "NestedGreaterGreater": "", "NestedLessLess": "", "NewLine": "\n", "nexist": "", "nexists": "", "nfr": "", "Nfr": "", "nge": "", "ngE": "", "ngeq": "", "ngeqq": "", "ngeqslant": "", "nges": "", "nGg": "", "ngsim": "", "ngt": "", "nGt": "", "ngtr": "", "nGtv": "", "nharr": "", "nhArr": "", "nhpar": "", "ni": "", "nis": "", "nisd": "", "niv": "", "njcy": "", "NJcy": "", "nlarr": "", "nlArr": "", "nldr": "", "nle": "", "nlE": "", "nleftarrow": "", "nLeftarrow": "", "nleftrightarrow": "", "nLeftrightarrow": "", "nleq": "", "nleqq": "", "nleqslant": "", "nles": "", "nless": "", "nLl": "", "nlsim": "", "nlt": "", "nLt": "", "nltri": "", "nltrie": "", "nLtv": "", "nmid": "", "NoBreak": "", "NonBreakingSpace": "", "nopf": "", "Nopf": "", "not": "", "Not": "", "NotCongruent": "", "NotCupCap": "", "NotDoubleVerticalBar": "", "NotElement": "", "NotEqual": "", "NotEqualTilde": "", "NotExists": "", "NotGreater": "", "NotGreaterEqual": "", "NotGreaterFullEqual": "", "NotGreaterGreater": "", "NotGreaterLess": "", "NotGreaterSlantEqual": "", "NotGreaterTilde": "", "NotHumpDownHump": "", "NotHumpEqual": "", "notin": "", "notindot": "", "notinE": "", "notinva": "", "notinvb": "", "notinvc": "", "NotLeftTriangle": "", "NotLeftTriangleBar": "", "NotLeftTriangleEqual": "", "NotLess": "", "NotLessEqual": "", "NotLessGreater": "", "NotLessLess": "", "NotLessSlantEqual": "", "NotLessTilde": "", "NotNestedGreaterGreater": "", "NotNestedLessLess": "", "notni": "", "notniva": "", "notnivb": "", "notnivc": "", "NotPrecedes": "", "NotPrecedesEqual": "", "NotPrecedesSlantEqual": "", "NotReverseElement": "", "NotRightTriangle": "", "NotRightTriangleBar": "", "NotRightTriangleEqual": "", "NotSquareSubset": "", "NotSquareSubsetEqual": "", "NotSquareSuperset": "", "NotSquareSupersetEqual": "", "NotSubset": "", "NotSubsetEqual": "", "NotSucceeds": "", "NotSucceedsEqual": "", "NotSucceedsSlantEqual": "", "NotSucceedsTilde": "", "NotSuperset": "", "NotSupersetEqual": "", "NotTilde": "", "NotTildeEqual": "", "NotTildeFullEqual": "", "NotTildeTilde": "", "NotVerticalBar": "", "npar": "", "nparallel": "", "nparsl": "", "npart": "", "npolint": "", "npr": "", "nprcue": "", "npre": "", "nprec": "", "npreceq": "", "nrarr": "", "nrArr": "", "nrarrc": "", "nrarrw": "", "nrightarrow": "", "nRightarrow": "", "nrtri": "", "nrtrie": "", "nsc": "", "nsccue": "", "nsce": "", "nscr": "", "Nscr": "", "nshortmid": "", "nshortparallel": "", "nsim": "", "nsime": "", "nsimeq": "", "nsmid": "", "nspar": "", "nsqsube": "", "nsqsupe": "", "nsub": "", "nsube": "", "nsubE": "", "nsubset": "", "nsubseteq": "", "nsubseteqq": "", "nsucc": "", "nsucceq": "", "nsup": "", "nsupe": "", "nsupE": "", "nsupset": "", "nsupseteq": "", "nsupseteqq": "", "ntgl": "", "ntilde": "", "Ntilde": "", "ntlg": "", "ntriangleleft": "", "ntrianglelefteq": "", "ntriangleright": "", "ntrianglerighteq": "", "nu": "", "Nu": "", "num": "#", "numero": "", "numsp": "", "nvap": "", "nvdash": "", "nvDash": "", "nVdash": "", "nVDash": "", "nvge": "", "nvgt": ">", "nvHarr": "", "nvinfin": "", "nvlArr": "", "nvle": "", "nvlt": "<", "nvltrie": "", "nvrArr": "", "nvrtrie": "", "nvsim": "", "nwarhk": "", "nwarr": "", "nwArr": "", "nwarrow": "", "nwnear": "", "oacute": "", "Oacute": "", "oast": "", "ocir": "", "ocirc": "", "Ocirc": "", "ocy": "", "Ocy": "", "odash": "", "odblac": "", "Odblac": "", "odiv": "", "odot": "", "odsold": "", "oelig": "", "OElig": "", "ofcir": "", "ofr": "", "Ofr": "", "ogon": "", "ograve": "", "Ograve": "", "ogt": "", "ohbar": "", "ohm": "", "oint": "", "olarr": "", "olcir": "", "olcross": "", "oline": "", "olt": "", "omacr": "", "Omacr": "", "omega": "", "Omega": "", "omicron": "", "Omicron": "", "omid": "", "ominus": "", "oopf": "", "Oopf": "", "opar": "", "OpenCurlyDoubleQuote": "", "OpenCurlyQuote": "", "operp": "", "oplus": "", "or": "", "Or": "", "orarr": "", "ord": "", "order": "", "orderof": "", "ordf": "", "ordm": "", "origof": "", "oror": "", "orslope": "", "orv": "", "oS": "", "oscr": "", "Oscr": "", "oslash": "", "Oslash": "", "osol": "", "otilde": "", "Otilde": "", "otimes": "", "Otimes": "", "otimesas": "", "ouml": "", "Ouml": "", "ovbar": "", "OverBar": "", "OverBrace": "", "OverBracket": "", "OverParenthesis": "", "par": "", "para": "", "parallel": "", "parsim": "", "parsl": "", "part": "", "PartialD": "", "pcy": "", "Pcy": "", "percnt": "%", "period": ".", "permil": "", "perp": "", "pertenk": "", "pfr": "", "Pfr": "", "phi": "", "Phi": "", "phiv": "", "phmmat": "", "phone": "", "pi": "", "Pi": "", "pitchfork": "", "piv": "", "planck": "", "planckh": "", "plankv": "", "plus": "+", "plusacir": "", "plusb": "", "pluscir": "", "plusdo": "", "plusdu": "", "pluse": "", "PlusMinus": "", "plusmn": "", "plussim": "", "plustwo": "", "pm": "", "Poincareplane": "", "pointint": "", "popf": "", "Popf": "", "pound": "", "pr": "", "Pr": "", "prap": "", "prcue": "", "pre": "", "prE": "", "prec": "", "precapprox": "", "preccurlyeq": "", "Precedes": "", "PrecedesEqual": "", "PrecedesSlantEqual": "", "PrecedesTilde": "", "preceq": "", "precnapprox": "", "precneqq": "", "precnsim": "", "precsim": "", "prime": "", "Prime": "", "primes": "", "prnap": "", "prnE": "", "prnsim": "", "prod": "", "Product": "", "profalar": "", "profline": "", "profsurf": "", "prop": "", "Proportion": "", "Proportional": "", "propto": "", "prsim": "", "prurel": "", "pscr": "", "Pscr": "", "psi": "", "Psi": "", "puncsp": "", "qfr": "", "Qfr": "", "qint": "", "qopf": "", "Qopf": "", "qprime": "", "qscr": "", "Qscr": "", "quaternions": "", "quatint": "", "quest": "?", "questeq": "", "quot": '"', "QUOT": '"', "rAarr": "", "race": "", "racute": "", "Racute": "", "radic": "", "raemptyv": "", "rang": "", "Rang": "", "rangd": "", "range": "", "rangle": "", "raquo": "", "rarr": "", "rArr": "", "Rarr": "", "rarrap": "", "rarrb": "", "rarrbfs": "", "rarrc": "", "rarrfs": "", "rarrhk": "", "rarrlp": "", "rarrpl": "", "rarrsim": "", "rarrtl": "", "Rarrtl": "", "rarrw": "", "ratail": "", "rAtail": "", "ratio": "", "rationals": "", "rbarr": "", "rBarr": "", "RBarr": "", "rbbrk": "", "rbrace": "}", "rbrack": "]", "rbrke": "", "rbrksld": "", "rbrkslu": "", "rcaron": "", "Rcaron": "", "rcedil": "", "Rcedil": "", "rceil": "", "rcub": "}", "rcy": "", "Rcy": "", "rdca": "", "rdldhar": "", "rdquo": "", "rdquor": "", "rdsh": "", "Re": "", "real": "", "realine": "", "realpart": "", "reals": "", "rect": "", "reg": "", "REG": "", "ReverseElement": "", "ReverseEquilibrium": "", "ReverseUpEquilibrium": "", "rfisht": "", "rfloor": "", "rfr": "", "Rfr": "", "rHar": "", "rhard": "", "rharu": "", "rharul": "", "rho": "", "Rho": "", "rhov": "", "RightAngleBracket": "", "rightarrow": "", "Rightarrow": "", "RightArrow": "", "RightArrowBar": "", "RightArrowLeftArrow": "", "rightarrowtail": "", "RightCeiling": "", "RightDoubleBracket": "", "RightDownTeeVector": "", "RightDownVector": "", "RightDownVectorBar": "", "RightFloor": "", "rightharpoondown": "", "rightharpoonup": "", "rightleftarrows": "", "rightleftharpoons": "", "rightrightarrows": "", "rightsquigarrow": "", "RightTee": "", "RightTeeArrow": "", "RightTeeVector": "", "rightthreetimes": "", "RightTriangle": "", "RightTriangleBar": "", "RightTriangleEqual": "", "RightUpDownVector": "", "RightUpTeeVector": "", "RightUpVector": "", "RightUpVectorBar": "", "RightVector": "", "RightVectorBar": "", "ring": "", "risingdotseq": "", "rlarr": "", "rlhar": "", "rlm": "", "rmoust": "", "rmoustache": "", "rnmid": "", "roang": "", "roarr": "", "robrk": "", "ropar": "", "ropf": "", "Ropf": "", "roplus": "", "rotimes": "", "RoundImplies": "", "rpar": ")", "rpargt": "", "rppolint": "", "rrarr": "", "Rrightarrow": "", "rsaquo": "", "rscr": "", "Rscr": "", "rsh": "", "Rsh": "", "rsqb": "]", "rsquo": "", "rsquor": "", "rthree": "", "rtimes": "", "rtri": "", "rtrie": "", "rtrif": "", "rtriltri": "", "RuleDelayed": "", "ruluhar": "", "rx": "", "sacute": "", "Sacute": "", "sbquo": "", "sc": "", "Sc": "", "scap": "", "scaron": "", "Scaron": "", "sccue": "", "sce": "", "scE": "", "scedil": "", "Scedil": "", "scirc": "", "Scirc": "", "scnap": "", "scnE": "", "scnsim": "", "scpolint": "", "scsim": "", "scy": "", "Scy": "", "sdot": "", "sdotb": "", "sdote": "", "searhk": "", "searr": "", "seArr": "", "searrow": "", "sect": "", "semi": ";", "seswar": "", "setminus": "", "setmn": "", "sext": "", "sfr": "", "Sfr": "", "sfrown": "", "sharp": "", "shchcy": "", "SHCHcy": "", "shcy": "", "SHcy": "", "ShortDownArrow": "", "ShortLeftArrow": "", "shortmid": "", "shortparallel": "", "ShortRightArrow": "", "ShortUpArrow": "", "shy": "", "sigma": "", "Sigma": "", "sigmaf": "", "sigmav": "", "sim": "", "simdot": "", "sime": "", "simeq": "", "simg": "", "simgE": "", "siml": "", "simlE": "", "simne": "", "simplus": "", "simrarr": "", "slarr": "", "SmallCircle": "", "smallsetminus": "", "smashp": "", "smeparsl": "", "smid": "", "smile": "", "smt": "", "smte": "", "smtes": "", "softcy": "", "SOFTcy": "", "sol": "/", "solb": "", "solbar": "", "sopf": "", "Sopf": "", "spades": "", "spadesuit": "", "spar": "", "sqcap": "", "sqcaps": "", "sqcup": "", "sqcups": "", "Sqrt": "", "sqsub": "", "sqsube": "", "sqsubset": "", "sqsubseteq": "", "sqsup": "", "sqsupe": "", "sqsupset": "", "sqsupseteq": "", "squ": "", "square": "", "Square": "", "SquareIntersection": "", "SquareSubset": "", "SquareSubsetEqual": "", "SquareSuperset": "", "SquareSupersetEqual": "", "SquareUnion": "", "squarf": "", "squf": "", "srarr": "", "sscr": "", "Sscr": "", "ssetmn": "", "ssmile": "", "sstarf": "", "star": "", "Star": "", "starf": "", "straightepsilon": "", "straightphi": "", "strns": "", "sub": "", "Sub": "", "subdot": "", "sube": "", "subE": "", "subedot": "", "submult": "", "subne": "", "subnE": "", "subplus": "", "subrarr": "", "subset": "", "Subset": "", "subseteq": "", "subseteqq": "", "SubsetEqual": "", "subsetneq": "", "subsetneqq": "", "subsim": "", "subsub": "", "subsup": "", "succ": "", "succapprox": "", "succcurlyeq": "", "Succeeds": "", "SucceedsEqual": "", "SucceedsSlantEqual": "", "SucceedsTilde": "", "succeq": "", "succnapprox": "", "succneqq": "", "succnsim": "", "succsim": "", "SuchThat": "", "sum": "", "Sum": "", "sung": "", "sup": "", "Sup": "", "sup1": "", "sup2": "", "sup3": "", "supdot": "", "supdsub": "", "supe": "", "supE": "", "supedot": "", "Superset": "", "SupersetEqual": "", "suphsol": "", "suphsub": "", "suplarr": "", "supmult": "", "supne": "", "supnE": "", "supplus": "", "supset": "", "Supset": "", "supseteq": "", "supseteqq": "", "supsetneq": "", "supsetneqq": "", "supsim": "", "supsub": "", "supsup": "", "swarhk": "", "swarr": "", "swArr": "", "swarrow": "", "swnwar": "", "szlig": "", "Tab": "	", "target": "", "tau": "", "Tau": "", "tbrk": "", "tcaron": "", "Tcaron": "", "tcedil": "", "Tcedil": "", "tcy": "", "Tcy": "", "tdot": "", "telrec": "", "tfr": "", "Tfr": "", "there4": "", "therefore": "", "Therefore": "", "theta": "", "Theta": "", "thetasym": "", "thetav": "", "thickapprox": "", "thicksim": "", "ThickSpace": "", "thinsp": "", "ThinSpace": "", "thkap": "", "thksim": "", "thorn": "", "THORN": "", "tilde": "", "Tilde": "", "TildeEqual": "", "TildeFullEqual": "", "TildeTilde": "", "times": "", "timesb": "", "timesbar": "", "timesd": "", "tint": "", "toea": "", "top": "", "topbot": "", "topcir": "", "topf": "", "Topf": "", "topfork": "", "tosa": "", "tprime": "", "trade": "", "TRADE": "", "triangle": "", "triangledown": "", "triangleleft": "", "trianglelefteq": "", "triangleq": "", "triangleright": "", "trianglerighteq": "", "tridot": "", "trie": "", "triminus": "", "TripleDot": "", "triplus": "", "trisb": "", "tritime": "", "trpezium": "", "tscr": "", "Tscr": "", "tscy": "", "TScy": "", "tshcy": "", "TSHcy": "", "tstrok": "", "Tstrok": "", "twixt": "", "twoheadleftarrow": "", "twoheadrightarrow": "", "uacute": "", "Uacute": "", "uarr": "", "uArr": "", "Uarr": "", "Uarrocir": "", "ubrcy": "", "Ubrcy": "", "ubreve": "", "Ubreve": "", "ucirc": "", "Ucirc": "", "ucy": "", "Ucy": "", "udarr": "", "udblac": "", "Udblac": "", "udhar": "", "ufisht": "", "ufr": "", "Ufr": "", "ugrave": "", "Ugrave": "", "uHar": "", "uharl": "", "uharr": "", "uhblk": "", "ulcorn": "", "ulcorner": "", "ulcrop": "", "ultri": "", "umacr": "", "Umacr": "", "uml": "", "UnderBar": "_", "UnderBrace": "", "UnderBracket": "", "UnderParenthesis": "", "Union": "", "UnionPlus": "", "uogon": "", "Uogon": "", "uopf": "", "Uopf": "", "uparrow": "", "Uparrow": "", "UpArrow": "", "UpArrowBar": "", "UpArrowDownArrow": "", "updownarrow": "", "Updownarrow": "", "UpDownArrow": "", "UpEquilibrium": "", "upharpoonleft": "", "upharpoonright": "", "uplus": "", "UpperLeftArrow": "", "UpperRightArrow": "", "upsi": "", "Upsi": "", "upsih": "", "upsilon": "", "Upsilon": "", "UpTee": "", "UpTeeArrow": "", "upuparrows": "", "urcorn": "", "urcorner": "", "urcrop": "", "uring": "", "Uring": "", "urtri": "", "uscr": "", "Uscr": "", "utdot": "", "utilde": "", "Utilde": "", "utri": "", "utrif": "", "uuarr": "", "uuml": "", "Uuml": "", "uwangle": "", "vangrt": "", "varepsilon": "", "varkappa": "", "varnothing": "", "varphi": "", "varpi": "", "varpropto": "", "varr": "", "vArr": "", "varrho": "", "varsigma": "", "varsubsetneq": "", "varsubsetneqq": "", "varsupsetneq": "", "varsupsetneqq": "", "vartheta": "", "vartriangleleft": "", "vartriangleright": "", "vBar": "", "Vbar": "", "vBarv": "", "vcy": "", "Vcy": "", "vdash": "", "vDash": "", "Vdash": "", "VDash": "", "Vdashl": "", "vee": "", "Vee": "", "veebar": "", "veeeq": "", "vellip": "", "verbar": "|", "Verbar": "", "vert": "|", "Vert": "", "VerticalBar": "", "VerticalLine": "|", "VerticalSeparator": "", "VerticalTilde": "", "VeryThinSpace": "", "vfr": "", "Vfr": "", "vltri": "", "vnsub": "", "vnsup": "", "vopf": "", "Vopf": "", "vprop": "", "vrtri": "", "vscr": "", "Vscr": "", "vsubne": "", "vsubnE": "", "vsupne": "", "vsupnE": "", "Vvdash": "", "vzigzag": "", "wcirc": "", "Wcirc": "", "wedbar": "", "wedge": "", "Wedge": "", "wedgeq": "", "weierp": "", "wfr": "", "Wfr": "", "wopf": "", "Wopf": "", "wp": "", "wr": "", "wreath": "", "wscr": "", "Wscr": "", "xcap": "", "xcirc": "", "xcup": "", "xdtri": "", "xfr": "", "Xfr": "", "xharr": "", "xhArr": "", "xi": "", "Xi": "", "xlarr": "", "xlArr": "", "xmap": "", "xnis": "", "xodot": "", "xopf": "", "Xopf": "", "xoplus": "", "xotime": "", "xrarr": "", "xrArr": "", "xscr": "", "Xscr": "", "xsqcup": "", "xuplus": "", "xutri": "", "xvee": "", "xwedge": "", "yacute": "", "Yacute": "", "yacy": "", "YAcy": "", "ycirc": "", "Ycirc": "", "ycy": "", "Ycy": "", "yen": "", "yfr": "", "Yfr": "", "yicy": "", "YIcy": "", "yopf": "", "Yopf": "", "yscr": "", "Yscr": "", "yucy": "", "YUcy": "", "yuml": "", "Yuml": "", "zacute": "", "Zacute": "", "zcaron": "", "Zcaron": "", "zcy": "", "Zcy": "", "zdot": "", "Zdot": "", "zeetrf": "", "ZeroWidthSpace": "", "zeta": "", "Zeta": "", "zfr": "", "Zfr": "", "zhcy": "", "ZHcy": "", "zigrarr": "", "zopf": "", "Zopf": "", "zscr": "", "Zscr": "", "zwj": "", "zwnj": "" };
      var decodeMapLegacy = { "aacute": "", "Aacute": "", "acirc": "", "Acirc": "", "acute": "", "aelig": "", "AElig": "", "agrave": "", "Agrave": "", "amp": "&", "AMP": "&", "aring": "", "Aring": "", "atilde": "", "Atilde": "", "auml": "", "Auml": "", "brvbar": "", "ccedil": "", "Ccedil": "", "cedil": "", "cent": "", "copy": "", "COPY": "", "curren": "", "deg": "", "divide": "", "eacute": "", "Eacute": "", "ecirc": "", "Ecirc": "", "egrave": "", "Egrave": "", "eth": "", "ETH": "", "euml": "", "Euml": "", "frac12": "", "frac14": "", "frac34": "", "gt": ">", "GT": ">", "iacute": "", "Iacute": "", "icirc": "", "Icirc": "", "iexcl": "", "igrave": "", "Igrave": "", "iquest": "", "iuml": "", "Iuml": "", "laquo": "", "lt": "<", "LT": "<", "macr": "", "micro": "", "middot": "", "nbsp": "", "not": "", "ntilde": "", "Ntilde": "", "oacute": "", "Oacute": "", "ocirc": "", "Ocirc": "", "ograve": "", "Ograve": "", "ordf": "", "ordm": "", "oslash": "", "Oslash": "", "otilde": "", "Otilde": "", "ouml": "", "Ouml": "", "para": "", "plusmn": "", "pound": "", "quot": '"', "QUOT": '"', "raquo": "", "reg": "", "REG": "", "sect": "", "shy": "", "sup1": "", "sup2": "", "sup3": "", "szlig": "", "thorn": "", "THORN": "", "times": "", "uacute": "", "Uacute": "", "ucirc": "", "Ucirc": "", "ugrave": "", "Ugrave": "", "uml": "", "uuml": "", "Uuml": "", "yacute": "", "Yacute": "", "yen": "", "yuml": "" };
      var decodeMapNumeric = { "0": "", "128": "", "130": "", "131": "", "132": "", "133": "", "134": "", "135": "", "136": "", "137": "", "138": "", "139": "", "140": "", "142": "", "145": "", "146": "", "147": "", "148": "", "149": "", "150": "", "151": "", "152": "", "153": "", "154": "", "155": "", "156": "", "158": "", "159": "" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty.call(object2, propertyName);
      };
      var contains = function(array, value) {
        var index = -1;
        var length = array.length;
        while (++index < length) {
          if (array[index] == value) {
            return true;
          }
        }
        return false;
      };
      var merge = function(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key2;
        for (key2 in defaults) {
          result[key2] = has(options, key2) ? options[key2] : defaults[key2];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message) {
        throw Error("Parse error: " + message);
      };
      var encode = function(string, options) {
        options = merge(options, encode.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string = string.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string = string.replace(regexEncodeNonAscii, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function($0) {
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode = function(html, options) {
        options = merge(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError("malformed character reference");
        }
        return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference;
          var next;
          if ($1) {
            reference = $1;
            return decodeMap[reference];
          }
          if ($2) {
            reference = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $0;
            } else {
              if (strict) {
                parseError(
                  "named character reference was not terminated by a semicolon"
                );
              }
              return decodeMapLegacy[reference] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $0;
        });
      };
      decode.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = function(string) {
        return string.replace(regexEscape, function($0) {
          return escapeMap[$0];
        });
      };
      var he2 = {
        "version": "1.2.0",
        "encode": encode,
        "decode": decode,
        "escape": escape,
        "unescape": decode
      };
      if (freeExports && !freeExports.nodeType) {
        if (freeModule) {
          freeModule.exports = he2;
        } else {
          for (var key in he2) {
            has(he2, key) && (freeExports[key] = he2[key]);
          }
        }
      } else {
        root.he = he2;
      }
    })(he$2);
  })(he$3, he$3.exports);
  return he$3.exports;
}
var heExports = requireHe();
const he$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(heExports);
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i;
    return -1;
  },
  // :: (string)  ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string)  OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey) content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string)  OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1) return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any)  OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any)  OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this;
    return new OrderedMap(map.content.concat(this.subtract(map).content));
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map) {
    map = OrderedMap.from(map);
    if (!map.size) return this;
    return new OrderedMap(this.subtract(map).content.concat(map.content));
  },
  // :: (union<Object, OrderedMap>)  OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map) {
    var result = this;
    map = OrderedMap.from(map);
    for (var i = 0; i < map.content.length; i += 2)
      result = result.remove(map.content[i]);
    return result;
  },
  // :: ()  Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value;
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content);
};
function findDiffStart(a, b2, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b2.childCount)
      return a.childCount == b2.childCount ? null : pos;
    let childA = a.child(i), childB = b2.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j2 = 0; childA.text[j2] == childB.text[j2]; j2++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b2, posA, posB) {
  for (let iA = a.childCount, iB = b2.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b2.child(--iB), size = childA.nodeSize;
    if (childA == childB) {
      posA -= size;
      posB -= size;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size;
    posB -= size;
  }
}
class Fragment {
  /**
  @internal
  */
  constructor(content, size) {
    this.content = content;
    this.size = size || 0;
    if (size == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end = pos + child.nodeSize;
      if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start = pos + 1;
        child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);
      }
      pos = end;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from, to, blockSeparator, leafText) {
    let text = "", first = true;
    this.nodesBetween(from, to, (node2, pos) => {
      let nodeText = node2.isText ? node2.text.slice(Math.max(from, pos) - pos, to - pos) : !node2.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node2) : leafText : node2.type.spec.leafText ? node2.type.spec.leafText(node2) : "";
      if (node2.isBlock && (node2.isLeaf && nodeText || node2.isTextblock) && blockSeparator) {
        if (first)
          first = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first)) {
      content[content.length - 1] = last.withText(last.text + first.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from, to = this.size) {
    if (from == 0 && to == this.size)
      return this;
    let result = [], size = 0;
    if (to > from)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end = pos + child.nodeSize;
        if (end > from) {
          if (pos < from || end > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size += child.nodeSize;
        }
        pos = end;
      }
    return new Fragment(result, size);
  }
  /**
  @internal
  */
  cutByIndex(from, to) {
    if (from == to)
      return Fragment.empty;
    if (from == 0 && to == this.content.length)
      return this;
    return new Fragment(this.content.slice(from, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index, node2) {
    let current = this.content[index];
    if (current == node2)
      return this;
    let copy2 = this.content.slice();
    let size = this.size + node2.nodeSize - current.nodeSize;
    copy2[index] = node2;
    return new Fragment(copy2, size);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node2) {
    return new Fragment([node2].concat(this.content), this.size + node2.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node2) {
    return new Fragment(this.content.concat(node2), this.size + node2.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index) {
    let found2 = this.content[index];
    if (!found2)
      throw new RangeError("Index " + index + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content[index] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end = curPos + cur.nodeSize;
      if (end >= pos) {
        if (end == pos)
          return retIndex(i + 1, end);
        return retIndex(i, curPos);
      }
      curPos = end;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return Fragment.empty;
    let joined, size = 0;
    for (let i = 0; i < array.length; i++) {
      let node2 = array[i];
      size += node2.nodeSize;
      if (i && node2.isText && array[i - 1].sameMarkup(node2)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node2.withText(joined[joined.length - 1].text + node2.text);
      } else if (joined) {
        joined.push(node2);
      }
    }
    return new Fragment(joined || array, size);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return Fragment.empty;
    if (nodes instanceof Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(index, offset) {
  found.index = index;
  found.offset = offset;
  return found;
}
function compareDeep(a, b2) {
  if (a === b2)
    return true;
  if (!(a && typeof a == "object") || !(b2 && typeof b2 == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b2) != array)
    return false;
  if (array) {
    if (a.length != b2.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b2[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b2) || !compareDeep(a[p], b2[p]))
        return false;
    for (let p in b2)
      if (!(p in a))
        return false;
  }
  return true;
}
class Mark {
  /**
  @internal
  */
  constructor(type2, attrs) {
    this.type = type2;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type2 = schema.marks[json.type];
    if (!type2)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type2.create(json.attrs);
    type2.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b2) {
    if (a == b2)
      return true;
    if (a.length != b2.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b2[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return Mark.none;
    if (marks instanceof Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b2) => a.type.rank - b2.type.rank);
    return copy2;
  }
}
Mark.none = [];
class ReplaceError extends Error {
}
class Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragmenti.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from, to) {
    return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new Slice(fragment, openStart, openEnd);
  }
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from, to) {
  let { index, offset } = content.findIndex(from), child = content.maybeChild(index);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset == from || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from).append(content.cut(to));
  }
  if (index != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));
}
function insertInto(content, dist2, insert, parent) {
  let { index, offset } = content.findIndex(dist2), child = content.maybeChild(index);
  if (offset == dist2 || child.isText) {
    if (parent && !parent.canReplace(index, index, insert))
      return null;
    return content.cut(0, dist2).append(insert).append(content.cut(dist2));
  }
  let inner = insertInto(child.content, dist2 - offset - 1, insert, child);
  return inner && content.replaceChild(index, child.copy(inner));
}
function replace($from, $to, slice) {
  if (slice.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice.openStart != $to.depth - slice.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice, 0);
}
function replaceOuter($from, $to, slice, depth) {
  let index = $from.index(depth), node2 = $from.node(depth);
  if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {
    let inner = replaceOuter($from, $to, slice, depth + 1);
    return node2.copy(node2.content.replaceChild(index, inner));
  } else if (!slice.content.size) {
    return close(node2, replaceTwoWay($from, $to, depth));
  } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));
  } else {
    let { start, end } = prepareSliceForReplace(slice, $from);
    return close(node2, replaceThreeWay($from, start, end, $to, depth));
  }
}
function checkJoin(main, sub) {
  if (!sub.type.compatibleContent(main.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main.type.name);
}
function joinable$1($before, $after, depth) {
  let node2 = $before.node(depth);
  checkJoin(node2, $after.node(depth));
  return node2;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node2 = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node2.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node2.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node2, content) {
  node2.type.checkContent(content);
  return node2.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type2 = joinable$1($from, $to, depth + 1);
    addNode(close(type2, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice, $along) {
  let extra = $along.depth - slice.openStart, parent = $along.node(extra);
  let node2 = parent.copy(slice.content);
  for (let i = extra - 1; i >= 0; i--)
    node2 = $along.node(i).copy(Fragment.from(node2));
  return {
    start: node2.resolveNoCache(slice.openStart + extra),
    end: node2.resolveNoCache(node2.content.size - slice.openEnd - extra)
  };
}
class ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parenttext nodes are flat in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index = this.index(this.depth);
    if (index == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);
    return dOff ? parent.child(index).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index).cut(0, dOff);
    return index == 0 ? null : this.parent.child(index - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index, depth) {
    depth = this.resolveDepth(depth);
    let node2 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index; i++)
      pos += node2.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index = this.index();
    if (parent.content.size == 0)
      return Mark.none;
    if (this.textOffset)
      return parent.child(index).marks;
    let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);
    if (!main) {
      let tmp = main;
      main = other;
      other = tmp;
    }
    let marks = main.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d2 = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d2 >= 0; d2--)
      if (other.pos <= this.end(d2) && (!pred || pred(this.node(d2))))
        return new NodeRange(this, other, d2);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start = 0, parentOffset = pos;
    for (let node2 = doc2; ; ) {
      let { index, offset } = node2.content.findIndex(parentOffset);
      let rem = parentOffset - offset;
      path.push(node2, index, start + offset);
      if (!rem)
        break;
      node2 = node2.child(index);
      if (node2.isText)
        break;
      parentOffset = rem - 1;
      start += offset + 1;
    }
    return new ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc2, pos) {
    let cache = resolveCache.get(doc2);
    if (cache) {
      for (let i = 0; i < cache.elts.length; i++) {
        let elt = cache.elts[i];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc2, cache = new ResolveCache());
    }
    let result = cache.elts[cache.i] = ResolvedPos.resolve(doc2, pos);
    cache.i = (cache.i + 1) % resolveCacheSize;
    return result;
  }
}
class ResolveCache {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
}
const resolveCacheSize = 12, resolveCache = /* @__PURE__ */ new WeakMap();
class NodeRange {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const emptyAttrs = /* @__PURE__ */ Object.create(null);
let Node$1 = class Node2 {
  /**
  @internal
  */
  constructor(type2, attrs, content, marks = Mark.none) {
    this.type = type2;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index) {
    return this.content.child(index);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index) {
    return this.content.maybeChild(index);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from, to, f, startPos = 0) {
    this.content.nodesBetween(from, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(from, to, blockSeparator, leafText) {
    return this.content.textBetween(from, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type2, attrs, marks) {
    return this.type == type2 && compareDeep(this.attrs, attrs || type2.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new Node2(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new Node2(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from, to = this.content.size) {
    if (from == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from, to = this.content.size, includeParents = false) {
    if (from == to)
      return Slice.empty;
    let $from = this.resolve(from), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start = $from.start(depth), node2 = $from.node(depth);
    let content = node2.content.cut($from.pos - start, $to.pos - start);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from, to, slice) {
    return replace(this.resolve(from), this.resolve(to), slice);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node2 = this; ; ) {
      let { index, offset } = node2.content.findIndex(pos);
      node2 = node2.maybeChild(index);
      if (!node2)
        return null;
      if (offset == pos || node2.isText)
        return node2;
      pos -= offset + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index, offset } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index), index, offset };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index, offset } = this.content.findIndex(pos);
    if (offset < pos)
      return { node: this.content.child(index), index, offset };
    let node2 = this.content.child(index - 1);
    return { node: node2, index: index - 1, offset: offset - node2.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from, to, type2) {
    let found2 = false;
    if (to > from)
      this.nodesBetween(from, to, (node2) => {
        if (type2.isInSet(node2.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {
    let one = this.contentMatchAt(from).matchFragment(replacement, start, end);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start; i < end; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from, to, type2, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start = this.contentMatchAt(from).matchType(type2);
    let end = start && start.matchFragment(this.content, to);
    return end ? end.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark.none;
    for (let i = 0; i < this.marks.length; i++) {
      let mark = this.marks[i];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m2) => m2.type.name)}`);
    this.content.forEach((node2) => node2.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    let node2 = schema.nodeType(json.type).create(json.attrs, content, marks);
    node2.type.checkAttrs(node2.attrs);
    return node2;
  }
};
Node$1.prototype.text = void 0;
class TextNode extends Node$1 {
  /**
  @internal
  */
  constructor(type2, attrs, content, marks) {
    super(type2, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from, to) {
    return this.text.slice(from, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from = 0, to = this.text.length) {
    if (from == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base = super.toJSON();
    base.text = this.text;
    return base;
  }
}
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
class ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type2) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type2)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start = 0, end = frag.childCount) {
    let cur = this;
    for (let i = start; cur && i < end; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type: type2 } = this.next[i];
      if (!(type2.isText || type2.hasRequiredAttrs()))
        return type2;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j2 = 0; j2 < other.next.length; j2++)
        if (this.next[i].type == other.next[j2].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search(match, types2) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types2.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type: type2, next } = match.next[i];
        if (!(type2.isText || type2.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search(next, types2.concat(type2));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type: type2, next } = match.next[i];
        if (!type2.isLeaf && !type2.hasRequiredAttrs() && !(type2.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type2.contentMatch, type: type2, via: current });
          seen[type2.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m2) {
      seen.push(m2);
      for (let i = 0; i < m2.next.length; i++)
        if (seen.indexOf(m2.next[i].next) == -1)
          scan(m2.next[i].next);
    }
    scan(this);
    return seen.map((m2, i) => {
      let out = i + (m2.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m2.next.length; i2++)
        out += (i2 ? ", " : "") + m2.next[i2].type.name + "->" + seen.indexOf(m2.next[i2].next);
      return out;
    }).join("\n");
  }
}
ContentMatch.empty = new ContentMatch(true);
class TokenStream {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
}
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types2 = stream.nodeTypes, type2 = types2[name];
  if (type2)
    return [type2];
  let result = [];
  for (let typeName in types2) {
    let type3 = types2[typeName];
    if (type3.isInGroup(name))
      result.push(type3);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type2) => {
      if (stream.inline == null)
        stream.inline = type2.isInline;
      else if (stream.inline != type2.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type2 };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node2());
  return nfa2;
  function node2() {
    return nfa2.push([]) - 1;
  }
  function edge(from, to, term) {
    let edge2 = { term, to };
    nfa2[from].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from = node2());
      }
    } else if (expr2.type == "star") {
      let loop = node2();
      edge(from, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node2();
      connect(compile(expr2.expr, from), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from)].concat(compile(expr2.expr, from));
    } else if (expr2.type == "range") {
      let cur = from;
      for (let i = 0; i < expr2.min; i++) {
        let next = node2();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node2();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b2) {
  return b2 - a;
}
function nullFrom(nfa2, node2) {
  let result = [];
  scan(node2);
  return result.sort(cmp);
  function scan(node3) {
    let edges = nfa2[node3];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node3);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node2) => {
      nfa2[node2].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node3) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node3) == -1)
            set.push(node3);
        });
      });
    });
    let state2 = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state2.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state2;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state2 = work[i], dead = !state2.validEnd, nodes = [];
    for (let j2 = 0; j2 < state2.next.length; j2++) {
      let { type: type2, next } = state2.next[j2];
      nodes.push(type2.name);
      if (dead && !(type2.isText || type2.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values, type2, name) {
  for (let name2 in values)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type2} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute(typeName, name, attrs[name]);
  return result;
}
class NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node$1(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node$1(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node$1(this, attrs, content.append(after), Mark.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _2 in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
}
function validateType(typeName, attrName, type2) {
  let types2 = type2.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types2.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types2} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
class Attribute {
  constructor(typeName, attrName, options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
    this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults = defaultAttrs(this.attrs);
    this.instance = defaults ? new Mark(this, defaults) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
}
let Schema$1 = class Schema {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type2 = this.nodes[prop], contentExpr = type2.spec.content || "", markExpr = type2.spec.marks;
      type2.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type2.inlineContent = type2.contentMatch.inlineContent;
      if (type2.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type2.isInline || !type2.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type2;
      }
      type2.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type2.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type2 = this.marks[prop], excl = type2.spec.excludes;
      type2.excluded = excl == null ? [type2] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = (json) => Node$1.fromJSON(this, json);
    this.markFromJSON = (json) => Mark.fromJSON(this, json);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type2, attrs = null, content, marks) {
    if (typeof type2 == "string")
      type2 = this.nodeType(type2);
    else if (!(type2 instanceof NodeType))
      throw new RangeError("Invalid node type: " + type2);
    else if (type2.schema != this)
      throw new RangeError("Node type from different schema used (" + type2.name + ")");
    return type2.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type2 = this.nodes.text;
    return new TextNode(type2, type2.defaultAttrs, text, Mark.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type2, attrs) {
    if (typeof type2 == "string")
      type2 = this.marks[type2];
    return type2.create(attrs);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
let DOMParser$1 = class DOMParser2 {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return false;
      let node2 = schema.nodes[r.node];
      return node2.contentMatch.matchType(node2);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, Mark.none, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, Mark.none, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style = rule.style;
      if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
  }
};
const blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
const ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
const listTags = { ol: true, ul: true };
const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type2, preserveWhitespace, base) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type2 && type2.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;
}
class NodeContext {
  constructor(type2, attrs, marks, solid, match, options) {
    this.type = type2;
    this.attrs = attrs;
    this.marks = marks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark.none;
    this.match = match || (options & OPT_OPEN_LEFT ? null : type2.contentMatch);
  }
  findWrapping(node2) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node2));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start = this.type.contentMatch, wrap2;
        if (wrap2 = start.findWrapping(node2.type)) {
          this.match = start;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node2.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m2;
      if (last && last.isText && (m2 = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text = last;
        if (last.text.length == m2[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m2[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node2) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node2.parentNode && !blockTags.hasOwnProperty(node2.parentNode.nodeName.toLowerCase());
  }
}
class ParseContext {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;
    if (preserveWS === "full" || top.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top.content[top.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS !== "full") {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value), marks, !/\S/.test(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom, marks);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top.content.length && top.content[0].isInline && this.open) {
          this.open--;
          top = this.top;
        }
        sync = true;
        if (!top.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom, marks);
        break out;
      }
      let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
      if (innerMarks)
        this.addAll(dom, innerMarks);
      if (sync)
        this.sync(top);
      this.needsBlock = oldNeedsBlock;
    } else {
      let innerMarks = this.readStyles(dom, marks);
      if (innerMarks)
        this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
    }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks, true);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom, marks) {
    let styles = dom.style;
    if (styles && styles.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
        if (value)
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m2) => !rule.clearMark(m2));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node2) => this.insertNode(node2, marks, false));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {
      this.findAtPoint(parent, index);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node2, marks, cautious) {
    let route, sync;
    for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node2);
      if (found2 && (!route || route.length > found2.length + penalty)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid) {
        if (cautious)
          break;
        penalty += 2;
      }
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      marks = this.enterInner(route[i], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node2, marks, cautious) {
    if (node2.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node2, marks, cautious);
    if (innerMarks) {
      this.closeExtra();
      let top = this.top;
      if (top.match)
        top.match = top.match.matchType(node2.type);
      let nodeMarks = Mark.none;
      for (let m2 of innerMarks.concat(node2.marks))
        if (top.type ? top.type.allowsMarkType(m2.type) : markMayApply(m2.type, node2.type))
          nodeMarks = m2.addToSet(nodeMarks);
      top.content.push(node2.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type2, attrs, marks, preserveWS) {
    let innerMarks = this.findPlace(type2.create(attrs), marks, false);
    if (innerMarks)
      innerMarks = this.enterInner(type2, attrs, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type2, attrs, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top = this.top;
    top.match = top.match && top.match.matchType(type2);
    let options = wsOptionsFor(type2, preserveWS, top.options);
    if (top.options & OPT_OPEN_LEFT && top.content.length == 0)
      options |= OPT_OPEN_LEFT;
    let applyMarks = Mark.none;
    marks = marks.filter((m2) => {
      if (top.type ? top.type.allowsMarkType(m2.type) : markMayApply(m2.type, type2)) {
        applyMarks = m2.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type2, attrs, applyMarks, solid, null, options));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j2 = content.length - 1; j2 >= 0; j2--)
        pos += content[j2].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d2 = $context.depth; d2 >= 0; d2--) {
        let deflt = $context.node(d2).contentMatchAt($context.indexAfter(d2)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type2 = this.parser.schema.nodes[name];
      if (type2.isTextblock && type2.defaultAttrs)
        return type2;
    }
  }
}
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type: type2, next } = match.edge(i);
        if (type2 == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
class DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc(options).createDocumentFragment();
    let top = target, active = [];
    fragment.forEach((node2) => {
      if (active.length || node2.marks.length) {
        let keep = 0, rendered = 0;
        while (keep < active.length && rendered < node2.marks.length) {
          let next = node2.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)
            break;
          keep++;
          rendered++;
        }
        while (keep < active.length)
          top = active.pop()[1];
        while (rendered < node2.marks.length) {
          let add = node2.marks[rendered++];
          let markDOM = this.serializeMark(add, node2.isInline, options);
          if (markDOM) {
            active.push([add, top]);
            top.appendChild(markDOM.dom);
            top = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top.appendChild(this.serializeNodeInner(node2, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node2, options) {
    let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node2.type.name](node2), null, node2.attrs);
    if (contentDOM) {
      if (node2.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node2.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node2, options = {}) {
    let dom = this.serializeNodeInner(node2, options);
    for (let i = node2.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node2.marks[i], node2.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);
  }
  static renderSpec(doc2, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc2, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node2) => node2.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
}
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc(options) {
  return options.document || window.document;
}
const suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i = 0; i < value.length; i++)
            scan(value[i]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result;
}
function renderSpec(doc2, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc2.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  let attrs = structure[1], start = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else if (name == "style" && dom.style)
          dom.style.cssText = attrs[name];
        else
          dom.setAttribute(name, attrs[name]);
      }
  }
  for (let i = start; i < structure.length; i++) {
    let child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc2, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}
const lower16 = 65535;
const factor16 = Math.pow(2, 16);
function makeRecover(index, offset) {
  return index + offset * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty)
      return StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;
      if (pos <= end) {
        let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;
        let result = start + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);
        let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start : pos != end)
          del |= DEL_SIDE;
        return new MapResult(result, del, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i] - (this.inverted ? diff : 0);
      if (start > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end = start + oldSize;
      if (pos <= end && i == index * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps, mirror, from = 0, to = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from;
    this.to = to;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from = 0, to = this.maps.length) {
    return new Mapping(this._maps, this.mirror, from, to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m2) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m2);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this._maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map = this._maps[i], result = map.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this._maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type2 = stepsByID[json.stepType];
    if (!type2)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type2.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
}
class StepResult {
  /**
  @internal
  */
  constructor(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc2) {
    return new StepResult(doc2, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc2, from, to, slice) {
    try {
      return StepResult.ok(doc2.replace(from, to, slice));
    } catch (e) {
      if (e instanceof ReplaceError)
        return StepResult.fail(e.message);
      throw e;
    }
  }
}
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
class AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice = new Slice(mapFragment(oldSlice.content, (node2, parent2) => {
      if (!node2.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node2;
      return node2.mark(this.mark.addToSet(node2.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos)
      return null;
    return new AddMarkStep(from.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from, to, mark) {
    super();
    this.from = from;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to);
    let slice = new Slice(mapFragment(oldSlice.content, (node2) => {
      return node2.mark(this.mark.removeFromSet(node2.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deleted && to.deleted || from.pos >= to.pos)
      return null;
    return new RemoveMarkStep(from.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2)
      return StepResult.fail("No node at mark step's position");
    let updated = node2.type.create(node2.attrs, null, this.mark.addToSet(node2.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (node2) {
      let newSet = this.mark.addToSet(node2.marks);
      if (newSet.length == node2.marks.length) {
        for (let i = 0; i < node2.marks.length; i++)
          if (!node2.marks[i].isInSet(newSet))
            return new AddNodeMarkStep(this.pos, node2.marks[i]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2)
      return StepResult.fail("No node at mark step's position");
    let updated = node2.type.create(node2.attrs, null, this.mark.removeFromSet(node2.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2 || !this.mark.isInSet(node2.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from, to, slice, structure = false) {
    super();
    this.from = from;
    this.to = to;
    this.slice = slice;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc2) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice, this.structure);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
class ReplaceAroundStep extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from, to, gapFrom, gapTo, slice, insert, structure = false) {
    super();
    this.from = from;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc2) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
}
Step.jsonID("replaceAround", ReplaceAroundStep);
function contentBetween(doc2, from, to) {
  let $from = doc2.resolve(from), dist2 = to - from, depth = $from.depth;
  while (dist2 > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist2--;
  }
  if (dist2 > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist2 > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist2--;
    }
  }
  return false;
}
function addMark(tr, from, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr.doc.nodesBetween(from, to, (node2, pos, parent) => {
    if (!node2.isInline)
      return;
    let marks = node2.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start = Math.max(pos, from), end = Math.min(pos + node2.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start && removing.mark.eq(marks[i]))
            removing.to = end;
          else
            removed.push(removing = new RemoveMarkStep(start, end, marks[i]));
        }
      }
      if (adding && adding.to == start)
        adding.to = end;
      else
        added.push(adding = new AddMarkStep(start, end, mark));
    }
  });
  removed.forEach((s) => tr.step(s));
  added.forEach((s) => tr.step(s));
}
function removeMark(tr, from, to, mark) {
  let matched = [], step = 0;
  tr.doc.nodesBetween(from, to, (node2, pos) => {
    if (!node2.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node2.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node2.marks))
        toRemove = [mark];
    } else {
      toRemove = node2.marks;
    }
    if (toRemove && toRemove.length) {
      let end = Math.min(pos + node2.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style = toRemove[i], found2;
        for (let j2 = 0; j2 < matched.length; j2++) {
          let m2 = matched[j2];
          if (m2.step == step - 1 && style.eq(matched[j2].style))
            found2 = m2;
        }
        if (found2) {
          found2.to = end;
          found2.step = step;
        } else {
          matched.push({ style, from: Math.max(pos, from), to: end, step });
        }
      }
    }
  });
  matched.forEach((m2) => tr.step(new RemoveMarkStep(m2.from, m2.to, m2.style)));
}
function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node2 = tr.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node2.childCount; i++) {
    let child = node2.child(i), end = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end, Slice.empty));
    } else {
      match = allowed;
      for (let j2 = 0; j2 < child.marks.length; j2++)
        if (!parentType.allowsMarkType(child.marks[j2].type))
          tr.step(new RemoveMarkStep(cur, end, child.marks[j2]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m2, newline = /\r?\n|\r/g, slice;
        while (m2 = newline.exec(child.text)) {
          if (!slice)
            slice = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m2.index, cur + m2.index + m2[0].length, slice));
        }
      }
    }
    cur = end;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr.step(replSteps[i]);
}
function canCut(node2, start, end) {
  return (start == 0 || node2.canReplace(start, node2.childCount)) && (end == node2.childCount || node2.canReplace(0, end));
}
function liftTarget(range2) {
  let parent = range2.parent;
  let content = parent.content.cutByIndex(range2.startIndex, range2.endIndex);
  for (let depth = range2.depth; ; --depth) {
    let node2 = range2.$from.node(depth);
    let index = range2.$from.index(depth), endIndex = range2.$to.indexAfter(depth);
    if (depth < range2.depth && node2.canReplace(index, endIndex, content))
      return depth;
    if (depth == 0 || node2.type.spec.isolating || !canCut(node2, index, endIndex))
      break;
  }
  return null;
}
function lift(tr, range2, target) {
  let { $from, $to, depth } = range2;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start = gapStart, end = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d2 = depth, splitting = false; d2 > target; d2--)
    if (splitting || $from.index(d2) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d2).copy(before));
      openStart++;
    } else {
      start--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d2 = depth, splitting = false; d2 > target; d2--)
    if (splitting || $to.after(d2 + 1) < $to.end(d2)) {
      splitting = true;
      after = Fragment.from($to.node(d2).copy(after));
      openEnd++;
    } else {
      end++;
    }
  tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range2, nodeType, attrs = null, innerRange = range2) {
  let around = findWrappingOutside(range2, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type2) {
  return { type: type2, attrs: null };
}
function findWrappingOutside(range2, type2) {
  let { parent, startIndex, endIndex } = range2;
  let around = parent.contentMatchAt(startIndex).findWrapping(type2);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type2;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range2, type2) {
  let { parent, startIndex, endIndex } = range2;
  let inner = parent.child(startIndex);
  let inside = type2.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type2;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr, range2, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start = range2.start, end = range2.end;
  tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType(tr, from, to, type2, attrs) {
  if (!type2.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from, to, (node2, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node2) : attrs;
    if (node2.isTextblock && !node2.hasMarkup(type2, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type2)) {
      let convertNewlines = null;
      if (type2.schema.linebreakReplacement) {
        let pre = type2.whitespace == "pre", supportLinebreak = !!type2.contentMatch.matchType(type2.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr, node2, pos, mapFrom);
      clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type2, void 0, convertNewlines === null);
      let mapping = tr.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node2.nodeSize, 1);
      tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type2.create(attrsHere, null, node2.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr, node2, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr, node2, pos, mapFrom) {
  node2.forEach((child, offset) => {
    if (child.isText) {
      let m2, newline = /\r?\n|\r/g;
      while (m2 = newline.exec(child.text)) {
        let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m2.index);
        tr.replaceWith(start, start + 1, node2.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr, node2, pos, mapFrom) {
  node2.forEach((child, offset) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);
      tr.replaceWith(start, start + 1, node2.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc2, pos, type2) {
  let $pos = doc2.resolve(pos), index = $pos.index();
  return $pos.parent.canReplaceWith(index, index + 1, type2);
}
function setNodeMarkup(tr, pos, type2, attrs, marks) {
  let node2 = tr.doc.nodeAt(pos);
  if (!node2)
    throw new RangeError("No node at given position");
  if (!type2)
    type2 = node2.type;
  let newNode = type2.create(attrs, null, marks || node2.marks);
  if (node2.isLeaf)
    return tr.replaceWith(pos, pos + node2.nodeSize, newNode);
  if (!type2.validContent(node2.content))
    throw new RangeError("Invalid content for node type " + type2.name);
  tr.step(new ReplaceAroundStep(pos, pos + node2.nodeSize, pos + 1, pos + node2.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc2, pos, depth = 1, typesAfter) {
  let $pos = doc2.resolve(pos), base = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d2 = $pos.depth - 1, i = depth - 2; d2 > base; d2--, i--) {
    let node2 = $pos.node(d2), index2 = $pos.index(d2);
    if (node2.type.spec.isolating)
      return false;
    let rest = node2.content.cutByIndex(index2, node2.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node2;
    if (!node2.canReplace(index2 + 1, node2.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index = $pos.indexAfter(base);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);
}
function split(tr, pos, depth = 1, typesAfter) {
  let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d2 = $pos.depth, e = $pos.depth - depth, i = depth - 1; d2 > e; d2--, i--) {
    before = Fragment.from($pos.node(d2).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d2).copy(after));
  }
  tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc2, pos) {
  let $pos = doc2.resolve(pos), index = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);
}
function canAppendWithSubstitutedLinebreaks(a, b2) {
  if (!b2.content.size)
    a.type.compatibleContent(b2.type);
  let match = a.contentMatchAt(a.childCount);
  let { linebreakReplacement } = a.type.schema;
  for (let i = 0; i < b2.childCount; i++) {
    let child = b2.child(i);
    let type2 = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
    match = match.matchType(type2);
    if (!match)
      return false;
    if (!a.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable(a, b2) {
  return !!(a && b2 && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b2));
}
function joinPoint(doc2, pos, dir = -1) {
  let $pos = doc2.resolve(pos);
  for (let d2 = $pos.depth; ; d2--) {
    let before, after, index = $pos.index(d2);
    if (d2 == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d2 + 1);
      index++;
      after = $pos.node(d2).maybeChild(index);
    } else {
      before = $pos.node(d2).maybeChild(index - 1);
      after = $pos.node(d2 + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d2).canReplace(index, index + 1))
      return pos;
    if (d2 == 0)
      break;
    pos = dir < 0 ? $pos.before(d2) : $pos.after(d2);
  }
}
function join(tr, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr.doc.type.schema;
  let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr.steps.length;
  if (convertNewlines === false) {
    let $after = tr.doc.resolve(pos + depth);
    replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);
  tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr.doc.resolve(start);
    replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);
  }
  return tr;
}
function insertPoint(doc2, pos, nodeType) {
  let $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d2 = $pos.depth - 1; d2 >= 0; d2--) {
      let index = $pos.index(d2);
      if ($pos.node(d2).canReplaceWith(index, index, nodeType))
        return $pos.before(d2 + 1);
      if (index > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d2 = $pos.depth - 1; d2 >= 0; d2--) {
      let index = $pos.indexAfter(d2);
      if ($pos.node(d2).canReplaceWith(index, index, nodeType))
        return $pos.after(d2 + 1);
      if (index < $pos.node(d2).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc2, pos, slice) {
  let $pos = doc2.resolve(pos);
  if (!slice.content.size)
    return pos;
  let content = slice.content;
  for (let i = 0; i < slice.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {
    for (let d2 = $pos.depth; d2 >= 0; d2--) {
      let bias = d2 == $pos.depth ? 0 : $pos.pos <= ($pos.start(d2 + 1) + $pos.end(d2 + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d2) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d2), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d2 + 1) : $pos.after(d2 + 1);
    }
  }
  return null;
}
function replaceStep(doc2, from, to = from, slice = Slice.empty) {
  if (from == to && !slice.size)
    return null;
  let $from = doc2.resolve(from), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice))
    return new ReplaceStep(from, to, slice);
  return new Fitter($from, $to, slice).fit();
}
function fitsTrivially($from, $to, slice) {
  return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);
}
class Fitter {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node2 = $from.node(i);
      this.frontier.push({
        type: node2.type,
        match: node2.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);
    if (slice.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d2 = 0, openEnd = this.unplaced.openEnd; d2 < startDepth; d2++) {
      let node2 = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node2.type.spec.isolating && openEnd <= d2) {
        startDepth = d2;
        break;
      }
      cur = node2.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type: type2, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false)) : parent && type2.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first && (wrap2 = match.findWrapping(first.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice = this.unplaced, fragment = parent ? parent.content : slice.content;
    let openStart = slice.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type: type2 } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type2.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node2 = cur.lastChild;
      this.frontier.push({ type: node2.type, match: node2.contentMatchAt(node2.childCount) });
      cur = node2.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top = this.frontier[this.depth], level;
    if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      let { match, type: type2 } = this.frontier[i];
      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      let fit = contentAfterFits($to, i, type2, match, dropInner);
      if (!fit)
        continue;
      for (let d2 = i - 1; d2 >= 0; d2--) {
        let { match: match2, type: type3 } = this.frontier[d2];
        let matches2 = contentAfterFits($to, d2, type3, match2, true);
        if (!matches2 || matches2.childCount)
          continue scan;
      }
      return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d2 = close2.depth + 1; d2 <= $to.depth; d2++) {
      let node2 = $to.node(d2), add = node2.type.contentMatch.fillBefore(node2.content, true, $to.index(d2));
      this.openFrontierNode(node2.type, node2.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type2, attrs = null, content) {
    let top = this.frontier[this.depth];
    top.match = top.match.matchType(type2);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type2.create(attrs, content)));
    this.frontier.push({ type: type2, match: type2.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
}
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node2, openStart, openEnd) {
  if (openStart <= 0)
    return node2;
  let frag = node2.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node2.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node2.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node2.copy(frag);
}
function contentAfterFits($to, depth, type2, match, open) {
  let node2 = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index == node2.childCount && !type2.compatibleContent(node2.type))
    return null;
  let fit = match.fillBefore(node2.content, true, index);
  return fit && !invalidMarks(type2, node2.content, index) ? fit : null;
}
function invalidMarks(type2, fragment, start) {
  for (let i = start; i < fragment.childCount; i++)
    if (!type2.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type2) {
  return type2.spec.defining || type2.spec.definingForContent;
}
function replaceRange(tr, from, to, slice) {
  if (!slice.size)
    return tr.deleteRange(from, to);
  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice))
    return tr.step(new ReplaceStep(from, to, slice));
  let targetDepths = coveredDepths($from, tr.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d2 = $from.depth, pos = $from.pos - 1; d2 > 0; d2--, pos--) {
    let spec = $from.node(d2).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d2) > -1)
      preferredTarget = d2;
    else if ($from.before(d2) == pos)
      targetDepths.splice(1, 0, -d2);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice.openStart;
  for (let content = slice.content, i = 0; ; i++) {
    let node2 = content.firstChild;
    leftNodes.push(node2);
    if (i == slice.openStart)
      break;
    content = node2.content;
  }
  for (let d2 = preferredDepth - 1; d2 >= 0; d2--) {
    let leftNode = leftNodes[d2], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d2;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j2 = slice.openStart; j2 >= 0; j2--) {
    let openDepth = (j2 + preferredDepth + 1) % (slice.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index, index, insert.type, insert.marks))
        return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));
    }
  }
  let startSteps = tr.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr.replace(from, to, slice);
    if (tr.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first = fragment.firstChild;
    fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start = match.fillBefore(fragment).append(fragment);
    fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr, from, to, node2) {
  if (!node2.isInline && from == to && tr.doc.resolve(from).parent.content.size) {
    let point = insertPoint(tr.doc, from, node2.type);
    if (point != null)
      from = to = point;
  }
  tr.replaceRange(from, to, new Slice(Fragment.from(node2), 0, 0));
}
function deleteRange(tr, from, to) {
  let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr.delete($from.before(depth), $to.after(depth));
  }
  for (let d2 = 1; d2 <= $from.depth && d2 <= $to.depth; d2++) {
    if (from - $from.start(d2) == $from.depth - d2 && to > $from.end(d2) && $to.end(d2) - to != $to.depth - d2 && $from.start(d2 - 1) == $to.start(d2 - 1) && $from.node(d2 - 1).canReplace($from.index(d2 - 1), $to.index(d2 - 1)))
      return tr.delete($from.before(d2), to);
  }
  tr.delete(from, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d2 = minDepth; d2 >= 0; d2--) {
    let start = $from.start(d2);
    if (start < $from.pos - ($from.depth - d2) || $to.end(d2) > $to.pos + ($to.depth - d2) || $from.node(d2).type.spec.isolating || $to.node(d2).type.spec.isolating)
      break;
    if (start == $to.start(d2) || d2 == $from.depth && d2 == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d2 && $to.start(d2 - 1) == start - 1)
      result.push(d2);
  }
  return result;
}
class AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node2.attrs)
      attrs[name] = node2.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node2.type.create(attrs, null, node2.marks);
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(json.pos, json.attr, json.value);
  }
}
Step.jsonID("attr", AttrStep);
class DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc2.attrs)
      attrs[name] = doc2.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc2.type.create(attrs, doc2.content, doc2.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep(json.attr, json.value);
  }
}
Step.jsonID("docAttr", DocAttrStep);
let TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc2;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from, to = from, slice = Slice.empty) {
    let step = replaceStep(this.doc, from, to, slice);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from, to, content) {
    return this.replace(from, to, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from, to) {
    return this.replace(from, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from, to, slice) {
    replaceRange(this, from, to, slice);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from, to, node2) {
    replaceRangeWith(this, from, to, node2);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from, to) {
    deleteRange(this, from, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range2, target) {
    lift(this, range2, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range2, wrappers) {
    wrap(this, range2, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from, to = from, type2, attrs = null) {
    setBlockType(this, from, to, type2, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type2, attrs = null, marks) {
    setNodeMarkup(this, pos, type2, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    let node2 = this.doc.nodeAt(pos);
    if (!node2)
      throw new RangeError("No node at position " + pos);
    if (mark instanceof Mark) {
      if (mark.isInSet(node2.marks))
        this.step(new RemoveNodeMarkStep(pos, mark));
    } else {
      let set = node2.marks, found2, steps = [];
      while (found2 = mark.isInSet(set)) {
        steps.push(new RemoveNodeMarkStep(pos, found2));
        set = found2.removeFromSet(set);
      }
      for (let i = steps.length - 1; i >= 0; i--)
        this.step(steps[i]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from, to, mark) {
    addMark(this, from, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from, to, mark) {
    removeMark(this, from, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
}
const classesById = /* @__PURE__ */ Object.create(null);
class Selection {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr, node2) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      let from = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from, to);
      } else {
        tr.replaceRangeWith(from, to, node2);
        selectionToInsertionEnd(tr, mapFrom, node2.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc2, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection.prototype.visible = true;
class SelectionRange {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
class TextSelection extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content = Slice.empty) {
    super.replace(tr, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection($anchor, $head);
  }
}
Selection.jsonID("text", TextSelection);
class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}
class NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node2 = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node2.nodeSize);
    super($pos, $end);
    this.node = node2;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc2.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc2, from) {
    return new NodeSelection(doc2.resolve(from));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node2) {
    return !node2.isText && node2.type.spec.selectable !== false;
  }
}
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node2 = $pos.nodeAfter;
    if (node2 && NodeSelection.isSelectable(node2))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
}
class AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr, content = Slice.empty) {
    if (content == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc2) {
    return new AllSelection(doc2);
  }
  map(doc2) {
    return new AllSelection(doc2);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node2, pos, index, dir, text = false) {
  if (node2.inlineContent)
    return TextSelection.create(doc2, pos);
  for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node2.childCount : i >= 0; i += dir) {
    let child = node2.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd(tr, startLen, bias) {
  let last = tr.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))
    return;
  let map = tr.mapping.maps[last], end;
  map.forEach((_from, _to, _newFrom, newTo) => {
    if (end == null)
      end = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end), bias));
}
const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
class Transaction extends Transform {
  /**
  @internal
  */
  constructor(state2) {
    super(state2.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state2.selection;
    this.storedMarks = state2.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    super.addStep(step, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time) {
    this.time = time;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice) {
    this.selection.replace(this, slice);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node2, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node2 = node2.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark.none));
    selection.replaceWith(this, node2);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from, to) {
    let schema = this.doc.type.schema;
    if (from == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from;
      to = to == null ? from : to;
      if (!text)
        return this.deleteRange(from, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from);
        marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from, to, schema.text(text, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _2 in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
class FieldDesc {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
}
const baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr, _marks, _old, state2) {
      return state2.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
class Configuration {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin) => {
        if (this.pluginsByKey[plugin.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin.key + ")");
        this.plugins.push(plugin);
        this.pluginsByKey[plugin.key] = plugin;
        if (plugin.spec.state)
          this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));
      });
  }
}
class EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr) {
    return this.applyTransaction(tr).state;
  }
  /**
  @internal
  */
  filterTransaction(tr, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin = this.config.plugins[i];
        if (plugin.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr = n < trs.length && plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j2 = 0; j2 < this.config.plugins.length; j2++)
                seen.push(j2 < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr) {
    if (!tr.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m2) => m2.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin = pluginFields[prop], state2 = plugin.spec.state;
        if (state2 && state2.toJSON)
          result[prop] = state2.toJSON.call(plugin, this[plugin.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node$1.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin = pluginFields[prop], state2 = plugin.spec.state;
            if (plugin.key == field.name && state2 && state2.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state2.fromJSON.call(plugin, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
}
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
class Plugin {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state2) {
    return state2[this.key];
  }
}
const keys = /* @__PURE__ */ Object.create(null);
function createKey(name) {
  if (name in keys)
    return name + "$" + ++keys[name];
  keys[name] = 0;
  return name + "$";
}
class PluginKey {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state2) {
    return state2.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state2) {
    return state2[this.key];
  }
}
function callOrGet(value, context = null, ...props) {
  if (typeof value === "function") {
    if (context) return value.bind(context)(...props);
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
const isMacOS = () => {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
};
const isIOS = () => {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    navigator.platform
  );
};
const isRegExp = (value) => {
  return Object.prototype.toString.call(value) === "[object RegExp]";
};
function objectIncludes(obj1, obj2, options = { strict: true }) {
  const keys2 = Object.keys(obj2);
  if (!keys2.length) return true;
  return keys2.every((key) => {
    if (options.strict) return obj2[key] === obj1[key];
    if (isRegExp(obj2[key])) return obj2[key].test(obj1[key]);
    return obj2[key] === obj1[key];
  });
}
function deleteProps(obj, propOrProps) {
  const isString = typeof propOrProps === "string";
  const props = isString ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    const contains = props.includes(prop);
    if (!contains) newObj[prop] = obj[prop];
    return newObj;
  }, {});
}
const CSS_DIMENSION_REGEX = /[\d-.]+(\w+)$/;
const DOM_SIZE_UNITS = ["px", "rem", "em", "in", "q", "mm", "cm", "pt", "pc", "vh", "vw", "vmin", "vmax"];
function parseSizeUnit(val = "0") {
  const length = val.toString() || "0";
  const value = Number.parseFloat(length);
  const match = length.match(CSS_DIMENSION_REGEX);
  const unit = (match?.[1] ?? "").toLowerCase();
  return [value, DOM_SIZE_UNITS.includes(unit) ? unit : null];
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
async function readFromClipboard(state2) {
  let html = "";
  let text = "";
  if (navigator.clipboard && navigator.clipboard.read) {
    try {
      const items = await navigator.clipboard.read();
      for (const item of items) {
        if (item.types.includes("text/html")) {
          html = await (await item.getType("text/html")).text();
          break;
        } else if (item.types.includes("text/plain")) {
          text = await (await item.getType("text/plain")).text();
        }
      }
    } catch {
      text = await navigator.clipboard.readText();
    }
  } else {
    text = await navigator.clipboard.readText();
  }
  let content = null;
  if (html) {
    try {
      content = DOMParser$1.fromSchema(state2.schema).parseSlice(
        new window.DOMParser().parseFromString(`<body>${html}</body>`, "text/html").body
      ).content;
    } catch (e) {
      console.error("error parsing html", e);
      content = state2.schema.text(text);
    }
  }
  if (!content && text) {
    content = state2.schema.text(text);
  }
  return content;
}
function inchesToTwips(inches) {
  if (inches == null) return;
  if (typeof inches === "string") inches = parseFloat(inches);
  return Math.round(inches * 1440);
}
function twipsToInches(twips) {
  if (twips == null) return;
  if (typeof twips === "string") twips = parseInt(twips, 10);
  return Math.round(twips / 1440 * 100) / 100;
}
function twipsToPixels(twips) {
  if (twips == null) return;
  twips = twipsToInches(twips);
  return Math.round(twips * 96);
}
function pixelsToTwips(pixels) {
  if (pixels == null) return;
  pixels = pixels / 96;
  return inchesToTwips(pixels);
}
function twipsToLines(twips) {
  if (twips == null) return;
  return twips / 240;
}
function linesToTwips(lines) {
  if (lines == null) return;
  return lines * 240;
}
function halfPointToPoints(halfPoints) {
  if (halfPoints == null) return;
  return Math.round(halfPoints / 2);
}
function emuToPixels(emu) {
  if (emu == null) return;
  if (typeof emu === "string") emu = parseFloat(emu);
  const pixels = emu * 96 / 914400;
  return Math.round(pixels);
}
function pixelsToEmu(px) {
  if (px == null) return;
  if (typeof px === "string") px = parseFloat(px);
  return Math.round(px * 9525);
}
function eigthPointsToPixels(eigthPoints) {
  if (eigthPoints == null) return;
  const points = parseFloat(eigthPoints) / 8;
  const pixels = points * 1.3333;
  return pixels;
}
function pixelsToEightPoints(pixels) {
  if (pixels == null) return;
  return Math.round(pixels * 6);
}
function twipsToPt(twips) {
  if (twips == null) return;
  return twips / 20;
}
function ptToTwips(pt) {
  if (pt == null) return;
  return pt * 20;
}
const getTextIndentExportValue = (indent) => {
  const [value, unit] = parseSizeUnit(indent);
  const functionsMap = {
    pt: ptToTwips,
    in: inchesToTwips
  };
  const exportValue = functionsMap[unit] ? functionsMap[unit](value) : pixelsToTwips(value);
  return exportValue;
};
const getArrayBufferFromUrl = async (input, isHeadless) => {
  const isLikelyUrl = /^https?:|^blob:|^file:|^data:/i.test(input);
  if (isHeadless && isLikelyUrl && typeof fetch === "function") {
    const res = await fetch(input);
    if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);
    return await res.arrayBuffer();
  }
  const base64 = input.includes(",") ? input.split(",", 2)[1] : input.trim().replace(/\s/g, "");
  try {
    if (typeof globalThis.atob === "function") {
      const binary = globalThis.atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    }
  } catch (err) {
    console.warn("atob failed, falling back to Buffer:", err);
  }
  const buf = Buffer2.from(base64, "base64");
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
};
const getContentTypesFromXml = (contentTypesXml) => {
  const parser = new window.DOMParser();
  const xmlDoc = parser.parseFromString(contentTypesXml, "text/xml");
  const defaults = xmlDoc.querySelectorAll("Default");
  return Array.from(defaults).map((item) => item.getAttribute("Extension"));
};
const getHexColorFromDocxSystem = (docxColor) => {
  const colorMap = /* @__PURE__ */ new Map([
    ["yellow", "#ffff00"],
    ["green", "#00ff00"],
    ["blue", "#0000FFFF"],
    ["cyan", "#00ffff"],
    ["magenta", "#ff00ff"],
    ["red", "#ff0000"],
    ["darkYellow", "#808000FF"],
    ["darkGreen", "#008000FF"],
    ["darkBlue", "#000080"],
    ["darkCyan", "#008080FF"],
    ["darkMagenta", "#800080FF"],
    ["darkGray", "#808080FF"],
    ["darkRed", "#800000FF"],
    ["lightGray", "#C0C0C0FF"],
    ["black", "#000"]
  ]);
  return colorMap.get(docxColor) || null;
};
function isValidHexColor(color) {
  if (!color || typeof color !== "string") return false;
  switch (color.length) {
    case 3:
      return /^[0-9A-F]{3}$/i.test(color);
    case 6:
      return /^[0-9A-F]{6}$/i.test(color);
    case 8:
      return /^[0-9A-F]{8}$/i.test(color);
    default:
      return false;
  }
}
const componentToHex = (val) => {
  const a = Number(val).toString(16);
  return a.length === 1 ? "0" + a : a;
};
const rgbToHex = (rgb) => {
  return "#" + rgb.match(/\d+/g).map(componentToHex).join("");
};
const getLineHeightValueString = (lineHeight, defaultUnit, lineRule = "", isObject = false) => {
  let [value, unit] = parseSizeUnit(lineHeight);
  if (Number.isNaN(value) || value === 0) return {};
  if (lineRule === "atLeast" && value < 1) return {};
  unit = unit ? unit : defaultUnit;
  return isObject ? { ["line-height"]: `${value}${unit}` } : `line-height: ${value}${unit}`;
};
const deobfuscateFont = (arrayBuffer, guidHex) => {
  const dta = new Uint8Array(arrayBuffer);
  const guidStr = guidHex.replace(/[-{}]/g, "");
  if (guidStr.length !== 32) {
    console.error("Invalid GUID");
    return;
  }
  const guidBytes = new Uint8Array(16);
  for (let i = 0, j2 = 0; i < 32; i += 2, j2++) {
    const hexByte = guidStr[i] + guidStr[i + 1];
    guidBytes[j2] = parseInt(hexByte, 16);
  }
  for (let i = 0; i < 32; i++) {
    const gi = 15 - i % 16;
    dta[i] ^= guidBytes[gi];
  }
  return dta.buffer;
};
const hasSomeParentWithClass = (element, classname) => {
  if (element.className?.split(" ")?.indexOf(classname) >= 0) return true;
  return element.parentNode && hasSomeParentWithClass(element.parentNode, classname);
};
function generateDocxRandomId(length = 8) {
  const characters = "0123456789abcdef";
  let id = [];
  for (let i = 0; i < length; i++) {
    const randomIndex = Math.floor(Math.random() * characters.length);
    id.push(characters[randomIndex]);
  }
  return id.join("");
}
function generateRandom32BitHex() {
  const val = Math.floor(Math.random() * 2147483647);
  return val.toString(16).toUpperCase().padStart(8, "0");
}
const DEFAULT_DOCX_DEFS = {
  "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
  "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
  "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
  "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
  "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
  "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
  "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
  "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
  "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
  "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
  "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
  "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
  "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
  "xmlns:o": "urn:schemas-microsoft-com:office:office",
  "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
  "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
  "xmlns:v": "urn:schemas-microsoft-com:vml",
  "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
  "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
  "xmlns:w10": "urn:schemas-microsoft-com:office:word",
  "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
  "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
  "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
  "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
  "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
  "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
  "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
  "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
  "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
  "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
  "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
  "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
  "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
  "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
  "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
};
const DEFAULT_CUSTOM_XML = {
  elements: [
    {
      type: "element",
      name: "Properties",
      attributes: {
        xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
        "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
      },
      elements: []
    }
  ]
};
const SETTINGS_CUSTOM_XML = {
  elements: [
    {
      type: "element",
      name: "w:settings",
      attributes: {
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
      },
      elements: []
    }
  ]
};
const COMMENT_REF = {
  type: "element",
  name: "w:r",
  elements: [
    {
      type: "element",
      name: "w:rPr",
      elements: [
        {
          type: "element",
          name: "w:rStyle",
          attributes: {
            "w:val": "CommentReference"
          }
        }
      ]
    },
    {
      type: "element",
      name: "w:annotationRef"
    }
  ]
};
const DEFAULT_LINKED_STYLES = {
  Normal: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:default": "1",
      "w:styleId": "Normal"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      }
    ]
  },
  Title: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Title"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "Title"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "TitleChar"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "10"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00B72667"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:contextualSpacing"
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "majorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "majorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:val": "-10"
            }
          },
          {
            type: "element",
            name: "w:kern",
            attributes: {
              "w:val": "28"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "56"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "56"
            }
          }
        ]
      }
    ]
  },
  Subtitle: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Subtitle"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "Subtitle"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "SubtitleChar"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "11"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00B72667"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:numPr",
            elements: [
              {
                type: "element",
                name: "w:ilvl",
                attributes: {
                  "w:val": "1"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:after": "160"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "minorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "minorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "595959",
              "w:themeColor": "text1",
              "w:themeTint": "A6"
            }
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:val": "15"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "28"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "28"
            }
          }
        ]
      }
    ]
  },
  Heading1: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Heading1"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "heading 1"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "Heading1Char"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "9"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00233D7B"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:keepNext"
          },
          {
            type: "element",
            name: "w:keepLines"
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:before": "360",
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:outlineLvl",
            attributes: {
              "w:val": "0"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "majorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "majorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "0F4761",
              "w:themeColor": "accent1",
              "w:themeShade": "BF"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "40"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "40"
            }
          }
        ]
      }
    ]
  },
  Heading2: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Heading2"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "heading 2"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "Heading2Char"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "9"
        }
      },
      {
        type: "element",
        name: "w:semiHidden"
      },
      {
        type: "element",
        name: "w:unhideWhenUsed"
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00233D7B"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:keepNext"
          },
          {
            type: "element",
            name: "w:keepLines"
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:before": "160",
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:outlineLvl",
            attributes: {
              "w:val": "1"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "majorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "majorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "0F4761",
              "w:themeColor": "accent1",
              "w:themeShade": "BF"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "32"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "32"
            }
          }
        ]
      }
    ]
  },
  Heading3: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Heading3"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "heading 3"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "Heading3Char"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "9"
        }
      },
      {
        type: "element",
        name: "w:semiHidden"
      },
      {
        type: "element",
        name: "w:unhideWhenUsed"
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00233D7B"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:keepNext"
          },
          {
            type: "element",
            name: "w:keepLines"
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:before": "160",
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:outlineLvl",
            attributes: {
              "w:val": "2"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:eastAsiaTheme": "majorEastAsia",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "0F4761",
              "w:themeColor": "accent1",
              "w:themeShade": "BF"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "28"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "28"
            }
          }
        ]
      }
    ]
  }
};
const COMMENTS_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w:comments",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
      },
      elements: []
    }
  ]
};
const COMMENTS_EXTENDED_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w15:commentsEx",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
      },
      elements: []
    }
  ]
};
const COMMENTS_EXTENSIBLE_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w16cex:commentsExtensible",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:cr": "http://schemas.microsoft.com/office/comments/2020/reactions",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl cr w16du wp14"
      },
      elements: []
    }
  ]
};
const COMMENTS_IDS_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w16cid:commentsIds",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
      },
      elements: []
    }
  ]
};
const DOCUMENT_RELS_XML_DEF = {
  elements: [
    {
      type: "element",
      name: "Relationships",
      attributes: {
        xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
      },
      elements: [
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId8",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
            Target: "fontTable.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId3",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings",
            Target: "webSettings.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId7",
            Type: "http://schemas.microsoft.com/office/2018/08/relationships/commentsExtensible",
            Target: "commentsExtensible.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId2",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
            Target: "settings.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId1",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
            Target: "styles.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId6",
            Type: "http://schemas.microsoft.com/office/2016/09/relationships/commentsIds",
            Target: "commentsIds.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId5",
            Type: "http://schemas.microsoft.com/office/2011/relationships/commentsExtended",
            Target: "commentsExtended.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId10",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
            Target: "theme/theme1.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId4",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
            Target: "comments.xml"
          }
        }
        // {
        //     "type": "element",
        //     "name": "Relationship",
        //     "attributes": {
        //         "Id": "rId9",
        //         "Type": "http://schemas.microsoft.com/office/2011/relationships/people",
        //         "Target": "people.xml"
        //     }
        // }
      ]
    }
  ]
};
const CONTENT_TYPES = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "Types",
      attributes: {
        xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
      },
      elements: [
        {
          type: "element",
          name: "Default",
          attributes: {
            Extension: "rels",
            ContentType: "application/vnd.openxmlformats-package.relationships+xml"
          }
        },
        {
          type: "element",
          name: "Default",
          attributes: {
            Extension: "xml",
            ContentType: "application/xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/document.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/styles.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/settings.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/webSettings.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/comments.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/commentsExtended.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtended+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/commentsIds.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsIds+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/commentsExtensible.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtensible+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/fontTable.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/people.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.people+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/theme/theme1.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.theme+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/docProps/core.xml",
            ContentType: "application/vnd.openxmlformats-package.core-properties+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/docProps/app.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/numbering.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml"
          }
        }
      ]
    }
  ]
};
const COMMENTS_XML_DEFINITIONS = {
  COMMENTS_XML_DEF,
  COMMENTS_EXTENDED_XML_DEF,
  COMMENTS_EXTENSIBLE_XML_DEF,
  COMMENTS_IDS_XML_DEF,
  DOCUMENT_RELS_XML_DEF,
  CONTENT_TYPES
};
const TrackInsertMarkName = "trackInsert";
const TrackDeleteMarkName = "trackDelete";
const TrackFormatMarkName = "trackFormat";
const carbonCopy = (obj) => {
  if (!obj) return void 0;
  try {
    return JSON.parse(JSON.stringify(obj));
  } catch (e) {
    console.error("Error in carbonCopy", obj, e);
    return void 0;
  }
};
function translateCommentNode(params, type2) {
  const { node: node2, commentsExportType, exportedCommentDefs = [] } = params;
  if (!exportedCommentDefs.length || commentsExportType === "clean") return;
  const nodeId = node2.attrs["w:id"];
  const originalComment = params.comments.find((comment) => {
    return comment.commentId == nodeId;
  });
  if (!originalComment) return;
  const commentIndex = params.comments?.findIndex((comment) => comment.commentId === originalComment.commentId);
  const parentId = originalComment.parentCommentId;
  let parentComment;
  if (parentId) {
    parentComment = params.comments.find((c) => c.commentId === parentId || c.importedId === parentId);
  }
  const isInternal = parentComment?.isInternal || originalComment.isInternal;
  if (commentsExportType === "external" && isInternal) return;
  const isResolved = !!originalComment.resolvedTime;
  if (isResolved) return;
  let commentSchema = getCommentSchema(type2, commentIndex);
  if (type2 === "End") {
    const commentReference = {
      name: "w:r",
      elements: [{ name: "w:commentReference", attributes: { "w:id": String(commentIndex) } }]
    };
    commentSchema = [commentSchema, commentReference];
  }
  return commentSchema;
}
const getCommentSchema = (type2, commentId) => {
  return {
    name: `w:commentRange${type2}`,
    attributes: {
      "w:id": String(commentId)
    }
  };
};
const prepareCommentParaIds = (comment) => {
  const newComment = {
    ...comment,
    commentParaId: generateRandom32BitHex()
  };
  return newComment;
};
const getCommentDefinition = (comment, commentId, allComments, editor) => {
  const translatedText = translateParagraphNode({ editor, node: comment.commentJSON });
  const attributes = {
    "w:id": String(commentId),
    "w:author": comment.creatorName || comment.importedAuthor?.name,
    "w:email": comment.creatorEmail || comment.importedAuthor?.email,
    "w:date": toIsoNoFractional(comment.createdTime),
    "w:initials": getInitials(comment.creatorName),
    "w:done": comment.resolvedTime ? "1" : "0",
    "w15:paraId": comment.commentParaId,
    "custom:internalId": comment.commentId || comment.internalId,
    "custom:trackedChange": comment.trackedChange,
    "custom:trackedChangeText": comment.trackedChangeText || null,
    "custom:trackedChangeType": comment.trackedChangeType,
    "custom:trackedDeletedText": comment.deletedText || null
  };
  if (comment?.parentCommentId) {
    const parentComment = allComments.find((c) => c.commentId === comment.parentCommentId);
    attributes["w15:paraIdParent"] = parentComment.commentParaId;
  }
  return {
    type: "element",
    name: "w:comment",
    attributes,
    elements: [translatedText]
  };
};
const getInitials = (name) => {
  if (!name) return null;
  const preparedText = name.replace("(imported)", "").trim();
  const initials = preparedText.split(" ").map((word) => word[0]).join("");
  return initials;
};
const toIsoNoFractional = (unixMillis) => {
  const date = new Date(unixMillis || Date.now());
  return date.toISOString().replace(/\.\d{3}Z$/, "Z");
};
const updateCommentsXml = (commentDefs = [], commentsXml) => {
  const newCommentsXml = carbonCopy(commentsXml);
  commentDefs.forEach((commentDef) => {
    const elements = commentDef.elements[0].elements;
    elements.unshift(COMMENT_REF);
    const paraId = commentDef.attributes["w15:paraId"];
    commentDef.elements[0].attributes["w14:paraId"] = paraId;
    commentDef.attributes = {
      "w:id": commentDef.attributes["w:id"],
      "w:author": commentDef.attributes["w:author"],
      "w:email": commentDef.attributes["w:email"],
      "w:date": commentDef.attributes["w:date"],
      "w:initials": commentDef.attributes["w:initials"],
      "custom:internalId": commentDef.attributes["custom:internalId"],
      "custom:trackedChange": commentDef.attributes["custom:trackedChange"],
      "custom:trackedChangeText": commentDef.attributes["custom:trackedChangeText"],
      "custom:trackedChangeType": commentDef.attributes["custom:trackedChangeType"],
      "custom:trackedDeletedText": commentDef.attributes["custom:trackedDeletedText"],
      "xmlns:custom": "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
    };
  });
  newCommentsXml.elements[0].elements = commentDefs;
  return newCommentsXml;
};
const updateCommentsExtendedXml = (comments = [], commentsExtendedXml) => {
  const xmlCopy = carbonCopy(commentsExtendedXml);
  const commentsEx = comments.map((comment) => {
    const attributes = {
      "w15:paraId": comment.commentParaId,
      "w15:done": comment.resolvedTime ? "1" : "0"
    };
    const parentId = comment.parentCommentId;
    if (parentId) {
      const parentComment = comments.find((c) => c.commentId === parentId);
      attributes["w15:paraIdParent"] = parentComment.commentParaId;
    }
    return {
      type: "element",
      name: "w15:commentEx",
      attributes
    };
  });
  xmlCopy.elements[0].elements = commentsEx;
  return xmlCopy;
};
const updateCommentsIdsAndExtensible = (comments = [], commentsIds, extensible) => {
  const documentIdsUpdated = carbonCopy(commentsIds);
  const extensibleUpdated = carbonCopy(extensible);
  documentIdsUpdated.elements[0].elements = [];
  extensibleUpdated.elements[0].elements = [];
  comments.forEach((comment) => {
    const newDurableId = generateRandom32BitHex();
    const newCommentIdDef = {
      type: "element",
      name: "w16cid:commentId",
      attributes: {
        "w16cid:paraId": comment.commentParaId,
        "w16cid:durableId": newDurableId
      }
    };
    documentIdsUpdated.elements[0].elements.push(newCommentIdDef);
    const newExtensible = {
      type: "element",
      name: "w16cex:commentExtensible",
      attributes: {
        "w16cex:durableId": newDurableId,
        "w16cex:dateUtc": toIsoNoFractional()
      }
    };
    extensibleUpdated.elements[0].elements.push(newExtensible);
  });
  return {
    documentIdsUpdated,
    extensibleUpdated
  };
};
const generateConvertedXmlWithCommentFiles = (convertedXml) => {
  const newXml = carbonCopy(convertedXml);
  newXml["word/comments.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_XML_DEF;
  newXml["word/commentsExtended.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_EXTENDED_XML_DEF;
  newXml["word/commentsExtensible.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_EXTENSIBLE_XML_DEF;
  newXml["word/commentsIds.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_IDS_XML_DEF;
  newXml["[Content_Types].xml"] = COMMENTS_XML_DEFINITIONS.CONTENT_TYPES;
  return newXml;
};
const removeCommentsFilesFromConvertedXml = (convertedXml) => {
  const updatedXml = carbonCopy(convertedXml);
  delete updatedXml["word/comments.xml"];
  delete updatedXml["word/commentsExtended.xml"];
  delete updatedXml["word/commentsExtensible.xml"];
  delete updatedXml["word/commentsIds.xml"];
  return updatedXml;
};
const generateRelationship = (target) => {
  const relsDefault = COMMENTS_XML_DEFINITIONS.DOCUMENT_RELS_XML_DEF.elements[0].elements;
  const rel = relsDefault.find((rel2) => rel2.attributes.Target === target);
  return { ...rel };
};
const prepareCommentsXmlFilesForExport = ({ convertedXml, defs, commentsWithParaIds, exportType }) => {
  const relationships = [];
  if (exportType === "clean") {
    const documentXml = removeCommentsFilesFromConvertedXml(convertedXml);
    return { documentXml, relationships };
  }
  const updatedXml = generateConvertedXmlWithCommentFiles(convertedXml);
  updatedXml["word/comments.xml"] = updateCommentsXml(defs, updatedXml["word/comments.xml"]);
  relationships.push(generateRelationship("comments.xml"));
  updatedXml["word/commentsExtended.xml"] = updateCommentsExtendedXml(
    commentsWithParaIds,
    updatedXml["word/commentsExtended.xml"]
  );
  relationships.push(generateRelationship("commentsExtended.xml"));
  const { documentIdsUpdated, extensibleUpdated } = updateCommentsIdsAndExtensible(
    commentsWithParaIds,
    updatedXml["word/commentsIds.xml"],
    updatedXml["word/commentsExtensible.xml"]
  );
  updatedXml["word/commentsIds.xml"] = documentIdsUpdated;
  updatedXml["word/commentsExtensible.xml"] = extensibleUpdated;
  relationships.push(generateRelationship("commentsIds.xml"));
  relationships.push(generateRelationship("commentsExtensible.xml"));
  return {
    relationships,
    documentXml: updatedXml
  };
};
const getColStyleDeclaration = (minWidth, width) => {
  if (width) {
    return ["width", `${Math.max(width, minWidth)}px`];
  }
  return ["min-width", `${minWidth}px`];
};
const createColGroup = (node2, cellMinWidth, overrideCol, overrideValue) => {
  let totalWidth = 0;
  let fixedWidth = true;
  const cols = [];
  const colsValues = [];
  const row = node2.firstChild;
  if (!row) return {};
  for (let i = 0, col = 0; i < row.childCount; i++) {
    const { colspan, colwidth } = row.child(i).attrs;
    for (let j2 = 0; j2 < colspan; j2++, col++) {
      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j2];
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth) fixedWidth = false;
      const [prop, value] = getColStyleDeclaration(cellMinWidth, hasWidth);
      cols.push(["col", { style: `${prop}: ${value}` }]);
      colsValues.push(parseInt(value, 10));
    }
  }
  const tableWidth = fixedWidth ? `${totalWidth}px` : "";
  const tableMinWidth = fixedWidth ? "" : `${totalWidth}px`;
  const colgroup = ["colgroup", {}, ...cols];
  const colgroupValues = [...colsValues];
  return {
    colgroup,
    tableWidth,
    tableMinWidth,
    colgroupValues
  };
};
function chainableEditorState(transaction, state2) {
  let { selection, doc: doc2, storedMarks } = transaction;
  return {
    ...state2,
    apply: state2.apply.bind(state2),
    applyTransaction: state2.applyTransaction.bind(state2),
    plugins: state2.plugins,
    schema: state2.schema,
    reconfigure: state2.reconfigure.bind(state2),
    toJSON: state2.toJSON.bind(state2),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction.selection;
      doc2 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
class CommandService {
  /**
   * @param {import('./commands/types/index.js').CommandServiceOptions} props
   */
  constructor(props) {
    __publicField(this, "editor");
    __publicField(this, "rawCommands");
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionService.commands;
  }
  /**
   * Static method for creating a service.
   * @param {import('./commands/types/index.js').CommandServiceOptions} params for the constructor.
   * @returns {CommandService} New instance of CommandService
   */
  static create(params) {
    return new CommandService(params);
  }
  /**
   * Get editor state.
   * @returns {import("prosemirror-state").EditorState} Editor state
   */
  get state() {
    return this.editor.state;
  }
  /**
   * Get all editor commands
   * @returns {import('./commands/types/index.js').EditorCommands} Commands object
   */
  get commands() {
    const { editor, state: state2 } = this;
    const { view } = editor;
    const { tr } = state2;
    const props = this.createProps(tr);
    const entries = Object.entries(this.rawCommands).map(([name, command]) => {
      const method = (...args) => {
        const fn = command(...args)(props);
        if (!tr.getMeta("preventDispatch")) {
          view.dispatch(tr);
        }
        return fn;
      };
      return [name, method];
    });
    return (
      /** @type {import('./commands/types/index.js').EditorCommands} */
      Object.fromEntries(entries)
    );
  }
  /**
   * Create a chain of commands to call multiple commands at once.
   * @returns {(startTr?: Transaction, shouldDispatch?: boolean) => ChainableCommandObject} Function that creates a command chain
   */
  get chain() {
    return () => this.createChain();
  }
  /**
   * Check if a command or a chain of commands can be executed. Without executing it.
   * @returns {() => import('./commands/types/index.js').CanObject} Function that creates a can object
   */
  get can() {
    return () => this.createCan();
  }
  /**
   * Creates a chain of commands.
   * @param {import("prosemirror-state").Transaction} [startTr] - Start transaction.
   * @param {boolean} [shouldDispatch=true] - Whether to dispatch the transaction.
   * @returns {import('./commands/types/index.js').ChainableCommandObject} The command chain.
   */
  createChain(startTr, shouldDispatch = true) {
    const { editor, state: state2, rawCommands } = this;
    const { view } = editor;
    const callbacks = [];
    const hasStartTr = !!startTr;
    const tr = startTr || state2.tr;
    const run2 = () => {
      if (!hasStartTr && shouldDispatch && !tr.getMeta("preventDispatch")) {
        view.dispatch(tr);
      }
      return callbacks.every((cb) => cb === true);
    };
    const entries = Object.entries(rawCommands).map(([name, command]) => {
      const chainedCommand = (...args) => {
        const props = this.createProps(tr, shouldDispatch);
        const callback = command(...args)(props);
        callbacks.push(callback);
        return chain;
      };
      return [name, chainedCommand];
    });
    const chain = {
      ...Object.fromEntries(entries),
      run: run2
    };
    return chain;
  }
  /**
   * Creates a can check for commands.
   * @param {import("prosemirror-state").Transaction} [startTr] - Start transaction.
   * @returns {import('./commands/types/index.js').CanObject} The can object.
   */
  createCan(startTr) {
    const { rawCommands, state: state2 } = this;
    const dispatch = false;
    const tr = startTr || state2.tr;
    const props = this.createProps(tr, dispatch);
    const commands = Object.fromEntries(
      Object.entries(rawCommands).map(([name, command]) => {
        return [name, (...args) => command(...args)({ ...props, dispatch: void 0 })];
      })
    );
    const result = {
      ...commands,
      chain: () => this.createChain(tr, dispatch)
    };
    return (
      /** @type {import('./commands/types/index.js').CanObject} */
      result
    );
  }
  /**
   * Creates default props for the command method.
   * @param {import("prosemirror-state").Transaction} tr Transaction.
   * @param {boolean} shouldDispatch Check if should dispatch.
   * @returns {Object} Props object.
   */
  createProps(tr, shouldDispatch = true) {
    const { editor, state: state2, rawCommands } = this;
    const { view } = editor;
    const props = {
      tr,
      editor,
      view,
      state: chainableEditorState(tr, state2),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr, shouldDispatch),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command]) => {
            return [name, (...args) => command(...args)(props)];
          })
        );
      }
    };
    return props;
  }
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
const getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node2, pos, parent, index) => {
    const chunk = node2.type.spec.toText?.({
      node: node2,
      pos,
      parent,
      index
    }) || node2.textContent || "%leaf%";
    textBefore += node2.isAtom && !node2.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
const handleListNode = (params) => {
  const { nodes, docx } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:p" || nodes[0].isList) {
    return { nodes: [], consumed: 0 };
  }
  const node2 = carbonCopy(nodes[0]);
  const isList2 = testForList(node2, docx);
  if (isList2) {
    node2.isList = true;
    const result = handleListNodes(params, node2);
    return {
      nodes: [result],
      consumed: 1
    };
  } else {
    return { nodes: [], consumed: 0 };
  }
};
const listHandlerEntity = {
  handlerName: "listHandler",
  handler: handleListNode
};
function handleListNodes(params, node2) {
  const { docx, nodeListHandler: nodeListHandler2, lists } = params;
  const initialpPr = node2.elements.find((el) => el.name === "w:pPr");
  const styleTag = initialpPr?.elements?.find((el) => el.name === "w:pStyle");
  const styleId = styleTag?.attributes["w:val"];
  const { numPr: numPrTag, type: numPrType } = getNumPrRecursive({ node: node2, styleId, docx });
  const currentListNumId = getNumIdFromTag(numPrTag);
  const iLvlTag = numPrTag?.elements?.find((el) => el.name === "w:ilvl");
  let iLvl = Number(iLvlTag?.attributes["w:val"]);
  if (!iLvl && iLvl !== 0) iLvl = getOutlineLevelFromStyleTag(styleId, docx);
  let numberingDefinition = getNodeNumberingDefinition(node2, iLvl, docx);
  if (!Object.keys(numberingDefinition).length) {
    const { definition, ilvl } = getNodeNumberingDefinitionByStyle(node2, docx);
    if (definition) numberingDefinition = definition;
    if (Number.isNaN(iLvl)) iLvl = ilvl;
  }
  const { listType, listOrderingType, listpPrs, start, lvlText, customFormat } = numberingDefinition;
  if (!listType) {
    const pPrIndex = node2.elements.findIndex((el) => el.name === "w:pPr");
    const pPr = node2.elements[pPrIndex];
    const numPrIndex2 = pPr?.elements?.findIndex((el) => el.name === "w:numPr");
    if (numPrIndex2 >= 0) {
      pPr?.elements?.splice(numPrIndex2, 1);
      node2.elements[pPrIndex] = pPr;
    }
    const styleIdIndex = pPr?.elements?.findIndex((el) => el.name === "w:pStyle");
    if (styleIdIndex >= 0) pPr?.elements?.splice(styleIdIndex, 1);
    const fallBack = nodeListHandler2.handler({ ...params, nodes: [node2] })?.filter((n) => n);
    return fallBack[0];
  }
  if (!lists[currentListNumId]) lists[currentListNumId] = { levels: {} };
  const currentListByNumId = lists[currentListNumId];
  if (!currentListByNumId.levels[iLvl]) currentListByNumId.levels[iLvl] = Number(start) || 1;
  else currentListByNumId.levels[iLvl]++;
  Object.keys(currentListByNumId.levels).forEach((key) => {
    const level = Number(key);
    if (level > iLvl) {
      delete currentListByNumId.levels[level];
    }
  });
  const path = generateListPath$1(iLvl, currentListNumId, styleId, currentListByNumId.levels, docx);
  if (!path.length) path.push(currentListByNumId.levels[iLvl]);
  const attrs = {};
  attrs.lvlText = lvlText;
  attrs.listLevel = path;
  attrs.listNumberingType = listOrderingType;
  attrs.numId = currentListNumId;
  attrs.level = iLvl;
  attrs.numPrType = numPrType;
  attrs.styleId = styleId;
  attrs.customFormat = customFormat;
  node2.isList = true;
  const nodePpr = node2.attrs?.paragraphProperties?.elements?.find((el) => el.name === "w:pPr");
  const numPrIndex = node2.attrs?.paragraphProperties?.elements?.findIndex((el) => el.name === "w:numPr");
  nodePpr?.elements?.splice(numPrIndex, 1);
  const listContents = nodeListHandler2.handler({ ...params, nodes: [node2] });
  const innerParagraph = listContents.find((el) => el.type === "paragraph");
  const firstElement = innerParagraph.content[0];
  firstElement?.marks?.find((mark) => mark.type === "textStyle");
  attrs.indent = listpPrs?.indent;
  const processedContents = listContents.map((el, index) => {
    const { attrs: elementAttrs } = el;
    const { indent, textIndent, paragraphProperties, ...rest } = elementAttrs;
    if (index === 0 && !attrs.indent) attrs.indent = indent;
    return {
      ...el,
      attrs: rest
    };
  });
  const listItem = {
    type: "listItem",
    content: processedContents || [],
    attrs
  };
  const resultingList = {
    type: listType,
    content: [listItem],
    attrs: {
      "list-style-type": listOrderingType,
      listId: currentListNumId
    }
  };
  return resultingList;
}
const getOutlineLevelFromStyleTag = (styleTag, docx) => {
  const matchedStyle = getStyleTagFromStyleId(styleTag, docx);
  const pPr = matchedStyle?.elements?.find((style) => style.name === "w:pPr");
  const outlineLevel = pPr?.elements?.find((style) => style.name === "w:outlineLvl");
  try {
    return parseInt(outlineLevel?.attributes["w:val"]);
  } catch {
  }
};
function testForList(node2, docx) {
  const { elements } = node2;
  const pPr = elements?.find((el) => el.name === "w:pPr");
  if (!pPr) return false;
  const paragraphStyle = pPr.elements?.find((el) => el.name === "w:pStyle");
  let numPr = pPr.elements?.find((el) => el.name === "w:numPr");
  let numId = getNumIdFromTag(numPr);
  const ilvlTag = numPr?.elements?.find((el) => el.name === "w:ilvl");
  let ilvl = ilvlTag?.attributes["w:val"];
  let outlinelvl;
  const styleId = paragraphStyle?.attributes["w:val"];
  const styleTag = getStyleTagFromStyleId(styleId, docx);
  if (styleTag && !numId) {
    const { numPr: numPrRecursve } = getNumPrRecursive({ node: node2, styleId, docx });
    numPr = numPrRecursve;
    numId = getNumIdFromTag(numPr);
    const stylePpr = styleTag?.elements?.find((el) => el.name === "w:pPr");
    ilvl = stylePpr?.elements?.find((el) => el.name === "w:ilvl")?.attributes["w:val"];
    outlinelvl = stylePpr?.elements?.find((el) => el.name === "w:outlineLvl")?.attributes["w:val"];
    ilvl = outlinelvl || ilvl;
  }
  const abstractNumDefinition = getAbstractDefinition(numId, docx);
  const levelDefinition = abstractNumDefinition?.elements?.find(
    (el) => el.name === "w:lvl" && el.attributes?.["w:ilvl"] == ilvl
  );
  if (numId && !levelDefinition && abstractNumDefinition) {
    return true;
  }
  if (!levelDefinition) return false;
  return !!numId;
}
const getNumIdFromTag = (tag) => {
  return tag?.elements?.find((el) => el.name === "w:numId")?.attributes["w:val"];
};
function getStyleTagFromStyleId(styleId, docx) {
  const styles = docx["word/styles.xml"];
  if (!styles) return {};
  const styleEls = styles.elements;
  const wStyles = styleEls.find((el) => el.name === "w:styles");
  const styleTags = wStyles.elements.filter((style) => style.name === "w:style");
  const styleDef = styleTags.find((tag) => tag.attributes["w:styleId"] === styleId);
  return styleDef;
}
function getNumPrRecursive({ node: node2, styleId, docx, seenStyleIds = /* @__PURE__ */ new Set() }) {
  const initialPpr = node2?.elements?.find((el) => el.name === "w:pPr");
  const initialNumPr = initialPpr?.elements?.find((el) => el.name === "w:numPr");
  let numPr = initialNumPr;
  let numId = getNumIdFromTag(numPr);
  if (numId) return { numPr, type: "inline" };
  const matchedStyle = getStyleTagFromStyleId(styleId, docx);
  const pPr = matchedStyle?.elements?.find((style) => style.name === "w:pPr");
  numPr = pPr?.elements?.find((style) => style.name === "w:numPr");
  numId = getNumIdFromTag(numPr);
  const basedOn = matchedStyle?.elements?.find((style) => style.name === "w:basedOn");
  if (!numId && !seenStyleIds.has(styleId)) {
    const basedOnStyleId = basedOn?.attributes["w:val"];
    seenStyleIds.add(styleId);
    if (!basedOnStyleId) return {};
    return getNumPrRecursive({ styleId: basedOnStyleId, docx, seenStyleIds });
  }
  return { numPr, type: "numbering" };
}
const orderedListTypes = [
  "decimal",
  // eg: 1, 2, 3, 4, 5, ...
  "decimalZero",
  // eg: 01, 02, 03, 04, 05, ...
  "lowerRoman",
  // eg: i, ii, iii, iv, v, ...
  "upperRoman",
  // eg: I, II, III, IV, V, ...
  "lowerLetter",
  // eg: a, b, c, d, e, ...
  "upperLetter",
  // eg: A, B, C, D, E, ...
  "ordinal",
  // eg: 1st, 2nd, 3rd, 4th, 5th, ...
  "cardinalText",
  // eg: one, two, three, four, five, ...
  "ordinalText",
  // eg: first, second, third, fourth, fifth, ...
  "hex",
  // eg: 0, 1, 2, ..., 9, A, B, C, ..., F, 10, 11, ...
  "chicago",
  // eg: (0, 1, 2, ..., 9, 10, 11, 12, ..., 19, 1A, 1B, 1C, ..., 1Z, 20, 21, ..., 2Z)
  "none"
  // No bullet
];
const unorderedListTypes = [
  "bullet",
  // A standard bullet point ()
  "square",
  // Square bullets ()
  "circle",
  // Circle bullets ()
  "disc"
  // Disc bullets ()
];
const getListNumIdFromStyleRef = (styleId, docx) => {
  const styles = docx["word/styles.xml"];
  if (!styles) return null;
  const { elements } = styles;
  const styleTags = elements[0].elements.filter((style2) => style2.name === "w:style");
  const style = styleTags.find((tag) => tag.attributes["w:styleId"] === styleId) || {};
  const pPr = style?.elements?.find((style2) => style2.name === "w:pPr");
  if (!pPr) return null;
  let numPr = pPr?.elements?.find((style2) => style2.name === "w:numPr");
  if (!numPr) return null;
  let numIdTag = numPr?.elements?.find((style2) => style2.name === "w:numId") || {};
  let numId = getNumIdFromTag(numPr);
  let ilvlTag = numPr?.elements?.find((style2) => style2.name === "w:ilvl");
  let ilvl = ilvlTag?.attributes?.["w:val"];
  const basedOnTag = style?.elements?.find((style2) => style2.name === "w:basedOn");
  const basedOnId = basedOnTag?.attributes?.["w:val"];
  let loopCount = 0;
  while (numPr && !numId && loopCount < 10) {
    const basedOnStyle = styleTags.find((tag) => tag.attributes["w:styleId"] === basedOnId) || {};
    const basedOnPPr = basedOnStyle?.elements?.find((style2) => style2.name === "w:pPr");
    numPr = basedOnPPr?.elements?.find((style2) => style2.name === "w:numPr");
    numIdTag = numPr?.elements?.find((style2) => style2.name === "w:numId") || {};
    numId = numIdTag?.attributes?.["w:val"];
    if (!ilvlTag) {
      ilvlTag = numPr?.elements?.find((style2) => style2.name === "w:ilvl");
      ilvl = ilvlTag?.attributes?.["w:val"];
    }
    loopCount++;
  }
  return { numId, ilvl };
};
const getAbstractDefinition = (numId, docx) => {
  const def = docx["word/numbering.xml"];
  if (!def) return {};
  const { elements } = def;
  const listData = elements[0];
  const numberingElements = listData.elements;
  const abstractDefinitions = numberingElements?.filter((style) => style.name === "w:abstractNum");
  const numDefinitions = numberingElements?.filter((style) => style.name === "w:num");
  const numDefinition = numDefinitions?.find((style) => style.attributes["w:numId"] == numId);
  const abstractNumId = numDefinition?.elements[0].attributes["w:val"];
  let listDefinitionForThisNumId = abstractDefinitions?.find(
    (style) => style.attributes["w:abstractNumId"] === abstractNumId
  );
  const templateIdTag = listDefinitionForThisNumId?.elements?.find((el) => el.name === "w:tmpl");
  const templateId = templateIdTag?.attributes?.["w:val"];
  if (templateId) {
    listDefinitionForThisNumId = numberingElements?.find((el) => {
      if (el.name !== "w:abstractNum") return false;
      const tmpl = el.elements?.find((el2) => el2.name === "w:tmpl");
      if (!tmpl) return false;
      const hasLevels = el.elements?.some((el2) => el2.name === "w:lvl");
      const tmplId = tmpl.attributes?.["w:val"];
      return tmplId && hasLevels && tmplId === templateId;
    });
  }
  return listDefinitionForThisNumId;
};
const generateListPath$1 = (level, numId, styleId, levels, docx) => {
  const iLvl = Number(level);
  const path = [];
  if (iLvl > 0) {
    for (let i = iLvl; i >= 0; i--) {
      const { start: lvlStart } = getListLevelDefinitionTag(numId, i, styleId, docx);
      if (!levels[i]) levels[i] = Number(lvlStart) || 1;
      path.unshift(levels[i]);
    }
  }
  return path;
};
const getListLevelDefinitionTag = (numId, level, pStyleId, docx) => {
  if (pStyleId) {
    const { numId: numIdFromStyles, ilvl: iLvlFromStyles } = getListNumIdFromStyleRef(pStyleId, docx) || {};
    if (!numId && numIdFromStyles) numId = numIdFromStyles;
    if (!level && iLvlFromStyles) level = iLvlFromStyles ? parseInt(iLvlFromStyles) : null;
  }
  const listDefinitionForThisNumId = getAbstractDefinition(numId, docx);
  const currentLevel = getDefinitionForLevel(listDefinitionForThisNumId, level);
  const numStyleLink = listDefinitionForThisNumId?.elements?.find((style) => style.name === "w:numStyleLink");
  const numStyleLinkId = numStyleLink?.attributes["w:val"];
  if (numStyleLinkId) {
    const current = getListNumIdFromStyleRef(numStyleLinkId, docx);
    return getListLevelDefinitionTag(current.numId, level, null, docx);
  }
  const start = currentLevel?.elements?.find((style) => style.name === "w:start")?.attributes["w:val"];
  let numFmtTag = currentLevel?.elements?.find((style) => style.name === "w:numFmt");
  let numFmt = numFmtTag?.attributes["w:val"];
  if (!numFmt) {
    const altChoice = currentLevel?.elements.find((style) => style.name === "mc:AlternateContent");
    const choice = altChoice?.elements.find((style) => style.name === "mc:Choice");
    const choiceNumFmtTag = choice?.elements.find((style) => style.name === "w:numFmt");
    const choiceNumFmt = choiceNumFmtTag?.attributes["w:val"];
    if (choiceNumFmt) {
      numFmtTag = choiceNumFmtTag;
      numFmt = choiceNumFmt;
    }
  }
  let lvlText = currentLevel?.elements?.find((style) => style.name === "w:lvlText").attributes["w:val"];
  lvlText = normalizeLvlTextChar(lvlText);
  let customFormat;
  if (numFmt === "custom") customFormat = numFmtTag?.attributes?.["w:format"];
  const lvlJc = currentLevel?.elements?.find((style) => style.name === "w:lvlJc").attributes["w:val"];
  const pPr = currentLevel?.elements?.find((style) => style.name === "w:pPr");
  const rPr = currentLevel?.elements?.find((style) => style.name === "w:rPr");
  return { start, numFmt, lvlText, lvlJc, pPr, rPr, customFormat };
};
function normalizeLvlTextChar(lvlText) {
  const normalizeChars = ["", "", "", "o", "", ""];
  if (!lvlText || !normalizeChars.includes(lvlText)) return lvlText;
  if (lvlText === "") lvlText = "";
  if (lvlText === "" || lvlText === "o") lvlText = "";
  if (lvlText === "" || lvlText === "") lvlText = "";
  if (lvlText === "") lvlText = "";
  return lvlText;
}
function getNodeNumberingDefinition(item, level, docx) {
  if (!item) return {};
  const { attributes = {} } = item;
  const { paragraphProperties = {} } = attributes;
  const { elements: listStyles = [] } = paragraphProperties;
  const initialPpr = item.elements.find((el) => el.name === "w:pPr");
  const styleTag = initialPpr?.elements?.find((el) => el.name === "w:pStyle");
  const styleId = styleTag?.attributes["w:val"];
  const { numPr: numPrTag } = getNumPrRecursive({ node: item, styleId, docx });
  if (!numPrTag) return {};
  const numIdTag = numPrTag?.elements.find((style) => style.name === "w:numId");
  const numId = numIdTag?.attributes["w:val"];
  const pStyle = listStyles.find((style) => style.name === "w:pStyle");
  const pStyleId = pStyle?.attributes["w:val"];
  const {
    start,
    numFmt: listTypeDef,
    lvlText,
    lvlJc,
    pPr,
    rPr,
    customFormat
  } = getListLevelDefinitionTag(numId, level, pStyleId, docx);
  let listpPrs, listrPrs;
  if (pPr) listpPrs = _processListParagraphProperties(pPr, initialPpr);
  if (rPr) listrPrs = _processListRunProperties(rPr);
  let listType;
  if (unorderedListTypes.includes(listTypeDef?.toLowerCase())) listType = "bulletList";
  else if (orderedListTypes.includes(listTypeDef)) listType = "orderedList";
  else if (listTypeDef === "custom") {
    listType = "orderedList";
  } else {
    return {};
  }
  return { listType, listOrderingType: listTypeDef, listrPrs, listpPrs, start, lvlText, lvlJc, customFormat };
}
function getNodeNumberingDefinitionByStyle(item, docx) {
  if (!item) return {};
  const initialPpr = item.elements?.find((el) => el.name === "w:pPr");
  const styleTag = initialPpr?.elements?.find((el) => el.name === "w:pStyle");
  const styleId = styleTag?.attributes["w:val"];
  const styleDef = getStyleTagFromStyleId(styleId, docx);
  if (!styleDef) return {};
  const pPr = styleDef.elements?.find((el) => el.name === "w:pPr");
  const numPr = pPr?.elements?.find((el) => el.name === "w:numPr");
  const numIdTag = numPr?.elements?.find((el) => el.name === "w:numId");
  const numId = numIdTag?.attributes?.["w:val"];
  if (!numId) return {};
  const abstractNumId = getAbstractNumIdByNumId(numId, docx);
  if (!abstractNumId) return {};
  const levelData = getLevelDataFromAbstractNum(abstractNumId, styleId, docx);
  if (!levelData) return {};
  const definition = extractDefinitionFromLevel(levelData.level, initialPpr);
  return {
    definition,
    ilvl: levelData.ilvl
  };
}
function getAbstractNumIdByNumId(numId, docx) {
  const numbering = docx["word/numbering.xml"];
  if (!numbering) return null;
  const { elements } = numbering;
  const listData = elements[0];
  const numberingElements = listData.elements || [];
  const numDef = numberingElements.find((el) => el.name === "w:num" && el.attributes?.["w:numId"] === numId);
  if (!numDef) return null;
  const abstractNumIdRef = numDef.elements?.find((el) => el.name === "w:abstractNumId");
  return abstractNumIdRef?.attributes?.["w:val"];
}
function getLevelDataFromAbstractNum(abstractNumId, styleId, docx) {
  const numbering = docx["word/numbering.xml"];
  if (!numbering) return null;
  const { elements } = numbering;
  const listData = elements[0];
  const numberingElements = listData.elements || [];
  const abstractNum = numberingElements.find(
    (el) => el.name === "w:abstractNum" && el.attributes?.["w:abstractNumId"] === abstractNumId
  );
  if (!abstractNum) return null;
  const levels = abstractNum.elements?.filter((el) => el.name === "w:lvl") || [];
  for (const level of levels) {
    const pStyle = level.elements?.find((el) => el.name === "w:pStyle");
    if (pStyle?.attributes?.["w:val"] === styleId) {
      const found2 = {
        level,
        ilvl: Number(level.attributes?.["w:ilvl"]) || 0
      };
      return found2;
    }
  }
  const level0 = levels.find((level) => level.attributes?.["w:ilvl"] === "0");
  if (level0) {
    return {
      level: level0,
      ilvl: 0
    };
  }
  return null;
}
function extractDefinitionFromLevel(level, initialPpr) {
  if (!level) return {};
  const start = level.elements?.find((el) => el.name === "w:start")?.attributes?.["w:val"];
  let numFmtTag = level.elements?.find((el) => el.name === "w:numFmt");
  let numFmt = numFmtTag?.attributes?.["w:val"];
  let lvlText = level.elements?.find((el) => el.name === "w:lvlText")?.attributes?.["w:val"];
  lvlText = normalizeLvlTextChar(lvlText);
  let customFormat;
  if (numFmt === "custom") customFormat = numFmtTag?.attributes?.["w:format"];
  const lvlJc = level.elements?.find((el) => el.name === "w:lvlJc")?.attributes?.["w:val"];
  const pPr = level.elements?.find((el) => el.name === "w:pPr");
  const rPr = level.elements?.find((el) => el.name === "w:rPr");
  let listpPrs, listrPrs;
  if (pPr) listpPrs = _processListParagraphProperties(pPr, initialPpr);
  if (rPr) listrPrs = _processListRunProperties(rPr);
  let listType;
  if (unorderedListTypes.includes(numFmt?.toLowerCase())) {
    listType = "bulletList";
  } else if (orderedListTypes.includes(numFmt)) {
    listType = "orderedList";
  } else if (numFmt === "custom") {
    listType = "orderedList";
  } else {
    return {};
  }
  return {
    listType,
    listOrderingType: numFmt,
    listrPrs,
    listpPrs,
    start,
    lvlText,
    lvlJc,
    customFormat
  };
}
function getDefinitionForLevel(data, level) {
  return data?.elements?.find((item) => Number(item.attributes["w:ilvl"]) === level);
}
function parseIndentElement(indElem) {
  if (!indElem || !indElem.attributes) return {};
  const out = {};
  if (indElem.attributes["w:left"] != null) out.left = twipsToPixels(indElem.attributes["w:left"]);
  if (indElem.attributes["w:right"] != null) out.right = twipsToPixels(indElem.attributes["w:right"]);
  if (indElem.attributes["w:firstLine"] != null) out.firstLine = twipsToPixels(indElem.attributes["w:firstLine"]);
  if (indElem.attributes["w:hanging"] != null) out.hanging = twipsToPixels(indElem.attributes["w:hanging"]);
  if (indElem.attributes["w:leftChars"] != null) out.leftChars = twipsToPixels(indElem.attributes["w:leftChars"]);
  return out;
}
function combineIndents(ind1, ind2) {
  ind1 = ind1 && typeof ind1 === "object" ? ind1 : {};
  ind2 = ind2 && typeof ind2 === "object" ? ind2 : {};
  const indent = {};
  ["left", "right", "firstLine", "hanging"].forEach((prop) => {
    const v1 = ind1[prop] !== void 0 ? Number(ind1[prop]) : null;
    const v2 = ind2[prop] !== void 0 ? Number(ind2[prop]) : null;
    if (v1 != null && v2 != null) {
      indent[prop] = prop === "left" || prop === "hanging" ? Math.max(v1, v2) : v1;
    } else if (v1 != null) {
      indent[prop] = v1;
    } else if (v2 != null) {
      indent[prop] = v2;
    }
  });
  return indent;
}
function _processListParagraphProperties(data, inlinePpr) {
  const { elements } = data;
  const expectedTypes = ["w:ind", "w:jc", "w:tabs"];
  const paragraphProperties = {};
  if (!elements) return paragraphProperties;
  elements.forEach((item) => {
    if (!expectedTypes.includes(item.name)) {
      console.warn(`[numbering.xml] Unexpected list paragraph prop found: ${item.name}`);
    }
  });
  const inlineIndent = inlinePpr?.elements?.find((item) => item.name === "w:ind");
  const parsedInlineIndent = parseIndentElement(inlineIndent);
  const styleIndent = elements.find((item) => item.name === "w:ind");
  parseIndentElement(styleIndent);
  paragraphProperties.indent = parsedInlineIndent;
  const justify = elements.find((item) => item.name === "w:jc");
  if (justify) {
    const justifyAttrs = {};
    if (!justify.attributes) justify.attributes = {};
    if (justify.attributes["w:val"] !== void 0) justifyAttrs.val = justify.attributes["w:val"];
    paragraphProperties.justify = justifyAttrs;
  }
  const tabs = elements.find((item) => item.name === "w:tabs");
  if (tabs) {
    const tabElements = tabs.elements.filter((item) => item.name === "w:tab");
    const tabStops = [];
    tabElements.forEach((tab) => {
      const tabStop = {};
      if (!tab.attributes) tab.attributes = {};
      if (tab.attributes["w:val"] !== void 0) tabStop.val = tab.attributes["w:val"];
      if (tab.attributes["w:leader"] !== void 0) tabStop.leader = tab.attributes["w:leader"];
      if (tab.attributes["w:pos"] !== void 0) tabStop.pos = twipsToPixels(tab.attributes["w:pos"]);
      tabStops.push(tabStop);
    });
    paragraphProperties.tabStops = tabStops;
  }
  return paragraphProperties;
}
function _processListRunProperties(data) {
  const { elements } = data;
  const expectedTypes = [
    "w:rFonts",
    "w:b",
    "w:bCs",
    "w:i",
    "w:iCs",
    "w:strike",
    "w:dstrike",
    "w:color",
    "w:sz",
    "w:szCs",
    "w:u",
    "w:bdr",
    "w:shd",
    "w:vertAlign",
    "w:jc",
    "w:spacing",
    "w:w",
    "w:smallCaps",
    "w:position",
    "w:lang"
  ];
  const runProperties = {};
  if (!elements) return runProperties;
  elements.forEach((item) => {
    if (!expectedTypes.includes(item.name)) ;
    const { attributes = {} } = item;
    Object.keys(attributes).forEach((key) => {
      runProperties[key] = attributes[key];
    });
  });
  return runProperties;
}
const docxNumberigHelpers = {
  getListLevelDefinitionTag,
  combineIndents,
  parseIndentElement,
  generateListPath: generateListPath$1,
  normalizeLvlTextChar
};
const baseOrderedListDef = {
  type: "element",
  name: "w:abstractNum",
  attributes: {
    "w:abstractNumId": "1",
    "w15:restartNumberingAfterBreak": "0"
  },
  elements: [
    {
      type: "element",
      name: "w:multiLevelType",
      attributes: {
        "w:val": "hybridMultilevel"
      }
    },
    {
      type: "element",
      name: "w:tmpl",
      attributes: {
        "w:val": "EE6417C4"
      }
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "0",
        "w:tplc": "0409000F"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "decimal"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%1."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "720",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "1",
        "w:tplc": "04090019",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerLetter"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%2."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "1440",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "2",
        "w:tplc": "0409001B",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerRoman"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%3."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "right"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2160",
                "w:hanging": "180"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "3",
        "w:tplc": "0409000F",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "decimal"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%4."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2880",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "4",
        "w:tplc": "04090019",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerLetter"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%5."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "3600",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "5",
        "w:tplc": "0409001B",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerRoman"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%6."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "right"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "4320",
                "w:hanging": "180"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "6",
        "w:tplc": "0409000F",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "decimal"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%7."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5040",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "7",
        "w:tplc": "04090019",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerLetter"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%8."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5760",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "8",
        "w:tplc": "0409001B",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerRoman"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%9."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "right"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "6480",
                "w:hanging": "180"
              }
            }
          ]
        }
      ]
    }
  ]
};
const baseBulletList = {
  type: "element",
  name: "w:abstractNum",
  attributes: {
    "w:abstractNumId": "0",
    "w15:restartNumberingAfterBreak": "0"
  },
  elements: [
    {
      type: "element",
      name: "w:nsid",
      attributes: {
        "w:val": "16126B07"
      }
    },
    {
      type: "element",
      name: "w:multiLevelType",
      attributes: {
        "w:val": "hybridMultilevel"
      }
    },
    {
      type: "element",
      name: "w:tmpl",
      attributes: {
        "w:val": "51EC4E08"
      }
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "0",
        "w:tplc": "04090001"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "720",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Symbol",
                "w:hAnsi": "Symbol",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "1",
        "w:tplc": "04090003",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "1440",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Courier New",
                "w:hAnsi": "Courier New",
                "w:cs": "Courier New",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "2",
        "w:tplc": "04090005",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2160",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Wingdings",
                "w:hAnsi": "Wingdings",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "3",
        "w:tplc": "04090001",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2880",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Symbol",
                "w:hAnsi": "Symbol",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "4",
        "w:tplc": "04090003",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "3600",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Courier New",
                "w:hAnsi": "Courier New",
                "w:cs": "Courier New",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "5",
        "w:tplc": "04090005",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "4320",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Wingdings",
                "w:hAnsi": "Wingdings",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "6",
        "w:tplc": "04090001",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5040",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Symbol",
                "w:hAnsi": "Symbol",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "7",
        "w:tplc": "04090003",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "o"
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5760",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Courier New",
                "w:hAnsi": "Courier New",
                "w:cs": "Courier New",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "8",
        "w:tplc": "04090005",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "6480",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Wingdings",
                "w:hAnsi": "Wingdings",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    }
  ]
};
function createDocument(converter, schema, editor, { check = false } = {}) {
  const documentData = converter.getSchema(editor);
  if (documentData) {
    const documentNode = schema.nodeFromJSON(documentData);
    if (check) {
      documentNode.check();
    }
    return documentNode;
  }
  return schema.topNodeType.createAndFill();
}
function getExtensionConfigField(extension, field, context = {}) {
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({ ...context });
    return value;
  }
  return extension.config[field];
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function cleanSchemaItem(schemaItem) {
  const entries = Object.entries(schemaItem).filter(([key, value]) => {
    if (key === "attrs" && isEmptyObject(value)) {
      return false;
    }
    return value !== null && value !== void 0;
  });
  return Object.fromEntries(entries);
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}' in schema.`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}' in schema.`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    const { type: type2 } = match.edge(i);
    if (type2.isTextblock && !type2.hasRequiredAttrs()) return type2;
  }
  return null;
}
const findParentNodeClosestToPos = ($pos, predicate) => {
  for (let i = $pos.depth; i > 0; i--) {
    const node2 = $pos.node(i);
    if (predicate(node2)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node: node2
      };
    }
  }
};
const findParentNode = (predicate) => {
  return ({ $from }) => findParentNodeClosestToPos($from, predicate);
};
const isList = (name, extensions) => {
  const nodeExtensions = extensions.filter((e) => e.type === "node");
  const extension = nodeExtensions.find((i) => i.name === name);
  if (!extension) return false;
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrGet(getExtensionConfigField(extension, "group", context));
  if (typeof group !== "string") return false;
  return group.split(" ").includes("list");
};
function generateDocxListAttributes(listType) {
  const listTypesMap = {
    bulletList: 1,
    orderedList: 2
  };
  return {
    attributes: {
      parentAttributes: {
        "w14:paraId": generateDocxRandomId(),
        "w14:textId": generateDocxRandomId(),
        "w:rsidR": generateDocxRandomId(),
        "w:rsidRDefault": generateDocxRandomId(),
        "w:rsidP": generateDocxRandomId(),
        paragraphProperties: {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:pStyle",
              attributes: {
                "w:val": "ListParagraph"
              }
            },
            {
              type: "element",
              name: "w:numPr",
              elements: [
                {
                  type: "element",
                  name: "w:ilvl",
                  attributes: {
                    "w:val": "0"
                  }
                },
                {
                  type: "element",
                  name: "w:numId",
                  attributes: {
                    "w:val": listTypesMap[listType] || 0
                  }
                }
              ]
            }
          ]
        }
      }
    }
  };
}
const isTextSelection = (value) => {
};
function findMarkInSet(marks, type2, attrs = {}) {
  return marks.find((item) => {
    return item.type === type2 && objectIncludes(item.attrs, attrs);
  });
}
function isMarkInSet(marks, type2, attrs = {}) {
  return !!findMarkInSet(marks, type2, attrs);
}
function getMarkRange($pos, type2, attrs = {}) {
  if (!$pos || !type2) return;
  let start = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start.offset && start.offset !== 0) {
    start = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start.node) return;
  const mark = findMarkInSet([...start.node.marks], type2, attrs);
  if (!mark) return;
  let startIndex = start.index;
  let startPos = $pos.start() + start.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start.node.nodeSize;
  findMarkInSet([...start.node.marks], type2, attrs);
  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type2, attrs)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return { from: startPos, to: endPos };
}
function isMarkActive(state2, typeOrName, attrs = {}) {
  const { empty, ranges } = state2.selection;
  const type2 = typeOrName ? getMarkType(typeOrName, state2.schema) : null;
  if (empty) {
    return !!(state2.storedMarks || state2.selection.$from.marks()).filter((mark) => {
      if (!type2) return true;
      return type2.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attrs, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from = $from.pos;
    const to = $to.pos;
    state2.doc.nodesBetween(from, to, (node2, pos) => {
      if (!node2.isText && !node2.marks.length) return;
      const relativeFrom = Math.max(from, pos);
      const relativeTo = Math.min(to, pos + node2.nodeSize);
      const range3 = relativeTo - relativeFrom;
      selectionRange += range3;
      markRanges.push(
        ...node2.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        }))
      );
    });
  });
  if (selectionRange === 0) return false;
  const matchedRange = markRanges.filter((markRange) => {
    if (!type2) return true;
    return type2.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attrs, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type2) return true;
    return markRange.mark.type !== type2 && markRange.mark.type.excludes(type2);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range2 = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range2 >= selectionRange;
}
function getMarksBetween(from, to, doc2) {
  const marks = [];
  if (from === to) {
    doc2.resolve(from).marks().forEach((mark) => {
      const $pos = doc2.resolve(from - 1);
      const range2 = getMarkRange($pos, mark.type);
      if (!range2) {
        return;
      }
      marks.push({
        mark,
        ...range2
      });
    });
  } else {
    doc2.nodesBetween(from, to, (node2, pos) => {
      if (!node2 || node2?.nodeSize === void 0) {
        return;
      }
      marks.push(
        ...node2.marks.map((mark) => ({
          from: pos,
          to: pos + node2.nodeSize,
          mark
        }))
      );
    });
  }
  return marks;
}
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) return "node";
  if (schema.marks[name]) return "mark";
  return null;
}
function isNodeActive(state2, typeOrName, attrs = {}) {
  const { from, to, empty } = state2.selection;
  const type2 = typeOrName ? getNodeType(typeOrName, state2.schema) : null;
  const nodeRanges = [];
  state2.doc.nodesBetween(from, to, (node2, pos) => {
    if (node2.isText) return;
    const relativeFrom = Math.max(from, pos);
    const relativeTo = Math.min(to, pos + node2.nodeSize);
    nodeRanges.push({
      node: node2,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type2) return true;
    return type2.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attrs, { strict: false }));
  if (empty) return !!matchedNodeRanges.length;
  const range2 = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range2 >= selectionRange;
}
function isActive(state2, name, attrs = {}) {
  if (!name) {
    return isNodeActive(state2, null, attrs) || isMarkActive(state2, null, attrs);
  }
  const schemaType = getSchemaTypeNameByName(name, state2.schema);
  if (schemaType === "node") {
    return isNodeActive(state2, name, attrs);
  }
  if (schemaType === "mark") {
    return isMarkActive(state2, name, attrs);
  }
  return false;
}
function getMarksFromSelection(state2) {
  const { from, to, empty } = state2.selection;
  const marks = [];
  if (empty) {
    if (state2.storedMarks) {
      marks.push(...state2.storedMarks);
    }
    marks.push(...state2.selection.$head.marks());
  } else {
    state2.doc.nodesBetween(from, to, (node2) => {
      marks.push(...node2.marks);
    });
  }
  return marks;
}
const findMark = (state2, markType, toArr = false) => {
  const { selection, doc: doc2 } = state2;
  const { $from, $to } = selection;
  const fromMark = $from.marks().find((mark) => mark.type === markType);
  const toMark = $to.marks().find((mark) => mark.type === markType);
  let markFound;
  const marksFound = [];
  doc2.nodesBetween($from.pos, $to.pos, (node2, from) => {
    if (node2.marks) {
      const actualMark = node2.marks.find((mark) => mark.type === markType);
      if (actualMark) {
        markFound = {
          from,
          to: from + node2.nodeSize,
          attrs: actualMark.attrs,
          contained: !fromMark || !toMark || fromMark === toMark
        };
        marksFound.push(markFound);
      }
    }
  });
  if (toArr) {
    return marksFound;
  }
  return markFound;
};
function getActiveFormatting(editor) {
  const { state: state2 } = editor;
  const { selection } = state2;
  const marks = getMarksFromSelection(state2);
  const markAttrs = selection.$head.parent.attrs.marksAttrs;
  const marksToProcess = marks.filter((mark) => !["textStyle", "link"].includes(mark.type.name)).map((mark) => ({ name: mark.type.name, attrs: mark.attrs }));
  const textStyleMarks = marks.filter((mark) => mark.type.name === "textStyle");
  marksToProcess.push(...textStyleMarks.flatMap(unwrapTextMarks));
  if (markAttrs) {
    const marksFromAttrs = markAttrs.filter((mark) => !["textStyle", "link"].includes(mark.type)).map((mark) => ({ name: mark.type, attrs: mark.attrs || {} }));
    const textStyleMarksFromAttrs = markAttrs.filter((mark) => mark.type === "textStyle");
    marksToProcess.push(...marksFromAttrs);
    marksToProcess.push(...textStyleMarksFromAttrs.flatMap(unwrapTextMarks));
  }
  const linkMarkType = state2.schema.marks["link"];
  const linkMark = findMark(state2, linkMarkType);
  if (linkMark) {
    let { from, to, attrs } = linkMark;
    if (selection.from >= from && selection.to <= to) {
      marksToProcess.push({ name: "link", attrs });
    }
  }
  const ignoreKeys = ["paragraphSpacing"];
  const attributes = getActiveAttributes(state2);
  Object.keys(attributes).forEach((key) => {
    if (ignoreKeys.includes(key)) return;
    const attrs = {};
    attrs[key] = attributes[key];
    marksToProcess.push({ name: key, attrs });
  });
  const textColor = marksToProcess.find((i) => i.name === "textColor");
  const textHightlight = marksToProcess.find((i) => i.name === "textHighlight");
  if (textColor) {
    marksToProcess.push({
      name: "color",
      attrs: { color: textColor.attrs?.textColor }
    });
  }
  if (textHightlight) {
    marksToProcess.push({
      name: "highlight",
      attrs: { color: textHightlight.attrs?.textHighlight }
    });
  }
  const hasPendingFormatting = !!editor.storage.formatCommands?.storedStyle;
  if (hasPendingFormatting) marksToProcess.push({ name: "copyFormat", attrs: true });
  return marksToProcess;
}
function unwrapTextMarks(textStyleMark) {
  const processedMarks = [];
  const { attrs } = textStyleMark;
  Object.keys(attrs).forEach((key) => {
    if (!attrs[key]) return;
    processedMarks.push({ name: key, attrs: { [key]: attrs[key] } });
  });
  return processedMarks;
}
function getActiveAttributes(state2) {
  try {
    const { from, to, empty } = state2.selection;
    const attributes = {};
    const getAttrs = (node2) => {
      Object.keys(node2.attrs).forEach((key) => {
        const value = node2.attrs[key];
        if (value) {
          attributes[key] = value;
        }
      });
    };
    let start = from;
    let end = to;
    if (empty) state2.doc.nodesBetween(start, end + 1, (node2) => getAttrs(node2));
    else state2.doc.nodesBetween(from, to, (node2) => getAttrs(node2));
    return attributes;
  } catch {
    return {};
  }
}
function findChildren(node2, predicate) {
  const nodesWithPos = [];
  node2.descendants((child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function posToDOMRect(view, from, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start = view.coordsAtPos(resolvedFrom);
  const end = view.coordsAtPos(resolvedEnd, -1);
  const top = Math.min(start.top, end.top);
  const bottom = Math.max(start.bottom, end.bottom);
  const left = Math.min(start.left, end.left);
  const right = Math.max(start.right, end.right);
  const width = right - left;
  const height = bottom - top;
  const x = left;
  const y2 = top;
  const data = {
    top,
    bottom,
    left,
    right,
    width,
    height,
    x,
    y: y2
  };
  return {
    ...data,
    toJSON: () => data
  };
}
const isInTable = (state2) => {
  const { $head } = state2.selection;
  for (let d2 = $head.depth; d2 > 0; d2 -= 1) {
    if ($head.node(d2).type?.spec?.tableRole === "row") {
      return true;
    }
  }
  return false;
};
function createDocFromHTML(content, schema) {
  let parsedContent;
  if (typeof content === "string") {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = content;
    parsedContent = tempDiv;
  } else {
    parsedContent = content;
  }
  return DOMParser$1.fromSchema(schema).parse(parsedContent);
}
function L() {
  return { async: false, breaks: false, extensions: null, gfm: true, hooks: null, pedantic: false, renderer: null, silent: false, tokenizer: null, walkTokens: null };
}
var O = L();
function H(l3) {
  O = l3;
}
var E = { exec: () => null };
function h(l3, e = "") {
  let t = typeof l3 == "string" ? l3 : l3.source, n = { replace: (r, i) => {
    let s = typeof i == "string" ? i : i.source;
    return s = s.replace(m.caret, "$1"), t = t.replace(r, s), n;
  }, getRegex: () => new RegExp(t, e) };
  return n;
}
var m = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (l3) => new RegExp(`^( {0,3}${l3})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}#`), htmlBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}<(?:[a-z].*>|!--)`, "i") }, xe = /^(?:[ \t]*(?:\n|$))+/, be = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Re = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, C = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Oe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, j = /(?:[*+-]|\d{1,9}[.)])/, se = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, ie = h(se).replace(/bull/g, j).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Te = h(se).replace(/bull/g, j).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), F = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, we = /^[^\n]+/, Q = /(?!\s*\])(?:\\.|[^\[\]\\])+/, ye = h(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Q).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Pe = h(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, j).getRegex(), v = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", U = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Se = h("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", U).replace("tag", v).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), oe = h(F).replace("hr", C).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex(), $e = h(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", oe).getRegex(), K = { blockquote: $e, code: be, def: ye, fences: Re, heading: Oe, hr: C, html: Se, lheading: ie, list: Pe, newline: xe, paragraph: oe, table: E, text: we }, re = h("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", C).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex(), _e = { ...K, lheading: Te, table: re, paragraph: h(F).replace("hr", C).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", re).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex() }, Le = { ...K, html: h(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", U).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: E, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: h(F).replace("hr", C).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", ie).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, Me = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, ze = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, ae = /^( {2,}|\\)\n(?!\s*$)/, Ae = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, D = /[\p{P}\p{S}]/u, W = /[\s\p{P}\p{S}]/u, le = /[^\s\p{P}\p{S}]/u, Ee = h(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, W).getRegex(), ue = /(?!~)[\p{P}\p{S}]/u, Ce = /(?!~)[\s\p{P}\p{S}]/u, Ie = /(?:[^\s\p{P}\p{S}]|~)/u, Be = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<(?! )[^<>]*?>/g, pe = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, qe = h(pe, "u").replace(/punct/g, D).getRegex(), ve = h(pe, "u").replace(/punct/g, ue).getRegex(), ce = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", De = h(ce, "gu").replace(/notPunctSpace/g, le).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), Ze = h(ce, "gu").replace(/notPunctSpace/g, Ie).replace(/punctSpace/g, Ce).replace(/punct/g, ue).getRegex(), Ge = h("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, le).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), He = h(/\\(punct)/, "gu").replace(/punct/g, D).getRegex(), Ne = h(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), je = h(U).replace("(?:-->|$)", "-->").getRegex(), Fe = h("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", je).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), q = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, Qe = h(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", q).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), he = h(/^!?\[(label)\]\[(ref)\]/).replace("label", q).replace("ref", Q).getRegex(), de = h(/^!?\[(ref)\](?:\[\])?/).replace("ref", Q).getRegex(), Ue = h("reflink|nolink(?!\\()", "g").replace("reflink", he).replace("nolink", de).getRegex(), X = { _backpedal: E, anyPunctuation: He, autolink: Ne, blockSkip: Be, br: ae, code: ze, del: E, emStrongLDelim: qe, emStrongRDelimAst: De, emStrongRDelimUnd: Ge, escape: Me, link: Qe, nolink: de, punctuation: Ee, reflink: he, reflinkSearch: Ue, tag: Fe, text: Ae, url: E }, Ke = { ...X, link: h(/^!?\[(label)\]\((.*?)\)/).replace("label", q).getRegex(), reflink: h(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", q).getRegex() }, N = { ...X, emStrongRDelimAst: Ze, emStrongLDelim: ve, url: h(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }, We = { ...N, br: h(ae).replace("{2,}", "*").getRegex(), text: h(N.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, I = { normal: K, gfm: _e, pedantic: Le }, M = { normal: X, gfm: N, breaks: We, pedantic: Ke };
var Xe = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, ke = (l3) => Xe[l3];
function w(l3, e) {
  if (e) {
    if (m.escapeTest.test(l3)) return l3.replace(m.escapeReplace, ke);
  } else if (m.escapeTestNoEncode.test(l3)) return l3.replace(m.escapeReplaceNoEncode, ke);
  return l3;
}
function J(l3) {
  try {
    l3 = encodeURI(l3).replace(m.percentDecode, "%");
  } catch {
    return null;
  }
  return l3;
}
function V(l3, e) {
  let t = l3.replace(m.findPipe, (i, s, o) => {
    let a = false, u = s;
    for (; --u >= 0 && o[u] === "\\"; ) a = !a;
    return a ? "|" : " |";
  }), n = t.split(m.splitPipe), r = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; r < n.length; r++) n[r] = n[r].trim().replace(m.slashPipe, "|");
  return n;
}
function z(l3, e, t) {
  let n = l3.length;
  if (n === 0) return "";
  let r = 0;
  for (; r < n; ) {
    let i = l3.charAt(n - r - 1);
    if (i === e && true) r++;
    else break;
  }
  return l3.slice(0, n - r);
}
function ge(l3, e) {
  if (l3.indexOf(e[1]) === -1) return -1;
  let t = 0;
  for (let n = 0; n < l3.length; n++) if (l3[n] === "\\") n++;
  else if (l3[n] === e[0]) t++;
  else if (l3[n] === e[1] && (t--, t < 0)) return n;
  return t > 0 ? -2 : -1;
}
function fe(l3, e, t, n, r) {
  let i = e.href, s = e.title || null, o = l3[1].replace(r.other.outputLinkReplace, "$1");
  n.state.inLink = true;
  let a = { type: l3[0].charAt(0) === "!" ? "image" : "link", raw: t, href: i, title: s, text: o, tokens: n.inlineTokens(o) };
  return n.state.inLink = false, a;
}
function Je(l3, e, t) {
  let n = l3.match(t.other.indentCodeCompensation);
  if (n === null) return e;
  let r = n[1];
  return e.split(`
`).map((i) => {
    let s = i.match(t.other.beginningSpace);
    if (s === null) return i;
    let [o] = s;
    return o.length >= r.length ? i.slice(r.length) : i;
  }).join(`
`);
}
var y = class {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "rules");
    __publicField(this, "lexer");
    this.options = e || O;
  }
  space(e) {
    let t = this.rules.block.newline.exec(e);
    if (t && t[0].length > 0) return { type: "space", raw: t[0] };
  }
  code(e) {
    let t = this.rules.block.code.exec(e);
    if (t) {
      let n = t[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : z(n, `
`) };
    }
  }
  fences(e) {
    let t = this.rules.block.fences.exec(e);
    if (t) {
      let n = t[0], r = Je(n, t[3] || "", this.rules);
      return { type: "code", raw: n, lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2], text: r };
    }
  }
  heading(e) {
    let t = this.rules.block.heading.exec(e);
    if (t) {
      let n = t[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let r = z(n, "#");
        (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (n = r.trim());
      }
      return { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(e) {
    let t = this.rules.block.hr.exec(e);
    if (t) return { type: "hr", raw: z(t[0], `
`) };
  }
  blockquote(e) {
    let t = this.rules.block.blockquote.exec(e);
    if (t) {
      let n = z(t[0], `
`).split(`
`), r = "", i = "", s = [];
      for (; n.length > 0; ) {
        let o = false, a = [], u;
        for (u = 0; u < n.length; u++) if (this.rules.other.blockquoteStart.test(n[u])) a.push(n[u]), o = true;
        else if (!o) a.push(n[u]);
        else break;
        n = n.slice(u);
        let p = a.join(`
`), c = p.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        r = r ? `${r}
${p}` : p, i = i ? `${i}
${c}` : c;
        let f = this.lexer.state.top;
        if (this.lexer.state.top = true, this.lexer.blockTokens(c, s, true), this.lexer.state.top = f, n.length === 0) break;
        let k = s.at(-1);
        if (k?.type === "code") break;
        if (k?.type === "blockquote") {
          let x = k, g = x.raw + `
` + n.join(`
`), T = this.blockquote(g);
          s[s.length - 1] = T, r = r.substring(0, r.length - x.raw.length) + T.raw, i = i.substring(0, i.length - x.text.length) + T.text;
          break;
        } else if (k?.type === "list") {
          let x = k, g = x.raw + `
` + n.join(`
`), T = this.list(g);
          s[s.length - 1] = T, r = r.substring(0, r.length - k.raw.length) + T.raw, i = i.substring(0, i.length - x.raw.length) + T.raw, n = g.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: r, tokens: s, text: i };
    }
  }
  list(e) {
    let t = this.rules.block.list.exec(e);
    if (t) {
      let n = t[1].trim(), r = n.length > 1, i = { type: "list", raw: "", ordered: r, start: r ? +n.slice(0, -1) : "", loose: false, items: [] };
      n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r ? n : "[*+-]");
      let s = this.rules.other.listItemRegex(n), o = false;
      for (; e; ) {
        let u = false, p = "", c = "";
        if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break;
        p = t[0], e = e.substring(p.length);
        let f = t[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (Z) => " ".repeat(3 * Z.length)), k = e.split(`
`, 1)[0], x = !f.trim(), g = 0;
        if (this.options.pedantic ? (g = 2, c = f.trimStart()) : x ? g = t[1].length + 1 : (g = t[2].search(this.rules.other.nonSpaceChar), g = g > 4 ? 1 : g, c = f.slice(g), g += t[1].length), x && this.rules.other.blankLine.test(k) && (p += k + `
`, e = e.substring(k.length + 1), u = true), !u) {
          let Z = this.rules.other.nextBulletRegex(g), ee = this.rules.other.hrRegex(g), te = this.rules.other.fencesBeginRegex(g), ne = this.rules.other.headingBeginRegex(g), me = this.rules.other.htmlBeginRegex(g);
          for (; e; ) {
            let G = e.split(`
`, 1)[0], A;
            if (k = G, this.options.pedantic ? (k = k.replace(this.rules.other.listReplaceNesting, "  "), A = k) : A = k.replace(this.rules.other.tabCharGlobal, "    "), te.test(k) || ne.test(k) || me.test(k) || Z.test(k) || ee.test(k)) break;
            if (A.search(this.rules.other.nonSpaceChar) >= g || !k.trim()) c += `
` + A.slice(g);
            else {
              if (x || f.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || te.test(f) || ne.test(f) || ee.test(f)) break;
              c += `
` + k;
            }
            !x && !k.trim() && (x = true), p += G + `
`, e = e.substring(G.length + 1), f = A.slice(g);
          }
        }
        i.loose || (o ? i.loose = true : this.rules.other.doubleBlankLine.test(p) && (o = true));
        let T = null, Y;
        this.options.gfm && (T = this.rules.other.listIsTask.exec(c), T && (Y = T[0] !== "[ ] ", c = c.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: p, task: !!T, checked: Y, loose: false, text: c, tokens: [] }), i.raw += p;
      }
      let a = i.items.at(-1);
      if (a) a.raw = a.raw.trimEnd(), a.text = a.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let u = 0; u < i.items.length; u++) if (this.lexer.state.top = false, i.items[u].tokens = this.lexer.blockTokens(i.items[u].text, []), !i.loose) {
        let p = i.items[u].tokens.filter((f) => f.type === "space"), c = p.length > 0 && p.some((f) => this.rules.other.anyLine.test(f.raw));
        i.loose = c;
      }
      if (i.loose) for (let u = 0; u < i.items.length; u++) i.items[u].loose = true;
      return i;
    }
  }
  html(e) {
    let t = this.rules.block.html.exec(e);
    if (t) return { type: "html", block: true, raw: t[0], pre: t[1] === "pre" || t[1] === "script" || t[1] === "style", text: t[0] };
  }
  def(e) {
    let t = this.rules.block.def.exec(e);
    if (t) {
      let n = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3];
      return { type: "def", tag: n, raw: t[0], href: r, title: i };
    }
  }
  table(e) {
    let t = this.rules.block.table.exec(e);
    if (!t || !this.rules.other.tableDelimiter.test(t[2])) return;
    let n = V(t[1]), r = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: t[0], header: [], align: [], rows: [] };
    if (n.length === r.length) {
      for (let o of r) this.rules.other.tableAlignRight.test(o) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(o) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(o) ? s.align.push("left") : s.align.push(null);
      for (let o = 0; o < n.length; o++) s.header.push({ text: n[o], tokens: this.lexer.inline(n[o]), header: true, align: s.align[o] });
      for (let o of i) s.rows.push(V(o, s.header.length).map((a, u) => ({ text: a, tokens: this.lexer.inline(a), header: false, align: s.align[u] })));
      return s;
    }
  }
  lheading(e) {
    let t = this.rules.block.lheading.exec(e);
    if (t) return { type: "heading", raw: t[0], depth: t[2].charAt(0) === "=" ? 1 : 2, text: t[1], tokens: this.lexer.inline(t[1]) };
  }
  paragraph(e) {
    let t = this.rules.block.paragraph.exec(e);
    if (t) {
      let n = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
      return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(e) {
    let t = this.rules.block.text.exec(e);
    if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) };
  }
  escape(e) {
    let t = this.rules.inline.escape.exec(e);
    if (t) return { type: "escape", raw: t[0], text: t[1] };
  }
  tag(e) {
    let t = this.rules.inline.tag.exec(e);
    if (t) return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = false), { type: "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: false, text: t[0] };
  }
  link(e) {
    let t = this.rules.inline.link.exec(e);
    if (t) {
      let n = t[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n)) return;
        let s = z(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0) return;
      } else {
        let s = ge(t[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let a = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
          t[2] = t[2].substring(0, s), t[0] = t[0].substring(0, a).trim(), t[3] = "";
        }
      }
      let r = t[2], i = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(r);
        s && (r = s[1], i = s[3]);
      } else i = t[3] ? t[3].slice(1, -1) : "";
      return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? r = r.slice(1) : r = r.slice(1, -1)), fe(t, { href: r && r.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, t[0], this.lexer, this.rules);
    }
  }
  reflink(e, t) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      let r = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = t[r.toLowerCase()];
      if (!i) {
        let s = n[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return fe(n, i, n[0], this.lexer, this.rules);
    }
  }
  emStrong(e, t, n = "") {
    let r = this.rules.inline.emStrongLDelim.exec(e);
    if (!r || r[3] && n.match(this.rules.other.unicodeAlphaNumeric)) return;
    if (!(r[1] || r[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
      let s = [...r[0]].length - 1, o, a, u = s, p = 0, c = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c.lastIndex = 0, t = t.slice(-1 * e.length + s); (r = c.exec(t)) != null; ) {
        if (o = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !o) continue;
        if (a = [...o].length, r[3] || r[4]) {
          u += a;
          continue;
        } else if ((r[5] || r[6]) && s % 3 && !((s + a) % 3)) {
          p += a;
          continue;
        }
        if (u -= a, u > 0) continue;
        a = Math.min(a, a + u + p);
        let f = [...r[0]][0].length, k = e.slice(0, s + r.index + f + a);
        if (Math.min(s, a) % 2) {
          let g = k.slice(1, -1);
          return { type: "em", raw: k, text: g, tokens: this.lexer.inlineTokens(g) };
        }
        let x = k.slice(2, -2);
        return { type: "strong", raw: k, text: x, tokens: this.lexer.inlineTokens(x) };
      }
    }
  }
  codespan(e) {
    let t = this.rules.inline.code.exec(e);
    if (t) {
      let n = t[2].replace(this.rules.other.newLineCharGlobal, " "), r = this.rules.other.nonSpaceChar.test(n), i = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return r && i && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: t[0], text: n };
    }
  }
  br(e) {
    let t = this.rules.inline.br.exec(e);
    if (t) return { type: "br", raw: t[0] };
  }
  del(e) {
    let t = this.rules.inline.del.exec(e);
    if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) };
  }
  autolink(e) {
    let t = this.rules.inline.autolink.exec(e);
    if (t) {
      let n, r;
      return t[2] === "@" ? (n = t[1], r = "mailto:" + n) : (n = t[1], r = n), { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(e) {
    let t;
    if (t = this.rules.inline.url.exec(e)) {
      let n, r;
      if (t[2] === "@") n = t[0], r = "mailto:" + n;
      else {
        let i;
        do
          i = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "";
        while (i !== t[0]);
        n = t[0], t[1] === "www." ? r = "http://" + t[0] : r = t[0];
      }
      return { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  inlineText(e) {
    let t = this.rules.inline.text.exec(e);
    if (t) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: t[0], text: t[0], escaped: n };
    }
  }
};
var b = class l {
  constructor(e) {
    __publicField(this, "tokens");
    __publicField(this, "options");
    __publicField(this, "state");
    __publicField(this, "tokenizer");
    __publicField(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || O, this.options.tokenizer = this.options.tokenizer || new y(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
    let t = { other: m, block: I.normal, inline: M.normal };
    this.options.pedantic ? (t.block = I.pedantic, t.inline = M.pedantic) : this.options.gfm && (t.block = I.gfm, this.options.breaks ? t.inline = M.breaks : t.inline = M.gfm), this.tokenizer.rules = t;
  }
  static get rules() {
    return { block: I, inline: M };
  }
  static lex(e, t) {
    return new l(t).lex(e);
  }
  static lexInline(e, t) {
    return new l(t).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(m.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let t = 0; t < this.inlineQueue.length; t++) {
      let n = this.inlineQueue[t];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, t = [], n = false) {
    for (this.options.pedantic && (e = e.replace(m.tabCharGlobal, "    ").replace(m.spaceLine, "")); e; ) {
      let r;
      if (this.options.extensions?.block?.some((s) => (r = s.call({ lexer: this }, e, t)) ? (e = e.substring(r.raw.length), t.push(r), true) : false)) continue;
      if (r = this.tokenizer.space(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        r.raw.length === 1 && s !== void 0 ? s.raw += `
` : t.push(r);
        continue;
      }
      if (r = this.tokenizer.code(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.at(-1).src = s.text) : t.push(r);
        continue;
      }
      if (r = this.tokenizer.fences(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.heading(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.hr(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.blockquote(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.list(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.html(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.def(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = { href: r.href, title: r.title }, t.push(r));
        continue;
      }
      if (r = this.tokenizer.table(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.lheading(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      let i = e;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, o = e.slice(1), a;
        this.options.extensions.startBlock.forEach((u) => {
          a = u.call({ lexer: this }, o), typeof a == "number" && a >= 0 && (s = Math.min(s, a));
        }), s < 1 / 0 && s >= 0 && (i = e.substring(0, s + 1));
      }
      if (this.state.top && (r = this.tokenizer.paragraph(i))) {
        let s = t.at(-1);
        n && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r), n = i.length !== e.length, e = e.substring(r.raw.length);
        continue;
      }
      if (r = this.tokenizer.text(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else throw new Error(s);
      }
    }
    return this.state.top = true, t;
  }
  inline(e, t = []) {
    return this.inlineQueue.push({ src: e, tokens: t }), t;
  }
  inlineTokens(e, t = []) {
    let n = e, r = null;
    if (this.tokens.links) {
      let o = Object.keys(this.tokens.links);
      if (o.length > 0) for (; (r = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) o.includes(r[0].slice(r[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (r = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, r.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; (r = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) n = n.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    let i = false, s = "";
    for (; e; ) {
      i || (s = ""), i = false;
      let o;
      if (this.options.extensions?.inline?.some((u) => (o = u.call({ lexer: this }, e, t)) ? (e = e.substring(o.raw.length), t.push(o), true) : false)) continue;
      if (o = this.tokenizer.escape(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.tag(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.link(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(o.raw.length);
        let u = t.at(-1);
        o.type === "text" && u?.type === "text" ? (u.raw += o.raw, u.text += o.text) : t.push(o);
        continue;
      }
      if (o = this.tokenizer.emStrong(e, n, s)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.codespan(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.br(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.del(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.autolink(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (!this.state.inLink && (o = this.tokenizer.url(e))) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      let a = e;
      if (this.options.extensions?.startInline) {
        let u = 1 / 0, p = e.slice(1), c;
        this.options.extensions.startInline.forEach((f) => {
          c = f.call({ lexer: this }, p), typeof c == "number" && c >= 0 && (u = Math.min(u, c));
        }), u < 1 / 0 && u >= 0 && (a = e.substring(0, u + 1));
      }
      if (o = this.tokenizer.inlineText(a)) {
        e = e.substring(o.raw.length), o.raw.slice(-1) !== "_" && (s = o.raw.slice(-1)), i = true;
        let u = t.at(-1);
        u?.type === "text" ? (u.raw += o.raw, u.text += o.text) : t.push(o);
        continue;
      }
      if (e) {
        let u = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(u);
          break;
        } else throw new Error(u);
      }
    }
    return t;
  }
};
var P = class {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "parser");
    this.options = e || O;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: t, escaped: n }) {
    let r = (t || "").match(m.notSpaceStart)?.[0], i = e.replace(m.endingNewline, "") + `
`;
    return r ? '<pre><code class="language-' + w(r) + '">' + (n ? i : w(i, true)) + `</code></pre>
` : "<pre><code>" + (n ? i : w(i, true)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  def(e) {
    return "";
  }
  heading({ tokens: e, depth: t }) {
    return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    let t = e.ordered, n = e.start, r = "";
    for (let o = 0; o < e.items.length; o++) {
      let a = e.items[o];
      r += this.listitem(a);
    }
    let i = t ? "ol" : "ul", s = t && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + i + s + `>
` + r + "</" + i + `>
`;
  }
  listitem(e) {
    let t = "";
    if (e.task) {
      let n = this.checkbox({ checked: !!e.checked });
      e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = n + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = n + " " + w(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = true)) : e.tokens.unshift({ type: "text", raw: n + " ", text: n + " ", escaped: true }) : t += n + " ";
    }
    return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let t = "", n = "";
    for (let i = 0; i < e.header.length; i++) n += this.tablecell(e.header[i]);
    t += this.tablerow({ text: n });
    let r = "";
    for (let i = 0; i < e.rows.length; i++) {
      let s = e.rows[i];
      n = "";
      for (let o = 0; o < s.length; o++) n += this.tablecell(s[o]);
      r += this.tablerow({ text: n });
    }
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + r + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    let t = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + t + `</${n}>
`;
  }
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${w(e, true)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: t, tokens: n }) {
    let r = this.parser.parseInline(n), i = J(e);
    if (i === null) return r;
    e = i;
    let s = '<a href="' + e + '"';
    return t && (s += ' title="' + w(t) + '"'), s += ">" + r + "</a>", s;
  }
  image({ href: e, title: t, text: n, tokens: r }) {
    r && (n = this.parser.parseInline(r, this.parser.textRenderer));
    let i = J(e);
    if (i === null) return w(n);
    e = i;
    let s = `<img src="${e}" alt="${n}"`;
    return t && (s += ` title="${w(t)}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : w(e.text);
  }
};
var S = class {
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
};
var R = class l2 {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "renderer");
    __publicField(this, "textRenderer");
    this.options = e || O, this.options.renderer = this.options.renderer || new P(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new S();
  }
  static parse(e, t) {
    return new l2(t).parse(e);
  }
  static parseInline(e, t) {
    return new l2(t).parseInline(e);
  }
  parse(e, t = true) {
    let n = "";
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      if (this.options.extensions?.renderers?.[i.type]) {
        let o = i, a = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (a !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(o.type)) {
          n += a || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "space": {
          n += this.renderer.space(s);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(s);
          continue;
        }
        case "code": {
          n += this.renderer.code(s);
          continue;
        }
        case "table": {
          n += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          n += this.renderer.list(s);
          continue;
        }
        case "html": {
          n += this.renderer.html(s);
          continue;
        }
        case "def": {
          n += this.renderer.def(s);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let o = s, a = this.renderer.text(o);
          for (; r + 1 < e.length && e[r + 1].type === "text"; ) o = e[++r], a += `
` + this.renderer.text(o);
          t ? n += this.renderer.paragraph({ type: "paragraph", raw: a, text: a, tokens: [{ type: "text", raw: a, text: a, escaped: true }] }) : n += a;
          continue;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
  parseInline(e, t = this.renderer) {
    let n = "";
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      if (this.options.extensions?.renderers?.[i.type]) {
        let o = this.options.extensions.renderers[i.type].call({ parser: this }, i);
        if (o !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type)) {
          n += o || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "escape": {
          n += t.text(s);
          break;
        }
        case "html": {
          n += t.html(s);
          break;
        }
        case "link": {
          n += t.link(s);
          break;
        }
        case "image": {
          n += t.image(s);
          break;
        }
        case "strong": {
          n += t.strong(s);
          break;
        }
        case "em": {
          n += t.em(s);
          break;
        }
        case "codespan": {
          n += t.codespan(s);
          break;
        }
        case "br": {
          n += t.br(s);
          break;
        }
        case "del": {
          n += t.del(s);
          break;
        }
        case "text": {
          n += t.text(s);
          break;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
};
var $ = (_a = class {
  constructor(e) {
    __publicField(this, "options");
    __publicField(this, "block");
    this.options = e || O;
  }
  preprocess(e) {
    return e;
  }
  postprocess(e) {
    return e;
  }
  processAllTokens(e) {
    return e;
  }
  provideLexer() {
    return this.block ? b.lex : b.lexInline;
  }
  provideParser() {
    return this.block ? R.parse : R.parseInline;
  }
}, __publicField(_a, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"])), _a);
var B = class {
  constructor(...e) {
    __publicField(this, "defaults", L());
    __publicField(this, "options", this.setOptions);
    __publicField(this, "parse", this.parseMarkdown(true));
    __publicField(this, "parseInline", this.parseMarkdown(false));
    __publicField(this, "Parser", R);
    __publicField(this, "Renderer", P);
    __publicField(this, "TextRenderer", S);
    __publicField(this, "Lexer", b);
    __publicField(this, "Tokenizer", y);
    __publicField(this, "Hooks", $);
    this.use(...e);
  }
  walkTokens(e, t) {
    let n = [];
    for (let r of e) switch (n = n.concat(t.call(this, r)), r.type) {
      case "table": {
        let i = r;
        for (let s of i.header) n = n.concat(this.walkTokens(s.tokens, t));
        for (let s of i.rows) for (let o of s) n = n.concat(this.walkTokens(o.tokens, t));
        break;
      }
      case "list": {
        let i = r;
        n = n.concat(this.walkTokens(i.items, t));
        break;
      }
      default: {
        let i = r;
        this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
          let o = i[s].flat(1 / 0);
          n = n.concat(this.walkTokens(o, t));
        }) : i.tokens && (n = n.concat(this.walkTokens(i.tokens, t)));
      }
    }
    return n;
  }
  use(...e) {
    let t = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      let r = { ...n };
      if (r.async = this.defaults.async || r.async || false, n.extensions && (n.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let s = t.renderers[i.name];
          s ? t.renderers[i.name] = function(...o) {
            let a = i.renderer.apply(this, o);
            return a === false && (a = s.apply(this, o)), a;
          } : t.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = t[i.level];
          s ? s.unshift(i.tokenizer) : t[i.level] = [i.tokenizer], i.start && (i.level === "block" ? t.startBlock ? t.startBlock.push(i.start) : t.startBlock = [i.start] : i.level === "inline" && (t.startInline ? t.startInline.push(i.start) : t.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens);
      }), r.extensions = t), n.renderer) {
        let i = this.defaults.renderer || new P(this.defaults);
        for (let s in n.renderer) {
          if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let o = s, a = n.renderer[o], u = i[o];
          i[o] = (...p) => {
            let c = a.apply(i, p);
            return c === false && (c = u.apply(i, p)), c || "";
          };
        }
        r.renderer = i;
      }
      if (n.tokenizer) {
        let i = this.defaults.tokenizer || new y(this.defaults);
        for (let s in n.tokenizer) {
          if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let o = s, a = n.tokenizer[o], u = i[o];
          i[o] = (...p) => {
            let c = a.apply(i, p);
            return c === false && (c = u.apply(i, p)), c;
          };
        }
        r.tokenizer = i;
      }
      if (n.hooks) {
        let i = this.defaults.hooks || new $();
        for (let s in n.hooks) {
          if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let o = s, a = n.hooks[o], u = i[o];
          $.passThroughHooks.has(s) ? i[o] = (p) => {
            if (this.defaults.async) return Promise.resolve(a.call(i, p)).then((f) => u.call(i, f));
            let c = a.call(i, p);
            return u.call(i, c);
          } : i[o] = (...p) => {
            let c = a.apply(i, p);
            return c === false && (c = u.apply(i, p)), c;
          };
        }
        r.hooks = i;
      }
      if (n.walkTokens) {
        let i = this.defaults.walkTokens, s = n.walkTokens;
        r.walkTokens = function(o) {
          let a = [];
          return a.push(s.call(this, o)), i && (a = a.concat(i.call(this, o))), a;
        };
      }
      this.defaults = { ...this.defaults, ...r };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, t) {
    return b.lex(e, t ?? this.defaults);
  }
  parser(e, t) {
    return R.parse(e, t ?? this.defaults);
  }
  parseMarkdown(e) {
    return (n, r) => {
      let i = { ...r }, s = { ...this.defaults, ...i }, o = this.onError(!!s.silent, !!s.async);
      if (this.defaults.async === true && i.async === false) return o(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof n > "u" || n === null) return o(new Error("marked(): input parameter is undefined or null"));
      if (typeof n != "string") return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
      s.hooks && (s.hooks.options = s, s.hooks.block = e);
      let a = s.hooks ? s.hooks.provideLexer() : e ? b.lex : b.lexInline, u = s.hooks ? s.hooks.provideParser() : e ? R.parse : R.parseInline;
      if (s.async) return Promise.resolve(s.hooks ? s.hooks.preprocess(n) : n).then((p) => a(p, s)).then((p) => s.hooks ? s.hooks.processAllTokens(p) : p).then((p) => s.walkTokens ? Promise.all(this.walkTokens(p, s.walkTokens)).then(() => p) : p).then((p) => u(p, s)).then((p) => s.hooks ? s.hooks.postprocess(p) : p).catch(o);
      try {
        s.hooks && (n = s.hooks.preprocess(n));
        let p = a(n, s);
        s.hooks && (p = s.hooks.processAllTokens(p)), s.walkTokens && this.walkTokens(p, s.walkTokens);
        let c = u(p, s);
        return s.hooks && (c = s.hooks.postprocess(c)), c;
      } catch (p) {
        return o(p);
      }
    };
  }
  onError(e, t) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        let r = "<p>An error occurred:</p><pre>" + w(n.message + "", true) + "</pre>";
        return t ? Promise.resolve(r) : r;
      }
      if (t) return Promise.reject(n);
      throw n;
    };
  }
};
var _ = new B();
function d(l3, e) {
  return _.parse(l3, e);
}
d.options = d.setOptions = function(l3) {
  return _.setOptions(l3), d.defaults = _.defaults, H(d.defaults), d;
};
d.getDefaults = L;
d.defaults = O;
d.use = function(...l3) {
  return _.use(...l3), d.defaults = _.defaults, H(d.defaults), d;
};
d.walkTokens = function(l3, e) {
  return _.walkTokens(l3, e);
};
d.parseInline = _.parseInline;
d.Parser = R;
d.parser = R.parse;
d.Renderer = P;
d.TextRenderer = S;
d.Lexer = b;
d.lexer = b.lex;
d.Tokenizer = y;
d.Hooks = $;
d.parse = d;
d.options;
d.setOptions;
d.use;
d.walkTokens;
d.parseInline;
R.parse;
b.lex;
d.use({
  breaks: false,
  // Use proper paragraphs, not <br> tags
  gfm: true
  // GitHub Flavored Markdown support
});
function createDocFromMarkdown(markdown, schema) {
  const html = convertMarkdownToHTML(markdown);
  return createDocFromHTML(html, schema);
}
function convertMarkdownToHTML(markdown) {
  let html = d.parse(markdown, { async: false });
  return html.replace(/<\/p>\n<ul>/g, "</p>\n<p>&nbsp;</p>\n<ul>").replace(/<\/p>\n<ol>/g, "</p>\n<p>&nbsp;</p>\n<ol>").replace(/<\/ul>\n<h/g, "</ul>\n<p>&nbsp;</p>\n<h").replace(/<\/ol>\n<h/g, "</ol>\n<p>&nbsp;</p>\n<h");
}
const helpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  chainableEditorState,
  cleanSchemaItem,
  convertMarkdownToHTML,
  createDocFromHTML,
  createDocFromMarkdown,
  createDocument,
  defaultBlockAt,
  findChildren,
  findMark,
  findParentNode,
  findParentNodeClosestToPos,
  generateDocxListAttributes,
  generateDocxRandomId,
  generateRandom32BitHex,
  getActiveFormatting,
  getExtensionConfigField,
  getMarkRange,
  getMarkType,
  getMarksBetween,
  getMarksFromSelection,
  getNodeType,
  getSchemaTypeByName,
  getSchemaTypeNameByName,
  isActive,
  isInTable,
  isList,
  isMarkActive,
  isNodeActive,
  isTextSelection,
  posToDOMRect
}, Symbol.toStringTag, { value: "Module" }));
const generateNewListDefinition = ({ numId, listType, level, start, text, fmt, editor }) => {
  if (typeof listType === "string") listType = editor.schema.nodes[listType];
  const definition = listType.name === "orderedList" ? baseOrderedListDef : baseBulletList;
  const numbering = editor.converter.numbering;
  const newNumbering = { ...numbering };
  let skipAddingNewAbstract = false;
  let newAbstractId = getNewListId(editor, "abstracts");
  let newAbstractDef = JSON.parse(
    JSON.stringify({
      ...definition,
      attributes: {
        ...definition.attributes,
        "w:abstractNumId": String(newAbstractId)
      }
    })
  );
  if (level && start && text && fmt) {
    if (newNumbering.definitions[numId]) {
      const abstractId = newNumbering.definitions[numId]?.elements[0]?.attributes["w:val"];
      newAbstractId = abstractId;
      const abstract = editor.converter.numbering.abstracts[abstractId];
      newAbstractDef = { ...abstract };
      skipAddingNewAbstract = true;
    }
    const levelDefIndex = newAbstractDef.elements.findIndex(
      (el) => el.name === "w:lvl" && el.attributes["w:ilvl"] === level
    );
    const levelProps = newAbstractDef.elements[levelDefIndex];
    const elToFilter = ["w:numFmt", "w:lvlText", "w:start"];
    const oldElements = levelProps.elements.filter((el) => !elToFilter.includes(el.name));
    levelProps.elements = [
      ...oldElements,
      {
        type: "element",
        name: "w:start",
        attributes: {
          "w:val": start
        }
      },
      {
        type: "element",
        name: "w:numFmt",
        attributes: {
          "w:val": fmt
        }
      },
      {
        type: "element",
        name: "w:lvlText",
        attributes: {
          "w:val": text
        }
      }
    ];
  }
  if (!skipAddingNewAbstract) newNumbering.abstracts[newAbstractId] = newAbstractDef;
  const newNumDef = getBasicNumIdTag(numId, newAbstractId);
  newNumbering.definitions[numId] = newNumDef;
  editor.converter.numbering = newNumbering;
  const change = { numDef: newNumDef, abstractDef: newAbstractDef, editor };
  editor.emit("list-definitions-change", { change, numbering: newNumbering, editor });
  return { abstract: newAbstractDef, definition: newNumDef };
};
const changeNumIdSameAbstract = (numId, level, listType, editor) => {
  const newId = getNewListId(editor, "definitions");
  const { abstract } = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  const numbering = editor.converter.numbering;
  const newNumbering = { ...numbering };
  const newAbstractId = getNewListId(editor, "abstracts");
  const newAbstractDef = {
    ...abstract,
    attributes: {
      ...abstract.attributes,
      "w:abstractNumId": String(newAbstractId)
    }
  };
  newNumbering.abstracts[newAbstractId] = newAbstractDef;
  const newNumDef = getBasicNumIdTag(newId, newAbstractId);
  newNumbering.definitions[newId] = newNumDef;
  return newId;
};
const getBasicNumIdTag = (numId, abstractId) => {
  return {
    type: "element",
    name: "w:num",
    attributes: {
      "w:numId": String(numId)
    },
    elements: [{ name: "w:abstractNumId", attributes: { "w:val": String(abstractId) } }]
  };
};
const getNewListId = (editor, grouping = "definitions") => {
  const defs = editor.converter.numbering[grouping] || {};
  const intKeys = Object.keys(defs).map((k) => Number(k)).filter((n) => Number.isInteger(n));
  const max2 = intKeys.length ? Math.max(...intKeys) : 0;
  return max2 + 1;
};
const getListDefinitionDetails = ({ numId, level, listType, editor, tries = 0 }) => {
  const { definitions, abstracts } = editor.converter.numbering;
  if (!numId) return {};
  const numDef = definitions[numId];
  if (!numDef && listType) {
    ListHelpers.generateNewListDefinition({ numId, listType, editor });
  }
  const abstractId = definitions[numId]?.elements?.find((item) => item.name === "w:abstractNumId")?.attributes?.["w:val"];
  const abstract = abstracts[abstractId];
  if (!abstract) {
    return {
      start: null,
      numFmt: null,
      lvlText: null,
      listNumberingType: null,
      customFormat: null,
      abstract: null,
      abstractId
    };
  }
  const numStyleLink = abstract.elements?.find((item) => item.name === "w:numStyleLink");
  const styleId = numStyleLink?.attributes?.["w:val"];
  if (styleId && tries < 1) {
    const styleDefinition = getStyleTagFromStyleId(styleId, editor.converter.convertedXml);
    const linkedNumId = styleDefinition?.elements?.find((el) => el.name === "w:pPr")?.elements?.find((el) => el.name === "w:numPr")?.elements?.find((el) => el.name === "w:numId")?.attributes?.["w:val"];
    if (linkedNumId) {
      return getListDefinitionDetails({
        numId: Number(linkedNumId),
        level,
        listType,
        editor,
        tries: tries + 1
      });
    }
  }
  const listDefinition = abstract.elements?.find(
    (item) => item.name === "w:lvl" && item.attributes?.["w:ilvl"] == level
  );
  if (!listDefinition) {
    return {
      start: null,
      numFmt: null,
      lvlText: null,
      listNumberingType: null,
      customFormat: null,
      abstract,
      abstractId
    };
  }
  const findElement = (name) => listDefinition.elements?.find((item) => item.name === name);
  const startElement = findElement("w:start");
  const numFmtElement = findElement("w:numFmt");
  const lvlTextElement = findElement("w:lvlText");
  const start = startElement?.attributes?.["w:val"];
  const numFmt = numFmtElement?.attributes?.["w:val"];
  const lvlText = lvlTextElement?.attributes?.["w:val"];
  const listNumberingType = numFmt;
  const customFormat = numFmt === "custom" ? numFmtElement?.attributes?.["w:format"] : void 0;
  return {
    start,
    numFmt,
    lvlText,
    listNumberingType,
    customFormat,
    abstract,
    abstractId
  };
};
const removeListDefinitions = (listId, editor) => {
  const { numbering } = editor.converter;
  if (!numbering) return;
  const { definitions, abstracts } = numbering;
  const abstractId = definitions[listId].elements[0].attributes["w:val"];
  delete definitions[listId];
  delete abstracts[abstractId];
  editor.converter.numbering = {
    definitions,
    abstracts
  };
};
const createListItemNodeJSON = ({ level, lvlText, numId, numFmt, listLevel, contentNode }) => {
  if (!contentNode) {
    contentNode = {
      type: "paragraph",
      content: []
    };
  }
  if (!Array.isArray(contentNode)) contentNode = [contentNode];
  const attrs = {
    lvlText,
    listLevel,
    level,
    numId,
    numPrType: "inline",
    listNumberingType: numFmt
  };
  const listItem = {
    type: "listItem",
    attrs,
    content: [...contentNode]
  };
  return listItem;
};
const createSchemaOrderedListNode = ({ level, numId, listType, editor, listLevel, contentNode }) => {
  level = Number(level);
  numId = Number(numId);
  const { start, lvlText, numFmt } = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  const listNodeJSON = createListItemNodeJSON({ level, lvlText, numFmt, numId, listLevel, contentNode });
  const node2 = {
    type: "orderedList",
    attrs: {
      "list-style-type": numFmt,
      listId: numId,
      order: level
    },
    content: [listNodeJSON]
  };
  return editor.schema.nodeFromJSON(node2);
};
const createNewList = ({ listType, tr, editor }) => {
  const numId = ListHelpers.getNewListId(editor);
  if (typeof listType === "string") listType = editor.schema.nodes[listType];
  ListHelpers.generateNewListDefinition({ numId, listType, editor });
  const { selection } = tr;
  const { $from } = selection;
  const content = $from.parent;
  const level = 0;
  const listNode = ListHelpers.createSchemaOrderedListNode({
    level,
    numId,
    listType,
    editor,
    listLevel: [1],
    contentNode: content?.toJSON()
  });
  const replaceFrom = $from.before($from.depth);
  const replaceTo = $from.after($from.depth);
  return insertNewList(tr, replaceFrom, replaceTo, listNode);
};
const getCurrentListItem = (state2) => {
  return findParentNode((node2) => node2.type.name === "listItem")(state2.selection);
};
const getParentOrderedList = (state2) => {
  return findParentNode((node2) => node2.type.name === "orderedList")(state2.selection);
};
const setSelectionInsideNewList = (tr, basePos) => {
  try {
    const $pos = tr.doc.resolve(basePos + 3);
    tr.setSelection(TextSelection.near($pos));
  } catch {
    const $fallback = tr.doc.resolve(basePos + 1);
    tr.setSelection(TextSelection.near($fallback));
  }
};
const replaceListWithNode = ({ tr, from, to, newNode }) => {
  tr.replaceWith(from, to, newNode);
};
const convertListItemToParagraph = ({ state: state2, tr, currentNode, replaceFrom, replaceTo }) => {
  const paragraphContent = currentNode.node.content.firstChild;
  if (!paragraphContent) return false;
  const paragraphNode = state2.schema.nodes.paragraph.create(
    paragraphContent.attrs,
    paragraphContent.content,
    paragraphContent.marks
  );
  replaceListWithNode({ tr, from: replaceFrom, to: replaceTo, newNode: paragraphNode });
  const newPos = replaceFrom + 1;
  const $pos = tr.doc.resolve(newPos);
  tr.setSelection(TextSelection.near($pos));
  return true;
};
const insertNewList = (tr, replaceFrom, replaceTo, listNode, marks = []) => {
  tr.replaceWith(replaceFrom, replaceTo, listNode);
  tr.ensureMarks(marks);
  const listStart = replaceFrom;
  const $paragraphStart = tr.doc.resolve(listStart + 2);
  const paragraphNode = $paragraphStart.parent;
  const endPos = $paragraphStart.pos + paragraphNode.content.size;
  const $endPos = tr.doc.resolve(endPos);
  tr.setSelection(TextSelection.near($endPos));
  return true;
};
const getListItemStyleDefinitions = ({ styleId, numId, level, editor, tries }) => {
  if (tries) return {};
  if (typeof numId === "string") numId = Number(numId);
  if (typeof level === "string") level = Number(level);
  const docx = { ...editor?.converter?.convertedXml };
  const newNumbering = { ...editor?.converter?.numbering };
  const styleDefinition = getStyleTagFromStyleId(styleId, docx);
  const stylePpr = styleDefinition?.elements.find((el) => el.name === "w:pPr");
  let abstractDefinition = getAbstractDefinition(numId, docx);
  if (!abstractDefinition) {
    const listDef = newNumbering.definitions[numId];
    const abstractId = listDef?.elements?.find((item) => item.name === "w:abstractNumId")?.attributes?.["w:val"];
    abstractDefinition = newNumbering.abstracts[abstractId];
  }
  const numDefinition = getDefinitionForLevel(abstractDefinition, level);
  const numDefPpr = numDefinition?.elements.find((el) => el.name === "w:pPr");
  const numLvlJs = numDefinition?.elements.find((el) => el.name === "w:lvlJc");
  return {
    stylePpr,
    numDefPpr,
    numLvlJs
  };
};
const addInlineTextMarks = (currentNode, filteredMarks) => {
  const newMarks = [...filteredMarks];
  try {
    const textMarks = currentNode.children[0].children[0].marks;
    const inlineTextStyleFromSplitBlock = textMarks.find((m2) => m2.type.name === "textStyle");
    inlineTextStyleFromSplitBlock && newMarks.push(inlineTextStyleFromSplitBlock);
  } catch {
  }
  return newMarks;
};
const ListHelpers = {
  getCurrentListItem,
  getParentOrderedList,
  setSelectionInsideNewList,
  replaceListWithNode,
  convertListItemToParagraph,
  // DOCX helpers
  insertNewList,
  getListDefinitionDetails,
  generateNewListDefinition,
  getBasicNumIdTag,
  getNewListId,
  removeListDefinitions,
  getListItemStyleDefinitions,
  // Schema helpers
  createNewList,
  createSchemaOrderedListNode,
  createListItemNodeJSON,
  addInlineTextMarks,
  changeNumIdSameAbstract,
  // Base list definitions
  baseOrderedListDef,
  baseBulletList
};
const extractListLevelStyles = (cssText, listId, level, numId) => {
  const pattern = new RegExp(`@list\\s+l${listId}:level${level}(?:\\s+lfo${numId})?\\s*\\{([^}]+)\\}`, "i");
  const match = cssText.match(pattern);
  if (!match) return null;
  const rawStyles = match[1].split(";").map((line) => line.trim()).filter(Boolean);
  const styleMap = {};
  for (const style of rawStyles) {
    const [key, value] = style.split(":").map((s) => s.trim());
    styleMap[key] = value;
  }
  return styleMap;
};
const numDefMap = /* @__PURE__ */ new Map([
  ["decimal", "decimal"],
  ["alpha-lower", "lowerLetter"],
  ["alpha-upper", "upperLetter"],
  ["roman-lower", "lowerRoman"],
  ["roman-upper", "upperRoman"],
  ["bullet", "bullet"]
]);
const numDefByTypeMap = /* @__PURE__ */ new Map([
  ["1", "decimal"],
  ["a", "lowerLetter"],
  ["A", "upperLetter"],
  ["I", "upperRoman"],
  ["i", "lowerRoman"]
]);
function getStartNumber(lvlText) {
  const match = lvlText.match(/^(\d+)/);
  if (match) return parseInt(match[1], 10);
  return null;
}
function letterToNumber(letter) {
  return letter.toLowerCase().charCodeAt(0) - "a".charCodeAt(0) + 1;
}
function getStartNumberFromAlpha(lvlText) {
  const match = lvlText.match(/^([a-zA-Z])/);
  if (match) return letterToNumber(match[1]);
  return null;
}
function romanToNumber(roman) {
  const map = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1e3 };
  let num = 0, prev = 0;
  for (let i = roman.length - 1; i >= 0; i--) {
    const curr = map[roman[i].toUpperCase()] || 0;
    if (curr < prev) num -= curr;
    else num += curr;
    prev = curr;
  }
  return num;
}
function getStartNumberFromRoman(lvlText) {
  const match = lvlText.match(/^([ivxlcdmIVXLCDM]+)/);
  if (match) return romanToNumber(match[1]);
  return null;
}
const startHelperMap = /* @__PURE__ */ new Map([
  ["decimal", getStartNumber],
  ["lowerLetter", getStartNumberFromAlpha],
  ["upperLetter", getStartNumberFromAlpha],
  ["lowerRoman", getStartNumberFromRoman],
  ["upperRoman", getStartNumberFromRoman],
  ["bullet", () => 1]
]);
const googleNumDefMap = /* @__PURE__ */ new Map([
  ["decimal", "decimal"],
  ["decimal-leading-zero", "decimal"],
  ["lower-alpha", "lowerLetter"],
  ["upper-alpha", "upperLetter"],
  ["lower-roman", "lowerRoman"],
  ["upper-roman", "upperRoman"],
  ["bullet", "bullet"]
]);
const getLvlTextForGoogleList = (fmt, level, editor) => {
  const bulletListDef = editor.converter.numbering.abstracts[0];
  const bulletDefForLevel = bulletListDef.elements.find(
    (el) => el.name === "w:lvl" && el.attributes?.["w:ilvl"] === (level - 1).toString()
  );
  const bulletLvlText = bulletDefForLevel.elements.find((el) => el.name === "w:lvlText")?.attributes?.["w:val"];
  switch (fmt) {
    case "decimal-leading-zero":
      return `0%${level}.`;
    case "bullet":
      return bulletLvlText;
    default:
      return `%${level}.`;
  }
};
const handleDocxPaste = (html, editor, view) => {
  const { converter } = editor;
  if (!converter || !converter.convertedXml) return handleHtmlPaste(html, editor);
  let cleanedHtml = convertEmToPt(html);
  cleanedHtml = cleanHtmlUnnecessaryTags(cleanedHtml);
  const tempDiv = document.createElement("div");
  tempDiv.innerHTML = cleanedHtml;
  const data = tempDiv.querySelectorAll("p, li");
  const startMap = {};
  data.forEach((item) => {
    let type2;
    if (item.localName === "li") {
      type2 = "listItem";
    } else {
      const html2 = item.innerHTML;
      type2 = "p";
      if (!html2.includes("<!--[if !supportLists]")) return;
    }
    const styleAttr = item.getAttribute("style") || "";
    const msoListMatch = styleAttr.match(/mso-list:\s*l(\d+)\s+level(\d+)\s+lfo(\d+)/);
    const css = tempDiv.querySelector("style").innerHTML;
    if (msoListMatch) {
      const [, abstractId, level, numId] = msoListMatch;
      const styles = extractListLevelStyles(css, abstractId, level, numId) || {};
      let start, numFmt, lvlText;
      if (type2 === "listItem") {
        const listType = item.parentNode.getAttribute("type");
        const startAttr = item.parentNode.getAttribute("start");
        if (!startMap[numId]) startMap[numId] = startAttr;
        start = startMap[numId];
        numFmt = numDefByTypeMap.get(listType);
        lvlText = `%${level}.`;
      } else {
        const msoNumFormat = styles["mso-level-number-format"] || "decimal";
        numFmt = numDefMap.get(msoNumFormat);
        const punc = item.innerText?.match(/^\s*[a-zA-Z0-9]+([.()])/i)?.[1] || ".";
        lvlText = numFmt === "bullet" ? normalizeLvlTextChar(styles["mso-level-text"]) : `%${level}${punc}`;
        const startGetter = startHelperMap.get(numFmt);
        if (!startMap[numId]) startMap[numId] = startGetter(item.children[0]?.innerText || "1");
        start = startMap[numId];
      }
      item.setAttribute("data-num-id", numId);
      item.setAttribute("data-list-level", parseInt(level) - 1);
      item.setAttribute("data-start", start);
      item.setAttribute("data-lvl-text", lvlText);
      item.setAttribute("data-num-fmt", numFmt);
      const ptToPxRatio = 1.333;
      const indent = parseInt(styles["margin-left"]) * ptToPxRatio || 0;
      if (indent > 0) item.setAttribute("data-left-indent", indent);
    }
    extractAndRemoveConditionalPrefix(item);
  });
  transformWordLists(tempDiv, editor);
  const doc2 = DOMParser$1.fromSchema(editor.schema).parse(tempDiv);
  tempDiv.remove();
  const { dispatch } = editor.view;
  if (!dispatch) return false;
  dispatch(view.state.tr.replaceSelectionWith(doc2, true));
  return true;
};
const transformWordLists = (container, editor) => {
  const listItems = Array.from(container.querySelectorAll("[data-num-id]"));
  const lists = {};
  const mappedLists = {};
  for (const item of listItems) {
    const level = parseInt(item.getAttribute("data-list-level"));
    const numFmt = item.getAttribute("data-num-fmt");
    const start = item.getAttribute("data-start");
    const lvlText = item.getAttribute("data-lvl-text");
    const indent = item.getAttribute("data-left-indent");
    const importedId = item.getAttribute("data-num-id");
    if (!mappedLists[importedId]) mappedLists[importedId] = ListHelpers.getNewListId(editor);
    const id = mappedLists[importedId];
    const listType = numFmt === "bullet" ? "bulletList" : "orderedList";
    ListHelpers.generateNewListDefinition({
      numId: id,
      listType,
      level: level.toString(),
      start,
      fmt: numFmt,
      text: lvlText,
      editor
    });
    if (!lists[id]) lists[id] = { levels: {} };
    const currentListByNumId = lists[id];
    if (!currentListByNumId.levels[level]) currentListByNumId.levels[level] = Number(start) || 1;
    else currentListByNumId.levels[level]++;
    Object.keys(currentListByNumId.levels).forEach((key) => {
      const level1 = Number(key);
      if (level1 > level) {
        delete currentListByNumId.levels[level1];
      }
    });
    const path = generateListPath(level, currentListByNumId.levels, start);
    if (!path.length) path.push(currentListByNumId.levels[level]);
    const li = document.createElement("li");
    li.innerHTML = item.innerHTML;
    li.setAttribute("data-num-id", id);
    li.setAttribute("data-list-level", JSON.stringify(path));
    li.setAttribute("data-level", level);
    li.setAttribute("data-lvl-text", lvlText);
    li.setAttribute("data-num-fmt", numFmt);
    if (indent) li.setAttribute("data-indent", JSON.stringify({ left: indent }));
    if (item.hasAttribute("data-font-family")) {
      li.setAttribute("data-font-family", item.getAttribute("data-font-family"));
    }
    if (item.hasAttribute("data-font-size")) {
      li.setAttribute("data-font-size", item.getAttribute("data-font-size"));
    }
    const parentNode = item.parentNode;
    let listForLevel;
    const newList = numFmt === "bullet" ? document.createElement("ul") : document.createElement("ol");
    newList.setAttribute("data-list-id", id);
    newList.level = level;
    parentNode.insertBefore(newList, item);
    listForLevel = newList;
    listForLevel.appendChild(li);
    item.remove();
  }
};
const generateListPath = (level, levels, start) => {
  const iLvl = Number(level);
  const path = [];
  if (iLvl > 0) {
    for (let i = iLvl; i >= 0; i--) {
      if (!levels[i]) levels[i] = Number(start);
      path.unshift(levels[i]);
    }
  }
  return path;
};
function extractAndRemoveConditionalPrefix(item) {
  const nodes = Array.from(item.childNodes);
  let fontFamily = null;
  let fontSize = null;
  let start = -1, end = -1;
  nodes.forEach((node2, index) => {
    if (node2.nodeType === Node.COMMENT_NODE && node2.nodeValue.includes("[if !supportLists]")) {
      start = index;
    }
    if (start !== -1 && node2.nodeType === Node.COMMENT_NODE && node2.nodeValue.includes("[endif]")) {
      end = index;
    }
  });
  if (start !== -1 && end !== -1) {
    for (let i = start + 1; i < end; i++) {
      const node2 = nodes[i];
      if (node2.nodeType === Node.ELEMENT_NODE && node2.style) {
        fontFamily = fontFamily || node2.style.fontFamily;
        fontSize = fontSize || node2.style.fontSize;
      }
    }
    for (let i = end; i >= start; i--) {
      item.removeChild(item.childNodes[i]);
    }
    if (fontFamily) item.setAttribute("data-font-family", fontFamily);
    if (fontSize) item.setAttribute("data-font-size", fontSize);
  }
}
function flattenListsInHtml$1(html, editor) {
  let parser, NodeInterface;
  if (editor.options?.mockDocument) {
    const win = editor.options.mockDocument.defaultView;
    parser = new win.DOMParser();
    NodeInterface = win.Node;
  } else {
    parser = new DOMParser();
    NodeInterface = window.Node;
  }
  const doc2 = parser.parseFromString(html, "text/html");
  let foundList;
  while (foundList = findListToFlatten$1(doc2)) {
    flattenFoundList$1(foundList, editor, NodeInterface);
  }
  return doc2.body.innerHTML;
}
function findListToFlatten$1(doc2) {
  let list = doc2.querySelector("ol:not([data-list-id]), ul:not([data-list-id])");
  if (list) return list;
  const allLists = doc2.querySelectorAll("ol[data-list-id], ul[data-list-id]");
  for (const list2 of allLists) {
    const liChildren = Array.from(list2.children).filter((c) => c.tagName.toLowerCase() === "li");
    if (liChildren.length > 1) {
      return list2;
    }
    const nestedLists = list2.querySelectorAll("ol, ul");
    if (nestedLists.length > 0) {
      return list2;
    }
  }
  return null;
}
function flattenFoundList$1(listElem, editor, NodeInterface) {
  const localDoc = listElem.ownerDocument;
  const tag = listElem.tagName.toLowerCase();
  let rootNumId = listElem.getAttribute("data-list-id");
  if (!rootNumId) {
    rootNumId = ListHelpers.getNewListId(editor);
    ListHelpers.generateNewListDefinition({
      numId: rootNumId,
      listType: tag === "ol" ? "orderedList" : "bulletList",
      editor
    });
  }
  let level = 0;
  let ancestor = listElem.parentElement;
  while (ancestor && ancestor !== localDoc.body) {
    if (ancestor.tagName && ancestor.tagName.toLowerCase() === "li") {
      level++;
    }
    ancestor = ancestor.parentElement;
  }
  const items = Array.from(listElem.children).filter((c) => c.tagName.toLowerCase() === "li");
  const newLists = [];
  items.forEach((li) => {
    const nestedLists = Array.from(li.querySelectorAll("ol, ul"));
    const nestedListsData = nestedLists.map((nl) => ({
      element: nl.cloneNode(true),
      parent: nl.parentNode
    }));
    nestedLists.forEach((nl) => nl.parentNode.removeChild(nl));
    const newList = createSingleItemList({ li, tag, rootNumId, level, editor, NodeInterface });
    newLists.push(newList);
    nestedListsData.forEach((data) => {
      newLists.push(data.element);
    });
  });
  const parent = listElem.parentNode;
  const nextSibling = listElem.nextSibling;
  parent.removeChild(listElem);
  newLists.forEach((list) => {
    parent.insertBefore(list, nextSibling);
  });
}
function createSingleItemList({ li, tag, rootNumId, level, listLevel, editor, NodeInterface }) {
  const localDoc = li.ownerDocument;
  const ELEMENT_NODE = NodeInterface.ELEMENT_NODE;
  const TEXT_NODE = NodeInterface.TEXT_NODE;
  const newList = localDoc.createElement(tag);
  const newLi = localDoc.createElement("li");
  Array.from(li.attributes).forEach((attr) => {
    if (!attr.name.startsWith("data-num-") && !attr.name.startsWith("data-level") && !attr.name.startsWith("data-list-")) {
      newLi.setAttribute(attr.name, attr.value);
    }
  });
  newList.setAttribute("data-list-id", rootNumId);
  newLi.setAttribute("data-num-id", rootNumId);
  newLi.setAttribute("data-level", String(level));
  const { listNumberingType, lvlText } = ListHelpers.getListDefinitionDetails({
    numId: rootNumId,
    level,
    editor
  });
  newLi.setAttribute("data-num-fmt", listNumberingType);
  newLi.setAttribute("data-lvl-text", lvlText || "");
  newLi.setAttribute("data-list-level", JSON.stringify(listLevel || [level + 1]));
  Array.from(li.childNodes).forEach((node2) => {
    if (node2.nodeType === ELEMENT_NODE || node2.nodeType === TEXT_NODE && node2.textContent.trim()) {
      newLi.appendChild(node2.cloneNode(true));
    }
  });
  if (newLi.childNodes.length === 0 || newLi.childNodes.length === 1 && newLi.childNodes[0].nodeType === TEXT_NODE) {
    const textContent = newLi.textContent.trim();
    if (textContent) {
      newLi.innerHTML = "";
      const p = localDoc.createElement("p");
      p.textContent = textContent;
      newLi.appendChild(p);
    }
  }
  newList.appendChild(newLi);
  return newList;
}
function unflattenListsInHtml(html) {
  const parser = new DOMParser();
  const doc2 = parser.parseFromString(html, "text/html");
  const allNodes = [...doc2.body.children];
  const listSequences = [];
  let currentSequence = null;
  allNodes.forEach((node2, index) => {
    const isFlattenList = node2.tagName && (node2.tagName === "OL" || node2.tagName === "UL") && node2.hasAttribute("data-list-id");
    if (isFlattenList) {
      const listId = node2.getAttribute("data-list-id");
      if (currentSequence && currentSequence.id === listId) {
        currentSequence.lists.push({ element: node2, index });
      } else {
        currentSequence = {
          id: listId,
          lists: [{ element: node2, index }]
        };
        listSequences.push(currentSequence);
      }
    } else {
      currentSequence = null;
    }
  });
  listSequences.reverse().forEach((sequence) => {
    const sequenceLists = sequence.lists;
    if (sequenceLists.length === 0) {
      return;
    }
    const items = sequenceLists.map(({ element: list }) => {
      const liElement = list.querySelector("li");
      if (!liElement) return null;
      return {
        element: liElement,
        level: parseInt(liElement.getAttribute("data-level") || "0"),
        numFmt: liElement.getAttribute("data-num-fmt") || "bullet",
        listLevel: JSON.parse(liElement.getAttribute("data-list-level") || "[1]")
      };
    }).filter((item) => item !== null);
    if (items.length === 0) {
      return;
    }
    const rootList = buildNestedList({ items });
    const firstOriginalList = sequenceLists[0].element;
    firstOriginalList?.parentNode?.insertBefore(rootList, firstOriginalList);
    sequenceLists.forEach(({ element: list }) => {
      if (list.parentNode) list.parentNode.removeChild(list);
    });
  });
  return doc2.body.innerHTML;
}
function buildNestedList({ items }) {
  if (!items.length) {
    return null;
  }
  const [rootItem] = items;
  const doc2 = rootItem.element.ownerDocument;
  const isOrderedList = rootItem.numFmt && !["bullet", "none"].includes(rootItem.numFmt);
  const rootList = doc2.createElement(isOrderedList ? "ol" : "ul");
  if (isOrderedList && rootItem.listLevel?.[0] && rootItem.listLevel[0] > 1) {
    rootList.setAttribute("start", rootItem.listLevel[0]);
  }
  const lastLevelItem = /* @__PURE__ */ new Map();
  items.forEach((item) => {
    const { element: liElement, level, numFmt } = item;
    const cleanLi = cleanListItem(liElement.cloneNode(true));
    if (level === 0) {
      rootList.append(cleanLi);
      lastLevelItem.set(0, cleanLi);
    } else {
      const parentLi = lastLevelItem.get(level - 1);
      if (!parentLi) {
        rootList.append(cleanLi);
        lastLevelItem.set(level, cleanLi);
        return;
      }
      let nestedList = null;
      [...parentLi.children].forEach((child) => {
        if (child.tagName && (child.tagName === "OL" || child.tagName === "UL")) {
          nestedList = child;
        }
      });
      if (!nestedList) {
        const listType = numFmt && !["bullet", "none"].includes(numFmt) ? "ol" : "ul";
        nestedList = doc2.createElement(listType);
        parentLi.append(nestedList);
      }
      nestedList.append(cleanLi);
      lastLevelItem.set(level, cleanLi);
    }
  });
  return rootList;
}
function cleanListItem(listItem) {
  const attrs = [
    "data-num-id",
    "data-level",
    "data-num-fmt",
    "data-lvl-text",
    "data-list-level",
    "data-marker-type",
    "aria-label"
  ];
  attrs.forEach((attr) => {
    listItem.removeAttribute(attr);
  });
  return listItem;
}
const handleGoogleDocsHtml = (html, editor, view) => {
  const htmlWithPtSizing = convertEmToPt(html);
  const cleanedHtml = sanitizeHtml(htmlWithPtSizing).innerHTML;
  const tempDiv = document.createElement("div");
  tempDiv.innerHTML = cleanedHtml;
  const htmlWithMergedLists = mergeSeparateLists(tempDiv);
  const flattenHtml = flattenListsInHtml(htmlWithMergedLists, editor);
  const doc2 = DOMParser$1.fromSchema(editor.schema).parse(flattenHtml);
  tempDiv.remove();
  const { dispatch } = editor.view;
  if (!dispatch) return false;
  dispatch(view.state.tr.replaceSelectionWith(doc2, true));
  return true;
};
function flattenListsInHtml(container, editor) {
  let foundList;
  while (foundList = findListToFlatten(container)) {
    flattenFoundList(foundList, editor);
  }
  return container;
}
function findListToFlatten(container) {
  let list = container.querySelector("ol:not([data-list-id]), ul:not([data-list-id])");
  if (list) return list;
  return null;
}
function flattenFoundList(listElem, editor) {
  let NodeInterface;
  if (editor.options.mockDocument) {
    const win = editor.options.mockDocument.defaultView;
    NodeInterface = win.Node;
  } else {
    NodeInterface = window.Node;
  }
  const tag = listElem.tagName.toLowerCase();
  const rootListLevel = Number(listElem.children[0].getAttribute("aria-level"));
  const rootListFmt = listElem.children[0].style["list-style-type"] || "decimal";
  const start = listElem.getAttribute("start") || 1;
  const rootNumId = ListHelpers.getNewListId(editor);
  ListHelpers.generateNewListDefinition({
    numId: rootNumId,
    listType: tag === "ol" ? "orderedList" : "bulletList",
    editor,
    fmt: googleNumDefMap.get(rootListFmt),
    level: (rootListLevel - 1).toString(),
    start,
    text: getLvlTextForGoogleList(rootListFmt, rootListLevel, editor)
  });
  const newLists = [];
  const items = Array.from(listElem.children).filter((c) => c.tagName.toLowerCase() === "li");
  items.forEach((li) => {
    const level = Number(li.getAttribute("aria-level")) - 1;
    const listLevel = [level + 1];
    const nestedLists = getNestedLists([li.nextSibling]);
    const newList = createSingleItemList({ li, tag, rootNumId, level, listLevel, editor, NodeInterface });
    newLists.push(newList);
    nestedLists.forEach((list) => {
      newLists.push(list.cloneNode(true));
    });
    if (nestedLists.length && ["OL", "UL"].includes(li.nextSibling.tagName)) {
      li.nextSibling?.remove();
    }
  });
  const parent = listElem.parentNode;
  const nextSibling = listElem.nextSibling;
  parent.removeChild(listElem);
  newLists.forEach((list) => {
    parent.insertBefore(list, nextSibling);
  });
}
function getNestedLists(nodes) {
  let result = [];
  const nodesArray = Array.from(nodes).filter((n) => n !== null);
  for (let item of nodesArray) {
    if (item.tagName === "OL" || item.tagName === "UL") {
      result.push(item);
      result.push(...getNestedLists(item.children));
    }
  }
  return result;
}
function mergeSeparateLists(container) {
  const tempCont = container.cloneNode(true);
  const rootLevelLists = Array.from(tempCont.querySelectorAll("ol:not(ol ol):not(ul ol)") || []);
  const mainList = rootLevelLists.find((list) => !list.getAttribute("start"));
  const hasStartAttr = rootLevelLists.some((list) => list.getAttribute("start") !== null);
  if (hasStartAttr) {
    const listsWithStartAttr = rootLevelLists.filter((list) => list.getAttribute("start") !== null);
    for (let [index, item] of listsWithStartAttr.entries()) {
      if (item.getAttribute("start") === (index + 2).toString()) {
        mainList.append(...item.childNodes);
        item.remove();
      }
    }
  }
  return tempCont;
}
class InputRule {
  constructor(config) {
    __publicField(this, "match");
    __publicField(this, "handler");
    this.match = config.match;
    this.handler = config.handler;
  }
}
const inputRuleMatcherHandler = (text, match) => {
  if (isRegExp(match)) {
    return match.exec(text);
  }
  const inputRuleMatch = match(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[super-editor warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
const run = (config) => {
  const { editor, from, to, text, rules, plugin } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from);
  if ($from.parent.type.spec.code || !!($from.nodeBefore || $from.nodeAfter)?.marks.find((mark) => mark.type.spec.code)) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.match);
    if (!match) {
      return;
    }
    const tr = view.state.tr;
    const state2 = chainableEditorState(tr, view.state);
    const range2 = {
      from: from - (match[0].length - text.length),
      to
    };
    const { commands, chain, can } = new CommandService({
      editor,
      state: state2
    });
    const handler = rule.handler({
      state: state2,
      range: range2,
      match,
      commands,
      chain,
      can
    });
    if (handler === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin, {
      transform: tr,
      from,
      to,
      text
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
};
const inputRulesPlugin = ({ editor, rules }) => {
  const plugin = new Plugin({
    key: new PluginKey("inputRulesPlugin"),
    state: {
      init() {
        return null;
      },
      apply(tr, prev, state2) {
        const stored = tr.getMeta(plugin);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text !== "string") {
              text = getHTMLFromFragment(Fragment.from(text), state2.schema);
            }
            const { from } = simulatedInputMeta;
            const to = from + text.length;
            run({
              editor,
              from,
              to,
              text,
              rules,
              plugin
            });
          });
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from, to, text) {
        return run({
          editor,
          from,
          to,
          text,
          rules,
          plugin
        });
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin
          });
        }
        return false;
      },
      // Paste handler
      handlePaste(view, event, slice) {
        const clipboard = event.clipboardData;
        const html = clipboard.getData("text/html");
        const fieldAnnotationContent = slice.content.content.filter((item) => item.type.name === "fieldAnnotation");
        if (fieldAnnotationContent.length) {
          return false;
        }
        return handleClipboardPaste({ editor, view }, html);
      }
    },
    isInputRules: true
  });
  return plugin;
};
function isWordHtml(html) {
  return /class=["']?Mso|xmlns:o=["']?urn:schemas-microsoft-com|<!--\[if gte mso|<meta[^>]+name=["']?Generator["']?[^>]+Word/i.test(
    html
  );
}
function isGoogleDocsHtml(html) {
  return /docs-internal-guid-/.test(html);
}
function handleHtmlPaste(html, editor, source) {
  let cleanedHtml;
  cleanedHtml = htmlHandler(html, editor);
  const doc2 = DOMParser$1.fromSchema(editor.schema).parse(cleanedHtml);
  const { dispatch, state: state2 } = editor.view;
  if (!dispatch) return false;
  const { $from } = state2.selection;
  const isInParagraph = $from.parent.type.name === "paragraph";
  const isSingleParagraph = doc2.childCount === 1 && doc2.firstChild.type.name === "paragraph";
  if (isInParagraph && isSingleParagraph) {
    const paragraphContent = doc2.firstChild.content;
    const tr = state2.tr.replaceSelectionWith(paragraphContent, false);
    dispatch(tr);
  } else if (isInParagraph) {
    const allContent = [];
    doc2.content.forEach((node2, index) => {
      if (node2.type.name === "paragraph") {
        allContent.push(...node2.content.content);
        if (index < doc2.content.childCount - 1) {
          allContent.push(editor.schema.text("\n"));
        }
      }
    });
    if (allContent.length > 0) {
      const fragment = Fragment.from(allContent);
      const tr = state2.tr.replaceSelectionWith(fragment, false);
      dispatch(tr);
    } else {
      dispatch(state2.tr.replaceSelectionWith(doc2, true));
    }
  } else {
    dispatch(state2.tr.replaceSelectionWith(doc2, true));
  }
  return true;
}
function htmlHandler(html, editor) {
  const flatHtml = flattenListsInHtml$1(html, editor);
  const htmlWithPtSizing = convertEmToPt(flatHtml);
  return sanitizeHtml(htmlWithPtSizing);
}
const convertEmToPt = (html) => {
  return html.replace(/font-size\s*:\s*([\d.]+)em/gi, (_2, emValue) => {
    const em = parseFloat(emValue);
    const pt = Math.round(em * 12 * 100) / 100;
    return `font-size: ${pt}pt`;
  });
};
function cleanHtmlUnnecessaryTags(html) {
  return html.replace(/<o:p>.*?<\/o:p>/gi, "").replace(/&nbsp;/gi, " ").replace(/<span[^>]*>\s*<\/span>/gi, "").replace(/<p[^>]*>\s*<\/p>/gi, "").trim();
}
function sanitizeHtml(html, forbiddenTags = ["meta", "svg", "script", "style", "button"]) {
  const container = document.createElement("div");
  container.innerHTML = html;
  const walkAndClean = (node2) => {
    for (const child of [...node2.children]) {
      if (forbiddenTags.includes(child.tagName.toLowerCase())) {
        child.remove();
        continue;
      }
      if (child.hasAttribute("linebreaktype")) {
        child.removeAttribute("linebreaktype");
      }
      walkAndClean(child);
    }
  };
  walkAndClean(container);
  return container;
}
function handleClipboardPaste({ editor, view }, html) {
  let source;
  if (!html) {
    source = "plain-text";
  } else if (isWordHtml(html)) {
    source = "word-html";
  } else if (isGoogleDocsHtml(html)) {
    source = "google-docs";
  } else {
    source = "browser-html";
  }
  switch (source) {
    case "plain-text":
      return false;
    case "word-html":
      if (editor.options.mode === "docx") {
        return handleDocxPaste(html, editor, view);
      }
      break;
    case "google-docs":
      return handleGoogleDocsHtml(html, editor, view);
    // falls through to browser-html handling when not in DOCX mode
    case "browser-html":
      return handleHtmlPaste(html, editor);
  }
  return false;
}
function translateChildNodes(params) {
  const { content: nodes } = params.node;
  if (!nodes) return [];
  const translatedNodes = [];
  nodes.forEach((node2) => {
    let translatedNode = exportSchemaToJson({ ...params, node: node2 });
    if (translatedNode instanceof Array) translatedNodes.push(...translatedNode);
    else translatedNodes.push(translatedNode);
  });
  return translatedNodes.filter((n) => n);
}
const baseNumbering = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w:numbering",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du wp14"
      },
      elements: [
        {
          type: "element",
          name: "w:abstractNum",
          attributes: {
            "w:abstractNumId": "0",
            "w15:restartNumberingAfterBreak": "0"
          },
          elements: [
            {
              type: "element",
              name: "w:nsid",
              attributes: {
                "w:val": "16126B07"
              }
            },
            {
              type: "element",
              name: "w:multiLevelType",
              attributes: {
                "w:val": "hybridMultilevel"
              }
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "0",
                "w:tplc": "04090001"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "720",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Symbol",
                        "w:hAnsi": "Symbol",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "1",
                "w:tplc": "04090003",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "o"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "1440",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Courier New",
                        "w:hAnsi": "Courier New",
                        "w:cs": "Courier New",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "2",
                "w:tplc": "04090005",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2160",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Wingdings",
                        "w:hAnsi": "Wingdings",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "3",
                "w:tplc": "04090001",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2880",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Symbol",
                        "w:hAnsi": "Symbol",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "4",
                "w:tplc": "04090003",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "o"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "3600",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Courier New",
                        "w:hAnsi": "Courier New",
                        "w:cs": "Courier New",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "5",
                "w:tplc": "04090005",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "4320",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Wingdings",
                        "w:hAnsi": "Wingdings",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "6",
                "w:tplc": "04090001",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5040",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Symbol",
                        "w:hAnsi": "Symbol",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "7",
                "w:tplc": "04090003",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "o"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5760",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Courier New",
                        "w:hAnsi": "Courier New",
                        "w:cs": "Courier New",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "8",
                "w:tplc": "04090005",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "6480",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Wingdings",
                        "w:hAnsi": "Wingdings",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          type: "element",
          name: "w:abstractNum",
          attributes: {
            "w:abstractNumId": "1",
            "w15:restartNumberingAfterBreak": "0"
          },
          elements: [
            {
              type: "element",
              name: "w:nsid",
              attributes: {
                "w:val": "587013BA"
              }
            },
            {
              type: "element",
              name: "w:multiLevelType",
              attributes: {
                "w:val": "hybridMultilevel"
              }
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "0",
                "w:tplc": "0409000F"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "decimal"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%1."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "720",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "1",
                "w:tplc": "04090019",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerLetter"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%2."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "1440",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "2",
                "w:tplc": "0409001B",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerRoman"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%3."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "right"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2160",
                        "w:hanging": "180"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "3",
                "w:tplc": "0409000F",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "decimal"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%4."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2880",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "4",
                "w:tplc": "04090019",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerLetter"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%5."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "3600",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "5",
                "w:tplc": "0409001B",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerRoman"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%6."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "right"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "4320",
                        "w:hanging": "180"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "6",
                "w:tplc": "0409000F",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "decimal"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%7."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5040",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "7",
                "w:tplc": "04090019",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerLetter"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%8."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5760",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "8",
                "w:tplc": "0409001B",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerRoman"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%9."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "right"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "6480",
                        "w:hanging": "180"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          type: "element",
          name: "w:num",
          attributes: {
            "w:numId": "1",
            "w16cid:durableId": "100147962"
          },
          elements: [
            {
              type: "element",
              name: "w:abstractNumId",
              attributes: {
                "w:val": "0"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:num",
          attributes: {
            "w:numId": "2",
            "w16cid:durableId": "485517411"
          },
          elements: [
            {
              type: "element",
              name: "w:abstractNumId",
              attributes: {
                "w:val": "1"
              }
            }
          ]
        }
      ]
    }
  ]
};
const translateDocumentSection = (params) => {
  const { node: node2 } = params;
  const { attrs = {} } = node2;
  const childContent = translateChildNodes({ ...params, nodes: node2.content });
  const nodeElements = [
    {
      name: "w:sdtContent",
      elements: childContent
    }
  ];
  const exportedTag = JSON.stringify({
    type: "documentSection",
    description: attrs.description
  });
  const sdtPr = generateSdtPrTagForDocumentSection(attrs.id, attrs.title, exportedTag);
  const { isLocked } = attrs;
  if (isLocked) {
    sdtPr.elements.push({
      name: "w:lock",
      attributes: {
        "w:val": "sdtContentLocked"
      }
    });
  }
  nodeElements.unshift(sdtPr);
  return {
    name: "w:sdt",
    elements: nodeElements
  };
};
const generateSdtPrTagForDocumentSection = (id, title, tag) => {
  return {
    name: "w:sdtPr",
    elements: [
      {
        name: "w:id",
        attributes: {
          "w:val": id
        }
      },
      {
        name: "w:alias",
        attributes: {
          "w:val": title
        }
      },
      {
        name: "w:tag",
        attributes: {
          "w:val": tag
        }
      }
    ]
  };
};
function exportSchemaToJson(params) {
  const { type: type2 } = params.node || {};
  const router = {
    doc: translateDocumentNode,
    body: translateBodyNode,
    heading: translateHeadingNode,
    paragraph: translateParagraphNode,
    text: translateTextNode,
    bulletList: translateList,
    orderedList: translateList,
    lineBreak: translateLineBreak,
    table: translateTable,
    tableRow: translateTableRow,
    tableCell: translateTableCell,
    bookmarkStart: translateBookmarkStart,
    fieldAnnotation: translateFieldAnnotation,
    tab: translateTab,
    image: translateImageNode,
    hardBreak: translateHardBreak,
    commentRangeStart: () => translateCommentNode(params, "Start"),
    commentRangeEnd: () => translateCommentNode(params, "End"),
    commentReference: () => null,
    shapeContainer: translateShapeContainer,
    shapeTextbox: translateShapeTextbox,
    contentBlock: translateContentBlock,
    structuredContent: translateStructuredContent,
    structuredContentBlock: translateStructuredContent,
    documentSection: translateDocumentSection,
    "page-number": translatePageNumberNode,
    "total-page-number": translateTotalPageNumberNode
  };
  if (!router[type2]) {
    console.error("No translation function found for node type:", type2);
    return null;
  }
  return router[type2](params);
}
function translateBodyNode(params) {
  let sectPr = params.bodyNode?.elements.find((n) => n.name === "w:sectPr") || {};
  if (params.converter) {
    const hasHeader = sectPr?.elements?.some((n) => n.name === "w:headerReference");
    const hasDefaultHeader = params.converter.headerIds?.default;
    if (!hasHeader && hasDefaultHeader && !params.editor.options.isHeaderOrFooter) {
      const defaultHeader = generateDefaultHeaderFooter("header", params.converter.headerIds?.default);
      sectPr.elements.push(defaultHeader);
    }
    const hasFooter = sectPr?.elements?.some((n) => n.name === "w:footerReference");
    const hasDefaultFooter = params.converter.footerIds?.default;
    if (!hasFooter && hasDefaultFooter && !params.editor.options.isHeaderOrFooter) {
      const defaultFooter = generateDefaultHeaderFooter("footer", params.converter.footerIds?.default);
      sectPr.elements.push(defaultFooter);
    }
    const newMargins = params.converter.pageStyles.pageMargins;
    const sectPrMargins = sectPr.elements.find((n) => n.name === "w:pgMar");
    const { attributes } = sectPrMargins;
    Object.entries(newMargins).forEach(([key, value]) => {
      const convertedValue = inchesToTwips(value);
      attributes[`w:${key}`] = convertedValue;
    });
    sectPrMargins.attributes = attributes;
  }
  const elements = translateChildNodes(params);
  if (params.isHeaderFooter) {
    return {
      name: "w:body",
      elements: [...elements]
    };
  }
  return {
    name: "w:body",
    elements: [...elements, sectPr]
  };
}
const generateDefaultHeaderFooter = (type2, id) => {
  return {
    type: "element",
    name: `w:${type2}Reference`,
    attributes: {
      "w:type": "default",
      "r:id": id
    }
  };
};
function translateHeadingNode(params) {
  const { node: node2 } = params;
  const { level = 1, ...otherAttrs } = node2.attrs;
  const paragraphNode = {
    type: "paragraph",
    content: node2.content,
    attrs: {
      ...otherAttrs,
      styleId: `Heading${level}`
      // Maps to Heading1, Heading2, etc. in Word
    }
  };
  return translateParagraphNode({ ...params, node: paragraphNode });
}
function translateParagraphNode(params) {
  const elements = translateChildNodes(params);
  const htmlAnnotationChild = elements.find((element) => element.name === "htmlAnnotation");
  if (htmlAnnotationChild) {
    return htmlAnnotationChild.elements;
  }
  const pPr = generateParagraphProperties(params.node);
  if (pPr) elements.unshift(pPr);
  let attributes = {};
  if (params.node.attrs?.rsidRDefault) {
    attributes["w:rsidRDefault"] = params.node.attrs.rsidRDefault;
  }
  const result = {
    name: "w:p",
    elements,
    attributes
  };
  return result;
}
function normalizeLineHeight(value) {
  if (typeof value === "string" && value.trim().endsWith("%")) {
    const parsed2 = parseFloat(value);
    return Number.isFinite(parsed2) ? parsed2 / 100 : null;
  }
  const parsed = parseFloat(value);
  return Number.isFinite(parsed) ? parsed : null;
}
function generateParagraphProperties(node2) {
  const { attrs = {} } = node2;
  const pPrElements = [];
  const { styleId } = attrs;
  if (styleId) pPrElements.push({ name: "w:pStyle", attributes: { "w:val": styleId } });
  const { spacing, indent, textAlign, textIndent, lineHeight, marksAttrs, keepLines, keepNext, dropcap } = attrs;
  if (spacing) {
    const { lineSpaceBefore, lineSpaceAfter, lineRule } = spacing;
    const attributes = {};
    if (lineSpaceBefore >= 0) attributes["w:before"] = pixelsToTwips(lineSpaceBefore);
    if (lineSpaceAfter >= 0) attributes["w:after"] = pixelsToTwips(lineSpaceAfter);
    const normalized = normalizeLineHeight(lineHeight);
    if (normalized !== null) {
      if (lineRule === "exact") {
        attributes["w:line"] = ptToTwips(normalized);
      } else {
        attributes["w:line"] = linesToTwips(normalized);
      }
    }
    attributes["w:lineRule"] = lineRule || "auto";
    const spacingElement = {
      name: "w:spacing",
      attributes
    };
    pPrElements.push(spacingElement);
  }
  if (lineHeight && !spacing) {
    const spacingElement = {
      name: "w:spacing",
      attributes: {
        "w:line": linesToTwips(lineHeight)
      }
    };
    pPrElements.push(spacingElement);
  }
  if (indent && Object.values(indent).some((v2) => v2 !== 0)) {
    const { left, right, firstLine, hanging } = indent;
    const attributes = {};
    if (left || left === 0) attributes["w:left"] = pixelsToTwips(left);
    if (right || right === 0) attributes["w:right"] = pixelsToTwips(right);
    if (firstLine || firstLine === 0) attributes["w:firstLine"] = pixelsToTwips(firstLine);
    if (hanging || hanging === 0) attributes["w:hanging"] = pixelsToTwips(hanging);
    if (textIndent && !attributes["w:left"]) {
      attributes["w:left"] = getTextIndentExportValue(textIndent);
    }
    const indentElement = {
      name: "w:ind",
      attributes
    };
    pPrElements.push(indentElement);
  } else if (textIndent && textIndent !== "0in") {
    const indentElement = {
      name: "w:ind",
      attributes: {
        "w:left": getTextIndentExportValue(textIndent)
      }
    };
    pPrElements.push(indentElement);
  }
  if (textAlign) {
    const textAlignElement = {
      name: "w:jc",
      attributes: { "w:val": textAlign === "justify" ? "both" : textAlign }
    };
    pPrElements.push(textAlignElement);
  }
  if (marksAttrs) {
    const outputMarks = processOutputMarks(marksAttrs);
    const rPrElement = generateRunProps(outputMarks);
    pPrElements.push(rPrElement);
  }
  if (keepLines) {
    pPrElements.push({
      name: "w:keepLines",
      attributes: { "w:val": keepLines }
    });
  }
  if (keepNext) {
    pPrElements.push({
      name: "w:keepNext",
      attributes: { "w:val": keepNext }
    });
  }
  if (dropcap) {
    pPrElements.push({
      name: "w:framePr",
      attributes: {
        "w:dropCap": dropcap.type,
        "w:lines": dropcap.lines,
        "w:wrap": dropcap.wrap,
        "w:vAnchor": dropcap.vAnchor,
        "w:hAnchor": dropcap.hAnchor
      }
    });
  }
  const sectPr = node2.attrs?.paragraphProperties?.sectPr;
  if (sectPr) {
    pPrElements.push(sectPr);
  }
  const { tabStops } = attrs;
  if (tabStops && tabStops.length > 0) {
    const tabElements = tabStops.map((tab) => {
      const tabAttributes = {
        "w:val": tab.val || "start",
        "w:pos": pixelsToTwips(tab.pos).toString()
      };
      if (tab.leader) {
        tabAttributes["w:leader"] = tab.leader;
      }
      return {
        name: "w:tab",
        attributes: tabAttributes
      };
    });
    pPrElements.push({
      name: "w:tabs",
      elements: tabElements
    });
  }
  const numPr = node2.attrs?.paragraphProperties?.elements?.find((n) => n.name === "w:numPr");
  const hasNumPr = pPrElements.some((n) => n.name === "w:numPr");
  if (numPr && !hasNumPr) pPrElements.push(numPr);
  if (!pPrElements.length) return null;
  return {
    name: "w:pPr",
    elements: pPrElements
  };
}
function translateDocumentNode(params) {
  const bodyNode = {
    type: "body",
    content: params.node.content
  };
  const translatedBodyNode = exportSchemaToJson({ ...params, node: bodyNode });
  const node2 = {
    name: "w:document",
    elements: [translatedBodyNode],
    attributes: DEFAULT_DOCX_DEFS
  };
  return [node2, params];
}
function getTextNodeForExport(text, marks, params) {
  const hasLeadingOrTrailingSpace = /^\s|\s$/.test(text);
  const space = hasLeadingOrTrailingSpace ? "preserve" : null;
  const nodeAttrs = space ? { "xml:space": space } : null;
  const textNodes = [];
  const outputMarks = processOutputMarks(marks);
  textNodes.push({
    name: "w:t",
    elements: [{ text, type: "text" }],
    attributes: nodeAttrs
  });
  if (params) {
    const { editor } = params;
    const customMarks = editor.extensionService.extensions.filter((e) => e.isExternal === true);
    marks.forEach((mark) => {
      const isCustomMark = customMarks.some((customMark) => {
        const customMarkName = customMark.name;
        return mark.type === customMarkName;
      });
      if (!isCustomMark) return;
      let attrsString = "";
      Object.entries(mark.attrs).forEach(([key, value]) => {
        if (value) {
          attrsString += `${key}=${value};`;
        }
      });
      if (isCustomMark) {
        textNodes.unshift({
          type: "element",
          name: "w:bookmarkStart",
          attributes: {
            "w:id": "5000",
            "w:name": mark.type + ";" + attrsString
          }
        });
        textNodes.push({
          type: "element",
          name: "w:bookmarkEnd",
          attributes: {
            "w:id": "5000"
          }
        });
      }
    });
  }
  return wrapTextInRun(textNodes, outputMarks);
}
function translateTextNode(params) {
  const { node: node2 } = params;
  const trackedMarks = [TrackInsertMarkName, TrackDeleteMarkName];
  const isTrackedNode = node2.marks?.some((m2) => trackedMarks.includes(m2.type));
  if (isTrackedNode) return translateTrackedNode(params);
  const isLinkNode = node2.marks?.some((m2) => m2.type === "link");
  if (isLinkNode) return translateLinkNode(params);
  const { text, marks = [] } = node2;
  return getTextNodeForExport(text, marks, params);
}
function createTrackStyleMark(marks) {
  const trackStyleMark = marks.find((mark) => mark.type === TrackFormatMarkName);
  if (trackStyleMark) {
    const markElement = {
      type: "element",
      name: "w:rPrChange",
      attributes: {
        "w:id": trackStyleMark.attrs.id,
        "w:author": trackStyleMark.attrs.author,
        "w:authorEmail": trackStyleMark.attrs.authorEmail,
        "w:date": trackStyleMark.attrs.date
      },
      elements: trackStyleMark.attrs.before.map((mark) => processOutputMarks([mark])).filter((r) => r !== void 0)
    };
    return markElement;
  }
  return void 0;
}
function translateTrackedNode(params) {
  const { node: node2 } = params;
  const marks = node2.marks;
  const trackingMarks = [TrackInsertMarkName, TrackDeleteMarkName, TrackFormatMarkName];
  const trackedMark = marks.find((m2) => trackingMarks.includes(m2.type));
  const isInsert = trackedMark.type === TrackInsertMarkName;
  const trackStyleMark = createTrackStyleMark(marks);
  node2.marks = marks.filter((m2) => !trackingMarks.includes(m2.type));
  if (trackStyleMark) {
    node2.marks.push(trackStyleMark);
  }
  const translatedTextNode = exportSchemaToJson({ ...params, node: node2 });
  if (!isInsert) {
    const textNode = translatedTextNode.elements.find((n) => n.name === "w:t");
    textNode.name = "w:delText";
  }
  const trackedNode = {
    name: isInsert ? "w:ins" : "w:del",
    type: "element",
    attributes: {
      "w:id": trackedMark.attrs.id,
      "w:author": trackedMark.attrs.author,
      "w:authorEmail": trackedMark.attrs.authorEmail,
      "w:date": trackedMark.attrs.date
    },
    elements: [translatedTextNode]
  };
  return trackedNode;
}
function wrapTextInRun(nodeOrNodes, marks) {
  let elements = [];
  if (Array.isArray(nodeOrNodes)) elements = nodeOrNodes;
  else elements = [nodeOrNodes];
  if (marks && marks.length) elements.unshift(generateRunProps(marks));
  return {
    name: "w:r",
    elements
  };
}
function generateRunProps(marks = []) {
  return {
    name: "w:rPr",
    elements: marks.filter((mark) => !!Object.keys(mark).length)
  };
}
function processOutputMarks(marks = []) {
  return marks.flatMap((mark) => {
    if (mark.type === "textStyle") {
      return Object.entries(mark.attrs).filter(([, value]) => value).map(([key]) => {
        const unwrappedMark = { type: key, attrs: mark.attrs };
        return translateMark(unwrappedMark);
      });
    } else {
      return translateMark(mark);
    }
  });
}
function translateLinkNode(params) {
  const { node: node2 } = params;
  const linkMark = node2.marks.find((m2) => m2.type === "link");
  const link = linkMark.attrs.href;
  let rId = linkMark.attrs.rId;
  if (!rId) {
    rId = addNewLinkRelationship(params, link);
  }
  node2.marks = node2.marks.filter((m2) => m2.type !== "link");
  const outputNode = exportSchemaToJson({ ...params, node: node2 });
  const contentNode = processLinkContentNode(outputNode);
  const newNode = {
    name: "w:hyperlink",
    type: "element",
    attributes: {
      "r:id": rId
    },
    elements: [contentNode]
  };
  return newNode;
}
function processLinkContentNode(node2) {
  if (!node2) return node2;
  const contentNode = carbonCopy(node2);
  if (!contentNode) return contentNode;
  const hyperlinkStyle = {
    name: "w:rStyle",
    attributes: { "w:val": "Hyperlink" }
  };
  const color = {
    name: "w:color",
    attributes: { "w:val": "467886" }
  };
  const underline = {
    name: "w:u",
    attributes: {
      "w:val": "none"
    }
  };
  if (contentNode.name === "w:r") {
    const runProps = contentNode.elements.find((el) => el.name === "w:rPr");
    if (runProps) {
      const foundColor = runProps.elements.find((el) => el.name === "w:color");
      const foundHyperlinkStyle = runProps.elements.find((el) => el.name === "w:rStyle");
      const underlineMark = runProps.elements.find((el) => el.name === "w:u");
      if (!foundColor) runProps.elements.unshift(color);
      if (!foundHyperlinkStyle) runProps.elements.unshift(hyperlinkStyle);
      if (!underlineMark) runProps.elements.unshift(underline);
    } else {
      const runProps2 = {
        name: "w:rPr",
        elements: [hyperlinkStyle, color]
      };
      contentNode.elements.unshift(runProps2);
    }
  }
  return contentNode;
}
function addNewLinkRelationship(params, link) {
  const newId = "rId" + generateDocxRandomId();
  if (!params.relationships || !Array.isArray(params.relationships)) {
    params.relationships = [];
  }
  params.relationships.push({
    type: "element",
    name: "Relationship",
    attributes: {
      Id: newId,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
      Target: link,
      TargetMode: "External"
    }
  });
  return newId;
}
function addNewImageRelationship(params, imagePath) {
  const newId = "rId" + generateDocxRandomId();
  const newRel = {
    type: "element",
    name: "Relationship",
    attributes: {
      Id: newId,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
      Target: imagePath
    }
  };
  params.relationships.push(newRel);
  return newId;
}
function translateList(params) {
  const { node: node2, editor } = params;
  const listItem = node2.content[0];
  const { numId, level } = listItem.attrs;
  const listType = node2.type.name;
  const listDef = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  if (!listDef) {
    ListHelpers.generateNewListDefinition({
      numId,
      listType,
      editor
    });
  }
  let numPrTag;
  if (numId !== void 0 && numId !== null) {
    numPrTag = generateNumPrTag(numId, level);
  }
  const collapsedParagraphNode = convertMultipleListItemsIntoSingleNode(listItem);
  let outputNode = exportSchemaToJson({ ...params, node: collapsedParagraphNode });
  if (Array.isArray(outputNode) && params.isFinalDoc) {
    const parsedElements = [];
    outputNode?.forEach((node3, index) => {
      if (node3?.elements) {
        const runs = node3.elements?.filter((n) => n.name === "w:r");
        parsedElements.push(...runs);
        if (node3.name === "w:p" && index < outputNode.length - 1) {
          parsedElements.push({
            name: "w:br"
          });
        }
      }
    });
    outputNode = {
      name: "w:p",
      elements: [{ name: "w:pPr", elements: [] }, ...parsedElements]
    };
  }
  let nodesToFlatten = [];
  const sdtNodes = outputNode.elements?.filter((n) => n.name === "w:sdt");
  if (sdtNodes && sdtNodes.length > 0) {
    nodesToFlatten = sdtNodes;
    nodesToFlatten?.forEach((sdtNode) => {
      const sdtContent = sdtNode.elements.find((n) => n.name === "w:sdtContent");
      const foundRun = sdtContent.elements?.find((el) => el.name === "w:r");
      if (sdtContent && sdtContent.elements && !foundRun) {
        const parsedElements = [];
        sdtContent.elements.forEach((element, index) => {
          if (element.name === "w:rPr" && element.elements?.length) {
            parsedElements.push(element);
          }
          const runs = element.elements?.filter((n) => n.name === "w:r");
          if (runs && runs.length) {
            parsedElements.push(...runs);
          }
          if (element.name === "w:p" && index < sdtContent.elements.length - 1) {
            parsedElements.push({
              name: "w:br"
            });
          }
        });
        sdtContent.elements = parsedElements;
      }
    });
  }
  const pPr = outputNode.elements?.find((n) => n.name === "w:pPr");
  if (pPr && pPr.elements && numPrTag) {
    pPr.elements.unshift(numPrTag);
  }
  const indentTag = restoreIndent(listItem.attrs.indent);
  indentTag && pPr?.elements?.push(indentTag);
  const runNode = outputNode.elements?.find((n) => n.name === "w:r");
  const rPr = runNode?.elements?.find((n) => n.name === "w:rPr");
  if (rPr) pPr.elements.push(rPr);
  if (listItem.attrs.numPrType !== "inline") {
    const numPrIndex = pPr?.elements?.findIndex((e) => e?.name === "w:numPr");
    if (numPrIndex !== -1) {
      pPr?.elements?.splice(numPrIndex, 1);
    }
  }
  return [outputNode];
}
const convertMultipleListItemsIntoSingleNode = (listItem) => {
  const { content } = listItem;
  if (!content || content.length === 0) {
    return null;
  }
  const firstParagraph = content[0];
  const collapsedParagraph = {
    ...firstParagraph,
    content: []
  };
  content.forEach((item, index) => {
    if (item.type === "paragraph") {
      if (index > 0) {
        collapsedParagraph.content.push({
          type: "lineBreak",
          attrs: {},
          content: []
        });
      }
      if (item.content && item.content.length > 0) {
        collapsedParagraph.content.push(...item.content);
      }
    } else {
      collapsedParagraph.content.push(item);
    }
  });
  return collapsedParagraph;
};
const restoreIndent = (indent) => {
  const attributes = {};
  if (!indent) indent = {};
  if (indent.left || indent.left === 0) attributes["w:left"] = pixelsToTwips(indent.left);
  if (indent.right || indent.right === 0) attributes["w:right"] = pixelsToTwips(indent.right);
  if (indent.firstLine || indent.firstLine === 0) attributes["w:firstLine"] = pixelsToTwips(indent.firstLine);
  if (indent.hanging || indent.hanging === 0) attributes["w:hanging"] = pixelsToTwips(indent.hanging);
  if (indent.leftChars || indent.leftChars === 0) attributes["w:leftChars"] = pixelsToTwips(indent.leftChars);
  if (!Object.keys(attributes).length) return;
  return {
    name: "w:ind",
    type: "element",
    attributes
  };
};
const generateNumPrTag = (numId, level) => {
  return {
    name: "w:numPr",
    type: "element",
    elements: [
      {
        name: "w:numId",
        type: "element",
        attributes: { "w:val": numId }
      },
      {
        name: "w:ilvl",
        type: "element",
        attributes: { "w:val": level }
      }
    ]
  };
};
function translateLineBreak(params) {
  const attributes = {};
  const { lineBreakType } = params.node?.attrs || {};
  if (lineBreakType) {
    attributes["w:type"] = lineBreakType;
  }
  return {
    name: "w:r",
    elements: [
      {
        name: "w:br",
        attributes
      }
    ],
    attributes
  };
}
function translateTable(params) {
  params.node = preProcessVerticalMergeCells(params.node, params);
  const elements = translateChildNodes(params);
  const tableProperties = generateTableProperties(params.node);
  const gridProperties = generateTableGrid(params.node, params);
  elements.unshift(tableProperties);
  elements.unshift(gridProperties);
  return {
    name: "w:tbl",
    elements
  };
}
function preProcessVerticalMergeCells(table, { editorSchema }) {
  const { content } = table;
  for (let rowIndex = 0; rowIndex < content.length; rowIndex++) {
    const row = content[rowIndex];
    if (!row.content) continue;
    for (let cellIndex = 0; cellIndex < row.content?.length; cellIndex++) {
      const cell = row.content[cellIndex];
      if (!cell) continue;
      const { attrs } = cell;
      if (attrs.rowspan > 1) {
        const rowsToChange = content.slice(rowIndex + 1, rowIndex + attrs.rowspan);
        const mergedCell = {
          type: cell.type,
          content: [
            // cells must end with a paragraph
            editorSchema.nodes.paragraph.createAndFill().toJSON()
          ],
          attrs: {
            ...cell.attrs,
            // reset colspan and rowspan
            colspan: null,
            rowspan: null,
            // to add vMerge
            continueMerge: true
          }
        };
        rowsToChange.forEach((rowToChange) => {
          rowToChange.content.splice(cellIndex, 0, mergedCell);
        });
      }
    }
  }
  return table;
}
function translateTab(params) {
  const { marks = [] } = params.node;
  const outputMarks = processOutputMarks(marks);
  const tabNode = {
    name: "w:tab"
  };
  return wrapTextInRun(tabNode, outputMarks);
}
function generateTableProperties(node2) {
  const elements = [];
  const { attrs } = node2;
  const { tableWidth, tableStyleId, borders, tableIndent, tableLayout, tableCellSpacing, justification } = attrs;
  if (tableStyleId) {
    const tableStyleElement = {
      name: "w:tblStyle",
      attributes: { "w:val": tableStyleId }
    };
    elements.push(tableStyleElement);
  }
  if (borders) {
    const borderElement = generateTableBorders(node2);
    elements.push(borderElement);
  }
  if (tableIndent) {
    const { width, type: type2 } = tableIndent;
    const tableIndentElement = {
      name: "w:tblInd",
      attributes: { "w:w": pixelsToTwips(width), "w:type": type2 }
    };
    elements.push(tableIndentElement);
  }
  if (tableLayout) {
    const tableLayoutElement = {
      name: "w:tblLayout",
      attributes: { "w:type": tableLayout }
    };
    elements.push(tableLayoutElement);
  }
  if (tableWidth && tableWidth.width) {
    const tableWidthElement = {
      name: "w:tblW",
      attributes: { "w:w": pixelsToTwips(tableWidth.width), "w:type": tableWidth.type }
    };
    elements.push(tableWidthElement);
  }
  if (tableCellSpacing) {
    elements.push({
      name: "w:tblCellSpacing",
      attributes: {
        "w:w": tableCellSpacing.w,
        "w:type": tableCellSpacing.type
      }
    });
  }
  if (justification) {
    const justificationElement = {
      name: "w:jc",
      attributes: { "w:val": justification }
    };
    elements.push(justificationElement);
  }
  return {
    name: "w:tblPr",
    elements
  };
}
function generateTableBorders(node2) {
  const { borders } = node2.attrs;
  const elements = [];
  if (!borders) return;
  const borderTypes = ["top", "bottom", "left", "right", "insideH", "insideV"];
  borderTypes.forEach((type2) => {
    const border = borders[type2];
    if (!border) return;
    let attributes = {};
    if (!Object.keys(border).length || !border.size) {
      attributes = {
        "w:val": "nil"
      };
    } else {
      attributes = {
        "w:val": "single",
        "w:sz": pixelsToEightPoints(border.size),
        "w:space": border.space || 0,
        "w:color": border?.color?.substring(1) || "000000"
      };
    }
    const borderElement = {
      name: `w:${type2}`,
      attributes
    };
    elements.push(borderElement);
  });
  return {
    name: "w:tblBorders",
    elements
  };
}
function generateTableGrid(node2, params) {
  const { editorSchema } = params;
  let colgroup = [];
  try {
    const pmNode = editorSchema.nodeFromJSON(node2);
    const cellMinWidth = 10;
    const { colgroupValues } = createColGroup(pmNode, cellMinWidth);
    colgroup = colgroupValues;
  } catch {
    colgroup = [];
  }
  const elements = [];
  colgroup?.forEach((width) => {
    elements.push({
      name: "w:gridCol",
      attributes: { "w:w": pixelsToTwips(width) }
    });
  });
  return {
    name: "w:tblGrid",
    elements
  };
}
function translateTableRow(params) {
  const elements = translateChildNodes(params);
  const tableRowProperties = generateTableRowProperties(params.node);
  if (tableRowProperties.elements.length) elements.unshift(tableRowProperties);
  return {
    name: "w:tr",
    elements
  };
}
function generateTableRowProperties(node2) {
  const { attrs } = node2;
  const elements = [];
  const { rowHeight, rowHeightType } = attrs;
  if (rowHeight) {
    const attributes = { "w:val": pixelsToTwips(rowHeight) };
    if (rowHeightType) attributes["w:hRule"] = rowHeightType;
    const rowHeightElement = {
      name: "w:trHeight",
      attributes
    };
    elements.push(rowHeightElement);
  }
  return {
    name: "w:trPr",
    elements
  };
}
function translateTableCell(params) {
  const elements = translateChildNodes({
    ...params,
    tableCell: params.node
  });
  const cellProps = generateTableCellProperties(params.node);
  elements.unshift(cellProps);
  return {
    name: "w:tc",
    elements
  };
}
function generateTableCellProperties(node2) {
  const elements = [];
  const { attrs } = node2;
  const { colwidth = [], cellWidthType = "dxa", background = {}, colspan, rowspan, widthUnit } = attrs;
  const colwidthSum = colwidth.reduce((acc, curr) => acc + curr, 0);
  const cellWidthElement = {
    name: "w:tcW",
    attributes: {
      "w:w": widthUnit === "px" ? pixelsToTwips(colwidthSum) : inchesToTwips(colwidthSum),
      "w:type": cellWidthType
    }
  };
  elements.push(cellWidthElement);
  if (colspan) {
    const gridSpanElement = {
      name: "w:gridSpan",
      attributes: { "w:val": `${colspan}` }
    };
    elements.push(gridSpanElement);
  }
  const { color } = background || {};
  if (color) {
    const cellBgElement = {
      name: "w:shd",
      attributes: { "w:fill": color }
    };
    elements.push(cellBgElement);
  }
  const { cellMargins } = attrs;
  if (cellMargins) {
    const cellMarginsElement = {
      name: "w:tcMar",
      elements: generateCellMargins(cellMargins)
    };
    elements.push(cellMarginsElement);
  }
  const { verticalAlign } = attrs;
  if (verticalAlign) {
    const vertAlignElement = {
      name: "w:vAlign",
      attributes: { "w:val": verticalAlign }
    };
    elements.push(vertAlignElement);
  }
  if (rowspan && rowspan > 1) {
    const vMergeElement = {
      name: "w:vMerge",
      type: "element",
      attributes: { "w:val": "restart" }
    };
    elements.push(vMergeElement);
  } else if (attrs.continueMerge) {
    const vMergeElement = {
      name: "w:vMerge",
      type: "element"
    };
    elements.push(vMergeElement);
  }
  const { borders = {} } = attrs;
  if (!!borders && Object.keys(borders).length) {
    const cellBordersElement = {
      name: "w:tcBorders",
      elements: Object.entries(borders).map(([key, value]) => {
        if (!value.size || value.val === "none") {
          return {
            name: `w:${key}`,
            attributes: {
              "w:val": "nil"
            }
          };
        }
        return {
          name: `w:${key}`,
          attributes: {
            "w:val": "single",
            "w:color": value.color ? value.color.substring(1) : "auto",
            "w:sz": pixelsToEightPoints(value.size),
            "w:space": value.space || 0
          }
        };
      })
    };
    elements.push(cellBordersElement);
  }
  return {
    name: "w:tcPr",
    elements
  };
}
function generateCellMargins(cellMargins) {
  const elements = [];
  const { top, right, bottom, left } = cellMargins;
  if (top != null) elements.push({ name: "w:top", attributes: { "w:w": pixelsToTwips(top) } });
  if (right != null) elements.push({ name: "w:right", attributes: { "w:w": pixelsToTwips(right) } });
  if (bottom != null) elements.push({ name: "w:bottom", attributes: { "w:w": pixelsToTwips(bottom) } });
  if (left != null) elements.push({ name: "w:left", attributes: { "w:w": pixelsToTwips(left) } });
  return elements;
}
function translateBookmarkStart(params) {
  const bookmarkStartNode = {
    name: "w:bookmarkStart",
    attributes: {
      "w:id": params.node.attrs.id,
      "w:name": params.node.attrs.name
    }
  };
  const bookmarkEndNode = {
    name: "w:bookmarkEnd",
    attributes: {
      "w:id": params.node.attrs.id
    }
  };
  return [bookmarkStartNode, bookmarkEndNode];
}
function translateMark(mark) {
  const xmlMark = SuperConverter.markTypes.find((m2) => m2.type === mark.type);
  if (!xmlMark) {
    return {};
  }
  const markElement = { name: xmlMark.name, attributes: {} };
  const { attrs } = mark;
  let value;
  switch (mark.type) {
    case "bold":
      if (attrs?.value) {
        markElement.attributes["w:val"] = attrs.value;
      } else {
        delete markElement.attributes;
      }
      markElement.type = "element";
      break;
    case "italic":
      delete markElement.attributes;
      markElement.type = "element";
      break;
    case "underline":
      markElement.type = "element";
      markElement.attributes["w:val"] = attrs.underlineType;
      break;
    // Text style cases
    case "fontSize":
      value = attrs.fontSize;
      markElement.attributes["w:val"] = value.slice(0, -2) * 2;
      break;
    case "fontFamily":
      value = attrs.fontFamily;
      ["w:ascii", "w:eastAsia", "w:hAnsi", "w:cs"].forEach((attr) => {
        const parsedValue = value.split(", ");
        markElement.attributes[attr] = parsedValue[0] ? parsedValue[0] : value;
      });
      break;
    // Add ability to get run styleIds from textStyle marks and inject to run properties in word
    case "styleId":
      markElement.name = "w:rStyle";
      markElement.attributes["w:val"] = attrs.styleId;
      break;
    case "color":
      let processedColor = attrs.color.replace(/^#/, "").replace(/;$/, "");
      if (processedColor.startsWith("rgb")) {
        processedColor = rgbToHex(processedColor);
      }
      markElement.attributes["w:val"] = processedColor;
      break;
    case "textAlign":
      markElement.attributes["w:val"] = attrs.textAlign;
      break;
    case "textIndent":
      markElement.attributes["w:firstline"] = inchesToTwips(attrs.textIndent);
      break;
    case "textTransform":
      if (attrs?.textTransform === "none") {
        markElement.attributes["w:val"] = "0";
      } else {
        delete markElement.attributes;
      }
      markElement.type = "element";
      break;
    case "lineHeight":
      markElement.attributes["w:line"] = linesToTwips(attrs.lineHeight);
      break;
    case "highlight":
      markElement.attributes["w:fill"] = attrs.color?.substring(1);
      markElement.attributes["w:color"] = "auto";
      markElement.attributes["w:val"] = "clear";
      markElement.name = "w:shd";
      break;
  }
  return markElement;
}
function getPngDimensions(base64) {
  if (!base64) return {};
  const type2 = base64.split(";")[0].split("/")[1];
  if (!base64 || type2 !== "png") {
    return {
      originalWidth: void 0,
      originalHeight: void 0
    };
  }
  let header = base64.split(",")[1].slice(0, 50);
  let uint8 = Uint8Array.from(atob(header), (c) => c.charCodeAt(0));
  let dataView = new DataView(uint8.buffer, 0, 28);
  return {
    originalWidth: dataView.getInt32(16),
    originalHeight: dataView.getInt32(20)
  };
}
function getScaledSize(originalWidth, originalHeight, maxWidth, maxHeight) {
  let scaledWidth = originalWidth;
  let scaledHeight = originalHeight;
  let ratio = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);
  scaledWidth = Math.round(scaledWidth * ratio);
  scaledHeight = Math.round(scaledHeight * ratio);
  return { scaledWidth, scaledHeight };
}
function translateImageNode(params, imageSize) {
  const {
    node: { attrs = {} },
    tableCell
  } = params;
  let imageId = attrs.rId;
  const src = attrs.src || attrs.imageSrc;
  const { originalWidth, originalHeight } = getPngDimensions(src);
  const imageName = params.node.type === "image" ? src?.split("word/media/")[1] : attrs.fieldId?.replace("-", "_");
  let size = attrs.size ? {
    w: pixelsToEmu(attrs.size.width),
    h: pixelsToEmu(attrs.size.height)
  } : imageSize;
  if (originalWidth && originalHeight) {
    const boxWidthPx = emuToPixels(size.w);
    const boxHeightPx = emuToPixels(size.h);
    const { scaledWidth, scaledHeight } = getScaledSize(originalWidth, originalHeight, boxWidthPx, boxHeightPx);
    size = {
      w: pixelsToEmu(scaledWidth),
      h: pixelsToEmu(scaledHeight)
    };
  }
  if (tableCell) {
    const colwidthSum = tableCell.attrs.colwidth.reduce((acc, curr) => acc + curr, 0);
    const leftMargin = tableCell.attrs.cellMargins?.left || 8;
    const rightMargin = tableCell.attrs.cellMargins?.right || 8;
    const maxWidthEmu = pixelsToEmu(colwidthSum - (leftMargin + rightMargin));
    const { width: w2, height: h2 } = resizeKeepAspectRatio(size.w, size.h, maxWidthEmu);
    if (w2 && h2) size = { w: w2, h: h2 };
  }
  if (params.node.type === "image" && !imageId) {
    const path = src?.split("word/")[1];
    imageId = addNewImageRelationship(params, path);
  } else if (params.node.type === "fieldAnnotation" && !imageId) {
    const type2 = src?.split(";")[0].split("/")[1];
    if (!type2) {
      return prepareTextAnnotation(params);
    }
    const imageUrl = `media/${imageName}_${attrs.hash}.${type2}`;
    imageId = addNewImageRelationship(params, imageUrl);
    params.media[`${imageName}_${attrs.hash}.${type2}`] = src;
  }
  let inlineAttrs = attrs.originalPadding || {
    distT: 0,
    distB: 0,
    distL: 0,
    distR: 0
  };
  const anchorElements = [];
  let wrapProp = [];
  if (attrs.isAnchor) {
    inlineAttrs = {
      ...inlineAttrs,
      simplePos: attrs.originalAttributes?.simplePos,
      relativeHeight: 1,
      behindDoc: attrs.originalAttributes?.behindDoc,
      locked: attrs.originalAttributes?.locked,
      layoutInCell: attrs.originalAttributes?.layoutInCell,
      allowOverlap: attrs.originalAttributes?.allowOverlap
    };
    if (attrs.simplePos) {
      anchorElements.push({
        name: "wp:simplePos",
        attributes: {
          x: 0,
          y: 0
        }
      });
    }
    if (attrs.anchorData) {
      anchorElements.push({
        name: "wp:positionH",
        attributes: {
          relativeFrom: attrs.anchorData.hRelativeFrom
        },
        ...attrs.marginOffset.left !== void 0 && {
          elements: [
            {
              name: "wp:posOffset",
              elements: [
                {
                  type: "text",
                  text: pixelsToEmu(attrs.marginOffset.left).toString()
                }
              ]
            }
          ]
        },
        ...attrs.anchorData.alignH && {
          elements: [
            {
              name: "wp:align",
              elements: [
                {
                  type: "text",
                  text: attrs.anchorData.alignH
                }
              ]
            }
          ]
        }
      });
      anchorElements.push({
        name: "wp:positionV",
        attributes: {
          relativeFrom: attrs.anchorData.vRelativeFrom
        },
        ...attrs.marginOffset.top !== void 0 && {
          elements: [
            {
              name: "wp:posOffset",
              elements: [
                {
                  type: "text",
                  text: pixelsToEmu(attrs.marginOffset.top).toString()
                }
              ]
            }
          ]
        },
        ...attrs.anchorData.alignV && {
          elements: [
            {
              name: "wp:align",
              elements: [
                {
                  type: "text",
                  text: attrs.anchorData.alignV
                }
              ]
            }
          ]
        }
      });
    }
    if (attrs.wrapText) {
      wrapProp.push({
        name: "wp:wrapSquare",
        attributes: {
          wrapText: attrs.wrapText
        }
      });
    }
    if (attrs.wrapTopAndBottom) {
      wrapProp.push({
        name: "wp:wrapTopAndBottom"
      });
    }
    if (attrs.isAnchor && !wrapProp.length) {
      wrapProp.push({
        name: "wp:wrapNone"
      });
    }
  }
  const drawingXmlns = "http://schemas.openxmlformats.org/drawingml/2006/main";
  const pictureXmlns = "http://schemas.openxmlformats.org/drawingml/2006/picture";
  const textNode = wrapTextInRun(
    {
      name: "w:drawing",
      elements: [
        {
          name: attrs.isAnchor ? "wp:anchor" : "wp:inline",
          attributes: inlineAttrs,
          elements: [
            ...anchorElements,
            {
              name: "wp:extent",
              attributes: {
                cx: size.w,
                cy: size.h
              }
            },
            {
              name: "wp:effectExtent",
              attributes: {
                l: 0,
                t: 0,
                r: 0,
                b: 0
              }
            },
            ...wrapProp,
            {
              name: "wp:docPr",
              attributes: {
                id: attrs.id || 0,
                name: attrs.alt || `Picture ${imageName}`
              }
            },
            {
              name: "wp:cNvGraphicFramePr",
              elements: [
                {
                  name: "a:graphicFrameLocks",
                  attributes: {
                    "xmlns:a": drawingXmlns,
                    noChangeAspect: 1
                  }
                }
              ]
            },
            {
              name: "a:graphic",
              attributes: { "xmlns:a": drawingXmlns },
              elements: [
                {
                  name: "a:graphicData",
                  attributes: { uri: pictureXmlns },
                  elements: [
                    {
                      name: "pic:pic",
                      attributes: { "xmlns:pic": pictureXmlns },
                      elements: [
                        {
                          name: "pic:nvPicPr",
                          elements: [
                            {
                              name: "pic:cNvPr",
                              attributes: {
                                id: attrs.id || 0,
                                name: attrs.title || `Picture ${imageName}`
                              }
                            },
                            {
                              name: "pic:cNvPicPr",
                              elements: [
                                {
                                  name: "a:picLocks",
                                  attributes: {
                                    noChangeAspect: 1,
                                    noChangeArrowheads: 1
                                  }
                                }
                              ]
                            }
                          ]
                        },
                        {
                          name: "pic:blipFill",
                          elements: [
                            {
                              name: "a:blip",
                              attributes: {
                                "r:embed": imageId
                              }
                            },
                            {
                              name: "a:stretch",
                              elements: [{ name: "a:fillRect" }]
                            }
                          ]
                        },
                        {
                          name: "pic:spPr",
                          attributes: {
                            bwMode: "auto"
                          },
                          elements: [
                            {
                              name: "a:xfrm",
                              elements: [
                                {
                                  name: "a:ext",
                                  attributes: {
                                    cx: size.w,
                                    cy: size.h
                                  }
                                },
                                {
                                  name: "a:off",
                                  attributes: {
                                    x: 0,
                                    y: 0
                                  }
                                }
                              ]
                            },
                            {
                              name: "a:prstGeom",
                              attributes: { prst: "rect" },
                              elements: [{ name: "a:avLst" }]
                            },
                            {
                              name: "a:noFill"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    []
  );
  return textNode;
}
function prepareTextAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] }
  } = params;
  const marksFromAttrs = translateFieldAttrsToMarks(attrs);
  return getTextNodeForExport(attrs.displayLabel, [...marks, ...marksFromAttrs], params);
}
function prepareCheckboxAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] }
  } = params;
  const content = he$1.decode(attrs.displayLabel);
  return getTextNodeForExport(content, marks, params);
}
function prepareHtmlAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] },
    editorSchema
  } = params;
  let html = attrs.rawHtml || attrs.displayLabel;
  const paragraphHtmlContainer = sanitizeHtml(html);
  const marksFromAttrs = translateFieldAttrsToMarks(attrs);
  const allMarks = [...marks, ...marksFromAttrs];
  let state2 = EditorState.create({
    doc: DOMParser$1.fromSchema(editorSchema).parse(paragraphHtmlContainer)
  });
  if (allMarks.length) {
    state2 = applyMarksToHtmlAnnotation(state2, allMarks);
  }
  const htmlAnnotationNode = state2.doc.toJSON();
  const listTypes = ["bulletList", "orderedList"];
  const { editor } = params;
  const seenLists = /* @__PURE__ */ new Map();
  state2.doc.descendants((node2) => {
    if (listTypes.includes(node2.type.name)) {
      const listItem = node2.firstChild;
      const { attrs: attrs2 } = listItem;
      const { level, numId } = attrs2;
      if (!seenLists.has(numId)) {
        const newNumId = ListHelpers.changeNumIdSameAbstract(numId, level, node2.type.name, editor);
        listItem.attrs.numId = newNumId;
        seenLists.set(numId, newNumId);
      } else {
        const newNumId = seenLists.get(numId);
        listItem.attrs.numId = newNumId;
      }
    }
  });
  const elements = translateChildNodes({
    ...params,
    node: htmlAnnotationNode
  });
  return {
    name: "htmlAnnotation",
    elements
  };
}
function prepareImageAnnotation(params, imageSize) {
  return translateImageNode(params, imageSize);
}
function prepareUrlAnnotation(params) {
  const {
    node: { attrs = {}, marks = [] }
  } = params;
  const newId = addNewLinkRelationship(params, attrs.linkUrl);
  const linkTextNode = getTextNodeForExport(attrs.linkUrl, marks, params);
  const contentNode = processLinkContentNode(linkTextNode);
  return {
    name: "w:hyperlink",
    type: "element",
    attributes: {
      "r:id": newId,
      "w:history": 1
    },
    elements: [contentNode]
  };
}
function getTranslationByAnnotationType(annotationType, annotationFieldType) {
  if (annotationType === "text" && annotationFieldType === "FILEUPLOADER") {
    return null;
  }
  const imageEmuSize = {
    w: 4286250,
    h: 4286250
  };
  const signatureEmuSize = {
    w: 99e4,
    h: 495e3
  };
  const dictionary = {
    text: prepareTextAnnotation,
    image: (params) => prepareImageAnnotation(params, imageEmuSize),
    signature: (params) => prepareImageAnnotation(params, signatureEmuSize),
    checkbox: prepareCheckboxAnnotation,
    html: prepareHtmlAnnotation,
    link: prepareUrlAnnotation
  };
  return dictionary[annotationType];
}
const translateFieldAttrsToMarks = (attrs = {}) => {
  const { fontFamily, fontSize, bold, underline, italic, textColor, textHighlight } = attrs;
  const marks = [];
  if (fontFamily) marks.push({ type: "fontFamily", attrs: { fontFamily } });
  if (fontSize) marks.push({ type: "fontSize", attrs: { fontSize } });
  if (bold) marks.push({ type: "bold", attrs: {} });
  if (underline) marks.push({ type: "underline", attrs: {} });
  if (italic) marks.push({ type: "italic", attrs: {} });
  if (textColor) marks.push({ type: "color", attrs: { color: textColor } });
  if (textHighlight) marks.push({ type: "highlight", attrs: { color: textHighlight } });
  return marks;
};
function translateFieldAnnotation(params) {
  const { node: node2, isFinalDoc, fieldsHighlightColor } = params;
  const { attrs = {} } = node2;
  const annotationHandler = getTranslationByAnnotationType(attrs.type, attrs.fieldType);
  if (!annotationHandler) return {};
  let processedNode;
  let sdtContentElements;
  if ((attrs.type === "image" || attrs.type === "signature") && !attrs.hash) {
    attrs.hash = generateDocxRandomId(4);
  }
  if (isFinalDoc) {
    return annotationHandler(params);
  } else {
    processedNode = annotationHandler(params);
    sdtContentElements = [processedNode];
    if (attrs.type === "html") {
      sdtContentElements = [...processedNode.elements];
    }
  }
  sdtContentElements = [...sdtContentElements];
  const fieldBackgroundTag = getFieldHighlightJson(fieldsHighlightColor);
  if (fieldBackgroundTag) {
    sdtContentElements.unshift(fieldBackgroundTag);
  }
  const annotationAttrs = {
    displayLabel: attrs.displayLabel,
    defaultDisplayLabel: attrs.defaultDisplayLabel,
    fieldId: attrs.fieldId,
    fieldType: attrs.fieldType,
    fieldTypeShort: attrs.type,
    fieldColor: attrs.fieldColor,
    fieldMultipleImage: attrs.multipleImage,
    fieldFontFamily: attrs.fontFamily,
    fieldFontSize: attrs.fontSize,
    fieldTextColor: attrs.textColor,
    fieldTextHighlight: attrs.textHighlight,
    hash: attrs.hash
  };
  const annotationAttrsJson = JSON.stringify(annotationAttrs);
  const result = {
    name: "w:sdt",
    elements: [
      {
        name: "w:sdtPr",
        elements: [
          { name: "w:tag", attributes: { "w:val": annotationAttrsJson } },
          { name: "w:alias", attributes: { "w:val": attrs.displayLabel } }
        ]
      },
      {
        name: "w:sdtContent",
        elements: sdtContentElements
      }
    ]
  };
  return result;
}
function translateHardBreak(params) {
  const { node: node2 = {} } = params;
  const { attrs = {} } = node2;
  const { pageBreakSource } = attrs;
  if (pageBreakSource === "sectPr") return null;
  return {
    name: "w:r",
    elements: [
      {
        name: "w:br",
        type: "element",
        attributes: { "w:type": "page" }
      }
    ]
  };
}
function translateShapeContainer(params) {
  const { node: node2 } = params;
  const elements = translateChildNodes(params);
  const shape = {
    name: "v:shape",
    attributes: {
      ...node2.attrs.attributes,
      fillcolor: node2.attrs.fillcolor
    },
    elements: [
      ...elements,
      ...node2.attrs.wrapAttributes ? [
        {
          name: "w10:wrap",
          attributes: { ...node2.attrs.wrapAttributes }
        }
      ] : []
    ]
  };
  const pict = {
    name: "w:pict",
    attributes: {
      "w14:anchorId": Math.floor(Math.random() * 4294967295).toString()
    },
    elements: [shape]
  };
  const par = {
    name: "w:p",
    elements: [wrapTextInRun(pict)]
  };
  return par;
}
function translateShapeTextbox(params) {
  const { node: node2 } = params;
  const elements = translateChildNodes(params);
  const textboxContent = {
    name: "w:txbxContent",
    elements
  };
  const textbox = {
    name: "v:textbox",
    attributes: {
      ...node2.attrs.attributes
    },
    elements: [textboxContent]
  };
  return textbox;
}
function translateContentBlock(params) {
  const { node: node2 } = params;
  const { drawingContent, vmlAttributes, horizontalRule } = node2.attrs;
  if (vmlAttributes || horizontalRule) {
    return translateVRectContentBlock(params);
  }
  const drawing = {
    name: "w:drawing",
    elements: [...drawingContent ? [...drawingContent.elements || []] : []]
  };
  const choice = {
    name: "mc:Choice",
    attributes: { Requires: "wps" },
    elements: [drawing]
  };
  const alternateContent = {
    name: "mc:AlternateContent",
    elements: [choice]
  };
  return wrapTextInRun(alternateContent);
}
function translateVRectContentBlock(params) {
  const { node: node2 } = params;
  const { vmlAttributes, background, attributes, style } = node2.attrs;
  const rectAttrs = {
    id: attributes?.id || `_x0000_i${Math.floor(Math.random() * 1e4)}`
  };
  if (style) {
    rectAttrs.style = style;
  }
  if (background) {
    rectAttrs.fillcolor = background;
  }
  if (vmlAttributes) {
    if (vmlAttributes.hralign) rectAttrs["o:hralign"] = vmlAttributes.hralign;
    if (vmlAttributes.hrstd) rectAttrs["o:hrstd"] = vmlAttributes.hrstd;
    if (vmlAttributes.hr) rectAttrs["o:hr"] = vmlAttributes.hr;
    if (vmlAttributes.stroked) rectAttrs.stroked = vmlAttributes.stroked;
  }
  if (attributes) {
    Object.entries(attributes).forEach(([key, value]) => {
      if (!rectAttrs[key] && value !== void 0) {
        rectAttrs[key] = value;
      }
    });
  }
  const rect = {
    name: "v:rect",
    attributes: rectAttrs
  };
  const pict = {
    name: "w:pict",
    attributes: {
      "w14:anchorId": Math.floor(Math.random() * 4294967295).toString()
    },
    elements: [rect]
  };
  return wrapTextInRun(pict);
}
class DocxExporter {
  constructor(converter) {
    __privateAdd(this, _DocxExporter_instances);
    this.converter = converter;
  }
  schemaToXml(data, debug = false) {
    const result = __privateMethod(this, _DocxExporter_instances, generate_xml_as_list_fn).call(this, data, debug);
    return result.join("");
  }
}
_DocxExporter_instances = new WeakSet();
generate_xml_as_list_fn = function(data, debug = false) {
  const json = JSON.parse(JSON.stringify(data));
  const declaration = this.converter.declaration.attributes;
  const xmlTag = `<?xml${Object.entries(declaration).map(([key, value]) => ` ${key}="${value}"`).join("")}?>`;
  const result = __privateMethod(this, _DocxExporter_instances, generateXml_fn).call(this, json, debug);
  const final = [xmlTag, ...result];
  return final;
};
replaceSpecialCharacters_fn = function(text) {
  if (!text) return;
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
};
generateXml_fn = function(node2) {
  if (!node2) return null;
  let { name } = node2;
  const { elements, attributes } = node2;
  let tag = `<${name}`;
  for (let attr in attributes) {
    const parsedAttrName = typeof attributes[attr] === "string" ? __privateMethod(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, attributes[attr]) : attributes[attr];
    tag += ` ${attr}="${parsedAttrName}"`;
  }
  const selfClosing = name && (!elements || !elements.length);
  if (selfClosing) tag += " />";
  else tag += ">";
  let tags = [tag];
  if (!name && node2.type === "text") {
    return node2.text;
  }
  if (elements) {
    if (name === "w:instrText") {
      tags.push(elements[0].text);
    } else if (name === "w:t" || name === "w:delText" || name === "wp:posOffset") {
      try {
        let text = String(elements[0].text);
        text = __privateMethod(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, text);
        tags.push(text);
      } catch (error) {
        console.error("Text element does not contain valid string:", error);
      }
    } else {
      if (elements) {
        for (let child of elements) {
          const newElements = __privateMethod(this, _DocxExporter_instances, generateXml_fn).call(this, child);
          if (!newElements) continue;
          if (typeof newElements === "string") {
            tags.push(newElements);
            continue;
          }
          const removeUndefined = newElements.filter((el) => {
            return el !== "<undefined>" && el !== "</undefined>";
          });
          tags.push(...removeUndefined);
        }
      }
    }
  }
  if (!selfClosing) tags.push(`</${name}>`);
  return tags;
};
function resizeKeepAspectRatio(width, height, maxWidth) {
  if (width > maxWidth) {
    let scale = maxWidth / width;
    let newHeight = Math.round(height * scale);
    return { width: maxWidth, height: newHeight };
  }
  return { width, height };
}
function applyMarksToHtmlAnnotation(state2, marks) {
  const { tr, doc: doc2, schema } = state2;
  const allowedMarks = ["fontFamily", "fontSize", "highlight"];
  if (!marks.some((m2) => allowedMarks.includes(m2.type))) {
    return state2;
  }
  const fontFamily = marks.find((m2) => m2.type === "fontFamily");
  const fontSize = marks.find((m2) => m2.type === "fontSize");
  const highlight = marks.find((m2) => m2.type === "highlight");
  const textStyleType = schema.marks.textStyle;
  const highlightType = schema.marks.highlight;
  doc2.descendants((node2, pos) => {
    if (!node2.isText) return;
    const foundTextStyle = node2.marks.find((m2) => m2.type.name === "textStyle");
    const foundHighlight = node2.marks.find((m2) => m2.type.name === "highlight");
    if (!foundTextStyle) {
      tr.addMark(
        pos,
        pos + node2.nodeSize,
        textStyleType.create({
          ...fontFamily?.attrs,
          ...fontSize?.attrs
        })
      );
    } else if (!foundTextStyle?.attrs.fontFamily && fontFamily) {
      tr.addMark(
        pos,
        pos + node2.nodeSize,
        textStyleType.create({
          ...foundTextStyle?.attrs,
          ...fontFamily.attrs
        })
      );
    } else if (!foundTextStyle?.attrs.fontSize && fontSize) {
      tr.addMark(
        pos,
        pos + node2.nodeSize,
        textStyleType.create({
          ...foundTextStyle?.attrs,
          ...fontSize.attrs
        })
      );
    }
    if (!foundHighlight) {
      tr.addMark(
        pos,
        pos + node2.nodeSize,
        highlightType.create({
          ...highlight?.attrs
        })
      );
    }
  });
  return state2.apply(tr);
}
function translateStructuredContent(params) {
  const { node: node2 } = params;
  const { attrs = {} } = node2;
  const childContent = translateChildNodes({ ...params, nodes: node2.content });
  const nodeElements = [
    {
      name: "w:sdtContent",
      elements: childContent
    }
  ];
  nodeElements.unshift(attrs.sdtPr);
  return {
    name: "w:sdt",
    elements: nodeElements
  };
}
const translatePageNumberNode = (params) => {
  const outputMarks = processOutputMarks(params.node.attrs?.marksAsAttrs || []);
  return getAutoPageJson("PAGE", outputMarks);
};
const translateTotalPageNumberNode = (params) => {
  const outputMarks = processOutputMarks(params.node.attrs?.marksAsAttrs || []);
  return getAutoPageJson("NUMPAGES", outputMarks);
};
const getAutoPageJson = (type2, outputMarks = []) => {
  return [
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "begin"
          }
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:instrText",
          elements: [
            {
              type: "text",
              text: ` ${type2}`
            }
          ]
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "separate"
          }
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "end"
          }
        }
      ]
    }
  ];
};
const getFieldHighlightJson = (fieldsHighlightColor) => {
  if (!fieldsHighlightColor) return null;
  let parsedColor = fieldsHighlightColor.trim();
  const hexRegex = /^#?([A-Fa-f0-9]{3}|[A-Fa-f0-9]{4}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/;
  if (!hexRegex.test(parsedColor)) {
    console.warn(`Invalid HEX color provided to fieldsHighlightColor export param: ${fieldsHighlightColor}`);
    return null;
  }
  if (parsedColor.startsWith("#")) {
    parsedColor = parsedColor.slice(1);
  }
  return {
    name: "w:rPr",
    elements: [
      {
        name: "w:shd",
        attributes: {
          "w:fill": `#${parsedColor}`,
          "w:color": "auto",
          "w:val": "clear"
        }
      }
    ]
  };
};
const defaultInitialXml = `<w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas" xmlns:cx="http://schemas.microsoft.com/office/drawing/2014/chartex" xmlns:cx1="http://schemas.microsoft.com/office/drawing/2015/9/8/chartex" xmlns:cx2="http://schemas.microsoft.com/office/drawing/2015/10/21/chartex" xmlns:cx3="http://schemas.microsoft.com/office/drawing/2016/5/9/chartex" xmlns:cx4="http://schemas.microsoft.com/office/drawing/2016/5/10/chartex" xmlns:cx5="http://schemas.microsoft.com/office/drawing/2016/5/11/chartex" xmlns:cx6="http://schemas.microsoft.com/office/drawing/2016/5/12/chartex" xmlns:cx7="http://schemas.microsoft.com/office/drawing/2016/5/13/chartex" xmlns:cx8="http://schemas.microsoft.com/office/drawing/2016/5/14/chartex" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:aink="http://schemas.microsoft.com/office/drawing/2016/ink" xmlns:am3d="http://schemas.microsoft.com/office/drawing/2017/model3d" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:oel="http://schemas.microsoft.com/office/2019/extlst" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing" xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex" xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid" xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml" xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex" xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup" xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk" xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml" xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape" mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh wp14"><w:body></w:body></w:document>`;
const parseXmlToJson = (xml) => {
  return JSON.parse(xmljs.xml2json(xml, null, 2));
};
const getInitialJSON = (parsedDocx, fallbackXml = defaultInitialXml) => {
  return parsedDocx["word/document.xml"] || parseXmlToJson(fallbackXml);
};
const handleAllTableNodes = (params) => {
  const { nodes } = params;
  if (nodes.length === 0) {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  switch (node2.name) {
    case "w:tbl":
      return { nodes: [handleTableNode(node2, params)], consumed: 1 };
  }
  return { nodes: [], consumed: 0 };
};
const tableNodeHandlerEntity = {
  handlerName: "tableNodeHandler",
  handler: handleAllTableNodes
};
function handleTableNode(node2, params) {
  const { docx, nodeListHandler: nodeListHandler2 } = params;
  const tblPr = node2.elements.find((el) => el.name === "w:tblPr");
  const tableBordersElement = tblPr.elements.find((el) => el.name === "w:tblBorders");
  const tableBorders = tableBordersElement?.elements || [];
  const { borders, rowBorders } = processTableBorders(tableBorders);
  const tblStyleTag = tblPr.elements.find((el) => el.name === "w:tblStyle");
  const tableStyleId = tblStyleTag?.attributes["w:val"];
  const attrs = { tableStyleId };
  const tableIndent = tblPr?.elements.find((el) => el.name === "w:tblInd");
  if (tableIndent) {
    const { "w:w": width, "w:type": type2 } = tableIndent.attributes;
    attrs["tableIndent"] = { width: twipsToPixels(width), type: type2 };
  }
  const tableLayout = tblPr?.elements.find((el) => el.name === "w:tblLayout");
  if (tableLayout) {
    const { "w:type": type2 } = tableLayout.attributes;
    attrs["tableLayout"] = type2;
  }
  const referencedStyles = getReferencedTableStyles(tblStyleTag, docx);
  const tblW = tblPr.elements.find((el) => el.name === "w:tblW");
  if (tblW) {
    attrs["tableWidth"] = {
      width: twipsToPixels(tblW.attributes["w:w"]),
      type: tblW.attributes["w:type"]
    };
  }
  const tblCellSpacing = tblPr.elements.find((el) => el.name === "w:tblCellSpacing");
  if (tblCellSpacing) {
    attrs["tableCellSpacing"] = {
      w: tblCellSpacing.attributes["w:w"],
      type: tblCellSpacing.attributes["w:type"]
    };
    attrs["borderCollapse"] = "separate";
  }
  const tblJustification = tblPr.elements.find((el) => el.name === "w:jc");
  if (tblJustification?.attributes) {
    attrs["justification"] = tblJustification.attributes["w:val"];
  }
  const rows = node2.elements.filter((el) => el.name === "w:tr");
  const refStylesBorders = referencedStyles?.borders || {};
  const refStylesRowBorders = referencedStyles?.rowBorders || {};
  const borderData = Object.keys(borders)?.length ? Object.assign(refStylesBorders, borders) : refStylesBorders;
  const borderRowData = Object.keys(rowBorders)?.length ? Object.assign(refStylesRowBorders, rowBorders) : refStylesRowBorders;
  attrs["borders"] = borderData;
  const content = [];
  rows.forEach((row) => {
    const result = handleTableRowNode(row, node2, borderRowData, tblStyleTag, params);
    if (result.content?.length) content.push(result);
  });
  return {
    type: "table",
    content,
    attrs
  };
}
function handleTableCellNode(node2, row, table, rowBorders, columnWidth = null, styleTag, params, columnIndex) {
  const { docx, nodeListHandler: nodeListHandler2 } = params;
  const tcPr = node2.elements.find((el) => el.name === "w:tcPr");
  const borders = tcPr?.elements?.find((el) => el.name === "w:tcBorders");
  const inlineBorders = processInlineCellBorders(borders, rowBorders);
  const gridColumnWidths = getGridColumnWidths(table);
  const tcWidth = tcPr?.elements?.find((el) => el.name === "w:tcW");
  let width = tcWidth ? twipsToPixels(tcWidth.attributes["w:w"]) : null;
  const widthType = tcWidth?.attributes["w:type"];
  if (!width && columnWidth) width = columnWidth;
  const vMerge = getTableCellMergeTag(node2);
  const { attributes: vMergeAttrs } = vMerge || {};
  const backgroundColor = tcPr?.elements?.find((el) => el.name === "w:shd");
  const background = {
    color: backgroundColor?.attributes["w:fill"]
  };
  const colspanTag = tcPr?.elements?.find((el) => el.name === "w:gridSpan");
  const colspan = colspanTag?.attributes["w:val"];
  const marginTag = tcPr?.elements?.find((el) => el.name === "w:tcMar");
  const verticalAlignTag = tcPr?.elements?.find((el) => el.name === "w:vAlign");
  const verticalAlign = verticalAlignTag?.attributes["w:val"] || "top";
  const attributes = {};
  const referencedStyles = getReferencedTableStyles(styleTag, docx) || {};
  attributes.cellMargins = getTableCellMargins(marginTag, referencedStyles);
  const { fontSize, fonts = {} } = referencedStyles;
  const fontFamily = fonts["ascii"];
  if (width) {
    attributes["colwidth"] = [width];
    attributes["widthUnit"] = "px";
    const defaultColWidths = gridColumnWidths;
    const hasDefaultColWidths = gridColumnWidths && gridColumnWidths.length > 0;
    const colspanNum = parseInt(colspan || 1, 10);
    if (colspanNum && colspanNum > 1 && hasDefaultColWidths) {
      let colwidth = [];
      for (let i = 0; i < colspanNum; i++) {
        let colwidthValue = defaultColWidths[columnIndex + i];
        let defaultColwidth = 100;
        if (typeof colwidthValue !== "undefined") {
          colwidth.push(colwidthValue);
        } else {
          colwidth.push(defaultColwidth);
        }
      }
      if (colwidth.length) {
        attributes["colwidth"] = [...colwidth];
      }
    }
  }
  if (widthType) attributes["widthType"] = widthType;
  if (colspan) attributes["colspan"] = parseInt(colspan, 10);
  if (background) attributes["background"] = background;
  attributes["verticalAlign"] = verticalAlign;
  if (fontSize) attributes["fontSize"] = fontSize;
  if (fontFamily) attributes["fontFamily"] = fontFamily["ascii"];
  if (rowBorders) attributes["borders"] = { ...rowBorders };
  if (inlineBorders) attributes["borders"] = Object.assign(attributes["borders"] || {}, inlineBorders);
  if (vMergeAttrs && vMergeAttrs["w:val"] === "restart") {
    const rows = table.elements.filter((el) => el.name === "w:tr");
    const currentRowIndex = rows.findIndex((r) => r === row);
    const remainingRows = rows.slice(currentRowIndex + 1);
    const cellsInRow = row.elements.filter((el) => el.name === "w:tc");
    let cellIndex = cellsInRow.findIndex((el) => el === node2);
    let rowspan = 1;
    for (let remainingRow of remainingRows) {
      const firstCell = remainingRow.elements.findIndex((el) => el.name === "w:tc");
      const cellAtIndex = remainingRow.elements[firstCell + cellIndex];
      if (!cellAtIndex) break;
      const vMerge2 = getTableCellMergeTag(cellAtIndex);
      const { attributes: currentCellMergeAttrs } = vMerge2 || {};
      if (!vMerge2 && !currentCellMergeAttrs || currentCellMergeAttrs && currentCellMergeAttrs["w:val"] === "restart") {
        break;
      }
      rowspan++;
      remainingRow.elements.splice(firstCell + cellIndex, 1);
    }
    attributes["rowspan"] = rowspan;
  }
  return {
    type: "tableCell",
    content: nodeListHandler2.handler({ ...params, nodes: node2.elements }),
    attrs: attributes
  };
}
const getTableCellMergeTag = (node2) => {
  const tcPr = node2.elements.find((el) => el.name === "w:tcPr");
  const vMerge = tcPr?.elements?.find((el) => el.name === "w:vMerge");
  return vMerge;
};
const processBorder = (borders, direction, rowBorders = {}) => {
  const borderAttrs = borders?.elements?.find((el) => el.name === `w:${direction}`)?.attributes;
  if (borderAttrs && borderAttrs["w:val"] !== "nil") {
    const border = {};
    const color = borderAttrs["w:color"];
    if (color) border["color"] = color === "auto" ? "#000000" : `#${color}`;
    const size = borderAttrs["w:sz"];
    if (size) border["size"] = eigthPointsToPixels(size);
    return border;
  }
  if (borderAttrs && borderAttrs["w:val"] === "nil") {
    const border = Object.assign({}, rowBorders[direction] || {});
    if (!Object.keys(border)) return null;
    border["val"] = "none";
    return border;
  }
  return null;
};
const processInlineCellBorders = (borders, rowBorders) => {
  if (!borders) return null;
  const processedBorders = {};
  const inlineBorderBottom = processBorder(borders, "bottom", rowBorders);
  if (inlineBorderBottom) processedBorders["bottom"] = inlineBorderBottom;
  const inlineBorderTop = processBorder(borders, "top", rowBorders);
  if (inlineBorderTop) processedBorders["top"] = inlineBorderTop;
  const inlineBorderLeft = processBorder(borders, "left", rowBorders);
  if (inlineBorderLeft) processedBorders["left"] = inlineBorderLeft;
  const inlineBorderRight = processBorder(borders, "right", rowBorders);
  if (inlineBorderRight) processedBorders["right"] = inlineBorderRight;
  return processedBorders;
};
function getReferencedTableStyles(tblStyleTag, docx) {
  if (!tblStyleTag) return null;
  const stylesToReturn = {};
  const { attributes = {} } = tblStyleTag;
  const tableStyleReference = attributes["w:val"];
  if (!tableStyleReference) return null;
  const styles = docx["word/styles.xml"];
  const { elements } = styles.elements[0];
  const styleElements = elements.filter((el) => el.name === "w:style");
  const styleTag = styleElements.find((el) => el.attributes["w:styleId"] === tableStyleReference);
  if (!styleTag) return null;
  stylesToReturn.name = styleTag.elements.find((el) => el.name === "w:name");
  const basedOn = styleTag.elements.find((el) => el.name === "w:basedOn");
  let baseTblPr;
  if (basedOn?.attributes) {
    const baseStyles = styleElements.find((el) => el.attributes["w:styleId"] === basedOn.attributes["w:val"]);
    baseTblPr = baseStyles ? baseStyles.elements.find((el) => el.name === "w:tblPr") : {};
  }
  const pPr = styleTag.elements.find((el) => el.name === "w:pPr");
  if (pPr) {
    const justification = pPr.elements.find((el) => el.name === "w:jc");
    if (justification?.attributes) stylesToReturn.justification = justification.attributes["w:val"];
  }
  const rPr = styleTag?.elements.find((el) => el.name === "w:rPr");
  if (rPr) {
    const fonts = rPr.elements.find((el) => el.name === "w:rFonts");
    if (fonts) {
      const { "w:ascii": ascii, "w:hAnsi": hAnsi, "w:cs": cs } = fonts.attributes;
      stylesToReturn.fonts = { ascii, hAnsi, cs };
    }
    const fontSize = rPr.elements.find((el) => el.name === "w:sz");
    if (fontSize?.attributes) stylesToReturn.fontSize = halfPointToPoints(fontSize.attributes["w:val"]) + "pt";
  }
  const tblPr = styleTag.elements.find((el) => el.name === "w:tblPr");
  if (tblPr && tblPr.elements) {
    if (baseTblPr && baseTblPr.elements) {
      tblPr.elements.push(...baseTblPr.elements);
    }
    const tableBorders = tblPr?.elements?.find((el) => el.name === "w:tblBorders");
    const { elements: borderElements = [] } = tableBorders || {};
    const { borders, rowBorders } = processTableBorders(borderElements);
    if (borders) stylesToReturn.borders = borders;
    if (rowBorders) stylesToReturn.rowBorders = rowBorders;
    const tableCellMargin = tblPr?.elements.find((el) => el.name === "w:tblCellMar");
    if (tableCellMargin) {
      const marginLeft = tableCellMargin.elements.find((el) => el.name === "w:left");
      const marginRight = tableCellMargin.elements.find((el) => el.name === "w:right");
      const marginTop = tableCellMargin.elements.find((el) => el.name === "w:top");
      const marginBottom = tableCellMargin.elements.find((el) => el.name === "w:bottom");
      stylesToReturn.cellMargins = {
        marginLeft: marginLeft?.attributes["w:w"],
        marginRight: marginRight?.attributes["w:w"],
        marginTop: marginTop?.attributes["w:w"],
        marginBottom: marginBottom?.attributes["w:w"]
      };
    }
  }
  return stylesToReturn;
}
function processTableBorders(borderElements) {
  const borders = {};
  const rowBorders = {};
  borderElements.forEach((borderElement) => {
    const { name } = borderElement;
    const borderName = name.split("w:")[1];
    const { attributes } = borderElement;
    const attrs = {};
    const color = attributes["w:color"];
    const size = attributes["w:sz"];
    if (color && color !== "auto") attrs["color"] = color.startsWith("#") ? color : `#${color}`;
    if (size && size !== "auto") attrs["size"] = eigthPointsToPixels(size);
    const rowBorderNames = ["insideH", "insideV"];
    if (rowBorderNames.includes(borderName)) rowBorders[borderName] = attrs;
    borders[borderName] = attrs;
  });
  return {
    borders,
    rowBorders
  };
}
function handleTableRowNode(node2, table, rowBorders, styleTag, params) {
  const attrs = {};
  const tPr = node2.elements.find((el) => el.name === "w:trPr");
  const rowHeightTag = tPr?.elements?.find((el) => el.name === "w:trHeight");
  const rowHeight = rowHeightTag?.attributes["w:val"];
  const borders = {};
  if (rowBorders?.insideH) borders["bottom"] = rowBorders.insideH;
  if (rowBorders?.insideV) borders["right"] = rowBorders.insideV;
  attrs["borders"] = borders;
  if (rowHeight) {
    attrs["rowHeight"] = twipsToPixels(rowHeight);
  }
  const gridColumnWidths = getGridColumnWidths(table);
  const cellNodes = node2.elements.filter((el) => el.name === "w:tc");
  let currentColumnIndex = 0;
  const content = cellNodes?.map((n) => {
    let colWidth = gridColumnWidths?.[currentColumnIndex] || null;
    const result = handleTableCellNode(n, node2, table, borders, colWidth, styleTag, params, currentColumnIndex);
    const tcPr = n.elements?.find((el) => el.name === "w:tcPr");
    const colspanTag = tcPr?.elements?.find((el) => el.name === "w:gridSpan");
    const colspan = parseInt(colspanTag?.attributes["w:val"] || 1, 10);
    currentColumnIndex += colspan;
    return result;
  }) || [];
  const newNode = {
    type: "tableRow",
    content,
    attrs
  };
  return newNode;
}
const getTableCellMargins = (marginTag, referencedStyles) => {
  const inlineMarginLeftTag = marginTag?.elements?.find((el) => el.name === "w:left");
  const inlineMarginRightTag = marginTag?.elements?.find((el) => el.name === "w:right");
  const inlineMarginTopTag = marginTag?.elements?.find((el) => el.name === "w:top");
  const inlineMarginBottomTag = marginTag?.elements?.find((el) => el.name === "w:bottom");
  const inlineMarginLeftValue = inlineMarginLeftTag?.attributes["w:w"];
  const inlineMarginRightValue = inlineMarginRightTag?.attributes["w:w"];
  const inlineMarginTopValue = inlineMarginTopTag?.attributes["w:w"];
  const inlineMarginBottomValue = inlineMarginBottomTag?.attributes["w:w"];
  const { cellMargins = {} } = referencedStyles;
  const {
    marginLeft: marginLeftStyle,
    marginRight: marginRightStyle,
    marginTop: marginTopStyle,
    marginBottom: marginBottomStyle
  } = cellMargins;
  const margins = {
    left: twipsToPixels(inlineMarginLeftValue ?? marginLeftStyle),
    right: twipsToPixels(inlineMarginRightValue ?? marginRightStyle),
    top: twipsToPixels(inlineMarginTopValue ?? marginTopStyle),
    bottom: twipsToPixels(inlineMarginBottomValue ?? marginBottomStyle)
  };
  return margins;
};
const getGridColumnWidths = (tableNode) => {
  const tblGrid = tableNode.elements.find((el) => el.name === "w:tblGrid");
  if (!tblGrid) return [];
  const columnWidths = tblGrid?.elements?.flatMap((el) => {
    if (el.name !== "w:gridCol") return [];
    return twipsToPixels(el.attributes["w:w"]);
  }) || [];
  return columnWidths;
};
const handleDrawingNode = (params) => {
  const { nodes, filename } = params;
  const validNodes = ["w:drawing", "w:p"];
  if (nodes.length === 0 || !validNodes.includes(nodes[0].name)) {
    return { nodes: [], consumed: 0 };
  }
  const mainNode = nodes[0];
  let node2;
  if (mainNode.name === "w:drawing") node2 = mainNode;
  else node2 = mainNode.elements.find((el) => el.name === "w:drawing");
  if (!node2) return { nodes: [], consumed: 0 };
  let result;
  const { elements } = node2;
  const currentFileName = filename || null;
  const isAnchor = elements.find((el) => el.name === "wp:anchor");
  if (isAnchor) {
    result = handleImageImport(elements[0], currentFileName, params);
    if (result && result.attrs) result.attrs.isAnchor = isAnchor;
  }
  const inlineImage = elements.find((el) => el.name === "wp:inline");
  if (inlineImage) result = handleImageImport(inlineImage, currentFileName, params);
  return { nodes: result ? [result] : [], consumed: 1 };
};
function handleImageImport(node2, currentFileName, params) {
  const { docx } = params;
  const { attributes } = node2;
  const padding = {
    top: emuToPixels(attributes["distT"]),
    bottom: emuToPixels(attributes["distB"]),
    left: emuToPixels(attributes["distL"]),
    right: emuToPixels(attributes["distR"])
  };
  const extent = node2.elements.find((el) => el.name === "wp:extent");
  const size = {
    width: emuToPixels(extent.attributes?.cx),
    height: emuToPixels(extent.attributes?.cy)
  };
  const graphic = node2.elements.find((el) => el.name === "a:graphic");
  const graphicData = graphic.elements.find((el) => el.name === "a:graphicData");
  const { uri: uri2 } = graphicData?.attributes || {};
  const shapeURI = "http://schemas.microsoft.com/office/word/2010/wordprocessingShape";
  if (!!uri2 && uri2 === shapeURI) {
    return handleShapeDrawing(params, node2, graphicData);
  }
  const picture = graphicData.elements.find((el) => el.name === "pic:pic");
  if (!picture || !picture.elements) return null;
  const blipFill = picture.elements.find((el) => el.name === "pic:blipFill");
  const blip = blipFill.elements.find((el) => el.name === "a:blip");
  const positionHTag = node2.elements.find((el) => el.name === "wp:positionH");
  const positionH = positionHTag?.elements.find((el) => el.name === "wp:posOffset");
  const positionHValue = emuToPixels(positionH?.elements[0]?.text);
  const hRelativeFrom = positionHTag?.attributes.relativeFrom;
  const alignH = positionHTag?.elements.find((el) => el.name === "wp:align")?.elements[0]?.text;
  const positionVTag = node2.elements.find((el) => el.name === "wp:positionV");
  const positionV = positionVTag?.elements?.find((el) => el.name === "wp:posOffset");
  const positionVValue = emuToPixels(positionV?.elements[0]?.text);
  const vRelativeFrom = positionVTag?.attributes.relativeFrom;
  const alignV = positionVTag?.elements?.find((el) => el.name === "wp:align")?.elements[0]?.text;
  const simplePos = node2.elements.find((el) => el.name === "wp:simplePos");
  const wrapSquare = node2.elements.find((el) => el.name === "wp:wrapSquare");
  const wrapTopAndBottom = node2.elements.find((el) => el.name === "wp:wrapTopAndBottom");
  const docPr = node2.elements.find((el) => el.name === "wp:docPr");
  let anchorData = null;
  if (hRelativeFrom || alignH || vRelativeFrom || alignV) {
    anchorData = {
      hRelativeFrom,
      vRelativeFrom,
      alignH,
      alignV
    };
  }
  const marginOffset = {
    left: positionHValue,
    top: positionVValue
  };
  const { attributes: blipAttributes = {} } = blip;
  const rEmbed = blipAttributes["r:embed"];
  if (!rEmbed) return null;
  const currentFile = currentFileName || "document.xml";
  let rels = docx[`word/_rels/${currentFile}.rels`];
  if (!rels) rels = docx[`word/_rels/document.xml.rels`];
  const relationships = rels.elements.find((el) => el.name === "Relationships");
  const { elements } = relationships;
  const rel = elements.find((el) => el.attributes["Id"] === rEmbed);
  if (!rel) return null;
  const { attributes: relAttributes } = rel;
  const path = `word/${relAttributes["Target"]}`;
  return {
    type: "image",
    attrs: {
      src: path,
      alt: docPr?.attributes.name || "Image",
      id: docPr?.attributes.id || "",
      title: docPr?.attributes.descr || "Image",
      inline: true,
      padding,
      marginOffset,
      size,
      anchorData,
      ...simplePos && {
        simplePos: {
          x: simplePos.attributes.x,
          y: simplePos.attributes.y
        }
      },
      ...wrapSquare && {
        wrapText: wrapSquare.attributes.wrapText
      },
      wrapTopAndBottom: !!wrapTopAndBottom,
      originalPadding: {
        distT: attributes["distT"],
        distB: attributes["distB"],
        distL: attributes["distL"],
        distR: attributes["distR"]
      },
      originalAttributes: node2.attributes,
      rId: relAttributes["Id"]
    }
  };
}
const handleShapeDrawing = (params, node2, graphicData) => {
  const wsp = graphicData.elements.find((el) => el.name === "wps:wsp");
  const textBox = wsp.elements.find((el) => el.name === "wps:txbx");
  const textBoxContent = textBox?.elements?.find((el) => el.name === "w:txbxContent");
  node2.elements.find((el) => el.name === "wp:docPr");
  const spPr = wsp.elements.find((el) => el.name === "wps:spPr");
  const prstGeom = spPr?.elements.find((el) => el.name === "a:prstGeom");
  if (!!prstGeom && prstGeom.attributes["prst"] === "rect") {
    return getRectangleShape(params, spPr);
  }
  if (!textBoxContent) {
    return null;
  }
  const { nodeListHandler: nodeListHandler2 } = params;
  const translatedElement = nodeListHandler2.handler({
    ...params,
    node: textBoxContent.elements[0],
    nodes: textBoxContent.elements
  });
  return translatedElement[0];
};
const getRectangleShape = (params, node2) => {
  const schemaAttrs = {};
  const [drawingNode] = params.nodes;
  if (drawingNode?.name === "w:drawing") {
    schemaAttrs.drawingContent = drawingNode;
  }
  const xfrm = node2.elements.find((el) => el.name === "a:xfrm");
  const start = xfrm.elements.find((el) => el.name === "a:off");
  const size = xfrm.elements.find((el) => el.name === "a:ext");
  const solidFill = node2.elements.find((el) => el.name === "a:solidFill");
  node2.elements.find((el) => el.name === "a:ln");
  const rectangleSize = {
    top: emuToPixels(start.attributes["y"]),
    left: emuToPixels(start.attributes["x"]),
    width: emuToPixels(size.attributes["cx"]),
    height: emuToPixels(size.attributes["cy"])
  };
  schemaAttrs.size = rectangleSize;
  const background = solidFill?.elements[0]?.attributes["val"];
  if (background) {
    schemaAttrs.background = "#" + background;
  }
  return {
    type: "contentBlock",
    attrs: schemaAttrs
  };
};
const drawingNodeHandlerEntity = {
  handlerName: "drawingNodeHandler",
  handler: handleDrawingNode
};
function parseMarks(property, unknownMarks = [], docx = null) {
  const marks = [];
  const seen = /* @__PURE__ */ new Set();
  const lang = property?.elements?.find((el) => el.name === "w:lang");
  lang?.attributes || {};
  property?.elements?.forEach((element) => {
    const marksForType = SuperConverter.markTypes.filter((mark) => mark.name === element.name);
    if (!marksForType.length) {
      const missingMarks = [
        "w:shd",
        "w:rStyle",
        "w:pStyle",
        "w:numPr",
        "w:outlineLvl",
        "w:bdr",
        "w:pBdr",
        "w:noProof",
        "w:contextualSpacing",
        "w:keepNext",
        "w:tabs",
        "w:keepLines"
      ];
      if (missingMarks.includes(element.name)) {
        unknownMarks.push(element.name);
      }
    }
    let filteredMarksForType = marksForType;
    if (element.name === "w:spacing") {
      const attrs = element.attributes || {};
      const hasLetterSpacing = attrs["w:val"];
      filteredMarksForType = marksForType.filter((m2) => {
        if (hasLetterSpacing) {
          return m2.type === "letterSpacing";
        }
        return m2.type === "lineHeight";
      });
    }
    filteredMarksForType.forEach((m2) => {
      if (!m2 || seen.has(m2.type)) return;
      seen.add(m2.type);
      const { attributes = {} } = element;
      const newMark = { type: m2.type };
      const exceptionMarks = ["w:b", "w:caps"];
      if ((attributes["w:val"] === "0" || attributes["w:val"] === "none") && !exceptionMarks.includes(m2.name)) {
        return;
      }
      const requiresValue = ["w:u"];
      if (requiresValue.includes(m2.name) && !attributes["w:val"]) {
        return;
      }
      if (m2.mark) newMark.type = m2.mark;
      if (m2.name === "w:caps") {
        newMark.attrs = {};
        if (attributes["w:val"] === "0") {
          newMark.attrs[m2.property] = "none";
        } else {
          newMark.attrs[m2.property] = "uppercase";
        }
        marks.push(newMark);
        return;
      }
      if (Object.keys(attributes).length) {
        const value = getMarkValue(m2.type, attributes, docx);
        if (value === null || value === void 0) return;
        newMark.attrs = {};
        newMark.attrs[m2.property] = value;
      }
      marks.push(newMark);
    });
  });
  return createImportMarks(marks);
}
function handleStyleChangeMarks(rPr, currentMarks) {
  const styleChangeMark = rPr.elements?.find((el) => el.name === "w:rPrChange");
  if (!styleChangeMark) {
    return [];
  }
  const { attributes } = styleChangeMark;
  const mappedAttributes = {
    id: attributes["w:id"],
    date: attributes["w:date"],
    author: attributes["w:author"],
    authorEmail: attributes["w:authorEmail"]
  };
  const submarks = parseMarks(styleChangeMark);
  return [{ type: TrackFormatMarkName, attrs: { ...mappedAttributes, before: submarks, after: [...currentMarks] } }];
}
function createImportMarks(marks) {
  const textStyleMarksToCombine = marks.filter((mark) => mark.type === "textStyle");
  const remainingMarks = marks.filter((mark) => mark.type !== "textStyle");
  const combinedTextAttrs = {};
  if (textStyleMarksToCombine.length) {
    textStyleMarksToCombine.forEach((mark) => {
      const { attrs = {} } = mark;
      Object.keys(attrs).forEach((attr) => {
        combinedTextAttrs[attr] = attrs[attr];
      });
    });
  }
  const result = [...remainingMarks, { type: "textStyle", attrs: combinedTextAttrs }];
  return result;
}
function getMarkValue(markType, attributes, docx) {
  if (markType === "tabs") markType = "textIndent";
  const markValueMapper = {
    color: () => `#${attributes["w:val"]}`,
    fontSize: () => `${attributes["w:val"] / 2}pt`,
    textIndent: () => getIndentValue(attributes),
    fontFamily: () => getFontFamilyValue(attributes, docx),
    lineHeight: () => getLineHeightValue(attributes),
    letterSpacing: () => `${twipsToPt(attributes["w:val"])}pt`,
    textAlign: () => attributes["w:val"],
    link: () => attributes["href"],
    underline: () => attributes["w:val"],
    bold: () => attributes?.["w:val"] || null,
    italic: () => attributes?.["w:val"] || null,
    highlight: () => getHighLightValue(attributes),
    strike: () => getStrikeValue(attributes)
  };
  if (markType in markValueMapper) {
    return markValueMapper[markType]();
  }
}
function getFontFamilyValue(attributes, docx) {
  const ascii = attributes["w:ascii"];
  const themeAscii = attributes["w:asciiTheme"];
  if (!docx || !themeAscii) return ascii;
  const theme = docx["word/theme/theme1.xml"];
  if (!theme) return ascii;
  const { elements: topElements } = theme;
  const { elements } = topElements[0];
  const themeElements = elements.find((el) => el.name === "a:themeElements");
  const fontScheme = themeElements.elements.find((el) => el.name === "a:fontScheme");
  const majorFont = fontScheme.elements.find((el) => el.name === "a:majorFont");
  const latin = majorFont.elements.find((el) => el.name === "a:latin");
  const typeface = latin.attributes["typeface"];
  return typeface;
}
function getIndentValue(attributes) {
  let value = attributes["w:left"];
  if (!value) return null;
  return `${twipsToInches(value)}in`;
}
function getLineHeightValue(attributes) {
  const value = attributes["w:line"];
  const lineRule = attributes["w:lineRule"];
  if (!value || value === "0") return null;
  if (lineRule === "exact") return `${twipsToPt(value)}pt`;
  return `${twipsToLines(value)}`;
}
function getHighLightValue(attributes) {
  const fill = attributes["w:fill"];
  if (fill && fill !== "auto") return `#${fill}`;
  if (isValidHexColor(attributes?.["w:val"])) return `#${attributes["w:val"]}`;
  return getHexColorFromDocxSystem(attributes?.["w:val"]) || null;
}
function getStrikeValue(attributes) {
  return attributes?.["w:val"] === "1" ? attributes["w:val"] : null;
}
function parseProperties(node2) {
  const marks = [];
  const unknownMarks = [];
  const { attributes = {}, elements = [] } = node2;
  const { nodes, paragraphProperties = {}, runProperties = {} } = splitElementsAndProperties(elements);
  const hasRun = elements.find((element) => element.name === "w:r");
  if (hasRun) paragraphProperties.elements = paragraphProperties?.elements?.filter((el) => el.name !== "w:rPr");
  if (runProperties && runProperties?.elements?.length) {
    marks.push(...parseMarks(runProperties, unknownMarks));
  }
  if (paragraphProperties && paragraphProperties.elements?.length) {
    const disallowedParagraphProperties = ["w:u"];
    const filteredParagraphProperties = {
      ...paragraphProperties,
      elements: paragraphProperties.elements?.filter((el) => !disallowedParagraphProperties.includes(el.name))
    };
    marks.push(...parseMarks(filteredParagraphProperties, unknownMarks));
  }
  marks.push(...handleStyleChangeMarks(runProperties, marks));
  if (paragraphProperties && paragraphProperties.elements?.length) {
    attributes["paragraphProperties"] = paragraphProperties;
  }
  if (marks && node2.name === "w:p") {
    marks.forEach((mark) => {
      const attrValue = Object.keys(mark.attrs ?? {})[0];
      if (attrValue) {
        const value = mark.attrs[attrValue];
        attributes[attrValue] = value;
      }
    });
  }
  return { elements: nodes, attributes, marks, unknownMarks };
}
function splitElementsAndProperties(elements) {
  const pPr = elements.find((el) => el.name === "w:pPr");
  const rPr = elements.find((el) => el.name === "w:rPr");
  const sectPr = elements.find((el) => el.name === "w:sectPr");
  const els = elements.filter((el) => el.name !== "w:pPr" && el.name !== "w:rPr" && el.name !== "w:sectPr");
  return {
    nodes: els,
    paragraphProperties: pPr,
    runProperties: rPr,
    sectionProperties: sectPr
  };
}
function getElementName(element) {
  return SuperConverter.allowedElements[element.name || element.type];
}
const isPropertiesElement = (element) => {
  return !!SuperConverter.propertyTypes[element.name || element.type];
};
const handleTrackChangeNode = (params) => {
  const { nodes, nodeListHandler: nodeListHandler2 } = params;
  if (nodes.length === 0 || !(nodes[0].name === "w:del" || nodes[0].name === "w:ins" || nodes[0].name === "w:sdt")) {
    return { nodes: [], consumed: 0 };
  }
  const mainNode = nodes[0];
  let node2;
  if (["w:ins", "w:del"].includes(mainNode.name)) {
    node2 = mainNode;
  } else {
    const sdtContent = mainNode.elements.find((el) => el.name === "w:sdtContent");
    const trackedChange = sdtContent?.elements.find((el) => ["w:ins", "w:del"].includes(el.name));
    if (trackedChange) node2 = trackedChange;
  }
  if (!node2) {
    return { nodes: [], consumed: 0 };
  }
  const { name } = node2;
  const { attributes, elements } = parseProperties(node2);
  const subs = nodeListHandler2.handler({ ...params, insideTrackChange: true, nodes: elements });
  const changeType = name === "w:del" ? TrackDeleteMarkName : TrackInsertMarkName;
  const mappedAttributes = {
    id: attributes["w:id"],
    date: attributes["w:date"],
    author: attributes["w:author"],
    authorEmail: attributes["w:authorEmail"],
    importedAuthor: `${attributes["w:author"]} (imported)`
  };
  subs.forEach((subElement) => {
    if (subElement.marks === void 0) subElement.marks = [];
    subElement.marks.push({ type: changeType, attrs: mappedAttributes });
  });
  return { nodes: subs, consumed: 1 };
};
const trackChangeNodeHandlerEntity = {
  handlerName: "trackChangeNodeHandler",
  handler: handleTrackChangeNode
};
const handleHyperlinkNode = (params) => {
  const { nodes, docx, nodeListHandler: nodeListHandler2 } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:hyperlink") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const rels = docx["word/_rels/document.xml.rels"];
  const relationships = rels.elements.find((el) => el.name === "Relationships");
  const { elements } = relationships;
  const { attributes } = node2;
  const rId = attributes["r:id"];
  const anchor = attributes["w:anchor"];
  attributes["w:history"];
  const rel = elements.find((el) => el.attributes["Id"] === rId) || {};
  const { attributes: relAttributes = {} } = rel;
  let href = relAttributes["Target"];
  if (anchor && !href) href = `#${anchor}`;
  const runNodes = node2.elements.filter((el) => el.name === "w:r");
  const linkMark = { type: "link", attrs: { href, rId } };
  for (const runNode of runNodes) {
    if (!runNode.marks) runNode.marks = [];
    runNode.marks.push(linkMark);
    const rPr = runNode.elements.find((el) => el.name === "w:rPr");
    if (rPr) {
      const styleRel = rPr.elements.find((el) => el.name === "w:rStyle");
      if (styleRel) {
        const styles = docx["word/styles.xml"];
        const { elements: elements2 } = styles.elements[0];
        const styleElements = elements2.filter((el) => el.name === "w:style");
        const style = styleElements.find((el) => el.attributes["w:styleId"] === "Hyperlink");
        const styleRpr = style?.elements?.find((el) => el.name === "w:rPr");
        if (styleRpr) {
          styleRpr.elements.forEach((styleEl) => {
            const hasElInRPr = rPr.elements.find((el) => el.name === styleEl.name);
            if (!hasElInRPr) rPr.elements.push(styleEl);
          });
        }
      }
    }
  }
  const updatedNode = nodeListHandler2.handler({ ...params, nodes: runNodes });
  return { nodes: updatedNode, consumed: 1 };
};
const hyperlinkNodeHandlerEntity = {
  handlerName: "hyperlinkNodeHandler",
  handler: handleHyperlinkNode
};
const handleRunNode = (params) => {
  const { nodes, nodeListHandler: nodeListHandler2, parentStyleId, docx } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:r") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const childParams = { ...params, nodes: node2.elements };
  let processedRun = nodeListHandler2.handler(childParams)?.filter((n) => n) || [];
  const hasRunProperties = node2.elements?.some((el) => el.name === "w:rPr");
  const defaultNodeStyles = getMarksFromStyles(docx, parentStyleId);
  if (hasRunProperties) {
    const { marks = [] } = parseProperties(node2);
    let runStyleAttributes = [];
    const runStyleElement = node2.elements?.find((el) => el.name === "w:rPr")?.elements?.find((el) => el.name === "w:rStyle");
    let runStyleId;
    if (runStyleElement && runStyleElement.attributes?.["w:val"] && docx) {
      runStyleId = runStyleElement.attributes["w:val"];
      const runStyleDefinition = getMarksFromStyles(docx, runStyleId);
      if (runStyleDefinition.marks && runStyleDefinition.marks.length > 0) {
        runStyleAttributes = runStyleDefinition.marks;
      }
    }
    let paragraphStyleAttributes = [];
    if (defaultNodeStyles.marks) {
      paragraphStyleAttributes = defaultNodeStyles.marks.filter((mark) => {
        if (["bold"].includes(mark.type) && marks.find((m2) => m2.type === "bold")?.attrs?.value === "0") {
          return false;
        }
        return true;
      });
    }
    const combinedMarks = [...paragraphStyleAttributes];
    runStyleAttributes.forEach((runStyle) => {
      const exists = combinedMarks.some(
        (mark) => mark.type === runStyle.type && JSON.stringify(mark.attrs || {}) === JSON.stringify(runStyle.attrs || {})
      );
      if (!exists) {
        combinedMarks.push(runStyle);
      }
    });
    marks.forEach((mark) => {
      const exists = combinedMarks.some(
        (existing) => existing.type === mark.type && JSON.stringify(existing.attrs || {}) === JSON.stringify(mark.attrs || {})
      );
      if (!exists) {
        combinedMarks.push(mark);
      }
    });
    if (runStyleId) combinedMarks.push({ type: "textStyle", attrs: { styleId: runStyleId } });
    if (node2.marks) combinedMarks.push(...node2.marks);
    const newMarks = createImportMarks(combinedMarks);
    processedRun = processedRun.map((n) => {
      const existingMarks = n.marks || [];
      return {
        ...n,
        marks: [...newMarks, ...existingMarks]
      };
    });
  }
  return { nodes: processedRun, consumed: 1 };
};
const getMarksFromStyles = (docx, styleId) => {
  const styles = docx?.["word/styles.xml"];
  if (!styles) {
    return {};
  }
  const styleTags = styles.elements[0].elements.filter((style2) => style2.name === "w:style");
  const style = styleTags.find((tag) => tag.attributes["w:styleId"] === styleId) || {};
  if (!style) return {};
  return parseProperties(style);
};
const runNodeHandlerEntity = {
  handlerName: "runNodeHandler",
  handler: handleRunNode
};
const handleTextNode = (params) => {
  const { nodes, insideTrackChange } = params;
  if (nodes.length === 0 || !(nodes[0].name === "w:t" || insideTrackChange && nodes[0].name === "w:delText")) {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const { type: type2 } = node2;
  const { attributes, elements, marks = [] } = parseProperties(node2);
  let text;
  if (elements.length === 1) {
    text = elements[0].text;
    text = text.replace(/\[\[sdspace\]\]/g, "");
  } else if (!elements.length && "attributes" in node2 && node2.attributes["xml:space"] === "preserve") {
    text = " ";
  } else return { nodes: [], consumed: 0 };
  return {
    nodes: [
      {
        type: getElementName(node2),
        text,
        attrs: { type: type2, attributes: attributes || {} },
        marks
      }
    ],
    consumed: 1
  };
};
const textNodeHandlerEntity = {
  handlerName: "textNodeHandler",
  handler: handleTextNode
};
const mergeTextNodes = (nodes) => {
  if (!nodes || !Array.isArray(nodes)) {
    return nodes;
  }
  let mergedNodes = [];
  let prevTextNode = null;
  for (let node2 of nodes) {
    if (node2.type === "text") {
      if (prevTextNode && canMergeTextNodes(prevTextNode, node2)) {
        prevTextNode = {
          ...prevTextNode,
          text: prevTextNode.text += node2.text
        };
      } else {
        if (prevTextNode) mergedNodes.push(prevTextNode);
        prevTextNode = { ...node2 };
      }
    } else {
      if (prevTextNode) {
        mergedNodes.push(prevTextNode);
        prevTextNode = null;
      }
      mergedNodes.push(node2);
    }
  }
  if (prevTextNode) {
    mergedNodes.push(prevTextNode);
  }
  return mergedNodes;
};
const canMergeTextNodes = (nodeA, nodeB) => {
  if (!nodeA || !nodeB) return false;
  let marksA = nodeA.marks ?? [];
  let marksB = nodeB.marks ?? [];
  if (marksA.length !== marksB.length) {
    return false;
  }
  for (let i = 0; i < marksA.length; i++) {
    if (!marksA[i].attrs) marksA[i].attrs = {};
    if (!marksB[i].attrs) marksB[i].attrs = {};
    if (marksA[i].type !== marksB[i].type || Object.keys(marksA[i].attrs).length !== Object.keys(marksB[i].attrs).length || !areAttrsEqual(marksA[i].attrs, marksB[i].attrs)) {
      return false;
    }
  }
  return true;
};
const areAttrsEqual = (attrsA = {}, attrsB = {}) => {
  return objectIncludes(attrsA, attrsB);
};
const kebabCase = (str) => str.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);
const comments_module_events = Object.freeze({
  RESOLVED: "resolved",
  NEW: "new",
  ADD: "add",
  UPDATE: "update",
  DELETED: "deleted",
  PENDING: "pending",
  SELECTED: "selected",
  // Comments list
  COMMENTS_LIST: "comments-list",
  // Tracked changes
  CHANGE_ACCEPTED: "change-accepted",
  CHANGE_REJECTED: "change-rejected"
});
const getFileObject = async (fileUrl, name, type2) => {
  const response = await fetch(fileUrl);
  const blob = await response.blob();
  return new File([blob], name, { type: type2 });
};
const vClickOutside = {
  mounted(el, binding) {
    const clickOutsideHandler = (event) => {
      if (!el.contains(event.target)) {
        binding.value(event);
      }
    };
    document.addEventListener("click", clickOutsideHandler);
    el.__clickOutsideHandler = clickOutsideHandler;
  },
  unmounted(el) {
    document.removeEventListener("click", el.__clickOutsideHandler);
    delete el.__clickOutsideHandler;
  }
};
const _hoisted_1 = ["accept"];
const _sfc_main = {
  __name: "BasicUpload",
  props: {
    accept: {
      type: String,
      default: ".docx, .pdf, .html, .md"
    }
  },
  emits: ["file-change"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const onFileChange = (event) => {
      emit("file-change", event.target.files[0]);
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", null, [
        createElementVNode("input", {
          type: "file",
          id: "fileInput",
          onChange: onFileChange,
          accept: __props.accept
        }, null, 40, _hoisted_1)
      ]);
    };
  }
};
const handleParagraphNode = (params) => {
  const { nodes, docx, nodeListHandler: nodeListHandler2, filename } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:p") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = carbonCopy(nodes[0]);
  let schemaNode;
  let processedElements = preProcessNodesForFldChar(node2.elements);
  node2.elements = processedElements;
  const handleStandardNode2 = nodeListHandler2.handlerEntities.find(
    (e) => e.handlerName === "standardNodeHandler"
  )?.handler;
  if (!handleStandardNode2) {
    console.error("Standard node handler not found");
    return { nodes: [], consumed: 0 };
  }
  const updatedParams = { ...params, nodes: [node2] };
  const result = handleStandardNode2(updatedParams);
  if (result.nodes.length === 1) {
    schemaNode = result.nodes[0];
  }
  const pPr = node2.elements?.find((el) => el.name === "w:pPr");
  const styleTag = pPr?.elements?.find((el) => el.name === "w:pStyle");
  const nestedRPr = pPr?.elements?.find((el) => el.name === "w:rPr");
  const framePr = pPr?.elements?.find((el) => el.name === "w:framePr");
  if (nestedRPr) {
    let marks = parseMarks(nestedRPr, []);
    if (!schemaNode.content?.length) {
      let highlightIndex = marks?.findIndex((i) => i.type === "highlight");
      if (highlightIndex !== -1) {
        marks.splice(highlightIndex, 1);
      }
    }
    schemaNode.attrs.marksAttrs = marks;
  }
  let styleId;
  if (styleTag) {
    styleId = styleTag.attributes["w:val"];
    schemaNode.attrs["styleId"] = styleId;
  }
  if (docx) {
    const indent = getParagraphIndent(node2, docx, styleId);
    if (!schemaNode.attrs.indent) {
      schemaNode.attrs.indent = {};
    }
    if (indent.left || indent.left === 0) {
      schemaNode.attrs.indent.left = indent.left;
    }
    if (indent.right || indent.right === 0) {
      schemaNode.attrs.indent.right = indent.right;
    }
    if (indent.firstLine || indent.firstLine === 0) {
      schemaNode.attrs.indent.firstLine = indent.firstLine;
    }
    if (indent.hanging || indent.hanging === 0) {
      schemaNode.attrs.indent.hanging = indent.hanging;
    }
    if (indent.textIndent || indent.textIndent === 0) {
      schemaNode.attrs.textIndent = `${indent.textIndent}in`;
    }
  }
  const justify = pPr?.elements?.find((el) => el.name === "w:jc");
  if (justify && justify.attributes) {
    schemaNode.attrs["textAlign"] = justify.attributes["w:val"];
  }
  const keepLines = pPr?.elements?.find((el) => el.name === "w:keepLines");
  if (keepLines && keepLines.attributes) {
    schemaNode.attrs["keepLines"] = keepLines.attributes["w:val"];
  }
  const keepNext = pPr?.elements?.find((el) => el.name === "w:keepNext");
  if (keepNext && keepNext.attributes) {
    schemaNode.attrs["keepNext"] = keepNext.attributes["w:val"];
  }
  if (docx) {
    const defaultStyleId = node2.attributes?.["w:rsidRDefault"];
    schemaNode.attrs["spacing"] = getParagraphSpacing(node2, docx, styleId, schemaNode.attrs.marksAttrs);
    schemaNode.attrs["rsidRDefault"] = defaultStyleId;
  }
  if (docx) {
    const { justify: justify2 } = getDefaultParagraphStyle(docx, styleId);
    if (justify2) {
      schemaNode.attrs.justify = {
        val: justify2["w:val"]
      };
    }
  }
  if (framePr && framePr.attributes["w:dropCap"]) {
    schemaNode.attrs.dropcap = {
      type: framePr.attributes["w:dropCap"],
      lines: framePr.attributes["w:lines"],
      wrap: framePr.attributes["w:wrap"],
      hAnchor: framePr.attributes["w:hAnchor"],
      vAnchor: framePr.attributes["w:vAnchor"]
    };
  }
  schemaNode.attrs["filename"] = filename;
  const tabs = pPr?.elements?.find((el) => el.name === "w:tabs");
  if (tabs && tabs.elements) {
    const tabStops = tabs.elements.filter((el) => el.name === "w:tab").map((tab) => {
      let val = tab.attributes["w:val"] || "start";
      if (val == "left") {
        val = "start";
      } else if (val == "right") {
        val = "end";
      }
      const tabStop = {
        val,
        pos: twipsToPixels(tab.attributes["w:pos"])
      };
      if (tab.attributes["w:leader"]) {
        tabStop.leader = tab.attributes["w:leader"];
      }
      return tabStop;
    });
    if (tabStops.length > 0) {
      schemaNode.attrs.tabStops = tabStops;
    }
  }
  if (schemaNode && schemaNode.content) {
    schemaNode = {
      ...schemaNode,
      content: mergeTextNodes(schemaNode.content)
    };
  }
  const sectPr = pPr?.elements?.find((el) => el.name === "w:sectPr");
  if (sectPr) {
    if (!schemaNode.attrs.paragraphProperties) schemaNode.attrs.paragraphProperties = {};
    schemaNode.attrs.paragraphProperties.sectPr = sectPr;
    schemaNode.attrs.pageBreakSource = "sectPr";
  }
  return { nodes: schemaNode ? [schemaNode] : [], consumed: 1 };
};
const getParagraphIndent = (node2, docx, styleId = "") => {
  const indent = {
    left: 0,
    right: 0,
    firstLine: 0,
    hanging: 0,
    textIndent: 0
  };
  const { indent: pDefaultIndent = {} } = getDefaultParagraphStyle(docx, styleId);
  const pPr = node2.elements?.find((el) => el.name === "w:pPr");
  const inLineIndentTag = pPr?.elements?.find((el) => el.name === "w:ind");
  const inLineIndent = inLineIndentTag?.attributes || {};
  const leftIndent = inLineIndent?.["w:left"] || pDefaultIndent?.["w:left"];
  const rightIndent = inLineIndent?.["w:right"] || pDefaultIndent?.["w:right"];
  const firstLine = inLineIndent?.["w:firstLine"] || pDefaultIndent?.["w:firstLine"];
  const hanging = inLineIndent?.["w:hanging"] || pDefaultIndent?.["w:hanging"];
  if (leftIndent) {
    indent.left = twipsToPixels(leftIndent);
  }
  if (rightIndent) {
    indent.right = twipsToPixels(rightIndent);
  }
  if (firstLine) {
    indent.firstLine = twipsToPixels(firstLine);
  }
  if (hanging) {
    indent.hanging = twipsToPixels(hanging);
  }
  const textIndentValue = leftIndent - parseInt(hanging || 0) || 0;
  if (textIndentValue) {
    indent.textIndent = twipsToInches(textIndentValue);
  }
  return indent;
};
const getParagraphSpacing = (node2, docx, styleId = "", marks = []) => {
  const spacing = {};
  const { spacing: pDefaultSpacing = {} } = getDefaultParagraphStyle(docx, styleId);
  let lineSpaceAfter, lineSpaceBefore, line, lineRuleStyle;
  const pPr = node2.elements?.find((el) => el.name === "w:pPr");
  const inLineSpacingTag = pPr?.elements?.find((el) => el.name === "w:spacing");
  const inLineSpacing = inLineSpacingTag?.attributes || {};
  const textStyleMark = marks.find((el) => el.type === "textStyle");
  const fontSize = textStyleMark?.attrs?.fontSize;
  const lineSpacing = inLineSpacing?.["w:line"] || line || pDefaultSpacing?.["w:line"];
  if (lineSpacing) spacing.line = twipsToLines(lineSpacing);
  const lineRule = inLineSpacing?.["w:lineRule"] || lineRuleStyle || pDefaultSpacing?.["w:lineRule"];
  if (lineRule) spacing.lineRule = lineRule;
  if (lineRule === "exact" && lineSpacing) {
    spacing.line = `${twipsToPt(lineSpacing)}pt`;
  }
  const beforeSpacing = inLineSpacing?.["w:before"] || lineSpaceBefore || pDefaultSpacing?.["w:before"];
  if (beforeSpacing) spacing.lineSpaceBefore = twipsToPixels(beforeSpacing);
  const beforeAutospacing = inLineSpacing?.["w:beforeAutospacing"];
  if (beforeAutospacing === "1" && fontSize) {
    spacing.lineSpaceBefore += Math.round(parseInt(fontSize) * 0.5 * 96 / 72);
  }
  const afterSpacing = inLineSpacing?.["w:after"] || lineSpaceAfter || pDefaultSpacing?.["w:after"];
  if (afterSpacing) spacing.lineSpaceAfter = twipsToPixels(afterSpacing);
  const afterAutospacing = inLineSpacing?.["w:afterAutospacing"];
  if (afterAutospacing === "1" && fontSize) {
    spacing.lineSpaceAfter += Math.round(parseInt(fontSize) * 0.5 * 96 / 72);
  }
  return spacing;
};
const getDefaultParagraphStyle = (docx, styleId = "") => {
  const styles = docx["word/styles.xml"];
  if (!styles) {
    return {};
  }
  const defaults = styles.elements[0].elements?.find((el) => el.name === "w:docDefaults");
  const pDefault = defaults.elements.find((el) => el.name === "w:pPrDefault");
  const pPrDefault = pDefault?.elements?.find((el) => el.name === "w:pPr");
  const pPrDefaultSpacingTag = pPrDefault?.elements?.find((el) => el.name === "w:spacing") || {};
  const pPrDefaultIndentTag = pPrDefault?.elements?.find((el) => el.name === "w:ind") || {};
  const stylesNormal = styles.elements[0].elements?.find(
    (el) => el.name === "w:style" && el.attributes["w:styleId"] === "Normal"
  );
  const pPrNormal = stylesNormal?.elements?.find((el) => el.name === "w:pPr");
  const pPrNormalSpacingTag = pPrNormal?.elements?.find((el) => el.name === "w:spacing") || {};
  const pPrNormalIndentTag = pPrNormal?.elements?.find((el) => el.name === "w:ind") || {};
  const isNormalAsDefault = stylesNormal?.attributes?.["w:default"] === "1";
  let pPrStyleIdSpacingTag = {};
  let pPrStyleIdIndentTag = {};
  let pPrStyleJc = {};
  if (styleId) {
    const stylesById = styles.elements[0].elements?.find(
      (el) => el.name === "w:style" && el.attributes["w:styleId"] === styleId
    );
    const pPrById = stylesById?.elements?.find((el) => el.name === "w:pPr");
    pPrStyleIdSpacingTag = pPrById?.elements?.find((el) => el.name === "w:spacing") || {};
    pPrStyleIdIndentTag = pPrById?.elements?.find((el) => el.name === "w:ind") || {};
    pPrStyleJc = pPrById?.elements?.find((el) => el.name === "w:jc") || {};
  }
  const { attributes: pPrDefaultSpacingAttr } = pPrDefaultSpacingTag;
  const { attributes: pPrNormalSpacingAttr } = pPrNormalSpacingTag;
  const { attributes: pPrByIdSpacingAttr } = pPrStyleIdSpacingTag;
  const { attributes: pPrByIdJcAttr } = pPrStyleJc;
  const { attributes: pPrDefaultIndentAttr } = pPrDefaultIndentTag;
  const { attributes: pPrNormalIndentAttr } = pPrNormalIndentTag;
  const { attributes: pPrByIdIndentAttr } = pPrStyleIdIndentTag;
  const spacingRest = isNormalAsDefault ? pPrNormalSpacingAttr || pPrDefaultSpacingAttr : pPrDefaultSpacingAttr || pPrNormalSpacingAttr;
  const indentRest = isNormalAsDefault ? pPrNormalIndentAttr || pPrDefaultIndentAttr : pPrDefaultIndentAttr || pPrNormalIndentAttr;
  return {
    spacing: pPrByIdSpacingAttr || spacingRest,
    indent: pPrByIdIndentAttr || indentRest,
    justify: pPrByIdJcAttr
  };
};
const paragraphNodeHandlerEntity = {
  handlerName: "paragraphNodeHandler",
  handler: handleParagraphNode
};
function getDefaultStyleDefinition(defaultStyleId, docx) {
  const result = { lineSpaceBefore: null, lineSpaceAfter: null };
  if (!defaultStyleId) return result;
  const styles = docx["word/styles.xml"];
  if (!styles) return result;
  const { elements } = styles.elements[0];
  const elementsWithId = elements.filter((el) => {
    const { attributes } = el;
    return attributes && attributes["w:styleId"] === defaultStyleId;
  });
  const firstMatch = elementsWithId[0];
  if (!firstMatch) return result;
  const qFormat = elementsWithId.find((el) => {
    const qFormat2 = el.elements.find((innerEl) => innerEl.name === "w:qFormat");
    return qFormat2;
  });
  const name = elementsWithId.find((el) => el.elements.some((inner) => inner.name === "w:name"))?.elements.find((inner) => inner.name === "w:name")?.attributes["w:val"];
  const pPr = firstMatch.elements.find((el) => el.name === "w:pPr");
  const spacing = pPr?.elements?.find((el) => el.name === "w:spacing");
  const justify = pPr?.elements?.find((el) => el.name === "w:jc");
  const indent = pPr?.elements?.find((el) => el.name === "w:ind");
  let lineSpaceBefore, lineSpaceAfter, line;
  if (spacing) {
    lineSpaceBefore = twipsToPixels(spacing?.attributes["w:before"]);
    lineSpaceAfter = twipsToPixels(spacing?.attributes["w:after"]);
    line = twipsToLines(spacing?.attributes["w:line"]);
  }
  let textAlign, leftIndent, rightIndent, firstLine;
  if (indent) {
    textAlign = justify?.attributes["w:val"];
    leftIndent = twipsToPixels(indent?.attributes["w:left"]);
    rightIndent = twipsToPixels(indent?.attributes["w:right"]);
    firstLine = twipsToPixels(indent?.attributes["w:firstLine"]);
  }
  const keepNext = pPr?.elements?.find((el) => el.name === "w:keepNext");
  const keepLines = pPr?.elements?.find((el) => el.name === "w:keepLines");
  const outlineLevel = pPr?.elements?.find((el) => el.name === "w:outlineLvl");
  const outlineLvlValue = outlineLevel?.attributes["w:val"];
  const pageBreakBefore = pPr?.elements?.find((el) => el.name === "w:pageBreakBefore");
  let pageBreakBeforeVal = 0;
  if (pageBreakBefore) {
    if (!pageBreakBefore.attributes?.["w:val"]) pageBreakBeforeVal = 1;
    else pageBreakBeforeVal = Number(pageBreakBefore?.attributes?.["w:val"]);
  }
  const pageBreakAfter = pPr?.elements?.find((el) => el.name === "w:pageBreakAfter");
  let pageBreakAfterVal;
  if (pageBreakAfter) {
    if (!pageBreakAfter.attributes?.["w:val"]) pageBreakAfterVal = 1;
    else pageBreakAfterVal = Number(pageBreakAfter?.attributes?.["w:val"]);
  }
  const basedOn = elementsWithId.find((el) => el.elements.some((inner) => inner.name === "w:basedOn"))?.elements.find((inner) => inner.name === "w:basedOn")?.attributes["w:val"];
  const parsedAttrs = {
    name,
    qFormat: qFormat ? true : false,
    keepNext: keepNext ? true : false,
    keepLines: keepLines ? true : false,
    outlineLevel: outlineLevel ? parseInt(outlineLvlValue) : null,
    pageBreakBefore: pageBreakBeforeVal ? true : false,
    pageBreakAfter: pageBreakAfterVal ? true : false,
    basedOn: basedOn ?? null
  };
  const rPr = firstMatch.elements.find((el) => el.name === "w:rPr");
  const parsedMarks = parseMarks(rPr, [], docx) || {};
  const parsedStyles = {
    spacing: { lineSpaceAfter, lineSpaceBefore, line },
    textAlign,
    indent: { leftIndent, rightIndent, firstLine }
  };
  parsedMarks.forEach((mark) => {
    const { type: type2, attrs } = mark;
    if (type2 === "textStyle") {
      Object.entries(attrs).forEach(([key, value]) => {
        parsedStyles[kebabCase(key)] = value;
      });
      return;
    }
    parsedStyles[type2] = attrs;
  });
  return {
    attrs: parsedAttrs,
    styles: parsedStyles
  };
}
function preProcessNodesForFldChar(nodes = []) {
  const processedNodes = [];
  let buffer2 = [];
  let collecting = false;
  for (const node2 of nodes) {
    const fldCharEl = node2.elements?.find((el) => el.name === "w:fldChar");
    const fldType = fldCharEl?.attributes?.["w:fldCharType"];
    if (fldType === "begin") {
      buffer2 = [node2];
      collecting = true;
      continue;
    }
    if (fldType === "separate" && collecting) {
      buffer2.push(node2);
      continue;
    }
    if (fldType === "end" && collecting) {
      buffer2.push(node2);
      processedNodes.push(...processCombinedNodesForFldChar(buffer2));
      buffer2 = [];
      collecting = false;
      continue;
    }
    if (collecting) {
      buffer2.push(node2);
    } else {
      processedNodes.push(node2);
    }
  }
  if (buffer2.length) {
    processedNodes.push(...buffer2);
  }
  return processedNodes;
}
const processCombinedNodesForFldChar = (nodesToCombine = []) => {
  let processedNodes = [];
  let hasPageMarker = false;
  let isNumPages = false;
  const textStart = nodesToCombine.findIndex(
    (n) => n.elements?.some((el) => el.name === "w:fldChar" && el.attributes["w:fldCharType"] === "separate")
  );
  const textEnd = nodesToCombine.findIndex(
    (n) => n.elements?.some((el) => el.name === "w:fldChar" && el.attributes["w:fldCharType"] === "end")
  );
  const textNodes = nodesToCombine.slice(textStart + 1, textEnd);
  const instrTextContainer = nodesToCombine.find((n) => n.elements?.some((el) => el.name === "w:instrText"));
  const instrTextNode = instrTextContainer?.elements?.find((el) => el.name === "w:instrText");
  const instrText = instrTextNode?.elements[0].text;
  if (!hasPageMarker) hasPageMarker = instrText?.trim().startsWith("PAGE");
  if (!isNumPages) isNumPages = instrText?.trim().startsWith("NUMPAGES");
  const urlMatch = instrText?.match(/HYPERLINK\s+"([^"]+)"/);
  if (hasPageMarker) {
    const pageNumNode = {
      name: "sd:autoPageNumber",
      type: "element"
    };
    nodesToCombine.forEach((n) => {
      const rPrNode = n.elements.find((el) => el.name === "w:rPr");
      if (rPrNode) pageNumNode.elements = [rPrNode];
    });
    processedNodes.push(pageNumNode);
  } else if (isNumPages) {
    const totalPageNumNode = {
      name: "sd:totalPageNumber",
      type: "element"
    };
    nodesToCombine.forEach((n) => {
      const rPrNode = n.elements.find((el) => el.name === "w:rPr");
      if (rPrNode) totalPageNumNode.elements = [rPrNode];
    });
    processedNodes.push(totalPageNumNode);
  } else if (urlMatch && urlMatch?.length >= 2) {
    const url = urlMatch[1];
    const textMarks = [];
    textNodes.forEach((n) => {
      const rPr2 = n.elements.find((el) => el.name === "w:rPr");
      if (!rPr2) return;
      const { elements } = rPr2;
      elements.forEach((el) => {
        textMarks.push(el);
      });
    });
    const linkMark = { name: "link", attributes: { href: url } };
    const rPr = { name: "w:rPr", type: "element", elements: [linkMark, ...textMarks] };
    processedNodes.push({
      name: "w:r",
      type: "element",
      elements: [rPr, ...textNodes]
    });
  }
  return processedNodes;
};
const tableOfContentsHandler = (params) => {
  return nodeListHandler.handler({ ...params, nodes: node.elements });
};
const handleDocPartObj = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:sdt") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const sdtPr = node2.elements.find((el) => el.name === "w:sdtPr");
  const docPartObj = sdtPr?.elements.find((el) => el.name === "w:docPartObj");
  const docPartGallery = docPartObj?.elements.find((el) => el.name === "w:docPartGallery");
  const docPartGalleryType = docPartGallery?.attributes["w:val"];
  if (!docPartGalleryType) {
    return { nodes: [], consumed: 0 };
  }
  if (!validGalleryTypeMap[docPartGalleryType]) {
    return { nodes: [], consumed: 0 };
  }
  const content = node2?.elements.find((el) => el.name === "w:sdtContent");
  const handler = validGalleryTypeMap[docPartGalleryType];
  const result = handler({ ...params, nodes: [content] });
  return {
    nodes: result,
    consumed: 1
  };
};
const validGalleryTypeMap = {
  "Table of Contents": tableOfContentsHandler
};
const handleAnnotationNode = (params) => {
  const { nodes, docx, nodeListHandler: nodeListHandler2, insideTrackChange } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:sdt") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const sdtPr = node2.elements.find((el) => el.name === "w:sdtPr");
  const sdtContent = node2.elements.find((el) => el.name === "w:sdtContent");
  const docPartObj = sdtPr?.elements.find((el) => el.name === "w:docPartObj");
  if (docPartObj) {
    return handleDocPartObj({ nodes, docx, nodeListHandler: nodeListHandler2, insideTrackChange });
  }
  const alias = sdtPr?.elements.find((el) => el.name === "w:alias");
  const tag = sdtPr?.elements.find((el) => el.name === "w:tag");
  const tagValue = tag?.attributes["w:val"];
  const processAsJSON = tagValue?.startsWith("{") && tagValue?.endsWith("}");
  let attrs = {};
  if (processAsJSON) {
    const parsedAttrs = parseTagAttrsJSON(tagValue);
    const attrsFromJSON = {
      type: parsedAttrs.fieldTypeShort,
      fieldId: parsedAttrs.fieldId,
      displayLabel: parsedAttrs.displayLabel,
      defaultDisplayLabel: parsedAttrs.defaultDisplayLabel,
      fieldType: parsedAttrs.fieldType,
      fieldColor: parsedAttrs.fieldColor,
      multipleImage: parsedAttrs.fieldMultipleImage,
      fontFamily: parsedAttrs.fieldFontFamily,
      fontSize: parsedAttrs.fieldFontSize,
      textColor: parsedAttrs.fieldTextColor,
      textHighlight: parsedAttrs.fieldTextHighlight,
      hash: parsedAttrs.hash
    };
    attrs = attrsFromJSON;
  } else {
    const attrsFromElements = getAttrsFromElements({ sdtPr, tag, alias });
    attrs = attrsFromElements;
  }
  const { attrs: marksAsAttrs, marks } = parseAnnotationMarks(sdtContent);
  const allAttrs = { ...attrs, ...marksAsAttrs };
  if (!allAttrs.hash) allAttrs.hash = generateDocxRandomId(4);
  if (!attrs.fieldId || !attrs.type) {
    return { nodes: [], consumed: 0 };
  }
  let result = {
    type: "text",
    text: `{{${attrs.displayLabel}}}`,
    attrs: allAttrs,
    marks
  };
  if (params.editor.options.annotations) {
    result = {
      type: "fieldAnnotation",
      attrs: allAttrs
    };
  }
  return {
    nodes: [result],
    consumed: 1
  };
};
const parseAnnotationMarks = (content = {}) => {
  let mainContent = content;
  const run2 = mainContent.elements?.find((el) => el.name === "w:r");
  const rPr = run2?.elements?.find((el) => el.name === "w:rPr");
  if (!rPr) return {};
  const unknownMarks = [];
  const marks = parseMarks(rPr, unknownMarks) || [];
  const marksWithFlatFontStyles = [];
  marks.forEach((mark) => {
    const { type: type2 } = mark;
    if (type2 === "textStyle") {
      const { attrs: attrs2 } = mark;
      Object.keys(attrs2).forEach((key) => {
        marksWithFlatFontStyles.push({ type: key, attrs: attrs2[key] });
      });
    } else {
      marksWithFlatFontStyles.push(mark);
    }
  });
  const attrs = {};
  marksWithFlatFontStyles?.forEach((mark) => {
    const { type: type2 } = mark;
    attrs[type2] = mark.attrs || true;
  });
  return {
    attrs,
    marks
  };
};
function getAttrsFromElements({ sdtPr, tag, alias }) {
  const type2 = sdtPr?.elements.find((el) => el.name === "w:fieldTypeShort")?.attributes["w:val"];
  const fieldType = sdtPr?.elements.find((el) => el.name === "w:fieldType")?.attributes["w:val"];
  const fieldColor = sdtPr?.elements.find((el) => el.name === "w:fieldColor")?.attributes["w:val"];
  const isMultipleImage = sdtPr?.elements.find((el) => el.name === "w:fieldMultipleImage")?.attributes["w:val"];
  const fontFamily = sdtPr?.elements.find((el) => el.name === "w:fieldFontFamily")?.attributes["w:val"];
  const fontSize = sdtPr?.elements.find((el) => el.name === "w:fieldFontSize")?.attributes["w:val"];
  const textColor = sdtPr?.elements.find((el) => el.name === "w:fieldTextColor")?.attributes["w:val"];
  const textHighlight = sdtPr?.elements.find((el) => el.name === "w:fieldTextHighlight")?.attributes["w:val"];
  const attrs = {
    type: type2,
    fieldId: tag?.attributes["w:val"],
    displayLabel: alias?.attributes["w:val"],
    fieldType,
    fieldColor,
    multipleImage: isMultipleImage === "true",
    fontFamily: fontFamily !== "null" ? fontFamily : null,
    fontSize: fontSize !== "null" ? fontSize : null,
    textColor: textColor !== "null" ? textColor : null,
    textHighlight: textHighlight !== "null" ? textHighlight : null
  };
  return attrs;
}
function parseTagAttrsJSON(json) {
  try {
    const attrs = JSON.parse(json);
    return attrs;
  } catch (err) {
    console.error(err);
    return {};
  }
}
const annotationNodeHandlerEntity = {
  handlerName: "annotationNodeHandler",
  handler: handleAnnotationNode
};
const handleSdtNode = (params) => {
  const { nodes, nodeListHandler: nodeListHandler2 } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:sdt") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const sdtPr = node2.elements.find((el) => el.name === "w:sdtPr");
  const tag = sdtPr?.elements.find((el) => el.name === "w:tag");
  let tagValue = tag?.attributes?.["w:val"];
  try {
    tagValue = JSON.parse(tagValue);
    const { type: type2 } = tagValue;
    if (type2 === "documentSection") return handleDocumentSectionNode(params, tagValue);
  } catch {
  }
  const sdtContent = node2.elements.find((el) => el.name === "w:sdtContent");
  const par = sdtContent?.elements?.find((el) => el.name === "w:p");
  const { marks } = parseAnnotationMarks(sdtContent);
  const translatedContent = nodeListHandler2.handler({ ...params, nodes: sdtContent?.elements });
  let structuredContentType = "structuredContent";
  if (par) {
    structuredContentType = "structuredContentBlock";
  }
  let result = {
    type: structuredContentType,
    content: translatedContent,
    marks,
    attrs: {
      sdtPr
    }
  };
  return {
    nodes: [result],
    consumed: 1
  };
};
const handleDocumentSectionNode = (params, tagValue) => {
  const { nodes, nodeListHandler: nodeListHandler2 } = params;
  const node2 = nodes[0];
  const sdtPr = node2.elements.find((el) => el.name === "w:sdtPr");
  const idTag = sdtPr?.elements.find((el) => el.name === "w:id");
  const id = idTag?.attributes?.["w:val"] || tagValue.id || null;
  const titleTag = sdtPr?.elements.find((el) => el.name === "w:alias");
  const title = titleTag?.attributes?.["w:val"] || tagValue.title || null;
  const { description } = tagValue;
  const sdtContent = node2.elements.find((el) => el.name === "w:sdtContent");
  const translatedContent = nodeListHandler2.handler({ ...params, nodes: sdtContent?.elements });
  const result = {
    type: "documentSection",
    content: translatedContent,
    attrs: {
      id,
      title,
      description
    }
  };
  return {
    nodes: [result],
    consumed: 1
  };
};
const sdtNodeHandlerEntity = {
  handlerName: "sdtNodeHandler",
  handler: handleSdtNode
};
const handleStandardNode = (params) => {
  const { nodes, docx, nodeListHandler: nodeListHandler2 } = params;
  if (!nodes || nodes.length === 0) {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const { name } = node2;
  const { attributes, elements, marks = [] } = parseProperties(node2);
  if (name === "w:sdt") {
    return { nodes: [], consumed: 0 };
  }
  if (isPropertiesElement(node2)) {
    return {
      nodes: [
        {
          type: getElementName(node2),
          attrs: { ...attributes },
          marks: []
        }
      ],
      consumed: 0
    };
  }
  if (!getElementName(node2)) {
    return {
      nodes: [
        {
          type: name,
          content: elements,
          attrs: { ...attributes },
          marks
        }
      ],
      consumed: 0,
      unhandled: true
    };
  }
  const content = [];
  const parentStyleId = getParentStyleId(node2);
  if (elements && elements.length) {
    const updatedElements = elements.map((el) => {
      if (!el.marks) el.marks = [];
      el.marks.push(...marks);
      return el;
    });
    const childParams = { ...params, nodes: updatedElements, parentStyleId };
    const childContent = nodeListHandler2.handler(childParams);
    content.push(...childContent);
  }
  const resultNode = {
    type: getElementName(node2),
    content,
    attrs: { ...attributes },
    marks: []
  };
  return { nodes: [resultNode], consumed: 1 };
};
const getParentStyleId = (node2) => {
  const pPr = node2.elements?.find((el) => el.name === "w:pPr");
  const styleTag = pPr?.elements?.find((el) => el.name === "w:pStyle");
  return styleTag ? styleTag.attributes["w:val"] : null;
};
const standardNodeHandlerEntity = {
  handlerName: "standardNodeHandler",
  handler: handleStandardNode
};
const handleLineBreakNode = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:br") {
    return { nodes: [], consumed: 0 };
  }
  const lineBreakType = nodes[0].attributes?.["w:type"];
  const breakType = lineBreakType === "page" ? "hardBreak" : "lineBreak";
  return {
    nodes: [
      {
        type: breakType
      }
    ],
    consumed: 1
  };
};
const lineBreakNodeHandlerEntity = {
  handlerName: "lineBreakNodeHandler",
  handler: handleLineBreakNode
};
const handleBookmarkNode = (params) => {
  const { nodes, nodeListHandler: nodeListHandler2, editor } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:bookmarkStart") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const handleStandardNode2 = nodeListHandler2.handlerEntities.find(
    (e) => e.handlerName === "standardNodeHandler"
  )?.handler;
  if (!handleStandardNode2) {
    console.error("Standard node handler not found");
    return { nodes: [], consumed: 0 };
  }
  const customMarks = editor?.extensionService?.extensions?.filter((e) => e.isExternal === true) || [];
  const bookmarkName = node2.attributes["w:name"]?.split(";")[0];
  const customMark = customMarks.find((mark) => mark.name === bookmarkName);
  if (customMark) {
    const bookmarkEndIndex = nodes.findIndex(
      (n) => n.name === "w:bookmarkEnd" && n.attributes["w:id"] === node2.attributes["w:id"]
    );
    const textNodes = nodes.slice(1, bookmarkEndIndex);
    const nodeListHandler3 = params.nodeListHandler;
    const attrs = {};
    node2.attributes["w:name"].split(";").forEach((name) => {
      const [key, value] = name.split("=");
      if (key && value) {
        attrs[key] = value;
      }
    });
    const translatedText = nodeListHandler3.handler({ ...params, nodes: textNodes });
    translatedText.forEach((n) => {
      n.marks.push({
        type: customMark.name,
        attrs
      });
    });
    return {
      nodes: translatedText,
      consumed: translatedText.length + 2
    };
  }
  const updatedParams = { ...params, nodes: [node2] };
  const result = handleStandardNode2(updatedParams);
  if (result.nodes.length === 1) {
    result.nodes[0].attrs.name = node2.attributes["w:name"];
    result.nodes[0].attrs.id = node2.attributes["w:id"];
  }
  return result;
};
const bookmarkNodeHandlerEntity = {
  handlerName: "bookmarkNodeHandler",
  handler: handleBookmarkNode
};
const handleAlternateChoice = (params) => {
  const skipHandlerResponse = { nodes: [], consumed: 0 };
  const { nodes, nodeListHandler: nodeListHandler2 } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:p") {
    return skipHandlerResponse;
  }
  const mainNode = nodes[0];
  const node2 = mainNode?.elements?.find((el) => el.name === "w:r");
  const hasAltChoice = node2?.elements?.some((el) => el.name === "mc:AlternateContent");
  if (!hasAltChoice) {
    return skipHandlerResponse;
  }
  const altChoiceNode = node2.elements.find((el) => el.name === "mc:AlternateContent");
  node2.elements.findIndex((el) => el.name === "mc:AlternateContent");
  const allowedNamespaces = ["wps", "wp14", "w14", "w15"];
  const wpsNode = altChoiceNode.elements.find(
    (el) => el.name === "mc:Choice" && allowedNamespaces.includes(el.attributes["Requires"])
  );
  if (!wpsNode) {
    return skipHandlerResponse;
  }
  const contents = wpsNode.elements;
  const result = nodeListHandler2.handler({
    ...params,
    nodes: contents
  });
  return { nodes: result, consumed: 1 };
};
const alternateChoiceHandler = {
  handlerName: "alternateChoiceHandler",
  handler: handleAlternateChoice
};
const handleAutoPageNumber = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== "sd:autoPageNumber") {
    return { nodes: [], consumed: 0 };
  }
  const rPr = nodes[0].elements?.find((el) => el.name === "w:rPr");
  const marks = parseMarks(rPr || { elements: [] });
  const processedNode = {
    type: "page-number",
    attrs: {
      marksAsAttrs: marks
    }
  };
  return { nodes: [processedNode], consumed: 1 };
};
const autoPageHandlerEntity = {
  handlerName: "autoPageNumberHandler",
  handler: handleAutoPageNumber
};
const handleAutoTotalPageNumber = (params) => {
  const { nodes } = params;
  if (nodes.length === 0 || nodes[0].name !== "sd:totalPageNumber") {
    return { nodes: [], consumed: 0 };
  }
  const rPr = nodes[0].elements?.find((el) => el.name === "w:rPr");
  const marks = parseMarks(rPr || { elements: [] });
  const processedNode = {
    type: "total-page-number",
    attrs: {
      marksAsAttrs: marks
    }
  };
  return { nodes: [processedNode], consumed: 1 };
};
const autoTotalPageCountEntity = {
  handlerName: "autoTotalPageCountEntity",
  handler: handleAutoTotalPageNumber
};
const handleTabNode = (params) => {
  const { nodes, docx, parentStyleId } = params;
  if (nodes.length === 0 || nodes[0].name !== "w:tab") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const styles = docx["word/styles.xml"];
  if (styles && styles.elements?.length) {
    const style = styles.elements[0]?.elements?.find((s) => s.attributes?.["w:styleId"] === parentStyleId);
    const pPr = style?.elements?.find((s) => s.name === "w:pPr");
    const tabsDef = pPr?.elements?.find((s) => s.name === "w:tabs");
    const firstTab = tabsDef?.elements?.find((s) => s.name === "w:tab");
    twipsToPixels(firstTab?.attributes?.["w:pos"]);
  }
  const { attributes = {} } = node2;
  const processedNode = {
    type: "tab",
    attrs: {
      tabSize: attributes["w:val"] || 48
    },
    content: []
  };
  return { nodes: [processedNode], consumed: 1 };
};
const tabNodeEntityHandler = {
  handlerName: "tabNodeHandler",
  handler: handleTabNode
};
const handlePictNode = (params) => {
  const { nodes } = params;
  if (!nodes.length || nodes[0].name !== "w:p") {
    return { nodes: [], consumed: 0 };
  }
  const [pNode] = nodes;
  const run2 = pNode.elements?.find((el) => el.name === "w:r");
  const pict = run2?.elements?.find((el) => el.name === "w:pict");
  if (!pict) {
    return { nodes: [], consumed: 0 };
  }
  const node2 = pict;
  const shape = node2.elements?.find((el) => el.name === "v:shape");
  const group = node2.elements?.find((el) => el.name === "v:group");
  const rect = node2.elements?.find((el) => el.name === "v:rect");
  if (rect) {
    const result2 = handleVRectImport({
      pNode,
      rect
    });
    return { nodes: result2 ? [result2] : [], consumed: 1 };
  }
  if (!shape && !group) {
    return { nodes: [], consumed: 0 };
  }
  let result = null;
  const isGroup = group && !shape;
  if (isGroup) {
    result = null;
  } else {
    const textbox = shape.elements?.find((el) => el.name === "v:textbox");
    if (textbox) {
      result = handleShapTextboxImport({
        shape,
        params
      });
    }
  }
  return { nodes: result ? [result] : [], consumed: 1 };
};
function handleVRectImport({ rect, pNode }) {
  const schemaAttrs = {};
  const rectAttrs = rect.attributes || {};
  schemaAttrs.attributes = rectAttrs;
  if (rectAttrs.style) {
    const parsedStyle = parseInlineStyles(rectAttrs.style);
    const rectStyle = buildVRectStyles(parsedStyle);
    if (rectStyle) {
      schemaAttrs.style = rectStyle;
    }
    const size = {};
    if (parsedStyle.width !== void 0) {
      const inlineWidth = parsePointsToPixels(parsedStyle.width);
      size.width = inlineWidth;
      if (rectAttrs["o:hr"] === "t" && !inlineWidth) {
        size.width = "100%";
      }
    }
    if (parsedStyle.height !== void 0) {
      size.height = parsePointsToPixels(parsedStyle.height);
    }
    if (Object.keys(size).length > 0) {
      schemaAttrs.size = size;
    }
  }
  if (rectAttrs.fillcolor) {
    schemaAttrs.background = rectAttrs.fillcolor;
  }
  const vmlAttrs = {};
  if (rectAttrs["o:hralign"]) vmlAttrs.hralign = rectAttrs["o:hralign"];
  if (rectAttrs["o:hrstd"]) vmlAttrs.hrstd = rectAttrs["o:hrstd"];
  if (rectAttrs["o:hr"]) vmlAttrs.hr = rectAttrs["o:hr"];
  if (rectAttrs.stroked) vmlAttrs.stroked = rectAttrs.stroked;
  if (Object.keys(vmlAttrs).length > 0) {
    schemaAttrs.vmlAttributes = vmlAttrs;
  }
  const isHorizontalRule = rectAttrs["o:hr"] === "t" || rectAttrs["o:hrstd"] === "t";
  if (isHorizontalRule) {
    schemaAttrs.horizontalRule = true;
  }
  const pPr = pNode.elements?.find((el) => el.name === "w:pPr");
  const spacingElement = pPr?.elements?.find((el) => el.name === "w:spacing");
  const spacingAttrs = spacingElement?.attributes || {};
  const inLineIndentTag = pPr?.elements?.find((el) => el.name === "w:ind");
  const inLineIndent = inLineIndentTag?.attributes || {};
  const spacing = {};
  if (spacingAttrs["w:after"]) spacing.lineSpaceAfter = twipsToPixels(spacingAttrs["w:after"]);
  if (spacingAttrs["w:before"]) spacing.lineSpaceBefore = twipsToPixels(spacingAttrs["w:before"]);
  if (spacingAttrs["w:line"]) spacing.line = twipsToLines(spacingAttrs["w:line"]);
  if (spacingAttrs["w:lineRule"]) spacing.lineRule = spacingAttrs["w:lineRule"];
  const indent = {
    left: 0,
    right: 0,
    firstLine: 0,
    hanging: 0
  };
  const leftIndent = inLineIndent?.["w:left"];
  const rightIndent = inLineIndent?.["w:right"];
  if (leftIndent) {
    indent.left = twipsToPixels(leftIndent);
  }
  if (rightIndent) {
    indent.right = twipsToPixels(rightIndent);
  }
  return {
    type: "paragraph",
    content: [
      {
        type: "contentBlock",
        attrs: schemaAttrs
      }
    ],
    attrs: {
      spacing: Object.keys(spacing).length > 0 ? spacing : void 0,
      rsidRDefault: pNode.attributes?.["w:rsidRDefault"],
      indent
    }
  };
}
function handleShapTextboxImport({ shape, params }) {
  const schemaAttrs = {};
  const schemaTextboxAttrs = {};
  const shapeAttrs = shape.attributes || {};
  schemaAttrs.attributes = shapeAttrs;
  if (shapeAttrs.fillcolor) {
    schemaAttrs.fillcolor = shapeAttrs.fillcolor;
  }
  const parsedStyle = parseInlineStyles(shapeAttrs.style);
  const shapeStyle = buildStyles(parsedStyle);
  if (shapeStyle) {
    schemaAttrs.style = shapeStyle;
  }
  const textbox = shape.elements?.find((el) => el.name === "v:textbox");
  const wrap2 = shape.elements?.find((el) => el.name === "w10:wrap");
  if (wrap2?.attributes) {
    schemaAttrs.wrapAttributes = wrap2.attributes;
  }
  if (textbox?.attributes) {
    schemaTextboxAttrs.attributes = textbox.attributes;
  }
  const textboxContent = textbox?.elements?.find((el) => el.name === "w:txbxContent");
  const textboxContentElems = textboxContent?.elements || [];
  const content = textboxContentElems.map(
    (elem) => handleParagraphNode({
      nodes: [elem],
      docx: params.docx,
      nodeListHandler: defaultNodeListHandler()
    })
  );
  const contentNodes = content.reduce((acc, current) => [...acc, ...current.nodes], []);
  const shapeTextbox = {
    type: "shapeTextbox",
    attrs: schemaTextboxAttrs,
    content: contentNodes
  };
  const shapeContainer = {
    type: "shapeContainer",
    attrs: schemaAttrs,
    content: [shapeTextbox]
  };
  return shapeContainer;
}
function parseInlineStyles(styleString) {
  if (!styleString) return {};
  return styleString.split(";").filter((style) => !!style.trim()).reduce((acc, style) => {
    const [prop, value] = style.split(":").map((str) => str.trim());
    if (prop && value) acc[prop] = value;
    return acc;
  }, {});
}
function buildStyles(styleObject) {
  const allowed = [
    "width",
    "height"
    // these styles should probably work relative to the page,
    // since in the doc it is positioned absolutely.
    // 'margin-left',
    // 'margin-right',
    // causes pagination issues.
    // 'margin-top',
    // 'margin-bottom',
    // styleObject - also contains other word styles (mso-).
  ];
  let style = "";
  for (const [prop, value] of Object.entries(styleObject)) {
    if (allowed.includes(prop)) {
      style += `${prop}: ${value};`;
    }
  }
  return style;
}
function buildVRectStyles(styleObject) {
  let style = "";
  for (const [prop, value] of Object.entries(styleObject)) {
    style += `${prop}: ${value};`;
  }
  return style;
}
function parsePointsToPixels(value) {
  if (typeof value !== "string") return value;
  if (value.endsWith("pt")) {
    const val = value.replace("pt", "");
    if (isNaN(val)) {
      return 0;
    }
    const points = parseFloat(val);
    return Math.ceil(points * 1.33);
  }
  if (value.endsWith("px")) {
    const val = value.replace("px", "");
    if (isNaN(val)) {
      return 0;
    }
    return parseInt(val);
  }
  const numValue = parseFloat(value);
  return isNaN(numValue) ? 0 : numValue;
}
const pictNodeHandlerEntity = {
  handlerName: "handlePictNode",
  handler: handlePictNode
};
function importCommentData({ docx, editor, converter }) {
  const nodeListHandler2 = defaultNodeListHandler();
  const comments = docx["word/comments.xml"];
  if (!comments) return;
  const { elements } = comments;
  if (!elements || !elements.length) return;
  const { elements: allComments = [] } = elements[0];
  const extractedComments = allComments.map((el) => {
    const { attributes } = el;
    const importedId = attributes["w:id"];
    const authorName = attributes["w:author"];
    const authorEmail = attributes["w:email"];
    const initials = attributes["w:initials"];
    const createdDate = attributes["w:date"];
    const internalId = attributes["custom:internalId"];
    const trackedChange = attributes["custom:trackedChange"] === "true";
    const trackedChangeType = attributes["custom:trackedChangeType"];
    const trackedChangeText = attributes["custom:trackedChangeText"] !== "null" ? attributes["custom:trackedChangeText"] : null;
    const trackedDeletedText = attributes["custom:trackedDeletedText"] !== "null" ? attributes["custom:trackedDeletedText"] : null;
    const date = new Date(createdDate);
    const unixTimestampMs = date.getTime();
    const parsedComment = nodeListHandler2.handler({
      nodes: el.elements,
      nodeListHandler: nodeListHandler2,
      docx,
      editor,
      converter
    });
    const { attrs } = parsedComment[0];
    const paraId = attrs["w14:paraId"];
    return {
      commentId: internalId || v4(),
      importedId,
      creatorName: authorName,
      creatorEmail: authorEmail,
      createdTime: unixTimestampMs,
      textJson: parsedComment[0],
      initials,
      paraId,
      trackedChange,
      trackedChangeText,
      trackedChangeType,
      trackedDeletedText
    };
  });
  const extendedComments = generateCommentsWithExtendedData({ docx, comments: extractedComments });
  return extendedComments;
}
const generateCommentsWithExtendedData = ({ docx, comments }) => {
  const commentsExtended = docx["word/commentsExtended.xml"];
  if (!commentsExtended) return [];
  const { elements: initialElements } = commentsExtended;
  const { elements } = initialElements[0];
  const commentEx = elements.filter((el) => el.name === "w15:commentEx");
  return comments.map((comment) => {
    const extendedDef = commentEx.find((ce2) => ce2.attributes["w15:paraId"] === comment.paraId);
    if (!extendedDef) return { ...comment };
    const { isDone, paraIdParent } = getExtendedDetails(extendedDef);
    let parentComment;
    if (paraIdParent) parentComment = comments.find((c) => c.paraId === paraIdParent);
    const newComment = {
      ...comment,
      isDone,
      parentCommentId: parentComment?.commentId
    };
    return newComment;
  });
};
const getExtendedDetails = (commentEx) => {
  const { attributes } = commentEx;
  const paraId = attributes["w15:paraId"];
  const isDone = attributes["w15:done"] === "1" ? true : false;
  const paraIdParent = attributes["w15:paraIdParent"];
  return { paraId, isDone, paraIdParent };
};
const createDocumentJson = (docx, converter, editor) => {
  const json = carbonCopy(getInitialJSON(docx));
  if (!json) return null;
  if (converter?.telemetry) {
    const files = Object.keys(docx).map((filePath) => {
      const parts = filePath.split("/");
      return {
        filePath,
        fileDepth: parts.length,
        fileType: filePath.split(".").pop()
      };
    });
    converter.telemetry.trackFileStructure(
      {
        totalFiles: files.length,
        maxDepth: Math.max(...files.map((f) => f.fileDepth)),
        totalNodes: 0,
        files
      },
      converter.fileSource,
      converter.documentId,
      converter.documentInternalId
    );
  }
  const nodeListHandler2 = defaultNodeListHandler();
  const bodyNode = json.elements[0].elements.find((el) => el.name === "w:body");
  if (bodyNode) {
    const node2 = bodyNode;
    const ignoreNodes = ["w:sectPr"];
    const content = node2.elements?.filter((n) => !ignoreNodes.includes(n.name)) ?? [];
    const comments = importCommentData({ docx, converter, editor });
    const lists = {};
    const parsedContent = nodeListHandler2.handler({
      nodes: content,
      nodeListHandler: nodeListHandler2,
      docx,
      converter,
      editor,
      lists
    });
    const result = {
      type: "doc",
      content: parsedContent,
      attrs: {
        attributes: json.elements[0].attributes
      }
    };
    if (result.content.length > 1) {
      converter?.telemetry?.trackUsage("document_import", {
        documentType: "docx",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
    return {
      pmDoc: result,
      savedTagsToRestore: node2,
      pageStyles: getDocumentStyles(node2, docx, converter, editor),
      comments,
      linkedStyles: getStyleDefinitions(docx),
      numbering: getNumberingDefinitions(docx)
    };
  }
  return null;
};
const defaultNodeListHandler = () => {
  const entities = [
    alternateChoiceHandler,
    runNodeHandlerEntity,
    pictNodeHandlerEntity,
    listHandlerEntity,
    paragraphNodeHandlerEntity,
    textNodeHandlerEntity,
    lineBreakNodeHandlerEntity,
    annotationNodeHandlerEntity,
    sdtNodeHandlerEntity,
    bookmarkNodeHandlerEntity,
    hyperlinkNodeHandlerEntity,
    drawingNodeHandlerEntity,
    trackChangeNodeHandlerEntity,
    tableNodeHandlerEntity,
    tabNodeEntityHandler,
    autoPageHandlerEntity,
    autoTotalPageCountEntity,
    standardNodeHandlerEntity
    // This is the last one as it can handle everything
  ];
  const handler = createNodeListHandler(entities);
  return {
    handler,
    handlerEntities: entities
  };
};
const createNodeListHandler = (nodeHandlers) => {
  const getSafeElementContext = (elements, index, processedNode, path) => {
    if (!elements || index < 0 || index >= elements.length) {
      return {
        elementIndex: index,
        error: "index_out_of_bounds",
        arrayLength: elements?.length
      };
    }
    const element = elements[index];
    return {
      elementName: element?.name,
      attributes: processedNode?.attrs,
      marks: processedNode?.marks,
      elementPath: path,
      type: processedNode?.type,
      content: processedNode?.content
    };
  };
  const nodeListHandlerFn = ({
    nodes: elements,
    docx,
    insideTrackChange,
    converter,
    editor,
    filename,
    parentStyleId,
    lists
  }) => {
    if (!elements || !elements.length) return [];
    const processedElements = [];
    try {
      for (let index = 0; index < elements.length; index++) {
        try {
          const nodesToHandle = elements.slice(index);
          if (!nodesToHandle || nodesToHandle.length === 0) {
            continue;
          }
          const { nodes, consumed, unhandled } = nodeHandlers.reduce(
            (res, handler) => {
              if (res.consumed > 0) return res;
              return handler.handler({
                nodes: nodesToHandle,
                docx,
                nodeListHandler: { handler: nodeListHandlerFn, handlerEntities: nodeHandlers },
                insideTrackChange,
                converter,
                editor,
                filename,
                parentStyleId,
                lists
              });
            },
            { nodes: [], consumed: 0 }
          );
          const context = getSafeElementContext(elements, index, nodes[0], `/word/${filename || "document.xml"}`);
          if (unhandled) {
            if (!context.elementName) continue;
            converter?.telemetry?.trackStatistic("unknown", context);
            continue;
          } else {
            converter?.telemetry?.trackStatistic("node", context);
            if (context.type === "orderedList" || context.type === "bulletList") {
              context.content.forEach((item) => {
                const innerItemContext = getSafeElementContext([item], 0, item, `/word/${filename || "document.xml"}`);
                converter?.telemetry?.trackStatistic("attributes", innerItemContext);
              });
            }
            const hasHighlightMark = nodes[0]?.marks?.find((mark) => mark.type === "highlight");
            if (hasHighlightMark) {
              converter?.docHiglightColors.add(hasHighlightMark.attrs.color.toUpperCase());
            }
          }
          if (consumed > 0) {
            index += consumed - 1;
          }
          if (nodes) {
            nodes.forEach((node2) => {
              if (node2?.type && !["runProperties"].includes(node2.type)) {
                if (node2.type === "text" && Array.isArray(node2.content) && !node2.content.length) {
                  return;
                }
                processedElements.push(node2);
              }
            });
          }
        } catch (error) {
          console.debug("Import error", error);
          editor?.emit("exception", { error });
          converter?.telemetry?.trackStatistic("error", {
            type: "processing_error",
            message: error.message,
            name: error.name,
            stack: error.stack,
            fileName: `/word/${filename || "document.xml"}`
          });
        }
      }
      return processedElements;
    } catch (error) {
      console.debug("Error during import", error);
      editor?.emit("exception", { error });
      converter?.telemetry?.trackStatistic("error", {
        type: "fatal_error",
        message: error.message,
        name: error.name,
        stack: error.stack,
        fileName: `/word/${filename || "document.xml"}`
      });
      throw error;
    }
  };
  return nodeListHandlerFn;
};
function getDocumentStyles(node2, docx, converter, editor) {
  const sectPr = node2.elements?.find((n) => n.name === "w:sectPr");
  const styles = {};
  sectPr?.elements?.forEach((el) => {
    const { name, attributes } = el;
    switch (name) {
      case "w:pgSz":
        styles["pageSize"] = {
          width: twipsToInches(attributes["w:w"]),
          height: twipsToInches(attributes["w:h"])
        };
        break;
      case "w:pgMar":
        styles["pageMargins"] = {
          top: twipsToInches(attributes["w:top"]),
          right: twipsToInches(attributes["w:right"]),
          bottom: twipsToInches(attributes["w:bottom"]),
          left: twipsToInches(attributes["w:left"]),
          header: twipsToInches(attributes["w:header"]),
          footer: twipsToInches(attributes["w:footer"]),
          gutter: twipsToInches(attributes["w:gutter"])
        };
        break;
      case "w:cols":
        styles["columns"] = {
          space: twipsToInches(attributes["w:space"]),
          num: attributes["w:num"],
          equalWidth: attributes["w:equalWidth"]
        };
        break;
      case "w:docGrid":
        styles["docGrid"] = {
          linePitch: twipsToInches(attributes["w:linePitch"]),
          type: attributes["w:type"]
        };
        break;
      case "w:titlePg":
        converter.headerIds.titlePg = true;
    }
  });
  importHeadersFooters(docx, converter, editor);
  styles.alternateHeaders = isAlternatingHeadersOddEven(docx);
  return styles;
}
function getStyleDefinitions(docx) {
  const styles = docx["word/styles.xml"];
  if (!styles) return [];
  const { elements } = styles.elements[0];
  const styleDefinitions = elements.filter((el) => el.name === "w:style");
  const latentStyles = elements.find((el) => el.name === "w:latentStyles");
  latentStyles?.elements.forEach((el) => {
    const { attributes } = el;
    styleDefinitions.find((style) => style.attributes["w:styleId"] === attributes["w:name"]);
  });
  const allParsedStyles = [];
  styleDefinitions.forEach((style) => {
    const id = style.attributes["w:styleId"];
    const parsedStyle = getDefaultStyleDefinition(id, docx);
    const importedStyle = {
      id: style.attributes["w:styleId"],
      type: style.attributes["w:type"],
      definition: parsedStyle,
      attributes: {}
    };
    allParsedStyles.push(importedStyle);
  });
  return allParsedStyles;
}
function addDefaultStylesIfMissing(styles) {
  if (!styles) return null;
  const updatedStyles = carbonCopy(styles);
  const { elements } = updatedStyles.elements[0];
  Object.keys(DEFAULT_LINKED_STYLES).forEach((styleId) => {
    const existsOnDoc = elements.some((el) => el.attributes?.["w:styleId"] === styleId);
    if (!existsOnDoc) {
      const missingStyle = DEFAULT_LINKED_STYLES[styleId];
      updatedStyles.elements[0].elements.push(missingStyle);
    }
  });
  return updatedStyles;
}
const importHeadersFooters = (docx, converter, mainEditor) => {
  const rels = docx["word/_rels/document.xml.rels"];
  const relationships = rels.elements.find((el) => el.name === "Relationships");
  const { elements } = relationships;
  const headerType = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header";
  const footerType = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer";
  const headers = elements.filter((el) => el.attributes["Type"] === headerType);
  const footers = elements.filter((el) => el.attributes["Type"] === footerType);
  const sectPr = findSectPr(docx["word/document.xml"]) || [];
  const allSectPrElements = sectPr.flatMap((el) => el.elements);
  if (!mainEditor) return;
  const editor = { ...mainEditor };
  editor.options.annotations = true;
  headers.forEach((header) => {
    const { rId, referenceFile, currentFileName } = getHeaderFooterSectionData(header, docx);
    const sectPrHeader = allSectPrElements.find(
      (el) => el.name === "w:headerReference" && el.attributes["r:id"] === rId
    );
    let sectionType = sectPrHeader?.attributes["w:type"];
    if (converter.headerIds[sectionType]) sectionType = null;
    const nodeListHandler2 = defaultNodeListHandler();
    const schema = nodeListHandler2.handler({
      nodes: referenceFile.elements[0].elements,
      nodeListHandler: nodeListHandler2,
      docx,
      converter,
      editor,
      filename: currentFileName
    });
    if (!converter.headerIds.ids) converter.headerIds.ids = [];
    converter.headerIds.ids.push(rId);
    converter.headers[rId] = { type: "doc", content: [...schema] };
    sectionType && (converter.headerIds[sectionType] = rId);
  });
  const titlePg = allSectPrElements?.find((el) => el.name === "w:titlePg");
  if (titlePg) converter.headerIds.titlePg = true;
  footers.forEach((footer) => {
    const { rId, referenceFile, currentFileName } = getHeaderFooterSectionData(footer, docx);
    const sectPrFooter = allSectPrElements.find(
      (el) => el.name === "w:footerReference" && el.attributes["r:id"] === rId
    );
    const sectionType = sectPrFooter?.attributes["w:type"];
    const nodeListHandler2 = defaultNodeListHandler();
    const schema = nodeListHandler2.handler({
      nodes: referenceFile.elements[0].elements,
      nodeListHandler: nodeListHandler2,
      docx,
      converter,
      editor,
      filename: currentFileName
    });
    if (!converter.footerIds.ids) converter.footerIds.ids = [];
    converter.footerIds.ids.push(rId);
    converter.footers[rId] = { type: "doc", content: [...schema] };
    converter.footerIds[sectionType] = rId;
  });
};
const findSectPr = (obj, result = []) => {
  for (const key in obj) {
    if (obj[key] === "w:sectPr") {
      result.push(obj);
    } else if (typeof obj[key] === "object") {
      findSectPr(obj[key], result);
    }
  }
  return result;
};
const getHeaderFooterSectionData = (sectionData, docx) => {
  const rId = sectionData.attributes.Id;
  const target = sectionData.attributes.Target;
  const referenceFile = docx[`word/${target}`];
  const currentFileName = target;
  return {
    rId,
    referenceFile,
    currentFileName
  };
};
function getNumberingDefinitions(docx) {
  let numbering = docx["word/numbering.xml"];
  if (!numbering || !numbering.elements?.length || !numbering.elements[0].elements?.length) numbering = baseNumbering;
  const elements = numbering.elements[0].elements;
  const abstractDefs = elements.filter((el) => el.name === "w:abstractNum");
  const definitions = elements.filter((el) => el.name === "w:num");
  const abstractDefinitions = {};
  abstractDefs.forEach((el) => {
    const abstractId = Number(el.attributes["w:abstractNumId"]);
    abstractDefinitions[abstractId] = el;
  });
  let importListDefs = {};
  definitions.forEach((el) => {
    const numId = Number(el.attributes["w:numId"]);
    importListDefs[numId] = el;
  });
  const listDefsEntries = Object.entries(importListDefs);
  const foundByDurableId = listDefsEntries.filter(([, def]) => def.attributes?.["w16cid:durableId"] === "485517411");
  if (foundByDurableId.length > 1) {
    importListDefs = Object.fromEntries(
      listDefsEntries.filter(([, def]) => def.attributes?.["w16cid:durableId"] !== "485517411")
    );
  }
  return {
    abstracts: abstractDefinitions,
    definitions: importListDefs
  };
}
const isAlternatingHeadersOddEven = (docx) => {
  const settings = docx["word/settings.xml"];
  if (!settings || !settings.elements?.length) return false;
  const { elements = [] } = settings.elements[0];
  const evenOdd = elements.find((el) => el.name === "w:evenAndOddHeaders");
  return !!evenOdd;
};
const HYPERLINK_RELATIONSHIP_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink";
const HEADER_RELATIONSHIP_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header";
const RELATIONSHIP_TYPES = (
  /** @type {const} */
  {
    image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
    hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink"
  }
);
const getDocumentRelationshipElements = (editor) => {
  const docx = editor.converter?.convertedXml;
  if (!docx) return [];
  const documentRels = docx["word/_rels/document.xml.rels"];
  const elements = documentRels?.elements;
  if (!Array.isArray(elements)) return [];
  const relationshipTag = elements.find((el) => el.name === "Relationships");
  return relationshipTag?.elements || [];
};
const getMaxRelationshipIdInt = (relationships) => {
  const ids = [];
  relationships.forEach((rel) => {
    const splitId = rel.attributes.Id.split("rId");
    const parsedInt = parseInt(splitId[1], 10);
    if (Number.isInteger(parsedInt)) {
      ids.push(parsedInt);
    }
  });
  if (ids.length === 0) return 0;
  return Math.max(...ids);
};
const findRelationshipIdFromTarget = (target, editor) => {
  if (!target) return null;
  if (target.startsWith("word/")) target = target.replace("word/", "");
  const relationships = getDocumentRelationshipElements(editor);
  const existingLinkRel = relationships?.find((rel) => rel.attributes.Target === target);
  if (existingLinkRel) {
    return existingLinkRel.attributes.Id;
  }
};
const insertNewRelationship = (target, type2, editor) => {
  if (!target || typeof target !== "string") {
    throw new Error("Target must be a non-empty string");
  }
  if (!type2 || typeof type2 !== "string") {
    throw new Error("Type must be a non-empty string");
  }
  if (!editor) {
    throw new Error("Editor instance is required");
  }
  const mappedType = RELATIONSHIP_TYPES[type2];
  if (!mappedType) {
    console.warn(
      `Unsupported relationship type: ${type2}. Available types: ${Object.keys(RELATIONSHIP_TYPES).join(", ")}`
    );
    return null;
  }
  const existingRelId = findRelationshipIdFromTarget(target, editor);
  if (existingRelId) {
    console.info(`Reusing existing relationship for target: ${target} (ID: ${existingRelId})`);
    return existingRelId;
  }
  const docx = editor.converter?.convertedXml;
  if (!docx) {
    console.error("No converted XML found in editor");
    return null;
  }
  const documentRels = docx["word/_rels/document.xml.rels"];
  if (!documentRels) {
    console.error("No document relationships found in the docx");
    return null;
  }
  const relationshipsTag = documentRels.elements?.find((el) => el.name === "Relationships");
  if (!relationshipsTag) {
    console.error("No Relationships tag found in document relationships");
    return null;
  }
  if (!relationshipsTag.elements) {
    relationshipsTag.elements = [];
  }
  const newId = getNewRelationshipId(editor);
  if (!newId) {
    console.error("Failed to generate new relationship ID");
    return null;
  }
  const newRel = {
    type: "element",
    name: "Relationship",
    attributes: {
      Id: newId,
      Type: mappedType,
      Target: target
    }
  };
  if (type2 === "hyperlink") {
    newRel.attributes.TargetMode = "External";
  }
  relationshipsTag.elements.push(newRel);
  return newId;
};
const getNewRelationshipId = (editor) => {
  const relationships = getDocumentRelationshipElements(editor);
  const maxIdInt = getMaxRelationshipIdInt(relationships);
  return `rId${maxIdInt + 1}`;
};
const DocxHelpers = {
  findRelationshipIdFromTarget,
  insertNewRelationship,
  getNewRelationshipId
};
const _SuperConverter = class _SuperConverter {
  constructor(params = null) {
    __privateAdd(this, _SuperConverter_instances);
    this.debug = params?.debug || false;
    this.declaration = null;
    this.documentAttributes = null;
    this.convertedXml = {};
    this.docx = params?.docx || [];
    this.media = params?.media || {};
    this.fonts = params?.fonts || {};
    this.addedMedia = {};
    this.comments = [];
    this.docHiglightColors = /* @__PURE__ */ new Set([]);
    this.xml = params?.xml;
    this.declaration = null;
    this.numbering = {};
    this.numbering = null;
    this.pageStyles = null;
    this.initialJSON = null;
    this.headers = {};
    this.headerIds = { default: null, even: null, odd: null, first: null };
    this.headerEditors = [];
    this.footers = {};
    this.footerIds = { default: null, even: null, odd: null, first: null };
    this.footerEditors = [];
    this.linkedStyles = [];
    this.json = params?.json;
    this.tagsNotInSchema = ["w:body"];
    this.savedTagsToRestore = [];
    this.telemetry = params?.telemetry || null;
    this.documentInternalId = null;
    this.fileSource = params?.fileSource || null;
    this.documentId = params?.documentId || null;
    if (this.docx.length || this.xml) this.parseFromXml();
  }
  /**
   * Get the DocxHelpers object that contains utility functions for working with docx files.
   * @returns {import('./docx-helpers/docx-helpers.js').DocxHelpers} The DocxHelpers object.
   */
  get docxHelpers() {
    return DocxHelpers;
  }
  parseFromXml() {
    this.docx?.forEach((file) => {
      this.convertedXml[file.name] = this.parseXmlToJson(file.content);
      if (file.name === "word/document.xml") {
        this.documentAttributes = this.convertedXml[file.name].elements[0]?.attributes;
      }
      if (file.name === "word/styles.xml") {
        this.convertedXml[file.name] = addDefaultStylesIfMissing(this.convertedXml[file.name]);
      }
    });
    this.initialJSON = this.convertedXml["word/document.xml"];
    if (!this.initialJSON) this.initialJSON = this.parseXmlToJson(this.xml);
    this.declaration = this.initialJSON?.declaration;
  }
  parseXmlToJson(xml) {
    const newXml = xml.replace(/(<w:t xml:space="preserve">)(\s+)(<\/w:t>)/g, "$1[[sdspace]]$2[[sdspace]]$3");
    return JSON.parse(xmljs.xml2json(newXml, null, 2));
  }
  static getStoredSuperdocVersion(docx) {
    try {
      const customXml = docx.find((doc2) => doc2.name === "docProps/custom.xml");
      if (!customXml) return;
      const converter = new _SuperConverter();
      const content = customXml.content;
      const contentJson = converter.parseXmlToJson(content);
      const properties = contentJson.elements.find((el) => el.name === "Properties");
      if (!properties.elements) return;
      const superdocVersion = properties.elements.find(
        (el) => el.name === "property" && el.attributes.name === "SuperdocVersion"
      );
      if (!superdocVersion) return;
      const version = superdocVersion.elements[0].elements[0].text;
      return version;
    } catch (e) {
      console.warn("Error getting Superdoc version", e);
      return;
    }
  }
  static updateDocumentVersion(docx = this.convertedXml, version = "0.15.17-next.11") {
    const customLocation = "docProps/custom.xml";
    if (!docx[customLocation]) {
      docx[customLocation] = generateCustomXml();
    }
    const customXml = docx["docProps/custom.xml"];
    if (!customXml) return;
    const properties = customXml.elements.find((el) => el.name === "Properties");
    if (!properties.elements) properties.elements = [];
    const superdocVersion = properties.elements.find(
      (el) => el.name === "property" && el.attributes.name === "SuperdocVersion"
    );
    if (!superdocVersion) {
      const newCustomXml = generateSuperdocVersion();
      properties.elements.push(newCustomXml);
    } else {
      superdocVersion.elements[0].elements[0].elements[0].text = version;
    }
    return docx;
  }
  getDocumentDefaultStyles() {
    const styles = this.convertedXml["word/styles.xml"];
    if (!styles) return {};
    const defaults = styles.elements[0].elements.find((el) => el.name === "w:docDefaults");
    const rDefault = defaults.elements.find((el) => el.name === "w:rPrDefault");
    if (!rDefault.elements) return {};
    const rElements = rDefault.elements[0].elements;
    const rFonts = rElements?.find((el) => el.name === "w:rFonts");
    if ("elements" in rDefault) {
      const fontThemeName = rElements.find((el) => el.name === "w:rFonts")?.attributes["w:asciiTheme"];
      let typeface, panose, fontSizeNormal;
      if (fontThemeName) {
        const fontInfo = this.getThemeInfo(fontThemeName);
        typeface = fontInfo.typeface;
        panose = fontInfo.panose;
      } else if (rFonts) {
        typeface = rFonts?.attributes["w:ascii"];
      }
      const paragraphDefaults = styles.elements[0].elements.filter((el) => {
        return el.name === "w:style" && el.attributes["w:styleId"] === "Normal";
      }) || [];
      paragraphDefaults.forEach((el) => {
        const rPr = el.elements.find((el2) => el2.name === "w:rPr");
        const fonts = rPr?.elements?.find((el2) => el2.name === "w:rFonts");
        typeface = fonts?.attributes["w:ascii"];
        fontSizeNormal = Number(rPr?.elements?.find((el2) => el2.name === "w:sz")?.attributes["w:val"]) / 2;
      });
      const rPrDefaults = defaults?.elements?.find((el) => el.name === "w:rPrDefault");
      if (rPrDefaults) {
        const rPr = rPrDefaults.elements?.find((el) => el.name === "w:rPr");
        const fonts = rPr?.elements?.find((el) => el.name === "w:rFonts");
        typeface = fonts?.attributes["w:ascii"];
        const fontSize = typeface ?? rPr?.elements?.find((el) => el.name === "w:sz")?.attributes["w:val"];
        fontSizeNormal = !fontSizeNormal && fontSize ? Number(fontSize) / 2 : null;
      }
      const fontSizePt = fontSizeNormal || Number(rElements.find((el) => el.name === "w:sz")?.attributes["w:val"]) / 2 || 10;
      const kern = rElements.find((el) => el.name === "w:kern")?.attributes["w:val"];
      return { fontSizePt, kern, typeface, panose };
    }
  }
  getDocumentFonts() {
    const fontTable = this.convertedXml["word/fontTable.xml"];
    if (!fontTable || !Object.keys(this.fonts).length) return;
    const fonts = fontTable.elements.find((el) => el.name === "w:fonts");
    const embededFonts = fonts?.elements.filter(
      (el) => el.elements?.some((nested) => nested?.attributes && nested.attributes["r:id"] && nested.attributes["w:fontKey"])
    );
    const fontsToInclude = embededFonts?.reduce((acc, cur) => {
      const embedElements = cur.elements.filter((el) => el.name.startsWith("w:embed"))?.map((el) => ({ ...el, fontFamily: cur.attributes["w:name"] }));
      return [...acc, ...embedElements];
    }, []);
    const rels = this.convertedXml["word/_rels/fontTable.xml.rels"];
    const relationships = rels?.elements.find((el) => el.name === "Relationships") || {};
    const { elements } = relationships;
    let styleString = "";
    for (const font of fontsToInclude) {
      const filePath = elements.find((el) => el.attributes.Id === font.attributes["r:id"])?.attributes?.Target;
      if (!filePath) return;
      const fontUint8Array = this.fonts[`word/${filePath}`];
      const fontBuffer = fontUint8Array?.buffer;
      if (!fontBuffer) return;
      const ttfBuffer = deobfuscateFont(fontBuffer, font.attributes["w:fontKey"]);
      if (!ttfBuffer) return;
      const blob = new Blob([ttfBuffer], { type: "font/ttf" });
      const fontUrl = URL.createObjectURL(blob);
      const isNormal = font.name.includes("Regular");
      const isBold = font.name.includes("Bold");
      const isItalic = font.name.includes("Italic");
      const isLight = font.name.includes("Light");
      const fontWeight = isNormal ? "normal" : isBold ? "bold" : isLight ? "200" : "normal";
      styleString += `
        @font-face {
          font-style: ${isItalic ? "italic" : "normal"};
          font-weight: ${fontWeight};
          font-display: swap;
          font-family: ${font.fontFamily};
          src: url(${fontUrl}) format('truetype');
        }
      `;
    }
    return styleString;
  }
  getDocumentInternalId() {
    const settingsLocation = "word/settings.xml";
    if (!this.convertedXml[settingsLocation]) {
      this.convertedXml[settingsLocation] = SETTINGS_CUSTOM_XML;
    }
    const settings = Object.assign({}, this.convertedXml[settingsLocation]);
    if (!settings.elements[0]?.elements?.length) {
      const idElement = this.createDocumentIdElement(settings);
      settings.elements[0].elements = [idElement];
      if (!settings.elements[0].attributes["xmlns:w15"]) {
        settings.elements[0].attributes["xmlns:w15"] = "http://schemas.microsoft.com/office/word/2012/wordml";
      }
      this.convertedXml[settingsLocation] = settings;
      return;
    }
    const w15DocId = settings.elements[0].elements.find((el) => el.name === "w15:docId");
    this.documentInternalId = w15DocId?.attributes["w15:val"];
  }
  createDocumentIdElement() {
    const docId = v4().toUpperCase();
    this.documentInternalId = docId;
    return {
      type: "element",
      name: "w15:docId",
      attributes: {
        "w15:val": `{${docId}}`
      }
    };
  }
  getThemeInfo(themeName) {
    themeName = themeName.toLowerCase();
    const theme1 = this.convertedXml["word/theme/theme1.xml"];
    if (!theme1) return {};
    const themeData = theme1.elements.find((el) => el.name === "a:theme");
    const themeElements = themeData.elements.find((el) => el.name === "a:themeElements");
    const fontScheme = themeElements.elements.find((el) => el.name === "a:fontScheme");
    let fonts;
    if (themeName.startsWith("major")) {
      fonts = fontScheme.elements.find((el) => el.name === "a:majorFont").elements[0];
    } else if (themeName.startsWith("minor")) {
      fonts = fontScheme.elements.find((el) => el.name === "a:minorFont").elements[0];
    }
    const { typeface, panose } = fonts.attributes;
    return { typeface, panose };
  }
  getSchema(editor) {
    this.getDocumentInternalId();
    const result = createDocumentJson({ ...this.convertedXml, media: this.media }, this, editor);
    if (result) {
      this.savedTagsToRestore.push({ ...result.savedTagsToRestore });
      this.pageStyles = result.pageStyles;
      this.numbering = result.numbering;
      this.comments = result.comments;
      this.linkedStyles = result.linkedStyles;
      return result.pmDoc;
    } else {
      return null;
    }
  }
  schemaToXml(data, debug = false) {
    const exporter = new DocxExporter(this);
    return exporter.schemaToXml(data, debug);
  }
  async exportToDocx(jsonData, editorSchema, documentMedia, isFinalDoc = false, commentsExportType, comments = [], editor, exportJsonOnly = false, fieldsHighlightColor) {
    const commentsWithParaIds = comments.map((c) => prepareCommentParaIds(c));
    const commentDefinitions = commentsWithParaIds.map(
      (c, index) => getCommentDefinition(c, index, commentsWithParaIds, editor)
    );
    const { result, params } = this.exportToXmlJson({
      data: jsonData,
      editorSchema,
      comments,
      commentDefinitions,
      commentsExportType,
      isFinalDoc,
      editor,
      fieldsHighlightColor
    });
    if (exportJsonOnly) return result;
    const exporter = new DocxExporter(this);
    const xml = exporter.schemaToXml(result);
    await __privateMethod(this, _SuperConverter_instances, exportProcessMediaFiles_fn).call(this, {
      ...documentMedia,
      ...params.media,
      ...this.media
    }, editor);
    let updatedXml = { ...this.convertedXml };
    let commentsRels = [];
    if (comments.length) {
      const { documentXml, relationships } = __privateMethod(this, _SuperConverter_instances, prepareCommentsXmlFilesForExport_fn).call(this, {
        defs: params.exportedCommentDefs,
        exportType: commentsExportType,
        commentsWithParaIds
      });
      updatedXml = { ...documentXml };
      commentsRels = relationships;
    }
    this.convertedXml = { ...this.convertedXml, ...updatedXml };
    const headFootRels = __privateMethod(this, _SuperConverter_instances, exportProcessHeadersFooters_fn).call(this, { isFinalDoc });
    __privateMethod(this, _SuperConverter_instances, exportProcessNewRelationships_fn).call(this, [...params.relationships, ...commentsRels, ...headFootRels]);
    storeSuperdocVersion(this.convertedXml);
    __privateMethod(this, _SuperConverter_instances, exportNumberingFile_fn).call(this, params);
    return xml;
  }
  exportToXmlJson({
    data,
    editorSchema,
    comments,
    commentDefinitions,
    commentsExportType = "clean",
    isFinalDoc = false,
    editor,
    isHeaderFooter = false,
    fieldsHighlightColor = null
  }) {
    const bodyNode = this.savedTagsToRestore.find((el) => el.name === "w:body");
    const [result, params] = exportSchemaToJson({
      node: data,
      bodyNode,
      relationships: [],
      documentMedia: {},
      media: {},
      isFinalDoc,
      editorSchema,
      converter: this,
      pageStyles: this.pageStyles,
      comments,
      commentsExportType,
      exportedCommentDefs: commentDefinitions,
      editor,
      isHeaderFooter,
      fieldsHighlightColor
    });
    return { result, params };
  }
};
_SuperConverter_instances = new WeakSet();
exportNumberingFile_fn = function() {
  const numberingPath = "word/numbering.xml";
  let numberingXml = this.convertedXml[numberingPath];
  const newNumbering = this.numbering;
  if (!numberingXml) numberingXml = baseNumbering;
  const currentNumberingXml = numberingXml.elements[0];
  const newAbstracts = Object.values(newNumbering.abstracts).map((entry) => entry);
  const newNumDefs = Object.values(newNumbering.definitions).map((entry) => entry);
  currentNumberingXml.elements = [...newAbstracts, ...newNumDefs];
  this.convertedXml[numberingPath] = numberingXml;
};
/**
 * Update comments files and relationships depending on export type
 */
prepareCommentsXmlFilesForExport_fn = function({ defs, exportType, commentsWithParaIds }) {
  const { documentXml, relationships } = prepareCommentsXmlFilesForExport({
    exportType,
    convertedXml: this.convertedXml,
    defs,
    commentsWithParaIds
  });
  return { documentXml, relationships };
};
exportProcessHeadersFooters_fn = function({ isFinalDoc = false }) {
  const relsData = this.convertedXml["word/_rels/document.xml.rels"];
  const relationships = relsData.elements.find((x) => x.name === "Relationships");
  const newDocRels = [];
  Object.entries(this.headers).forEach(([id, header], index) => {
    const fileName = relationships.elements.find((el) => el.attributes.Id === id)?.attributes.Target || `header${index + 1}.xml`;
    const headerEditor = this.headerEditors.find((item) => item.id === id);
    if (!headerEditor) return;
    const { result, params } = this.exportToXmlJson({
      data: header,
      editor: headerEditor.editor,
      editorSchema: headerEditor.editor.schema,
      comments: [],
      commentDefinitions: [],
      isHeaderFooter: true,
      isFinalDoc
    });
    const bodyContent = result.elements[0].elements;
    const file = this.convertedXml[`word/${fileName}`];
    if (!file) {
      this.convertedXml[`word/${fileName}`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            attributes: DEFAULT_DOCX_DEFS,
            name: "w:hdr",
            type: "element",
            elements: []
          }
        ]
      };
      newDocRels.push({
        type: "element",
        name: "Relationship",
        attributes: {
          Id: id,
          Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header",
          Target: fileName
        }
      });
    }
    this.convertedXml[`word/${fileName}`].elements[0].elements = bodyContent;
    if (params.relationships.length) {
      const relationships2 = this.convertedXml[`word/_rels/${fileName}.rels`]?.elements?.find((x) => x.name === "Relationships")?.elements || [];
      this.convertedXml[`word/_rels/${fileName}.rels`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            name: "Relationships",
            attributes: {
              xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
            },
            elements: [...relationships2, ...params.relationships]
          }
        ]
      };
    }
  });
  Object.entries(this.footers).forEach(([id, footer], index) => {
    const fileName = relationships.elements.find((el) => el.attributes.Id === id)?.attributes.Target || `footer${index + 1}.xml`;
    const footerEditor = this.footerEditors.find((item) => item.id === id);
    if (!footerEditor) return;
    const { result, params } = this.exportToXmlJson({
      data: footer,
      editor: footerEditor.editor,
      editorSchema: footerEditor.editor.schema,
      comments: [],
      commentDefinitions: [],
      isHeaderFooter: true,
      isFinalDoc
    });
    const bodyContent = result.elements[0].elements;
    const file = this.convertedXml[`word/${fileName}`];
    if (!file) {
      this.convertedXml[`word/${fileName}`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            attributes: DEFAULT_DOCX_DEFS,
            name: "w:ftr",
            type: "element",
            elements: []
          }
        ]
      };
      newDocRels.push({
        type: "element",
        name: "Relationship",
        attributes: {
          Id: id,
          Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer",
          Target: fileName
        }
      });
    }
    this.convertedXml[`word/${fileName}`].elements[0].elements = bodyContent;
    if (params.relationships.length) {
      const relationships2 = this.convertedXml[`word/_rels/${fileName}.rels`]?.elements?.find((x) => x.name === "Relationships")?.elements || [];
      this.convertedXml[`word/_rels/${fileName}.rels`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            name: "Relationships",
            attributes: {
              xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
            },
            elements: [...relationships2, ...params.relationships]
          }
        ]
      };
    }
  });
  return newDocRels;
};
exportProcessNewRelationships_fn = function(rels = []) {
  const relsData = this.convertedXml["word/_rels/document.xml.rels"];
  const relationships = relsData.elements.find((x) => x.name === "Relationships");
  const newRels = [];
  const regex = /rId|mi/g;
  let largestId = Math.max(...relationships.elements.map((el) => Number(el.attributes.Id.replace(regex, ""))));
  rels.forEach((rel) => {
    const existingId = rel.attributes.Id;
    const existingTarget = relationships.elements.find((el) => el.attributes.Target === rel.attributes.Target);
    const isNewMedia = rel.attributes.Target?.startsWith("media/") && existingId.length > 6;
    const isNewHyperlink = rel.attributes.Type === HYPERLINK_RELATIONSHIP_TYPE && existingId.length > 6;
    const isNewHeadFoot = rel.attributes.Type === HEADER_RELATIONSHIP_TYPE && existingId.length > 6;
    if (existingTarget && !isNewMedia && !isNewHyperlink && !isNewHeadFoot) {
      return;
    }
    rel.attributes.Target = rel.attributes?.Target?.replace(/&/g, "&amp;");
    rel.attributes.Id = existingId.length > 6 ? existingId : `rId${++largestId}`;
    newRels.push(rel);
  });
  relationships.elements = [...relationships.elements, ...newRels];
};
exportProcessMediaFiles_fn = async function(media, editor) {
  const processedData = {};
  for (const filePath in media) {
    if (typeof media[filePath] !== "string") continue;
    const name = filePath.split("/").pop();
    processedData[name] = await getArrayBufferFromUrl(media[filePath], editor.options.isHeadless);
  }
  this.convertedXml.media = {
    ...this.convertedXml.media,
    ...processedData
  };
  this.media = this.convertedXml.media;
  this.addedMedia = processedData;
};
__publicField(_SuperConverter, "allowedElements", Object.freeze({
  "w:document": "doc",
  "w:body": "body",
  "w:p": "paragraph",
  "w:r": "run",
  "w:t": "text",
  "w:delText": "text",
  "w:br": "lineBreak",
  "w:tbl": "table",
  "w:tr": "tableRow",
  "w:tc": "tableCell",
  "w:drawing": "drawing",
  "w:bookmarkStart": "bookmarkStart",
  // 'w:tab': 'tab',
  // Formatting only
  "w:sectPr": "sectionProperties",
  "w:rPr": "runProperties",
  // Comments
  "w:commentRangeStart": "commentRangeStart",
  "w:commentRangeEnd": "commentRangeEnd",
  "w:commentReference": "commentReference"
}));
__publicField(_SuperConverter, "markTypes", [
  { name: "w:b", type: "bold", property: "value" },
  // { name: 'w:bCs', type: 'bold' },
  { name: "w:i", type: "italic" },
  // { name: 'w:iCs', type: 'italic' },
  { name: "w:u", type: "underline", mark: "underline", property: "underlineType" },
  { name: "w:strike", type: "strike", mark: "strike" },
  { name: "w:color", type: "color", mark: "textStyle", property: "color" },
  { name: "w:sz", type: "fontSize", mark: "textStyle", property: "fontSize" },
  // { name: 'w:szCs', type: 'fontSize', mark: 'textStyle', property: 'fontSize' },
  { name: "w:rFonts", type: "fontFamily", mark: "textStyle", property: "fontFamily" },
  { name: "w:rStyle", type: "styleId", mark: "textStyle", property: "styleId" },
  { name: "w:jc", type: "textAlign", mark: "textStyle", property: "textAlign" },
  { name: "w:ind", type: "textIndent", mark: "textStyle", property: "textIndent" },
  { name: "w:spacing", type: "lineHeight", mark: "textStyle", property: "lineHeight" },
  { name: "w:spacing", type: "letterSpacing", mark: "textStyle", property: "letterSpacing" },
  { name: "link", type: "link", mark: "link", property: "href" },
  { name: "w:highlight", type: "highlight", mark: "highlight", property: "color" },
  { name: "w:shd", type: "highlight", mark: "highlight", property: "color" },
  { name: "w:caps", type: "textTransform", mark: "textStyle", property: "textTransform" }
]);
__publicField(_SuperConverter, "propertyTypes", Object.freeze({
  "w:pPr": "paragraphProperties",
  "w:rPr": "runProperties",
  "w:sectPr": "sectionProperties",
  "w:numPr": "numberingProperties",
  "w:tcPr": "tableCellProperties"
}));
__publicField(_SuperConverter, "elements", /* @__PURE__ */ new Set(["w:document", "w:body", "w:p", "w:r", "w:t", "w:delText"]));
let SuperConverter = _SuperConverter;
function storeSuperdocVersion(docx) {
  const customLocation = "docProps/custom.xml";
  if (!docx[customLocation]) docx[customLocation] = generateCustomXml();
  const customXml = docx[customLocation];
  const properties = customXml.elements.find((el) => el.name === "Properties");
  if (!properties.elements) properties.elements = [];
  const elements = properties.elements;
  const cleanProperties = elements.filter((prop) => typeof prop === "object" && prop !== null).filter((prop) => {
    const { attributes } = prop;
    return attributes.name !== "SuperdocVersion";
  });
  let pid = 2;
  try {
    pid = cleanProperties.length ? Math.max(...elements.map((el) => el.attributes.pid)) + 1 : 2;
  } catch {
  }
  cleanProperties.push(generateSuperdocVersion(pid));
  properties.elements = cleanProperties;
  return docx;
}
function generateCustomXml() {
  return DEFAULT_CUSTOM_XML;
}
function generateSuperdocVersion(pid = 2, version = "0.15.17-next.11") {
  return {
    type: "element",
    name: "property",
    attributes: {
      name: "SuperdocVersion",
      fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
      pid
    },
    elements: [
      {
        type: "element",
        name: "vt:lpwstr",
        elements: [
          {
            type: "text",
            text: version
          }
        ]
      }
    ]
  };
}
export {
  twipsToLines as $,
  AllSelection as A,
  isIOS as B,
  DOMSerializer as C,
  DOMParser$1 as D,
  Mark as E,
  Fragment as F,
  dropPoint as G,
  process$1 as H,
  Buffer2 as I,
  getSchemaTypeByName as J,
  inputRulesPlugin as K,
  ListHelpers as L,
  Mapping as M,
  NodeSelection as N,
  TrackDeleteMarkName as O,
  PluginKey as P,
  TrackInsertMarkName as Q,
  ReplaceAroundStep as R,
  Schema$1 as S,
  TextSelection as T,
  v4 as U,
  TrackFormatMarkName as V,
  comments_module_events as W,
  findMark as X,
  objectIncludes as Y,
  AddMarkStep as Z,
  RemoveMarkStep as _,
  Plugin as a,
  pixelsToTwips as a0,
  helpers as a1,
  posToDOMRect as a2,
  CommandService as a3,
  SuperConverter as a4,
  createDocument as a5,
  createDocFromMarkdown as a6,
  createDocFromHTML as a7,
  EditorState as a8,
  hasSomeParentWithClass as a9,
  getActiveFormatting as aA,
  readFromClipboard as aB,
  handleClipboardPaste as aC,
  getFileObject as aD,
  _sfc_main as aE,
  isActive as aa,
  unflattenListsInHtml as ab,
  parseSizeUnit as ac,
  minMax as ad,
  getLineHeightValueString as ae,
  InputRule as af,
  kebabCase as ag,
  getListItemStyleDefinitions as ah,
  docxNumberigHelpers as ai,
  parseIndentElement as aj,
  combineIndents as ak,
  StepMap as al,
  getColStyleDeclaration as am,
  SelectionRange as an,
  Transform as ao,
  findParentNodeClosestToPos as ap,
  isInTable as aq,
  createColGroup as ar,
  generateDocxRandomId as as,
  insertNewRelationship as at,
  htmlHandler as au,
  commonjsGlobal as av,
  getDefaultExportFromCjs$1 as aw,
  getContentTypesFromXml as ax,
  xmljs as ay,
  vClickOutside as az,
  getMarkType as b,
  callOrGet as c,
  getMarksFromSelection as d,
  getNodeType as e,
  getSchemaTypeNameByName as f,
  getExtensionConfigField as g,
  cleanSchemaItem as h,
  canSplit as i,
  defaultBlockAt as j,
  canJoin as k,
  liftTarget as l,
  joinPoint as m,
  Selection as n,
  Slice as o,
  isTextSelection as p,
  getMarkRange as q,
  replaceStep as r,
  isMarkActive as s,
  isNodeActive as t,
  deleteProps as u,
  ReplaceStep as v,
  NodeRange as w,
  findWrapping as x,
  findParentNode as y,
  isMacOS as z
};
