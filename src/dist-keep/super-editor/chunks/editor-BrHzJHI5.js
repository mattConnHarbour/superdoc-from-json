var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _Attribute_static, getGlobalAttributes_fn, getNodeAndMarksAttributes_fn, _Schema_static, createNodesSchema_fn, createMarksSchema_fn, _events, _ExtensionService_instances, setupExtensions_fn, attachEditorEvents_fn, _editor, _stateValidators, _requiredNodeTypes, _requiredMarkTypes, _SuperValidator_instances, initializeValidators_fn, collectValidatorRequirements_fn, analyzeDocument_fn, _commandService, _Editor_instances, initContainerElement_fn, init_fn, initRichText_fn, onFocus_fn, checkHeadless_fn, insertNewFileData_fn, registerPluginByNameIfNotExists_fn, createExtensionService_fn, createCommandService_fn, createConverter_fn, initMedia_fn, initFonts_fn, createSchema_fn, generatePmData_fn, createView_fn, onCollaborationReady_fn, initComments_fn, initPagination_fn, dispatchTransaction_fn, handleNodeSelection_fn, prepareDocumentForImport_fn, prepareDocumentForExport_fn, endCollaboration_fn, validateDocumentInit_fn, _ListItemNodeView_instances, init_fn2, _FieldAnnotationView_instances, createAnnotation_fn, _AutoPageNumberNodeView_instances, renderDom_fn, scheduleUpdateNodeStyle_fn, _DocumentSectionView_instances, init_fn3, addToolTip_fn;
import * as Y from "yjs";
import { UndoManager, Item as Item$1, ContentType, Text as Text$1, XmlElement, encodeStateAsUpdate } from "yjs";
import { P as PluginKey, a as Plugin, M as Mapping, c as callOrGet, g as getExtensionConfigField, b as getMarkType, d as getMarksFromSelection, e as getNodeType, f as getSchemaTypeNameByName, S as Schema$1, h as cleanSchemaItem, T as TextSelection, N as NodeSelection, i as canSplit, j as defaultBlockAt$1, l as liftTarget, A as AllSelection, k as canJoin, m as joinPoint, n as Selection, r as replaceStep$1, F as Fragment, R as ReplaceAroundStep$1, o as Slice, p as isTextSelection, q as getMarkRange, s as isMarkActive, t as isNodeActive, u as deleteProps, D as DOMParser$1, v as ReplaceStep, w as NodeRange, x as findWrapping, y as findParentNode, L as ListHelpers, z as isMacOS, B as isIOS, C as DOMSerializer, E as Mark$1, G as dropPoint, H as process$1, I as Buffer2, J as getSchemaTypeByName, K as inputRulesPlugin, O as TrackDeleteMarkName, Q as TrackInsertMarkName, U as v4, V as TrackFormatMarkName, W as comments_module_events, X as findMark, Y as objectIncludes, Z as AddMarkStep, _ as RemoveMarkStep, $ as twipsToLines, a0 as pixelsToTwips, a1 as helpers, a2 as posToDOMRect, a3 as CommandService, a4 as SuperConverter, a5 as createDocument, a6 as createDocFromMarkdown, a7 as createDocFromHTML, a8 as EditorState, a9 as hasSomeParentWithClass, aa as isActive, ab as unflattenListsInHtml, ac as parseSizeUnit, ad as minMax, ae as getLineHeightValueString, af as InputRule, ag as kebabCase, ah as getListItemStyleDefinitions, ai as docxNumberigHelpers, aj as parseIndentElement, ak as combineIndents, al as StepMap, am as getColStyleDeclaration, an as SelectionRange, ao as Transform, ap as findParentNodeClosestToPos, aq as isInTable$1, ar as createColGroup, as as generateDocxRandomId, at as insertNewRelationship, au as htmlHandler } from "./converter-Gn2vfeVr.js";
import { ref, computed, createElementBlock, openBlock, withModifiers, Fragment as Fragment$1, renderList, normalizeClass, createCommentVNode, toDisplayString, createElementVNode, createApp } from "vue";
import { D as DocxZipper } from "./docx-zipper-C4LsZ-H4.js";
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ (function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten2() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
})(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ (function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten2() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
})(RopeSequence);
const max_empty_items = 500;
class Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end2 = this.items.length;
    for (; ; end2--) {
      let next = this.items.get(end2 - 1);
      if (next.selection) {
        --end2;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end2, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end2, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map2;
        if (step && transform.maybeStep(step).doc) {
          map2 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map2, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new Branch(this.items.append(array.map((map2) => new Item(map2))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start2);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map2 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map2, step, selection));
      } else {
        rebasedItems.push(new Item(map2));
      }
    }, start2);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    let branch = new Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map2 = step && step.getMap();
        mapFrom--;
        if (map2)
          remap.appendMap(map2, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events++;
          let newItem = new Item(map2.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch(RopeSequence.from(items.reverse()), events);
  }
}
Branch.empty = new Branch(RopeSequence.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
class Item {
  constructor(map2, step, selection, mirrorOffset) {
    this.map = map2;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new Item(step.getMap().invert(), step, this.selection);
    }
  }
}
class HistoryState {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state, tr, options) {
  let historyTr = tr.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state)), history2.undone, rangesFor(tr.mapping.maps), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state)), null, history2.prevTime, history2.prevComposition);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);
    return new HistoryState(history2.done.addTransform(tr, newGroup ? state.selection.getBookmark() : void 0, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start2, end2) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start2 <= prevRanges[i + 1] && end2 >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)
    maps[i].forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state, redo2) {
  let preserveItems = mustPreserveItems(state);
  let histOptions = historyKey.get(state).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state) {
  let plugins = state.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new PluginKey("history");
const closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr, hist, state) {
        return applyTransaction(hist, state, tr, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo$1 : inputType == "historyRedo" ? redo$1 : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll) {
  return (state, dispatch) => {
    let hist = historyKey.getState(state);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr = histTransaction(hist, state, redo2);
      if (tr)
        dispatch(scroll ? tr.scrollIntoView() : tr);
    }
    return true;
  };
}
const undo$1 = buildCommand(false, true);
const redo$1 = buildCommand(true, true);
function undoDepth(state) {
  let hist = historyKey.getState(state);
  return hist ? hist.done.eventCount : 0;
}
function redoDepth(state) {
  let hist = historyKey.getState(state);
  return hist ? hist.undone.eventCount : 0;
}
class Extension {
  constructor(config) {
    __publicField(this, "type", "extension");
    __publicField(this, "name", "extension");
    __publicField(this, "options");
    __publicField(this, "storage");
    __publicField(this, "config", {
      name: this.name
    });
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, "addOptions", {
          name: this.name
        })
      );
    }
    this.storage = callOrGet(
      getExtensionConfigField(this, "addStorage", {
        name: this.name,
        options: this.options
      })
    ) || {};
  }
  /**
   * Static method for creating an extension.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new Extension(...args);
  }
}
const History = Extension.create({
  name: "history",
  addOptions() {
    return {
      /**
       * @typedef {Object} HistoryOptions
       * @category Options
       * @property {number} [depth=100] - Maximum undo/redo steps to remember
       * @property {number} [newGroupDelay=500] - Milliseconds to wait before starting a new history group
       */
      depth: 100,
      newGroupDelay: 500
    };
  },
  addPmPlugins() {
    const historyPlugin = history(this.options);
    return [historyPlugin];
  },
  //prettier-ignore
  addCommands() {
    return {
      /**
       * Undo the last action
       * @category Command
       * @returns {Function} Command function
       * @example
       * undo()
       * @note Groups changes within the newGroupDelay window
       */
      undo: () => ({ state, dispatch, tr }) => {
        tr.setMeta("inputType", "historyUndo");
        return undo$1(state, dispatch);
      },
      /**
       * Redo the last undone action
       * @category Command
       * @returns {Function} Command function
       * @example
       * redo()
       * @note Only available after an undo action
       */
      redo: () => ({ state, dispatch, tr }) => {
        tr.setMeta("inputType", "historyRedo");
        return redo$1(state, dispatch);
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-Shift-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo()
    };
  }
});
let Node$1 = class Node2 {
  constructor(config) {
    __publicField(this, "type", "node");
    __publicField(this, "name", "node");
    __publicField(this, "options");
    __publicField(this, "storage");
    __publicField(this, "config", {
      name: this.name
    });
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, "addOptions", {
          name: this.name
        })
      );
    }
    this.storage = callOrGet(
      getExtensionConfigField(this, "addStorage", {
        name: this.name,
        options: this.options
      })
    ) || {};
  }
  /**
   * Static method for creating Node extension.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new Node2(...args);
  }
};
class Mark {
  constructor(config) {
    __publicField(this, "type", "mark");
    __publicField(this, "name", "mark");
    __publicField(this, "options");
    __publicField(this, "storage");
    __publicField(this, "isExternal");
    __publicField(this, "config", {
      name: this.name
    });
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    this.isExternal = Boolean(this.config.isExternal);
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, "addOptions", {
          name: this.name
        })
      );
    }
    this.storage = callOrGet(
      getExtensionConfigField(this, "addStorage", {
        name: this.name,
        options: this.options
      })
    ) || {};
  }
  /**
   * Static method for creating Mark extension.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new Mark(...args);
  }
}
class Attribute {
  /**
   * Get a list of all attributes defined in the extensions.
   * @param extensions List of all extensions.
   * @returns Extension attributes.
   */
  static getAttributesFromExtensions(extensions) {
    const extensionAttributes = [];
    const defaultAttribute = {
      default: null,
      rendered: true,
      renderDOM: null,
      parseDOM: null,
      keepOnSplit: true
    };
    const globalAttributes = __privateMethod(this, _Attribute_static, getGlobalAttributes_fn).call(this, extensions, defaultAttribute);
    const nodeAndMarksAttributes = __privateMethod(this, _Attribute_static, getNodeAndMarksAttributes_fn).call(this, extensions, defaultAttribute);
    extensionAttributes.push(...globalAttributes, ...nodeAndMarksAttributes);
    return extensionAttributes;
  }
  /**
   * Inserts extension attributes into parseRule attributes.
   * @param parseRule PM ParseRule.
   * @param extensionAttrs List of attributes to insert.
   */
  static insertExtensionAttrsToParseRule(parseRule, extensionAttrs) {
    if ("style" in parseRule) {
      return parseRule;
    }
    return {
      ...parseRule,
      getAttrs: (node) => {
        const oldAttrs = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;
        if (oldAttrs === false) return false;
        const parseFromString = (value) => {
          if (typeof value !== "string") return value;
          if (value.match(/^[+-]?(\d*\.)?\d+$/)) return Number(value);
          if (value === "true") return true;
          if (value === "false") return false;
          return value;
        };
        let newAttrs = {};
        for (const item of extensionAttrs) {
          const value = item.attribute.parseDOM ? item.attribute.parseDOM(node) : parseFromString(node.getAttribute(item.name));
          if (value === null || value === void 0) continue;
          newAttrs = {
            ...newAttrs,
            [item.name]: value
          };
        }
        return { ...oldAttrs, ...newAttrs };
      }
    };
  }
  /**
   * Get attributes to render.
   * @param nodeOrMark Node or Mark.
   * @param extensionAttrs Extension attributes.
   */
  static getAttributesToRender(nodeOrMark, extensionAttrs) {
    const attributes = extensionAttrs.filter((item) => item.attribute.rendered).map((item) => {
      if (!item.attribute.renderDOM) {
        return { [item.name]: nodeOrMark.attrs[item.name] };
      }
      return item.attribute.renderDOM(nodeOrMark.attrs) || {};
    });
    let mergedAttrs = {};
    for (const attribute of attributes) {
      mergedAttrs = this.mergeAttributes(mergedAttrs, attribute);
    }
    return mergedAttrs;
  }
  /**
   * Merges attributes.
   * @param objects Objects with attributes.
   * @returns Object with merged attributes.
   */
  static mergeAttributes(...objects) {
    const items = objects.filter((item) => !!item);
    let attrs = {};
    for (const item of items) {
      const mergedAttributes = { ...attrs };
      for (const [key, value] of Object.entries(item)) {
        const exists = mergedAttributes[key];
        if (!exists) {
          mergedAttributes[key] = value;
          continue;
        }
        if (key === "class") {
          const valueClasses = value ? value.split(" ") : [];
          const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
          const insertClasses = valueClasses.filter((value2) => !existingClasses.includes(value2));
          mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
        } else if (key === "style") {
          mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
        } else {
          mergedAttributes[key] = value;
        }
      }
      attrs = mergedAttributes;
    }
    return attrs;
  }
  /**
   * Get extension attributes that should be splitted by keepOnSplit flag.
   * @param extensionAttrs Array of attributes.
   * @param typeName The type of the extension.
   * @param attributes The extension attributes.
   * @returns The splitted attributes.
   */
  static getSplittedAttributes(extensionAttrs, typeName, attributes) {
    const entries = Object.entries(attributes).filter(([name]) => {
      const extensionAttr = extensionAttrs.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttr) return false;
      return extensionAttr.attribute.keepOnSplit;
    });
    return Object.fromEntries(entries);
  }
  /**
   * Get mark attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The mark type or name.
   * @returns The mark attrs.
   */
  static getMarkAttributes(state, typeOrName) {
    const type = getMarkType(typeOrName, state.schema);
    const marks = getMarksFromSelection(state);
    const mark = marks.find((markItem) => markItem.type.name === type.name);
    if (!mark) return {};
    return { ...mark.attrs };
  }
  /**
   * Get node attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The node type or name.
   * @returns The node attrs.
   */
  static getNodeAttributes(state, typeOrName) {
    const type = getNodeType(typeOrName, state.schema);
    const { from: from2, to } = state.selection;
    const nodes = [];
    state.doc.nodesBetween(from2, to, (node2) => {
      nodes.push(node2);
    });
    const node = nodes.reverse().find((nodeItem) => nodeItem.type.name === type.name);
    if (!node) return {};
    return { ...node.attrs };
  }
  /**
   * Get node or mark attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The node/mark type or name.
   * @returns The attrs of the node/mark or an empty object.
   */
  static getAttributes(state, typeOrName) {
    const schemaType = getSchemaTypeNameByName(
      typeof typeOrName === "string" ? typeOrName : typeOrName.name,
      state.schema
    );
    if (schemaType === "node") {
      return this.getNodeAttributes(state, typeOrName);
    }
    if (schemaType === "mark") {
      return this.getMarkAttributes(state, typeOrName);
    }
    return {};
  }
}
_Attribute_static = new WeakSet();
getGlobalAttributes_fn = function(extensions, defaultAttribute) {
  const extensionAttributes = [];
  const collectAttribute = (globalAttr) => {
    for (const type of globalAttr.types) {
      const entries = Object.entries(globalAttr.attributes);
      for (const [name, attribute] of entries) {
        extensionAttributes.push({
          type,
          name,
          attribute: {
            ...defaultAttribute,
            ...attribute
          }
        });
      }
    }
  };
  for (const extension of extensions) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addGlobalAttributes = getExtensionConfigField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) continue;
    const globalAttributes = addGlobalAttributes();
    for (const globalAttr of globalAttributes) {
      collectAttribute(globalAttr);
    }
  }
  return extensionAttributes;
};
getNodeAndMarksAttributes_fn = function(extensions, defaultAttribute) {
  const extensionAttributes = [];
  const nodeAndMarkExtensions = extensions.filter((e) => {
    return e.type === "node" || e.type === "mark";
  });
  for (const extension of nodeAndMarkExtensions) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionConfigField(extension, "addAttributes", context);
    if (!addAttributes) continue;
    const attributes = addAttributes();
    for (const [name, attribute] of Object.entries(attributes)) {
      const merged = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof merged.default === "function") {
        merged.default = merged.default();
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: merged
      });
    }
  }
  return extensionAttributes;
};
__privateAdd(Attribute, _Attribute_static);
const _Schema = class _Schema {
  /**
   * Creates PM schema by resolved extensions.
   * @param extensions List of extensions.
   * @param editor Editor instance.
   * @returns PM schema
   */
  static createSchemaByExtensions(extensions, editor) {
    var _a, _b;
    const nodeExtensions = extensions.filter((e) => e.type === "node");
    const markExtensions = extensions.filter((e) => e.type === "mark");
    const topNode = nodeExtensions.find((e) => getExtensionConfigField(e, "topNode"))?.name;
    const attributes = Attribute.getAttributesFromExtensions(extensions);
    const nodes = __privateMethod(_a = _Schema, _Schema_static, createNodesSchema_fn).call(_a, nodeExtensions, attributes, editor);
    const marks = __privateMethod(_b = _Schema, _Schema_static, createMarksSchema_fn).call(_b, markExtensions, attributes, editor);
    return new Schema$1({ topNode, nodes, marks });
  }
};
_Schema_static = new WeakSet();
createNodesSchema_fn = function(nodeExtensions, attributes, editor) {
  const nodeEntries = nodeExtensions.map((extension) => {
    const extensionAttributes = attributes.filter((a) => a.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const attrs = Object.fromEntries(
      extensionAttributes.map((attr) => {
        return [attr.name, { default: attr?.attribute?.default }];
      })
    );
    const additionalNodeFields = nodeExtensions.reduce((fields, e) => {
      const extendNodeSchema = getExtensionConfigField(e, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanSchemaItem({
      content: callOrGet(getExtensionConfigField(extension, "content", context)),
      group: callOrGet(getExtensionConfigField(extension, "group", context)),
      marks: callOrGet(getExtensionConfigField(extension, "marks", context)),
      inline: callOrGet(getExtensionConfigField(extension, "inline", context)),
      atom: callOrGet(getExtensionConfigField(extension, "atom", context)),
      selectable: callOrGet(getExtensionConfigField(extension, "selectable", context)),
      draggable: callOrGet(getExtensionConfigField(extension, "draggable", context)),
      code: callOrGet(getExtensionConfigField(extension, "code", context)),
      defining: callOrGet(getExtensionConfigField(extension, "defining", context)),
      isolating: callOrGet(getExtensionConfigField(extension, "isolating", context)),
      attrs,
      ...additionalNodeFields
    });
    const parseDOM = callOrGet(getExtensionConfigField(extension, "parseDOM", context));
    if (parseDOM) {
      schema.parseDOM = parseDOM.map((parseRule) => {
        return Attribute.insertExtensionAttrsToParseRule(parseRule, extensionAttributes);
      });
    }
    const renderDOM = getExtensionConfigField(extension, "renderDOM", context);
    if (renderDOM) {
      schema.toDOM = (node) => renderDOM({
        node,
        htmlAttributes: Attribute.getAttributesToRender(node, extensionAttributes)
      });
    }
    const renderText = getExtensionConfigField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  });
  return Object.fromEntries(nodeEntries);
};
createMarksSchema_fn = function(markExtensions, attributes, editor) {
  const markEntries = markExtensions.map((extension) => {
    const extensionAttributes = attributes.filter((a) => a.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const attrs = Object.fromEntries(
      extensionAttributes.map((attr) => {
        return [attr.name, { default: attr?.attribute?.default }];
      })
    );
    const schema = cleanSchemaItem({
      group: callOrGet(getExtensionConfigField(extension, "group", context)),
      inclusive: callOrGet(getExtensionConfigField(extension, "inclusive", context)),
      excludes: callOrGet(getExtensionConfigField(extension, "excludes", context)),
      spanning: callOrGet(getExtensionConfigField(extension, "spanning", context)),
      code: callOrGet(getExtensionConfigField(extension, "code", context)),
      attrs
    });
    const parseDOM = callOrGet(getExtensionConfigField(extension, "parseDOM", context));
    if (parseDOM) {
      schema.parseDOM = parseDOM.map((parseRule) => {
        return Attribute.insertExtensionAttrsToParseRule(parseRule, extensionAttributes);
      });
    }
    const renderDOM = getExtensionConfigField(extension, "renderDOM", context);
    if (renderDOM) {
      schema.toDOM = (mark) => renderDOM({
        mark,
        htmlAttributes: Attribute.getAttributesToRender(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  });
  return Object.fromEntries(markEntries);
};
__privateAdd(_Schema, _Schema_static);
let Schema = _Schema;
const first = (commands2) => (props) => {
  const items = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) return true;
  }
  return false;
};
const command = (fn2) => (props) => fn2(props);
const insertTabChar = () => ({ tr }) => {
  tr.insertText("	", tr.selection.from, tr.selection.to);
  return true;
};
const insertTabCharacter = ({ tr, state, dispatch }) => {
  const { from: from2 } = tr.selection;
  const tabText = state.schema.text("	");
  tr = tr.replaceSelectionWith(tabText);
  tr = tr.setSelection(TextSelection.create(tr.doc, from2 + 1));
  if (dispatch) dispatch(tr);
  return true;
};
const insertTabNode = () => ({ tr, state, dispatch }) => {
  const newPos = tr.selection.from;
  const tabNode = state.schema?.nodes?.tab?.create();
  if (!tabNode) return insertTabCharacter({ tr, state, dispatch });
  tr.insert(newPos, tabNode);
  if (dispatch) dispatch(tr);
  return true;
};
const setMeta$1 = (key, value) => ({ tr }) => {
  tr.setMeta(key, value);
  return true;
};
const ensureMarks = (state, splittableMarks) => {
  const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();
  if (marks) {
    const filtered = marks.filter((m) => splittableMarks?.includes(m.type.name));
    state.tr.ensureMarks(filtered);
  }
};
const splitBlock$1 = ({ keepMarks = true } = {}) => (props) => {
  const { tr, state, dispatch, editor } = props;
  const { selection, doc: doc2 } = tr;
  const { $from, $to } = selection;
  const extensionAttrs = editor.extensionService.attributes;
  const newAttrs = Attribute.getSplittedAttributes(extensionAttrs, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) return false;
    if (dispatch) {
      if (keepMarks) ensureMarks(state, editor.extensionService.splittableMarks);
      tr.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) return false;
  if (dispatch) {
    const atEnd = $to.parentOffset === $to.parent.content.size;
    if (selection instanceof TextSelection) tr.deleteSelection();
    const deflt = $from.depth === 0 ? null : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types = atEnd && deflt ? [{ type: deflt, attrs: newAttrs }] : void 0;
    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);
    if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types = deflt ? [{ type: deflt, attrs: newAttrs }] : void 0;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr.mapping.map($from.before());
        const $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) ensureMarks(state, editor.extensionService.splittableMarks);
    tr.scrollIntoView();
  }
  return true;
};
const deleteSelection$1 = (state, dispatch) => {
  if (state.selection.empty)
    return false;
  if (dispatch)
    dispatch(state.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
const joinBackward$1 = (state, dispatch, view) => {
  let $cursor = atBlockStart(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range = $cursor.blockRange(), target = range && liftTarget(range);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state, $cut, dispatch, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = replaceStep$1(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state.tr.step(delStep);
          tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
function textblockAt(node, side, only = false) {
  for (let scan = node; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
const selectNodeBackward$1 = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node = $cut && $cut.nodeBefore;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state, view) {
  let { $cursor } = state.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
const joinForward$1 = (state, dispatch, view) => {
  let $cursor = atBlockEnd(state, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state, $cut, dispatch, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep$1(state.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr = state.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
const selectNodeForward$1 = (state, dispatch, view) => {
  let { $head, empty: empty2 } = state.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node = $cut && $cut.nodeAfter;
  if (!node || !NodeSelection.isSelectable(node))
    return false;
  if (dispatch)
    dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
const joinUp$1 = (state, dispatch) => {
  let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr = state.tr.join(point);
    if (nodeSel)
      tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const joinDown$1 = (state, dispatch) => {
  let sel = state.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state.tr.join(point).scrollIntoView());
  return true;
};
const newlineInCode$1 = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type } = match.edge(i);
    if (type.isTextblock && !type.hasRequiredAttrs())
      return type;
  }
  return null;
}
const exitCode$1 = (state, dispatch) => {
  let { $head, $anchor } = state.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));
  if (!type || !above.canReplaceWith(after, after, type))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const createParagraphNear$1 = (state, dispatch) => {
  let sel = state.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type || !type.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr = state.tr.insert(side, type.createAndFill());
    tr.setSelection(TextSelection.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const liftEmptyBlock$1 = (state, dispatch) => {
  let { $cursor } = state.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state.doc, before)) {
      if (dispatch)
        dispatch(state.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range = $cursor.blockRange(), target = range && liftTarget(range);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state.tr.lift(range, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state, dispatch) => {
    let { $from, $to } = state.selection;
    if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d = $from.depth; ; d--) {
      let node = $from.node(d);
      if (node.isBlock) {
        atEnd = $from.end(d) == $from.pos + ($from.depth - d);
        atStart = $from.start(d) == $from.pos - ($from.depth - d);
        deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));
        types.unshift(atEnd && deflt ? { type: deflt } : null);
        splitDepth = d;
        break;
      } else {
        if (d == 1)
          return false;
        types.unshift(null);
      }
    }
    let tr = state.tr;
    if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)
      tr.deleteSelection();
    let splitPos = tr.mapping.map($from.pos);
    let can = canSplit(tr.doc, splitPos, types.length, types);
    if (!can) {
      types[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr.doc, splitPos, types.length, types);
    }
    if (!can)
      return false;
    tr.split(splitPos, types.length, types);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first2 = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first2);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
const splitBlock = splitBlockAs();
const selectAll$1 = (state, dispatch) => {
  if (dispatch)
    dispatch(state.tr.setSelection(new AllSelection(state.doc)));
  return true;
};
function joinMaybeClear(state, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
    if (dispatch)
      dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state, $cut, dispatch, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state, $cut, dispatch))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end2 = $cut.pos + after.nodeSize, wrap = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap = Fragment.from(conn[i].create(null, wrap));
      wrap = Fragment.from(before.copy(wrap));
      let tr = state.tr.step(new ReplaceAroundStep$1($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap, 1, 0), conn.length, true));
      let $joinAt = tr.doc.resolve(end2 + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr.doc, $joinAt.pos))
        tr.join($joinAt.pos);
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state.tr.lift(range, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap = [];
    for (; ; ) {
      wrap.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end2 = Fragment.empty;
        for (let i = wrap.length - 1; i >= 0; i--)
          end2 = Fragment.from(wrap[i].copy(end2));
        let tr = state.tr.step(new ReplaceAroundStep$1($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end2, wrap.length, 0), 0, true));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state, dispatch) {
    let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
const selectTextblockStart$1 = selectTextblockSide(-1);
const selectTextblockEnd$1 = selectTextblockSide(1);
function setBlockType(nodeType, attrs = null) {
  return function(state, dispatch) {
    let applicable = false;
    for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (applicable)
          return false;
        if (!node.isTextblock || node.hasMarkup(nodeType, attrs))
          return;
        if (node.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state.doc.resolve(pos), index2 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr = state.tr;
      for (let i = 0; i < state.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state.selection.ranges[i];
        tr.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state, dispatch, view) {
    for (let i = 0; i < commands2.length; i++)
      if (commands2[i](state, dispatch, view))
        return true;
    return false;
  };
}
chainCommands(deleteSelection$1, joinBackward$1, selectNodeBackward$1);
chainCommands(deleteSelection$1, joinForward$1, selectNodeForward$1);
({
  "Enter": chainCommands(newlineInCode$1, createParagraphNear$1, liftEmptyBlock$1, splitBlock)
});
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
const liftEmptyBlock = () => ({ state, dispatch }) => liftEmptyBlock$1(state, dispatch);
const createParagraphNear = () => ({ state, dispatch }) => {
  return createParagraphNear$1(state, dispatch);
};
const newlineInCode = () => ({ state, dispatch }) => newlineInCode$1(state, dispatch);
const exitCode = () => ({ state, dispatch }) => {
  return exitCode$1(state, dispatch);
};
function canSetMark(editor, state, tr, newMarkType) {
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  let cursor = null;
  if (isTextSelection()) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = state.storedMarks ?? cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  return selection.ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;
    state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {
      if (someNodeSupportsMark) return false;
      if (node.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
const setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch, editor }) => {
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  const { empty: empty2, ranges } = selection;
  const type = getMarkType(typeOrName, state.schema);
  if (dispatch) {
    if (empty2) {
      const oldAttributes = Attribute.getMarkAttributes(state, type);
      tr.addStoredMark(
        type.create({
          ...oldAttributes,
          ...attributes
        })
      );
    } else {
      ranges.forEach((range) => {
        const from2 = range.$from.pos;
        const to = range.$to.pos;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node.nodeSize, to);
          const someHasMark = node.marks.find((mark) => mark.type === type);
          if (someHasMark) {
            node.marks.forEach((mark) => {
              if (type === mark.type) {
                tr.addMark(
                  trimmedFrom,
                  trimmedTo,
                  type.create({
                    ...mark.attrs,
                    ...attributes
                  })
                );
              }
            });
          } else {
            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(editor, state, tr, type);
};
const unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch, editor }) => {
  const { extendEmptyMarkRange = false } = options;
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  const type = getMarkType(typeOrName, state.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch) return true;
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = $from.marks().find((mark) => mark.type === type)?.attrs;
    const range = getMarkRange($from, type, attrs);
    if (range) {
      from2 = range.from;
      to = range.to;
    }
    tr.removeMark(from2, to, type);
  } else {
    ranges.forEach((range) => {
      tr.removeMark(range.$from.pos, range.$to.pos, type);
    });
  }
  tr.removeStoredMark(type);
  return true;
};
const unsetAllMarks = () => ({ tr, dispatch, editor }) => {
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  const { empty: empty2, ranges } = selection;
  if (empty2) return true;
  if (dispatch) {
    ranges.forEach((range) => {
      tr.removeMark(range.$from.pos, range.$to.pos);
    });
  }
  return true;
};
const toggleMark = (typeOrName, attrs = {}, options = {}) => ({ state, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type = getMarkType(typeOrName, state.schema);
  const isActive2 = isMarkActive(state, type, attrs);
  if (isActive2) return commands2.unsetMark(type, { extendEmptyMarkRange });
  return commands2.setMark(type, attrs);
};
const clearNodes = () => ({ state, tr, dispatch }) => {
  const { selection } = tr;
  const { ranges } = selection;
  if (!dispatch) return true;
  ranges.forEach(({ $from, $to }) => {
    state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {
      if (node.type.isText) return;
      const { doc: doc2, mapping } = tr;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) return;
      const targetLiftDepth = liftTarget(nodeRange);
      if (node.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
const setNode = (typeOrName, attrs = {}) => ({ state, dispatch, chain }) => {
  const type = getNodeType(typeOrName, state.schema);
  if (!type.isTextblock) return false;
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType(type, attrs)(state);
    if (canSetBlock) return true;
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type, attrs)(updatedState, dispatch);
  }).run();
};
const toggleNode = (typeOrName, toggleTypeOrName, attrs = {}) => ({ state, commands: commands2 }) => {
  const type = getNodeType(typeOrName, state.schema);
  const toggleType = getNodeType(toggleTypeOrName, state.schema);
  const isActive2 = isNodeActive(state, type, attrs);
  if (isActive2) return commands2.setNode(toggleType);
  return commands2.setNode(type, attrs);
};
const selectAll = () => ({ state, dispatch }) => selectAll$1(state, dispatch);
const deleteSelection = () => ({ state, tr, dispatch }) => {
  const { from: from2, to, empty: empty2 } = state.selection;
  if (empty2) {
    return deleteSelection$1(state, dispatch);
  }
  let hasListContent = false;
  state.doc.nodesBetween(from2, to, (node) => {
    if (node.type.name === "orderedList" || node.type.name === "bulletList" || node.type.name === "listItem") {
      hasListContent = true;
      return false;
    }
  });
  if (hasListContent) {
    const transaction = tr || state.tr;
    transaction.deleteRange(from2, to);
    if (dispatch) {
      dispatch(transaction);
    }
    return true;
  }
  return deleteSelection$1(state, dispatch);
};
const findNodePosition = (doc2, targetNode) => {
  let nodePos = null;
  doc2.descendants((node, pos) => {
    if (node === targetNode) {
      nodePos = pos;
      return false;
    }
  });
  return nodePos;
};
const isList = (n) => n.type.name === "orderedList" || n.type.name === "bulletList";
const handleBackspaceNextToList = () => ({ state, dispatch }) => {
  const { selection, doc: doc2 } = state;
  const { $from } = selection;
  if (!selection.empty) return false;
  if ($from.parent.type.name !== "paragraph") return false;
  if ($from.parentOffset !== 0) return false;
  const parentDepth = $from.depth - 1;
  if (parentDepth < 0) return false;
  const container = $from.node(parentDepth);
  const idx = $from.index(parentDepth);
  if (idx === 0) return false;
  const beforeNode = container.child(idx - 1);
  if (!beforeNode || !isList(beforeNode)) return false;
  const listItem = beforeNode.lastChild;
  if (!listItem || listItem.type.name !== "listItem") return false;
  const targetPara = listItem.lastChild;
  if (!targetPara || targetPara.type.name !== "paragraph") return false;
  const paraStartPos = findNodePosition(doc2, targetPara);
  if (paraStartPos == null) return false;
  const inlineContent = Fragment.from($from.parent.content);
  const tr = state.tr;
  tr.setMeta("updateListSync", true);
  const oldParaPos = $from.before();
  tr.delete(oldParaPos, oldParaPos + $from.parent.nodeSize);
  const insertPos = paraStartPos + 1 + targetPara.content.size;
  tr.insert(insertPos, inlineContent);
  tr.setSelection(TextSelection.near(tr.doc.resolve(insertPos), 1));
  dispatch(tr);
  return true;
};
const handleDeleteNextToList = () => ({ state, dispatch }) => {
  const { selection, doc: doc2 } = state;
  const { $from } = selection;
  if (!selection.empty) return false;
  if ($from.parent.type.name !== "paragraph") return false;
  if ($from.parentOffset !== $from.parent.content.size) return false;
  let currentDepth = $from.depth;
  let listItemDepth = -1;
  while (currentDepth > 0) {
    const node = $from.node(currentDepth - 1);
    if (node.type.name === "listItem") {
      listItemDepth = currentDepth - 1;
      break;
    }
    currentDepth--;
  }
  if (listItemDepth !== -1) {
    const listDepth = listItemDepth - 1;
    const list = $from.node(listDepth);
    const listItemIdx = $from.index(listDepth);
    const listContainer = $from.node(listDepth - 1);
    const listIdx = $from.index(listDepth - 1);
    if (listItemIdx < list.childCount - 1) {
      return true;
    }
    if (listIdx >= listContainer.childCount - 1) return false;
    const nextNode = listContainer.child(listIdx + 1);
    if (!isList(nextNode)) return false;
    const nextListItem = nextNode.firstChild;
    if (!nextListItem || nextListItem.type.name !== "listItem") return false;
    const nextPara = nextListItem.firstChild;
    if (!nextPara || nextPara.type.name !== "paragraph") return false;
    const nextListStartPos = findNodePosition(doc2, nextNode);
    if (nextListStartPos == null) return false;
    const targetInlineContent = Fragment.from(nextPara.content);
    const tr = state.tr;
    tr.setMeta("updateListSync", true);
    tr.delete(nextListStartPos, nextListStartPos + nextNode.nodeSize);
    const insertPos = tr.mapping.map($from.pos);
    tr.insert(insertPos, targetInlineContent);
    tr.setSelection(TextSelection.near(tr.doc.resolve(insertPos), 1));
    dispatch(tr);
    return true;
  } else {
    const parentDepth = $from.depth - 1;
    if (parentDepth < 0) return false;
    const container = $from.node(parentDepth);
    const idx = $from.index(parentDepth);
    if (idx >= container.childCount - 1) return false;
    const afterNode = container.child(idx + 1);
    if (!afterNode || !isList(afterNode)) return false;
    const listItem = afterNode.firstChild;
    if (!listItem || listItem.type.name !== "listItem") return false;
    const targetPara = listItem.firstChild;
    if (!targetPara || targetPara.type.name !== "paragraph") return false;
    const listStartPos = findNodePosition(doc2, afterNode);
    if (listStartPos == null) return false;
    const targetInlineContent = Fragment.from(targetPara.content);
    const tr = state.tr;
    tr.setMeta("updateListSync", true);
    tr.delete(listStartPos, listStartPos + afterNode.nodeSize);
    const insertPos = tr.mapping.map($from.pos);
    tr.insert(insertPos, targetInlineContent);
    tr.setSelection(TextSelection.near(tr.doc.resolve(insertPos), 1));
    dispatch(tr);
    return true;
  }
};
const updateAttributes = (typeOrName, attrs = {}) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) return false;
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range) => {
      const from2 = range.$from.pos;
      const to = range.$to.pos;
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr.setNodeMarkup(pos, void 0, { ...node.attrs, ...attrs });
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              const trimmedFrom = Math.max(pos, from2);
              const trimmedTo = Math.min(pos + node.nodeSize, to);
              tr.addMark(trimmedFrom, trimmedTo, markType.create({ ...mark.attrs, ...attrs }));
            }
          });
        }
      });
    });
  }
  return true;
};
const resetAttributes = (typeOrName, attrs) => ({ tr, state, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state.schema
  );
  if (!schemaType) return false;
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range) => {
      state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {
        if (nodeType && nodeType === node.type) {
          tr.setNodeMarkup(pos, void 0, deleteProps(node.attrs, attrs));
        }
        if (markType && node.marks.length) {
          node.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attrs)));
            }
          });
        }
      });
    });
  }
  return true;
};
const joinUp = () => ({ state, dispatch }) => joinUp$1(state, dispatch);
const joinDown = () => ({ state, dispatch }) => joinDown$1(state, dispatch);
const joinBackward = () => ({ state, dispatch }) => {
  const { selection, doc: doc2 } = state;
  const { $from } = selection;
  if (!$from.parent.isTextblock || $from.parentOffset > 0) {
    return joinBackward$1(state, dispatch);
  }
  const beforePos = $from.before();
  const nodeBefore = doc2.resolve(beforePos).nodeBefore;
  const nodeAfter = doc2.resolve(beforePos).nodeAfter;
  const isList2 = (node) => node?.type.name === "orderedList" || node?.type.name === "bulletList";
  if (isList2(nodeBefore) || isList2(nodeAfter)) {
    return false;
  }
  return joinBackward$1(state, dispatch);
};
const joinForward = () => ({ state, dispatch }) => {
  const { selection, doc: doc2 } = state;
  const { $from } = selection;
  if (!$from.parent.isTextblock || $from.parentOffset > 0) {
    return joinForward$1(state, dispatch);
  }
  const beforePos = $from.before();
  const nodeBefore = doc2.resolve(beforePos).nodeBefore;
  const nodeAfter = doc2.resolve(beforePos).nodeAfter;
  const isList2 = (node) => node?.type.name === "orderedList" || node?.type.name === "bulletList";
  if (isList2(nodeBefore) || isList2(nodeAfter)) {
    return false;
  }
  return joinForward$1(state, dispatch);
};
const selectNodeBackward = () => ({ state, dispatch }) => {
  return selectNodeBackward$1(state, dispatch);
};
const selectNodeForward = () => ({ state, dispatch }) => selectNodeForward$1(state, dispatch);
const selectTextblockStart = () => ({ state, dispatch }) => selectTextblockStart$1(state, dispatch);
const selectTextblockEnd = () => ({ state, dispatch }) => selectTextblockEnd$1(state, dispatch);
const insertContent = (value, options) => ({ tr, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
};
const removeWhitespaces = (node) => {
  const children = node.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options) {
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node = schema.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node.check();
      }
      return node;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[super-editor error]: Invalid JSON content", { cause: error });
      }
      console.warn("[super-editor warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema$1({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __supereditor__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser$1.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
      } else {
        DOMParser$1.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[super-editor error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${invalidContent}`)
        });
      }
    }
    const parser = DOMParser$1.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(elementFromString(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd(tr, startLen, bias) {
  const last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep$1)) {
    return;
  }
  const map2 = tr.mapping.maps[last];
  let end2 = 0;
  map2.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 === 0) {
      end2 = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end2), bias));
}
const isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
const insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {
  if (dispatch) {
    options = {
      parseOptions: {},
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content;
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...options.parseOptions
        },
        errorOnInvalidContent: options.errorOnInvalidContent ?? editor.options.enableContentCheck
      });
    } catch (e) {
      editor.emit("contentError", {
        editor,
        error: e,
        disableCollaboration: () => {
          console.error("[super-editor error]: Unable to disable collaboration at this point in time");
        }
      });
      return false;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node) => {
      node.check();
      isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v) => v.text || "").join("");
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr.insertText(newContent, from2, to);
    } else {
      newContent = content;
      tr.replaceWith(from2, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options.applyPasteRules) {
      tr.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
const undoInputRule = () => ({ state, dispatch }) => {
  const plugins = state.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin = plugins[i];
    let undoable;
    if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {
      if (dispatch) {
        const tr = state.tr;
        const toUndo = undoable.transform;
        for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {
          tr.step(toUndo.steps[j].invert(toUndo.docs[j]));
        }
        if (undoable.text) {
          const marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
function wrapInList$1(listType, attrs = null) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to);
    if (!range)
      return false;
    let tr = dispatch ? state.tr : null;
    if (!wrapRangeInList(tr, range, listType, attrs))
      return false;
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr, range, listType, attrs = null) {
  let doJoin = false, outerRange = range, doc2 = range.$from.doc;
  if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {
    if (range.$from.index(range.depth - 1) == 0)
      return false;
    let $insert = doc2.resolve(range.start - 2);
    outerRange = new NodeRange($insert, $insert, range.depth);
    if (range.endIndex < range.parent.childCount)
      range = new NodeRange(range.$from, doc2.resolve(range.$to.end(range.depth)), range.depth);
    doJoin = true;
  }
  let wrap = findWrapping(outerRange, listType, attrs, range);
  if (!wrap)
    return false;
  if (tr)
    doWrapInList(tr, range, wrap, doJoin, listType);
  return true;
}
function doWrapInList(tr, range, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr.step(new ReplaceAroundStep$1(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));
  let found = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found = i + 1;
  let splitDepth = wrappers.length - found;
  let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;
  for (let i = range.startIndex, e = range.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr;
}
function liftListItem$1(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range.depth - 1).type == itemType)
      return liftToOuterList(state, dispatch, itemType, range);
    else
      return liftOutOfList(state, dispatch, range);
  };
}
function liftToOuterList(state, dispatch, itemType, range) {
  let tr = state.tr, end2 = range.end, endOfList = range.$to.end(range.depth);
  if (end2 < endOfList) {
    tr.step(new ReplaceAroundStep$1(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));
    range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);
  }
  const target = liftTarget(range);
  if (target == null)
    return false;
  tr.lift(range, target);
  let $after = tr.doc.resolve(tr.mapping.map(end2, -1) - 1);
  if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr.join($after.pos);
  dispatch(tr.scrollIntoView());
  return true;
}
function liftOutOfList(state, dispatch, range) {
  let tr = state.tr, list = range.parent;
  for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;
  if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start2 = $start.pos, end2 = start2 + item.nodeSize;
  tr.step(new ReplaceAroundStep$1(start2 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start2 + 1, end2 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}
function sinkListItem$1(itemType) {
  return function(state, dispatch) {
    let { $from, $to } = state.selection;
    let range = $from.blockRange($to, (node) => node.childCount > 0 && node.firstChild.type == itemType);
    if (!range)
      return false;
    let startIndex = range.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range.start, after = range.end;
      dispatch(state.tr.step(new ReplaceAroundStep$1(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}
const wrapInList = (typeOrName, attrs = {}) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return wrapInList$1(type, attrs)(state, dispatch);
};
const toggleList = (listType) => ({ editor, state, tr }) => {
  const { selection } = state;
  const { from: from2, to } = selection;
  const isList2 = findParentNode((node) => node.type === listType)(tr.selection);
  if (!isList2) {
    if (!selection.empty && from2 !== to) {
      const paragraphsToConvert = [];
      state.doc.nodesBetween(from2, to, (node, pos) => {
        if (node.type.name === "paragraph") {
          const nodeFrom = pos;
          const nodeTo = pos + node.nodeSize;
          if (nodeFrom < to && nodeTo > from2) {
            paragraphsToConvert.push({
              node,
              pos,
              from: Math.max(nodeFrom, from2),
              to: Math.min(nodeTo, to)
            });
          }
        }
        return false;
      });
      if (paragraphsToConvert.length > 1) {
        const numId = ListHelpers.getNewListId(editor);
        if (typeof listType === "string") listType = editor.schema.nodes[listType];
        ListHelpers.generateNewListDefinition({ numId, listType, editor });
        paragraphsToConvert.reverse().forEach(({ node, pos }) => {
          const level = 0;
          const listLevel = [1];
          const listNode = ListHelpers.createSchemaOrderedListNode({
            level,
            numId,
            listType,
            editor,
            listLevel,
            contentNode: node.toJSON()
          });
          const replaceFrom = pos;
          const replaceTo = pos + node.nodeSize;
          ListHelpers.insertNewList(tr, replaceFrom, replaceTo, listNode);
        });
        return true;
      }
    }
    return ListHelpers.createNewList({ listType, tr, editor });
  }
  return false;
};
const decreaseListIndent = () => ({ editor, tr }) => {
  const { state } = editor;
  const currentNode = ListHelpers.getCurrentListItem(state);
  if (!currentNode) return false;
  const parentList = ListHelpers.getParentOrderedList(state);
  if (!parentList) return false;
  const currentLevel = currentNode.node.attrs.level;
  const newLevel = currentLevel - 1;
  if (newLevel < 0) {
    return false;
  }
  const numId = currentNode.node.attrs.numId;
  tr.setNodeMarkup(currentNode.pos, null, {
    ...currentNode.node.attrs,
    level: newLevel,
    numId
  });
  return true;
};
const splitListItem = () => (props) => {
  const { tr, state, editor } = props;
  const type = getNodeType("listItem", state.schema);
  const { $from, $to } = state.selection;
  tr.setMeta("updateListSync", true);
  const currentListItem = findParentNode((node) => node.type.name === "listItem")(state.selection);
  if (!currentListItem) return false;
  if (state.selection.node && state.selection.node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    return handleSplitInEmptyBlock(props, currentListItem);
  }
  const matchedListItem = findParentNode((node) => node.type === type)(state.selection);
  const { node: listItemNode } = matchedListItem || {};
  if (listItemNode.type !== type) return false;
  const listTypes = ["orderedList", "bulletList"];
  const matchedParentList = findParentNode((node) => listTypes.includes(node.type.name))(state.selection);
  const { node: parentListNode } = matchedParentList || {};
  if ($from.pos !== $to.pos) tr.delete($from.pos, $to.pos);
  const paragraphNode = $from.node();
  const paraOffset = $from.parentOffset;
  const beforeCursor = paragraphNode.content.cut(0, paraOffset);
  const afterCursor = paragraphNode.content.cut(paraOffset);
  let firstList, secondList;
  const marks = state.storedMarks || $from.marks() || [];
  const listItemHasMultipleParagraphs = listItemNode.childCount > 1;
  if (listItemHasMultipleParagraphs) {
    const paragraphIndex = $from.index(-1);
    let contentBeforeCurrentPara = [];
    for (let i = 0; i < paragraphIndex; i++) {
      contentBeforeCurrentPara.push(listItemNode.child(i));
    }
    let contentAfterCurrentPara = [];
    for (let i = paragraphIndex + 1; i < listItemNode.childCount; i++) {
      contentAfterCurrentPara.push(listItemNode.child(i));
    }
    let firstListContent = [...contentBeforeCurrentPara];
    if (beforeCursor.size > 0) {
      const modifiedFirstParagraph = editor.schema.nodes.paragraph.create(paragraphNode.attrs, beforeCursor);
      firstListContent.push(modifiedFirstParagraph);
    }
    let secondListContent = [];
    if (afterCursor && afterCursor.size > 0) {
      const modifiedSecondParagraph = editor.schema.nodes.paragraph.create(paragraphNode.attrs, afterCursor);
      secondListContent.push(modifiedSecondParagraph);
    } else {
      const emptyParagraph = editor.schema.nodes.paragraph.create(paragraphNode.attrs);
      secondListContent.push(emptyParagraph);
    }
    secondListContent = secondListContent.concat(contentAfterCurrentPara);
    if (firstListContent.length === 0) {
      const emptyParagraph = editor.schema.nodes.paragraph.create();
      firstListContent = [emptyParagraph];
    }
    if (secondListContent.length === 0) {
      const emptyParagraph = editor.schema.nodes.paragraph.create();
      secondListContent = [emptyParagraph];
    }
    const firstListItem = editor.schema.nodes.listItem.create(
      { ...listItemNode.attrs },
      Fragment.from(firstListContent)
    );
    firstList = editor.schema.nodes.orderedList.createAndFill(parentListNode.attrs, Fragment.from(firstListItem));
    const secondListItem = editor.schema.nodes.listItem.create(
      { ...listItemNode.attrs },
      Fragment.from(secondListContent)
    );
    secondList = editor.schema.nodes.orderedList.createAndFill(parentListNode.attrs, Fragment.from(secondListItem));
  } else {
    let firstParagraphContent = beforeCursor;
    if (beforeCursor.size === 0) {
      firstParagraphContent = editor.schema.text(" ", marks);
    }
    const firstParagraph = editor.schema.nodes.paragraph.create(paragraphNode.attrs, firstParagraphContent);
    const firstListItem = editor.schema.nodes.listItem.create({ ...listItemNode.attrs }, firstParagraph);
    firstList = editor.schema.nodes.orderedList.createAndFill(parentListNode.attrs, Fragment.from(firstListItem));
    let secondParagraphContent = afterCursor;
    if (afterCursor.size === 0) {
      secondParagraphContent = editor.schema.text(" ", marks);
    }
    const secondParagraph = editor.schema.nodes.paragraph.create(paragraphNode.attrs, secondParagraphContent);
    const secondListItem = editor.schema.nodes.listItem.create({ ...listItemNode.attrs }, secondParagraph);
    secondList = editor.schema.nodes.orderedList.createAndFill(parentListNode.attrs, Fragment.from(secondListItem));
  }
  if (!firstList || !secondList) return false;
  const listStart = matchedParentList.pos;
  const listEnd = matchedParentList.pos + parentListNode.nodeSize;
  tr.replaceWith(listStart, listEnd, firstList);
  const insertPosition = listStart + firstList.nodeSize;
  tr.insert(insertPosition, secondList);
  const secondListStart = insertPosition + 2;
  tr.setSelection(TextSelection.near(tr.doc.resolve(secondListStart)));
  tr.scrollIntoView();
  if (marks?.length) {
    tr.ensureMarks(marks);
  }
  tr.setMeta("splitListItem", true);
  return true;
};
const handleSplitInEmptyBlock = (props, currentListItem) => {
  const { state, editor, tr } = props;
  const { schema } = state;
  const { $from } = state.selection;
  const extensionAttrs = editor.extensionService.attributes;
  const listItemNode = currentListItem.node;
  const isEmptyParagraph = $from.parent.content.size === 0;
  const listItemHasOtherContent = listItemNode.content.size > $from.parent.nodeSize;
  const isAtEndOfListItem = $from.indexAfter(-1) === $from.node(-1).childCount;
  if (isEmptyParagraph && listItemHasOtherContent && isAtEndOfListItem) {
    try {
      const listTypes = ["orderedList", "bulletList"];
      const parentList = findParentNode((node) => listTypes.includes(node.type.name))(state.selection);
      if (!parentList) return false;
      const newParagraphAttrs = Attribute.getSplittedAttributes(extensionAttrs, "paragraph", {});
      const newParagraph = schema.nodes.paragraph.create(newParagraphAttrs);
      const newListItem = schema.nodes.listItem.create({ ...listItemNode.attrs }, newParagraph);
      const newList = schema.nodes.orderedList.createAndFill(parentList.node.attrs, Fragment.from(newListItem));
      if (!newList) return false;
      const insertPos = parentList.pos + parentList.node.nodeSize;
      tr.insert(insertPos, newList);
      const newPos = insertPos + 2;
      tr.setSelection(TextSelection.near(tr.doc.resolve(newPos)));
      tr.scrollIntoView();
      return true;
    } catch (error) {
      console.error("Error creating new list item:", error);
      return false;
    }
  }
  if (isEmptyParagraph && listItemHasOtherContent && !isAtEndOfListItem) {
    return false;
  }
  const isListItemEmpty = () => {
    if (listItemNode.childCount === 0) return true;
    for (let i = 0; i < listItemNode.childCount; i++) {
      const child = listItemNode.child(i);
      if (child.type.name === "paragraph" && child.content.size === 0) {
        continue;
      } else if (child.type.name === "paragraph" && child.content.size > 0) {
        return false;
      } else {
        return false;
      }
    }
    return true;
  };
  if (isListItemEmpty()) {
    const didOutdent = decreaseListIndent()({ editor, tr });
    if (didOutdent) return true;
    try {
      const listTypes = ["orderedList", "bulletList"];
      const parentList = findParentNode((node) => listTypes.includes(node.type.name))(state.selection);
      if (!parentList) {
        console.error("No parent list found");
        return false;
      }
      const newParagraphAttrs = Attribute.getSplittedAttributes(extensionAttrs, "paragraph", {});
      const paragraphType = schema.nodes.paragraph;
      let newParagraph = paragraphType.createAndFill(newParagraphAttrs);
      if (!newParagraph) {
        newParagraph = paragraphType.create();
      }
      const listStart = parentList.pos;
      const listEnd = parentList.pos + parentList.node.nodeSize;
      tr.replaceWith(listStart, listEnd, newParagraph);
      const newPos = listStart + 1;
      tr.setSelection(TextSelection.near(tr.doc.resolve(newPos)));
      tr.scrollIntoView();
      return true;
    } catch (error) {
      console.error("Error destroying list:", error);
      return false;
    }
  }
  return false;
};
const sinkListItem = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return sinkListItem$1(type)(state, dispatch);
};
const liftListItem = (typeOrName) => ({ state, dispatch }) => {
  const type = getNodeType(typeOrName, state.schema);
  return liftListItem$1(type)(state, dispatch);
};
const deleteListItem = () => (props) => {
  const { tr, state } = props;
  const { selection } = state;
  tr.setMeta("updateListSync", true);
  if (!selection.empty) {
    const { from: from2, to } = selection;
    const fullySelectedBlocks = [];
    state.doc.nodesBetween(from2, to, (node, pos) => {
      if (node.isBlock && pos >= from2 && pos + node.nodeSize <= to) {
        fullySelectedBlocks.push({ pos, size: node.nodeSize });
      }
    });
    if (fullySelectedBlocks.length) {
      fullySelectedBlocks.sort((a, b) => b.pos - a.pos).forEach(({ pos, size }) => {
        tr.delete(pos, pos + size);
      });
      const $new = tr.doc.resolve(from2);
      tr.setSelection(TextSelection.near($new));
      return true;
    }
    return false;
  }
  const { $from } = state.selection;
  if ($from.parentOffset !== 0) return false;
  const currentListItem = findParentNode((n) => n.type.name === "listItem")(state.selection);
  if (!currentListItem) return false;
  const listTypes = ["orderedList", "bulletList"];
  const parentList = findParentNode((n) => listTypes.includes(n.type.name))(state.selection);
  if (!parentList) return false;
  const currentParagraphNode = findParentNode((n) => n.type.name === "paragraph")(state.selection);
  const paragraphNode = currentListItem.node.content.firstChild;
  if (paragraphNode !== currentParagraphNode.node) return false;
  const listFrom = parentList.pos;
  const listTo = listFrom + parentList.node.nodeSize;
  if (currentListItem.node.content.size === 0) {
    tr.delete(listFrom, listTo);
    return true;
  }
  const listItemContent = currentListItem.node.content;
  const nodes = [];
  listItemContent.forEach((child) => {
    nodes.push(child);
  });
  tr.replaceWith(listFrom, listTo, nodes);
  const $pos = tr.doc.resolve(listFrom + 1);
  tr.setSelection(TextSelection.near($pos));
  return true;
};
const increaseListIndent = () => ({ editor, tr }) => {
  const { state } = editor;
  const currentNode = ListHelpers.getCurrentListItem(state);
  if (!currentNode) return false;
  const parentList = ListHelpers.getParentOrderedList(state);
  if (!parentList) return false;
  const newLevel = currentNode.node.attrs.level + 1;
  const numId = currentNode.node.attrs.numId;
  tr.setNodeMarkup(currentNode.pos, null, {
    ...currentNode.node.attrs,
    level: newLevel,
    numId
  });
  return true;
};
const restoreSelection = () => ({ editor, state, tr }) => {
  if (editor.options.lastSelection) {
    const selectionTr = tr.setSelection(
      TextSelection.create(state.doc, editor.options.lastSelection.from, editor.options.lastSelection.to)
    );
    editor.view.dispatch(selectionTr);
  }
};
const commands$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clearNodes,
  command,
  createParagraphNear,
  decreaseListIndent,
  deleteListItem,
  deleteSelection,
  exitCode,
  first,
  handleBackspaceNextToList,
  handleDeleteNextToList,
  increaseListIndent,
  insertContent,
  insertContentAt,
  insertTabChar,
  insertTabCharacter,
  insertTabNode,
  joinBackward,
  joinDown,
  joinForward,
  joinUp,
  liftEmptyBlock,
  liftListItem,
  newlineInCode,
  resetAttributes,
  restoreSelection,
  selectAll,
  selectNodeBackward,
  selectNodeForward,
  selectTextblockEnd,
  selectTextblockStart,
  setMark,
  setMeta: setMeta$1,
  setNode,
  sinkListItem,
  splitBlock: splitBlock$1,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapInList
}, Symbol.toStringTag, { value: "Module" }));
const Commands = Extension.create({
  name: "commands",
  addCommands() {
    return { ...commands$1 };
  }
});
const handleEnter = (editor) => {
  return editor.commands.first(({ commands: commands2 }) => [
    () => commands2.newlineInCode(),
    () => commands2.createParagraphNear(),
    () => commands2.liftEmptyBlock(),
    () => commands2.splitBlock()
  ]);
};
const handleBackspace = (editor) => {
  return editor.commands.first(({ commands: commands2, tr }) => [
    () => commands2.undoInputRule(),
    () => {
      tr.setMeta("inputType", "deleteContentBackward");
      return false;
    },
    () => commands2.deleteSelection(),
    () => commands2.handleBackspaceNextToList(),
    () => commands2.deleteListItem(),
    () => commands2.joinBackward(),
    () => commands2.selectNodeBackward()
  ]);
};
const handleDelete = (editor) => {
  return editor.commands.first(({ commands: commands2 }) => [
    () => commands2.deleteSelection(),
    () => commands2.handleDeleteNextToList(),
    () => commands2.joinForward(),
    () => commands2.selectNodeForward()
  ]);
};
const Keymap = Extension.create({
  name: "keymap",
  addShortcuts() {
    const baseKeymap = {
      Enter: () => handleEnter(this.editor),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: () => handleBackspace(this.editor),
      "Mod-Backspace": () => handleBackspace(this.editor),
      "Shift-Backspace": () => handleBackspace(this.editor),
      Delete: () => handleDelete(this.editor),
      "Mod-Delete": () => handleDelete(this.editor),
      "Mod-a": () => this.editor.commands.selectAll(),
      Tab: () => this.editor.commands.insertTabNode()
    };
    const pcBaseKeymap = {
      ...baseKeymap
    };
    const macBaseKeymap = {
      ...baseKeymap,
      "Ctrl-h": () => handleBackspace(this.editor),
      "Alt-Backspace": () => handleBackspace(this.editor),
      "Ctrl-d": () => handleDelete(this.editor),
      "Ctrl-Alt-Backspace": () => handleDelete(this.editor),
      "Alt-Delete": () => handleDelete(this.editor),
      "Alt-d": () => handleDelete(this.editor),
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
      "Ctrl-t": () => this.editor.commands.insertTabChar()
    };
    if (isMacOS() || isIOS()) {
      return macBaseKeymap;
    }
    return pcBaseKeymap;
  }
});
const Editable = Extension.create({
  name: "editable",
  addPmPlugins() {
    const editablePlugin = new Plugin({
      key: new PluginKey("editable"),
      props: {
        editable: () => {
          return this.editor.options.editable;
        }
      }
    });
    return [editablePlugin];
  }
});
const EditorFocus = Extension.create({
  name: "editorFocus",
  addPmPlugins() {
    const editor = this.editor;
    const editorFocusPlugin = new Plugin({
      key: new PluginKey("editorFocus"),
      props: {
        handleDOMEvents: {
          focus: (view, event) => {
            editor.isFocused = true;
            const tr = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
            view.dispatch(tr);
            return false;
          },
          blur: (view, event) => {
            editor.isFocused = false;
            const tr = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
            view.dispatch(tr);
            return false;
          }
        }
      }
    });
    return [editorFocusPlugin];
  }
});
const global = globalThis || void 0 || self;
const domIndex = function(node) {
  for (var index2 = 0; ; index2++) {
    node = node.previousSibling;
    if (!node)
      return index2;
  }
};
const parentNode = function(node) {
  let parent = node.assignedSlot || node.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
let reusedRange = null;
const textRange = function(node, from2, to) {
  let range = reusedRange || (reusedRange = document.createRange());
  range.setEnd(node, to == null ? node.nodeValue.length : to);
  range.setStart(node, from2 || 0);
  return range;
};
const clearReusedRange = function() {
  reusedRange = null;
};
const isEquivalentPosition = function(node, off, targetNode, targetOff) {
  return targetNode && (scanFor(node, off, targetNode, targetOff, -1) || scanFor(node, off, targetNode, targetOff, 1));
};
const atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node, off, targetNode, targetOff, dir) {
  var _a;
  for (; ; ) {
    if (node == targetNode && off == targetOff)
      return true;
    if (off == (dir < 0 ? 0 : nodeSize(node))) {
      let parent = node.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) || node.contentEditable == "false")
        return false;
      off = domIndex(node) + (dir < 0 ? 0 : 1);
      node = parent;
    } else if (node.nodeType == 1) {
      let child = node.childNodes[off + (dir < 0 ? -1 : 0)];
      if (child.nodeType == 1 && child.contentEditable == "false") {
        if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection)
          off += dir;
        else
          return false;
      } else {
        node = child;
        off = dir < 0 ? nodeSize(node) : 0;
      }
    } else {
      return false;
    }
  }
}
function nodeSize(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function textNodeBefore$1(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3 && offset2)
      return node;
    if (node.nodeType == 1 && offset2 > 0) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2 - 1];
      offset2 = nodeSize(node);
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset2 = domIndex(node);
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node, offset2) {
  for (; ; ) {
    if (node.nodeType == 3 && offset2 < node.nodeValue.length)
      return node;
    if (node.nodeType == 1 && offset2 < node.childNodes.length) {
      if (node.contentEditable == "false")
        return null;
      node = node.childNodes[offset2];
      offset2 = 0;
    } else if (node.parentNode && !hasBlockDesc(node)) {
      offset2 = domIndex(node) + 1;
      node = node.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node); atStart || atEnd; ) {
    if (node == parent)
      return true;
    let index2 = domIndex(node);
    node = node.parentNode;
    if (!node)
      return false;
    atStart = atStart && index2 == 0;
    atEnd = atEnd && index2 == nodeSize(node);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
const selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc2, x, y) {
  if (doc2.caretPositionFromPoint) {
    try {
      let pos = doc2.caretPositionFromPoint(x, y);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_) {
    }
  }
  if (doc2.caretRangeFromPoint) {
    let range = doc2.caretRangeFromPoint(x, y);
    if (range)
      return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };
  }
}
const nav = typeof navigator != "undefined" ? navigator : null;
const doc$1 = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
const chrome = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
const windows$1 = nav ? /Win/.test(nav.platform) : false;
const android = /Android \d/.test(agent);
const webkit = !!doc$1 && "webkitFontSmoothing" in doc$1.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc2) {
  let vp = doc2.defaultView && doc2.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide$1(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node) {
  let rect = node.getBoundingClientRect();
  let scaleX = rect.width / node.offsetWidth || 1;
  let scaleY = rect.height / node.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc2 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc2.body;
    let bounding = atTop ? windowRect(doc2) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide$1(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide$1(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide$1(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide$1(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide$1(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide$1(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide$1(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide$1(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide$1(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {
    let dom = view.root.elementFromPoint(x, y);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack = [], doc2 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc2)
      break;
  }
  return stack;
}
function resetScrollPos({ refDOM, refTop, stack }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack, dTop) {
  for (let i = 0; i < stack.length; i++) {
    let { dom, top: top2, left: left2 } = stack[i];
    if (dom.scrollTop != top2 + dTop)
      dom.scrollTop = top2 + dTop;
    if (dom.scrollLeft != left2)
      dom.scrollLeft = left2;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node, offset: offset2 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node, coords) {
  let len = node.nodeValue.length;
  let range = document.createRange();
  for (let i = 0; i < len; i++) {
    range.setEnd(node, i + 1);
    range.setStart(node, i);
    let rect = singleRect(range, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
  if (node.nodeType == 1 && !node.firstChild) {
    let rect = node.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node, offset2, bias);
}
function posFromCaret(view, node, offset2, coords) {
  let outsideBlock = -1;
  for (let cur = node, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset2, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j = 0; j < rects.length; j++) {
          let rect = rects[j];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc2 = view.dom.ownerDocument, node, offset2 = 0;
  let caret = caretFromPoint(doc2, coords.left, coords.top);
  if (caret)
    ({ node, offset: offset2 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node && p; p = parentNode(p))
      if (p.draggable)
        node = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node) {
    if (gecko && node.nodeType == 1) {
      offset2 = Math.min(offset2, node.childNodes.length);
      if (offset2 < node.childNodes.length) {
        let next = node.childNodes[offset2], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset2++;
      }
    }
    let prev;
    if (webkit && offset2 && node.nodeType == 1 && (prev = node.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset2--;
    if (node == view.dom && offset2 == node.childNodes.length - 1 && node.lastChild.nodeType == 1 && coords.top > node.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node.nodeType != 1 || node.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node, offset: offset2, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset2 : offset2 == node.nodeValue.length))) {
      let rect = singleRect(textRange(node, offset2, offset2), side);
      if (gecko && offset2 && /\s/.test(node.nodeValue[offset2 - 1]) && offset2 < node.nodeValue.length) {
        let rectBefore = singleRect(textRange(node, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
      let before = node.childNodes[offset2 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset2 < nodeSize(node)) {
      let after = node.childNodes[offset2];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node))) {
    let before = node.childNodes[offset2 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset2 < nodeSize(node)) {
    let after = node.childNodes[offset2];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0)
    return rect;
  let x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0)
    return rect;
  let y = top2 ? rect.top : rect.bottom;
  return { top: y, bottom: y, left: rect.left, right: rect.right };
}
function withFlushedState(view, state, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state)
    view.updateState(state);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state, dir) {
  let sel = state.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
const maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state, dir) {
  let { $head } = state.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
let cachedState = null;
let cachedDir = null;
let cachedResult = false;
function endOfTextblock(view, state, dir) {
  if (cachedState == state && cachedDir == dir)
    return cachedResult;
  cachedState = state;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state, dir) : endOfTextblockHorizontal(view, state, dir);
}
const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
class ViewDesc {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size = 0;
    for (let i = 0; i < this.children.length; i++)
      size += this.children[i].size;
    return size;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset2 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset2];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search2 = dom; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = false;
            break;
          }
          if (search2.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom.childNodes.length)
        for (let search2 = dom; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = true;
            break;
          }
          if (search2.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset2, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset2, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == pos && end2 != offset2) {
        while (!child.border && child.children.length) {
          for (let i2 = 0; i2 < child.children.length; i2++) {
            let inner = child.children[i2];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end2)
        return child.descAt(pos - offset2 - child.border);
      offset2 = end2;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset2 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = curPos + child.size;
      if (end2 > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end2;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter = true;
      for (; ; i--, enter = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter = true;
      for (; ; i++, enter = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i = 0; ; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (fromOffset == -1 && from2 <= end2) {
        let childBase = offset2 + child.border;
        if (from2 >= childBase && to <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset2;
        for (let j = i; j > 0; j--) {
          let prev = this.children[j - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end2 > to || i == this.children.length - 1)) {
        to = end2;
        for (let j = i + 1; j < this.children.length; j++) {
          let next = this.children[j];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end2;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node, offset: offset2 } = this.domFromPos(pos, 0);
    if (node.nodeType != 1 || offset2 == node.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node.childNodes[offset2];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (from2 > offset2 && to < end2)
        return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, view, force);
      offset2 = end2;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node, offset: offset2 } = anchorDOM;
      if (node.nodeType == 3) {
        brKludge = !!(offset2 && node.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node.nodeValue.length) {
          for (let scan = node, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node.childNodes[offset2 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range = document.createRange();
      range.setEnd(headDOM.node, headDOM.offset);
      range.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset2 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == end2 ? from2 <= end2 && to >= offset2 : from2 < end2 && to > offset2) {
        let startInside = offset2 + child.border, endInside = end2 - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset2 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset2 = end2;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node = this.parent; node; node = node.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node.dirty < dirty)
        node.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  get ignoreForSelection() {
    return false;
  }
  isText(text) {
    return false;
  }
}
class WidgetViewDesc extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap = document.createElement("span");
        wrap.appendChild(dom);
        dom = wrap;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CompositionViewDesc extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset2) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
}
class MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy = MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size = this.size;
    if (to < size)
      nodes = replaceNodes(nodes, to, size, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy;
    copy.children = nodes;
    return copy;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
}
class NodeViewDesc extends ViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node.type.name], descObj;
    let spec = custom && custom(node, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node.isText) {
      if (!dom)
        dom = document.createTextNode(node.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node.isText)
      return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark$1.none : this.node.child(i).marks, inline, view);
      updater.placeWidget(widget, view, off);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
      else if (compositionInChild && view.state.selection.from > off && view.state.selection.to < off + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off);
      }
      off += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node, pos, text }) {
    if (this.getDesc(node))
      return;
    let topNode = node;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node.sameMarkup(this.node))
      return false;
    this.updateInner(node, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  let docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
class TextViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset2, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node = this.node.cut(from2, to), dom = document.createTextNode(node.text);
    return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
}
class TrailingHackViewDesc extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CustomNodeViewDesc extends NodeViewDesc {
  constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {
      let result = this.spec.update(node, outerDeco, innerDeco);
      if (result)
        this.updateInner(node, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node.isLeaf) {
      return false;
    } else {
      return super.update(node, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
}
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
const OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
const noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m;
      while (m = prop.exec(prev.style))
        dom.style.removeProperty(m[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));
}
function sameOuterDeco(a, b) {
  if (a.length != b.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class ViewTreeUpdater {
  constructor(top2, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start2, end2) {
    if (start2 == end2)
      return;
    for (let i = start2; i < end2; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start2, end2 - start2);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep < maxKeep && (keep == depth - 1 ? this.top : this.stack[keep + 1 << 1]).matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)
      keep++;
    while (keep < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found = i;
          break;
        }
      }
      if (found > -1) {
        if (found > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node, outerDeco, innerDeco, index2) {
    let found = -1, targetDesc;
    if (index2 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index2 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node, outerDeco, innerDeco)) {
      found = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found = i;
          break;
        }
      }
    }
    if (found < 0)
      return false;
    this.destroyBetween(this.index, found);
    this.index++;
    return true;
  }
  updateNodeAt(node, outerDeco, innerDeco, index2, view) {
    let child = this.top.children[index2];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index2);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node, outerDeco, innerDeco, view, index2, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index2)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node.isAtom || !next.children.length || !next.node.content.eq(node.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node) {
    return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));
  }
}
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node = desc.node;
    if (!node)
      continue;
    if (node != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches.push(desc);
  }
  return { index: fI, matched, matches: matches.reverse() };
}
function compareSide(a, b) {
  return a.type.side - b.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset2, child), i);
      offset2 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index2;
    if (restNode) {
      index2 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index2 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset2)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    let end2 = offset2 + child.nodeSize;
    if (child.isText) {
      let cutAt = end2;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end2) {
        restNode = child.cut(cutAt - offset2);
        child = child.cut(0, cutAt - offset2);
        end2 = cutAt;
        index2 = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end2)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d) => !d.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset2, child), index2);
    offset2 = end2;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found >= 0 && found + text.length + childStart >= from2)
        return childStart + found;
      if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off = 0; i < nodes.length; i++) {
    let child = nodes[i], start2 = off, end2 = off += child.size;
    if (start2 >= to || end2 <= from2) {
      result.push(child);
    } else {
      if (start2 < from2)
        result.push(child.slice(0, from2 - start2, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end2 > to)
        result.push(child.slice(to - start2, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc2 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc2.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min2 = head, max2 = head;
      for (let i = 0; i < domSel.rangeCount; i++) {
        let range = domSel.getRangeAt(i);
        min2 = Math.min(min2, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));
        max2 = Math.max(max2, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));
      }
      if (min2 < 0)
        return null;
      [anchor, head] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
      $head = doc2.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc2.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
const brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after = offset2 < node.childNodes.length ? node.childNodes[offset2] : null;
  let before = offset2 ? node.childNodes[offset2 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range = document.createRange();
  if (!domSel)
    return;
  let node = view.cursorWrapper.dom, img = node.nodeName == "IMG";
  if (img)
    range.setStart(node.parentNode, domIndex(node) + 1);
  else
    range.setStart(node, 0);
  range.collapse(true);
  domSel.removeAllRanges();
  domSel.addRange(range);
  if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
    node.disabled = true;
    node.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state, dir) {
  let { $anchor, $head } = state.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node || node.isText || !node.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));
      return apply(view, new TextSelection(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply(view, next);
      return false;
    } else if (!(mac$2 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node || node.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;
      if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node)) {
        return apply(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));
      } else if (webkit) {
        return apply(view, new TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply(view, new TextSelection(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply(view, next);
    return false;
  }
}
function nodeLen(node) {
  return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node.nodeType == 1 && offset2 < nodeLen(node) && isIgnorable(node.childNodes[offset2], -1))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node.nodeType != 1) {
        break;
      } else {
        let before = node.childNodes[offset2 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node = before;
          offset2 = node.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node)) {
      break;
    } else {
      let prev = node.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = 0;
      } else {
        node = prev;
        offset2 = nodeLen(node);
      }
    }
  }
  if (force)
    setSelFocus(view, node, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node = sel.focusNode, offset2 = sel.focusOffset;
  if (!node)
    return;
  let len = nodeLen(node);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node.nodeType != 1)
        break;
      let after = node.childNodes[offset2];
      if (isIgnorable(after, 1)) {
        moveNode = node;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node)) {
      break;
    } else {
      let next = node.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node = node.parentNode;
        if (node == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node = next;
        offset2 = 0;
        len = nodeLen(node);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node, offset2) {
  while (node && offset2 == node.childNodes.length && !hasBlockDesc(node)) {
    offset2 = domIndex(node) + 1;
    node = node.parentNode;
  }
  while (node && offset2 < node.childNodes.length) {
    let next = node.childNodes[offset2];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = 0;
  }
}
function textNodeBefore(node, offset2) {
  while (node && !offset2 && !hasBlockDesc(node)) {
    offset2 = domIndex(node);
    node = node.parentNode;
  }
  while (node && offset2) {
    let next = node.childNodes[offset2 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node = next;
    offset2 = node.childNodes.length;
  }
}
function setSelFocus(view, node, offset2) {
  if (node.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node, offset2)) {
      node = after;
      offset2 = 0;
    } else if (before = textNodeBefore(node, offset2)) {
      node = before;
      offset2 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range = document.createRange();
    range.setEnd(node, offset2);
    range.setStart(node, offset2);
    sel.removeAllRanges();
    sel.addRange(range);
  } else if (sel.extend) {
    sel.extend(node, offset2);
  }
  view.domObserver.setCurSelection();
  let { state } = view;
  setTimeout(() => {
    if (view.state == state)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows$1) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed2 = getComputedStyle(view.dom).direction;
  return computed2 == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac$2 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view.state.tr;
    if (dir < 0)
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node, state) {
  view.domObserver.stop();
  node.contentEditable = state;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac$2 && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac$2 && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac$2 && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac$2 && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac$2 && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac$2 && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac$2 ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node = content.firstChild;
    context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);
    content = node.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc2 = detachedDoc(), wrap = doc2.createElement("div");
  wrap.appendChild(serializer.serializeFragment(content, { document: doc2 }));
  let firstChild = wrap.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc2.createElement(needsWrap[i]);
      while (wrap.firstChild)
        wrapper.appendChild(wrap.firstChild);
      wrap.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap, text, slice: slice2 };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text)
    return null;
  let asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode)
      return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node = slice2.content.firstChild; openStart < slice2.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) {
      }
      for (let node = slice2.content.lastChild; openEnd < slice2.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d = $context.depth; d >= 0; d--) {
    let parent = $context.node(d);
    let match = parent.contentMatchAt($context.index(d));
    let lastWrap, result = [];
    fragment.forEach((node) => {
      if (!result)
        return;
      let wrap = match.findWrapping(node.type), inLast;
      if (!wrap)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node, wrap);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node, wrap, from2 = 0) {
  for (let i = wrap.length - 1; i >= from2; i--)
    node = wrap[i].create(null, Fragment.from(node));
  return node;
}
function addToSibling(wrap, lastWrap, node, sibling, depth) {
  if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node, wrap, depth + 1))));
  }
}
function closeRight(node, depth) {
  if (depth == 0)
    return node;
  let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));
  let fill = node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true);
  return node.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node.contentMatchAt(node.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
let _policy = null;
function maybeWrapTrusted(html) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html;
  if (!_policy)
    _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
  return _policy.createHTML(html);
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap;
  if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap.map((n) => "<" + n + ">").join("") + html + wrap.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html);
  if (wrap)
    for (let i = 0; i < wrap.length; i++)
      elt = elt.querySelector(wrap[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node = nodes[i];
    if (node.childNodes.length == 1 && node.textContent == "" && node.parentNode)
      node.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type = schema.nodes[array[i]];
    if (!type || type.hasRequiredAttrs())
      break;
    content = Fragment.from(type.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
const handlers = {};
const editHandlers = {};
const passiveHandlers = { touchstart: true, touchmove: true };
class InputState {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
}
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type in view.input.eventHandlers)
    view.dom.removeEventListener(type, view.input.eventHandlers[type]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type in currentHandlers)
      if (!view.input.eventHandlers[type])
        view.dom.addEventListener(type, view.input.eventHandlers[type] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node = event.target; node != view.dom; node = node.parentNode)
    if (!node || node.nodeType == 11 || node.pmViewDesc && node.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    let deflt = () => view.state.tr.insertText(text).scrollIntoView();
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))
      view.dispatch(deflt());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr = view.state.tr.setSelection(selection);
  tr.setMeta("pointer", true);
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;
  if (node && node.isAtom && NodeSelection.isSelectable(node)) {
    updateSelection(view, new NodeSelection($pos));
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt));
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick$1(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection.create(doc2, 0, doc2.content.size));
      return true;
    }
    return false;
  }
  let $pos = doc2.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node.inlineContent)
      updateSelection(view, TextSelection.create(doc2, nodePos + 1, nodePos + 1 + node.content.size));
    else if (NodeSelection.isSelectable(node))
      updateSelection(view, NodeSelection.create(doc2, nodePos));
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
    if (view.input.lastClick.type == "singleClick")
      type = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type == "doubleClick" ? handleDoubleClick : handleTripleClick$1)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
class MouseDown {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)));
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
}
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state } = view, $pos = state.selection.$to;
    if (state.selection instanceof TextSelection && (state.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m) => m.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state.selection.empty);
      if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node = sel.focusNode, offset2 = sel.focusOffset; node && node.nodeType == 1 && offset2 != 0; ) {
          let before = offset2 < 0 ? node.lastChild : node.childNodes[offset2 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node = before;
            offset2 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view), cur = view.state.selection;
    if (sel && !sel.eq(cur))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap.appendChild(dom);
  wrap.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range = document.createRange();
  range.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range);
  setTimeout(() => {
    if (wrap.parentNode)
      wrap.parentNode.removeChild(wrap);
    view.focus();
  }, 50);
}
const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
class Dragging {
  constructor(slice2, move, node) {
    this.slice = slice2;
    this.move = move;
    this.node = node;
  }
}
const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
function dragMoves(view, event) {
  let moves = view.someProp("dragCopies", (test) => !test(event));
  return moves != null ? moves : !event[dragCopyModifier];
}
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
  else if (mouseDown && mouseDown.mightDrag) {
    node = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node || view.state.selection).content();
  let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice2, dragMoves(view, event), node);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move = !!(dragging && dragMoves(view, event));
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr = view.state.tr;
  if (move) {
    let { node } = dragging;
    if (node)
      node.replace(tr);
    else
      tr.deleteSelection();
  }
  let pos = tr.mapping.map(insertPos);
  let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode2)
    tr.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice2);
  if (tr.doc.eq(beforeInsert))
    return;
  let $pos = tr.doc.resolve(pos);
  if (isNode2 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    let end2 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end2)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b) {
  if (a == b)
    return true;
  for (let p in a)
    if (a[p] !== b[p])
      return false;
  for (let p in b)
    if (!(p in a))
      return false;
  return true;
}
class WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node) {
    if (this.spec.destroy)
      this.spec.destroy(node);
  }
}
class InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType;
  }
  destroy() {
  }
}
class NodeType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset2, to.pos - offset2, this);
  }
  valid(node, span) {
    let { index: index2, offset: offset2 } = node.content.findIndex(span.from), child;
    return offset2 == span.from && !(child = node.child(index2)).isText && offset2 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
}
class Decoration {
  /**
  @internal
  */
  constructor(from2, to, type) {
    this.from = from2;
    this.to = to;
    this.type = type;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new Decoration(from2, to, new NodeType(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
}
const none = [], noSpec = {};
class DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start2, end2, predicate) {
    let result = [];
    this.findInner(start2 == null ? 0 : start2, end2 == null ? 1e9 : end2, result, 0, predicate);
    return result;
  }
  findInner(start2, end2, result, offset2, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end2 && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end2 && this.children[i + 1] > start2) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start2 - childOff, end2 - childOff, result, offset2 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc2, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node, offset2, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node, offset2, oldOffset, options);
    else
      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  }
  addInner(doc2, decorations, offset2) {
    let children, childIndex = 0;
    doc2.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found;
      if (!(found = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc2, local[i]))
        local.splice(i--, 1);
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found;
      let from2 = children[i] + offset2, to = children[i + 1] + offset2;
      for (let j = 0, span; j < decorations.length; j++)
        if (span = decorations[j]) {
          if (span.from > from2 && span.to < to) {
            decorations[j] = null;
            (found || (found = [])).push(span);
          }
        }
      if (!found)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found, from2 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j = 0; j < local.length; j++)
            if (local[j].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet(local, children) : empty;
  }
  forChild(offset2, node) {
    if (this == empty)
      return this;
    if (node.isLeaf)
      return DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset2) {
        if (this.children[i] == offset2)
          child = this.children[i + 2];
        break;
      }
    let start2 = offset2 + 1, end2 = start2 + node.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end2 && dec.to > start2 && dec.type instanceof InlineType) {
        let from2 = Math.max(start2, dec.from) - start2, to = Math.min(end2, dec.to) - start2;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node) {
    return removeOverlap(this.localsInner(node));
  }
  /**
  @internal
  */
  localsInner(node) {
    if (this == empty)
      return none;
    if (node.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
  forEachSet(f) {
    f(this);
  }
}
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
const empty = DecorationSet.empty;
class DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc2) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
    return DecorationGroup.from(mappedDecos);
  }
  forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset2, child);
      if (result == empty)
        continue;
      if (result instanceof DecorationGroup)
        found = found.concat(result.members);
      else
        found.push(result);
    }
    return DecorationGroup.from(found);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j = 0; j < locals.length; j++)
          result.push(locals[j]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup(members.every((m) => m instanceof DecorationSet) ? members : members.reduce((r2, m) => r2.concat(m instanceof DecorationSet ? m : m.members), []));
    }
  }
  forEachSet(f) {
    for (let i = 0; i < this.members.length; i++)
      this.members[i].forEachSet(f);
  }
}
function mapChildren(oldChildren, newLocal, mapping, node, offset2, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end2 = children[i2 + 1];
        if (end2 < 0 || oldStart > end2 + baseOffset - moved)
          continue;
        let start2 = children[i2] + baseOffset - moved;
        if (oldEnd >= start2) {
          children[i2 + 1] = oldStart <= start2 ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset2;
      if (fromLocal < 0 || fromLocal >= node.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index: index2, offset: childOffset } = node.content.findIndex(fromLocal);
      let childNode = node.maybeChild(index2);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
    let built = buildTree(decorations, node, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j < children.length && children[j] < from2)
        j += 3;
      children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node, offset2) {
  if (node.isLeaf)
    return null;
  let end2 = offset2 + node.nodeSize, found = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end2) {
      (found || (found = [])).push(span);
      spans[i] = null;
    }
  }
  return found;
}
function withoutNulls(array) {
  let result = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result.push(array[i]);
  return result;
}
function buildTree(spans, node, offset2, options) {
  let children = [], hasNulls = false;
  node.forEach((childNode, localStart) => {
    let found = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found) {
      hasNulls = true;
      let subtree = buildTree(found, childNode, offset2 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b) {
  return a.from - b.from || a.to - b.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j = i + 1; j < working.length; j++) {
        let next = working[j];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j] = next.copy(next.from, span.to);
            insertAhead(working, j + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found.push(result);
  });
  if (view.cursorWrapper)
    found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found);
}
const observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
const useCharData = ie$1 && ie_version <= 11;
class SelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
}
class DOMObserver {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie$1 && ie_version <= 11 && mutations.some((m) => m.type == "childList" && m.removedNodes.length || m.type == "characterData" && m.oldValue.length > m.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let [a, b] = brs;
        if (a.parentNode && a.parentNode.parentNode == b.parentNode)
          b.remove();
        else
          a.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++) {
        let node = mut.addedNodes[i];
        added.push(node);
        if (node.nodeType == 3)
          this.lastChangedTextNode = node;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
}
let cssChecked = /* @__PURE__ */ new WeakMap();
let cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range) {
  let anchorNode = range.startContainer, anchorOffset = range.startOffset;
  let focusNode = range.endContainer, focusOffset = range.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range = selection.getComposedRanges(view.root)[0];
    if (range)
      return rangeToSelectionRange(view, range);
  }
  let found;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read2, true);
  return found ? rangeToSelectionRange(view, found) : null;
}
function blockParent(view, node) {
  for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {
    let desc = view.docView.nearestDesc(p, true);
    if (desc && desc.node.isBlock)
      return p;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off = toOffset; off > fromOffset; off--) {
      let node = parent.childNodes[off - 1], desc = node.pmViewDesc;
      if (node.nodeName == "BR" && !desc) {
        toOffset = off;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find,
    ruleFromNode,
    context: $from
  });
  if (find && find[0].pos != null) {
    let anchor2 = find[0].pos, head = find[1] && find[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc2, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
const isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr.setMeta("pointer", true);
      else if (origin == "key")
        tr.scrollIntoView();
      if (compositionID)
        tr.setMeta("composition", compositionID);
      view.dispatch(tr);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from2, to);
  let doc2 = view.state.doc, compare = doc2.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr.setMeta("composition", compositionID);
          view.dispatch(tr);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == " ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc2.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && !/\S/.test(parse.doc.textBetween($from.pos, $to.pos, "", "")) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head > $from.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let mkTr = (base2) => {
    let tr = base2 || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
    if (parse.sel) {
      let sel2 = resolveSelection(view, tr.doc, parse.sel);
      if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
        tr.setSelection(sel2);
    }
    if (compositionID)
      tr.setMeta("composition", compositionID);
    return tr.scrollIntoView();
  };
  let markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      let tr = mkTr(view.state.tr.delete(chFrom, chTo));
      let marks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
      if (marks)
        tr.ensureMarks(marks);
      view.dispatch(tr);
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      let tr = mkTr(view.state.tr);
      if (markChange.type == "add")
        tr.addMark(chFrom, chTo, markChange.mark);
      else
        tr.removeMark(chFrom, chTo, markChange.mark);
      view.dispatch(tr);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));
      if (!view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text, deflt)))
        view.dispatch(deflt());
    }
  } else {
    view.dispatch(mkTr());
  }
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
    return null;
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type, mark, update;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type = "add";
    update = (node) => node.mark(mark.addToSet(node.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type = "remove";
    update = (node) => node.mark(mark.removeFromSet(node.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type };
}
function looksLikeBackspace(old, start2, end2, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end2 - start2 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start2);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end2 == start2 + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end2++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end2++;
    }
  }
  return end2;
}
function findDiff(a, b, pos, preferredPos, preferredSide) {
  let start2 = a.findDiffStart(b, pos);
  if (start2 == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a.size < b.size) {
    let move = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move;
    if (start2 && start2 < b.size && isSurrogatePair(b.textBetween(start2 - 1, start2 + 1)))
      start2 += move ? 1 : -1;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    let move = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move;
    if (start2 && start2 < a.size && isSurrogatePair(a.textBetween(start2 - 1, start2 + 1)))
      start2 += move ? 1 : -1;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b >= 55296 && b <= 56319;
}
class EditorView {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state) {
    this.updateStateInner(state, this._props);
  }
  updateStateInner(state, prevProps) {
    var _a;
    let prev = this.state, redraw = false, updateSel = false;
    if (state.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state;
    let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? "reset" : state.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);
    if (updateDoc || !state.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie$1 || chrome) && !this.composing && !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
    else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin = this.directPlugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin = this.state.plugins[i];
        if (plugin.spec.view)
          this.pluginViews.push(plugin.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found < 0 ? void 0 : NodeSelection.create(this.state.doc, found));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie$1) {
      let node = this.root.activeElement;
      if (node == this.dom)
        return true;
      if (!node || !this.dom.contains(node))
        return false;
      while (node && this.dom != node && this.dom.contains(node)) {
        if (node.contentEditable == "false")
          return false;
        node = node.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search2 = this.dom.parentNode; search2; search2 = search2.parentNode) {
        if (search2.nodeType == 9 || search2.nodeType == 11 && search2.host) {
          if (!search2.getSelection)
            Object.getPrototypeOf(search2).getSelection = () => search2.ownerDocument.getSelection();
          return this._root = search2;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimesfor example when interpreting an event
  targetyou don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state) {
    return endOfTextblock(this, state || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(slice2) {
    return serializeForClipboard(this, slice2);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
EditorView.prototype.dispatch = function(tr) {
  let dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction)
    dispatchTransaction.call(this, tr);
  else
    this.updateState(this.state.apply(tr));
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b[prop])
      return true;
    nA++;
  }
  for (let _ in b)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin) {
  if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
const floor$1 = Math.floor;
const abs = Math.abs;
const min$2 = (a, b) => a < b ? a : b;
const max$2 = (a, b) => a > b ? a : b;
const isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;
const BIT7 = 64;
const BIT8 = 128;
const BIT30 = 1 << 29;
const BITS6 = 63;
const BITS7 = 127;
const BITS31 = 2147483647;
const isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor$1(num) === num);
const create$2 = () => /* @__PURE__ */ new Set();
const isArray = Array.isArray;
const fromCharCode = String.fromCharCode;
const toLowerCase = (s) => s.toLowerCase();
const trimLeftRegex = /^\s*/g;
const trimLeft = (s) => s.replace(trimLeftRegex, "");
const fromCamelCaseRegex = /([A-Z])/g;
const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
const _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    buf[i] = /** @type {number} */
    encodedString.codePointAt(i);
  }
  return buf;
};
const utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
const _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
let utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}
class Encoder {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
}
const createEncoder = () => new Encoder();
const encode = (f) => {
  const encoder = createEncoder();
  f(encoder);
  return toUint8Array(encoder);
};
const length = (encoder) => {
  let len = encoder.cpos;
  for (let i = 0; i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
};
const toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i = 0; i < encoder.bufs.length; i++) {
    const d = encoder.bufs[i];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
const verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max$2(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
const write$1 = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
const writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write$1(encoder, BIT8 | BITS7 & num);
    num = floor$1(num / 128);
  }
  write$1(encoder, BITS7 & num);
};
const writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write$1(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor$1(num / 64);
  while (num > 0) {
    write$1(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor$1(num / 128);
  }
};
const _strBuffer = new Uint8Array(3e4);
const _maxStrBSize = _strBuffer.length / 3;
const _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i = 0; i < written; i++) {
      write$1(encoder, _strBuffer[i]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
const _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    write$1(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i)
    );
  }
};
const writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
const writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min$2(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max$2(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
const writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
const writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
const writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
const floatTestBed = new DataView(new ArrayBuffer(4));
const isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
const writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write$1(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write$1(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write$1(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write$1(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write$1(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write$1(encoder, 126);
      } else if (isArray(data)) {
        write$1(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i = 0; i < data.length; i++) {
          writeAny(encoder, data[i]);
        }
      } else if (data instanceof Uint8Array) {
        write$1(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write$1(encoder, 118);
        const keys2 = Object.keys(data);
        writeVarUint(encoder, keys2.length);
        for (let i = 0; i < keys2.length; i++) {
          const key = keys2[i];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write$1(encoder, data ? 120 : 121);
      break;
    default:
      write$1(encoder, 127);
  }
};
const create$1 = (s) => new Error(s);
const methodUnimplemented = () => {
  throw create$1("Method unimplemented");
};
const unexpectedCase = () => {
  throw create$1("Unexpected case");
};
const create = () => /* @__PURE__ */ new Map();
const setIfUndefined = (map2, key, createT) => {
  let set = map2.get(key);
  if (set === void 0) {
    map2.set(key, set = createT());
  }
  return set;
};
const keys = Object.keys;
const every = (obj, f) => {
  for (const key in obj) {
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
};
const isOneOf = (value, options) => options.includes(value);
const createMutex = () => {
  let token = true;
  return (f, g) => {
    if (token) {
      token = false;
      try {
        f();
      } finally {
        token = true;
      }
    } else if (g !== void 0) {
      g();
    }
  };
};
const highSurrogateRegex = /[\uD800-\uDBFF]/;
const lowSurrogateRegex = /[\uDC00-\uDFFF]/;
const simpleDiffString = (a, b) => {
  let left2 = 0;
  let right2 = 0;
  while (left2 < a.length && left2 < b.length && a[left2] === b[left2]) {
    left2++;
  }
  if (left2 > 0 && highSurrogateRegex.test(a[left2 - 1])) left2--;
  while (right2 + left2 < a.length && right2 + left2 < b.length && a[a.length - right2 - 1] === b[b.length - right2 - 1]) {
    right2++;
  }
  if (right2 > 0 && lowSurrogateRegex.test(a[a.length - right2])) right2--;
  return {
    index: left2,
    remove: a.length - left2 - right2,
    insert: b.slice(left2, b.length - right2)
  };
};
const simpleDiff = simpleDiffString;
const ySyncPluginKey = new PluginKey("y-sync");
const yUndoPluginKey = new PluginKey("y-undo");
const yCursorPluginKey = new PluginKey("yjs-cursor");
const rand = Math.random;
const oneOf = (arr) => arr[floor$1(rand() * arr.length)];
const undefinedToNull = (v) => v === void 0 ? null : v;
class VarStoragePolyfill {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
}
let _localStorage = new VarStoragePolyfill();
let usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
const varStorage = _localStorage;
const isNode$1 = typeof process$1 !== "undefined" && process$1.release && /node|io\.js/.test(process$1.release.name) && Object.prototype.toString.call(typeof process$1 !== "undefined" ? process$1 : 0) === "[object process]";
const isBrowser$1 = typeof window !== "undefined" && typeof document !== "undefined" && !isNode$1;
let params;
const computeParams = () => {
  if (params === void 0) {
    if (isNode$1) {
      params = create();
      const pargs = process$1.argv;
      let currParamName = null;
      for (let i = 0; i < pargs.length; i++) {
        const parg = pargs[i];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
};
const hasParam = (name) => computeParams().has(name);
const getVariable = (name) => isNode$1 ? undefinedToNull(process$1.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
const hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
hasConf("production");
const forceColor = isNode$1 && isOneOf(process$1.env.FORCE_COLOR, ["true", "1", "2"]);
forceColor || !hasParam("--no-colors") && // @todo deprecate --no-colors
!hasConf("no-color") && (!isNode$1 || process$1.stdout.isTTY) && (!isNode$1 || hasParam("--color") || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));
const doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
typeof DOMParser !== "undefined" ? new DOMParser() : null;
const createTimeoutClass = (clearFunction) => class TT {
  /**
   * @param {number} timeoutId
   */
  constructor(timeoutId) {
    this._ = timeoutId;
  }
  destroy() {
    clearFunction(this._);
  }
};
const Timeout = createTimeoutClass(clearTimeout);
const timeout = (timeout2, callback) => new Timeout(setTimeout(callback, timeout2));
const rotr = (w, shift2) => w >>> shift2 | w << 32 - shift2;
const sum0to256 = (x) => rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
const sum1to256 = (x) => rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
const sigma0to256 = (x) => rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
const sigma1to256 = (x) => rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
const K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const HINIT = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
class Hasher {
  constructor() {
    const buf = new ArrayBuffer(64 + 64 * 4);
    this._H = new Uint32Array(buf, 0, 8);
    this._H.set(HINIT);
    this._W = new Uint32Array(buf, 64, 64);
  }
  _updateHash() {
    const H = this._H;
    const W = this._W;
    for (let t = 16; t < 64; t++) {
      W[t] = sigma1to256(W[t - 2]) + W[t - 7] + sigma0to256(W[t - 15]) + W[t - 16];
    }
    let a = H[0];
    let b = H[1];
    let c = H[2];
    let d = H[3];
    let e = H[4];
    let f = H[5];
    let g = H[6];
    let h = H[7];
    for (let tt = 0, T1, T2; tt < 64; tt++) {
      T1 = h + sum1to256(e) + (e & f ^ ~e & g) + K[tt] + W[tt] >>> 0;
      T2 = sum0to256(a) + (a & b ^ a & c ^ b & c) >>> 0;
      h = g;
      g = f;
      f = e;
      e = d + T1 >>> 0;
      d = c;
      c = b;
      b = a;
      a = T1 + T2 >>> 0;
    }
    H[0] += a;
    H[1] += b;
    H[2] += c;
    H[3] += d;
    H[4] += e;
    H[5] += f;
    H[6] += g;
    H[7] += h;
  }
  /**
   * Returns a 32-byte hash.
   *
   * @param {Uint8Array} data
   */
  digest(data) {
    let i = 0;
    for (; i + 56 <= data.length; ) {
      let j2 = 0;
      for (; j2 < 16 && i + 3 < data.length; j2++) {
        this._W[j2] = data[i++] << 24 | data[i++] << 16 | data[i++] << 8 | data[i++];
      }
      if (i % 64 !== 0) {
        this._W.fill(0, j2, 16);
        while (i < data.length) {
          this._W[j2] |= data[i] << (3 - i % 4) * 8;
          i++;
        }
        this._W[j2] |= BIT8 << (3 - i % 4) * 8;
      }
      this._updateHash();
    }
    const isPaddedWith1 = i % 64 !== 0;
    this._W.fill(0, 0, 16);
    let j = 0;
    for (; i < data.length; j++) {
      for (let ci = 3; ci >= 0 && i < data.length; ci--) {
        this._W[j] |= data[i++] << ci * 8;
      }
    }
    if (!isPaddedWith1) {
      this._W[j - (i % 4 === 0 ? 0 : 1)] |= BIT8 << (3 - i % 4) * 8;
    }
    this._W[14] = data.byteLength / BIT30;
    this._W[15] = data.byteLength * 8;
    this._updateHash();
    const dv = new Uint8Array(32);
    for (let i2 = 0; i2 < this._H.length; i2++) {
      for (let ci = 0; ci < 4; ci++) {
        dv[i2 * 4 + ci] = this._H[i2] >>> (3 - ci) * 8;
      }
    }
    return dv;
  }
}
const digest = (data) => new Hasher().digest(data);
const toBase64Browser = (bytes) => {
  let s = "";
  for (let i = 0; i < bytes.byteLength; i++) {
    s += fromCharCode(bytes[i]);
  }
  return btoa(s);
};
const toBase64Node = (bytes) => Buffer2.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
const toBase64 = isBrowser$1 ? toBase64Browser : toBase64Node;
const encodeAny = (data) => encode((encoder) => writeAny(encoder, data));
const _convolute = (digest2) => {
  const N = 6;
  for (let i = N; i < digest2.length; i++) {
    digest2[i % N] = digest2[i % N] ^ digest2[i];
  }
  return digest2.slice(0, N);
};
const hashOfJSON = (json) => toBase64(_convolute(digest(encodeAny(json))));
const createEmptyMeta = () => ({
  mapping: /* @__PURE__ */ new Map(),
  isOMark: /* @__PURE__ */ new Map()
});
const isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && /** @type {number} */
snapshot.sv.get(item.id.client) > item.id.clock && !Y.isDeleted(snapshot.ds, item.id);
const defaultColors = [{ light: "#ecd44433", dark: "#ecd444" }];
const getUserColor = (colorMapping, colors, user) => {
  if (!colorMapping.has(user)) {
    if (colorMapping.size < colors.length) {
      const usedColors = create$2();
      colorMapping.forEach((color) => usedColors.add(color));
      colors = colors.filter((color) => !usedColors.has(color));
    }
    colorMapping.set(user, oneOf(colors));
  }
  return (
    /** @type {ColorDef} */
    colorMapping.get(user)
  );
};
const ySyncPlugin = (yXmlFragment, {
  colors = defaultColors,
  colorMapping = /* @__PURE__ */ new Map(),
  permanentUserData = null,
  onFirstRender = () => {
  },
  mapping
} = {}) => {
  let initialContentChanged = false;
  const binding = new ProsemirrorBinding(yXmlFragment, mapping);
  const plugin = new Plugin({
    props: {
      editable: (state) => {
        const syncState = ySyncPluginKey.getState(state);
        return syncState.snapshot == null && syncState.prevSnapshot == null;
      }
    },
    key: ySyncPluginKey,
    state: {
      /**
       * @returns {any}
       */
      init: (_initargs, _state) => {
        return {
          type: yXmlFragment,
          doc: yXmlFragment.doc,
          binding,
          snapshot: null,
          prevSnapshot: null,
          isChangeOrigin: false,
          isUndoRedoOperation: false,
          addToHistory: true,
          colors,
          colorMapping,
          permanentUserData
        };
      },
      apply: (tr, pluginState) => {
        const change = tr.getMeta(ySyncPluginKey);
        if (change !== void 0) {
          pluginState = Object.assign({}, pluginState);
          for (const key in change) {
            pluginState[key] = change[key];
          }
        }
        pluginState.addToHistory = tr.getMeta("addToHistory") !== false;
        pluginState.isChangeOrigin = change !== void 0 && !!change.isChangeOrigin;
        pluginState.isUndoRedoOperation = change !== void 0 && !!change.isChangeOrigin && !!change.isUndoRedoOperation;
        if (binding.prosemirrorView !== null) {
          if (change !== void 0 && (change.snapshot != null || change.prevSnapshot != null)) {
            timeout(0, () => {
              if (binding.prosemirrorView == null) {
                return;
              }
              if (change.restore == null) {
                binding._renderSnapshot(
                  change.snapshot,
                  change.prevSnapshot,
                  pluginState
                );
              } else {
                binding._renderSnapshot(
                  change.snapshot,
                  change.snapshot,
                  pluginState
                );
                delete pluginState.restore;
                delete pluginState.snapshot;
                delete pluginState.prevSnapshot;
                binding.mux(() => {
                  binding._prosemirrorChanged(
                    binding.prosemirrorView.state.doc
                  );
                });
              }
            });
          }
        }
        return pluginState;
      }
    },
    view: (view) => {
      binding.initView(view);
      if (mapping == null) {
        binding._forceRerender();
      }
      onFirstRender();
      return {
        update: () => {
          const pluginState = plugin.getState(view.state);
          if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {
            if (
              // If the content doesn't change initially, we don't render anything to Yjs
              // If the content was cleared by a user action, we want to catch the change and
              // represent it in Yjs
              initialContentChanged || view.state.doc.content.findDiffStart(
                view.state.doc.type.createAndFill().content
              ) !== null
            ) {
              initialContentChanged = true;
              if (pluginState.addToHistory === false && !pluginState.isChangeOrigin) {
                const yUndoPluginState = yUndoPluginKey.getState(view.state);
                const um = yUndoPluginState && yUndoPluginState.undoManager;
                if (um) {
                  um.stopCapturing();
                }
              }
              binding.mux(() => {
                pluginState.doc.transact((tr) => {
                  tr.meta.set("addToHistory", pluginState.addToHistory);
                  binding._prosemirrorChanged(view.state.doc);
                }, ySyncPluginKey);
              });
            }
          }
        },
        destroy: () => {
          binding.destroy();
        }
      };
    }
  });
  return plugin;
};
const restoreRelativeSelection = (tr, relSel, binding) => {
  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {
    if (relSel.type === "all") {
      tr.setSelection(new AllSelection(tr.doc));
    } else if (relSel.type === "node") {
      const anchor = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.anchor,
        binding.mapping
      );
      tr.setSelection(NodeSelection.create(tr.doc, anchor));
    } else {
      const anchor = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.anchor,
        binding.mapping
      );
      const head = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.head,
        binding.mapping
      );
      if (anchor !== null && head !== null) {
        const sel = TextSelection.between(tr.doc.resolve(anchor), tr.doc.resolve(head));
        tr.setSelection(sel);
      }
    }
  }
};
const getRelativeSelection = (pmbinding, state) => ({
  type: (
    /** @type {any} */
    state.selection.jsonID
  ),
  anchor: absolutePositionToRelativePosition(
    state.selection.anchor,
    pmbinding.type,
    pmbinding.mapping
  ),
  head: absolutePositionToRelativePosition(
    state.selection.head,
    pmbinding.type,
    pmbinding.mapping
  )
});
class ProsemirrorBinding {
  /**
   * @param {Y.XmlFragment} yXmlFragment The bind source
   * @param {ProsemirrorMapping} mapping
   */
  constructor(yXmlFragment, mapping = /* @__PURE__ */ new Map()) {
    this.type = yXmlFragment;
    this.prosemirrorView = null;
    this.mux = createMutex();
    this.mapping = mapping;
    this.isOMark = /* @__PURE__ */ new Map();
    this._observeFunction = this._typeChanged.bind(this);
    this.doc = yXmlFragment.doc;
    this.beforeTransactionSelection = null;
    this.beforeAllTransactions = () => {
      if (this.beforeTransactionSelection === null && this.prosemirrorView != null) {
        this.beforeTransactionSelection = getRelativeSelection(
          this,
          this.prosemirrorView.state
        );
      }
    };
    this.afterAllTransactions = () => {
      this.beforeTransactionSelection = null;
    };
    this._domSelectionInView = null;
  }
  /**
   * Create a transaction for changing the prosemirror state.
   *
   * @returns
   */
  get _tr() {
    return this.prosemirrorView.state.tr.setMeta("addToHistory", false);
  }
  _isLocalCursorInView() {
    if (!this.prosemirrorView.hasFocus()) return false;
    if (isBrowser$1 && this._domSelectionInView === null) {
      timeout(0, () => {
        this._domSelectionInView = null;
      });
      this._domSelectionInView = this._isDomSelectionInView();
    }
    return this._domSelectionInView;
  }
  _isDomSelectionInView() {
    const selection = this.prosemirrorView._root.getSelection();
    if (selection == null || selection.anchorNode == null) return false;
    const range = this.prosemirrorView._root.createRange();
    range.setStart(selection.anchorNode, selection.anchorOffset);
    range.setEnd(selection.focusNode, selection.focusOffset);
    const rects = range.getClientRects();
    if (rects.length === 0) {
      if (range.startContainer && range.collapsed) {
        range.selectNodeContents(range.startContainer);
      }
    }
    const bounding = range.getBoundingClientRect();
    const documentElement = doc.documentElement;
    return bounding.bottom >= 0 && bounding.right >= 0 && bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) && bounding.top <= (window.innerHeight || documentElement.clientHeight || 0);
  }
  /**
   * @param {Y.Snapshot} snapshot
   * @param {Y.Snapshot} prevSnapshot
   */
  renderSnapshot(snapshot, prevSnapshot) {
    if (!prevSnapshot) {
      prevSnapshot = Y.createSnapshot(Y.createDeleteSet(), /* @__PURE__ */ new Map());
    }
    this.prosemirrorView.dispatch(
      this._tr.setMeta(ySyncPluginKey, { snapshot, prevSnapshot })
    );
  }
  unrenderSnapshot() {
    this.mapping.clear();
    this.mux(() => {
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeFromYElement(
          /** @type {Y.XmlElement} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      const tr = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment.from(fragmentContent), 0, 0)
      );
      tr.setMeta(ySyncPluginKey, { snapshot: null, prevSnapshot: null });
      this.prosemirrorView.dispatch(tr);
    });
  }
  _forceRerender() {
    this.mapping.clear();
    this.mux(() => {
      const sel = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection;
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeFromYElement(
          /** @type {Y.XmlElement} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      const tr = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment.from(fragmentContent), 0, 0)
      );
      if (sel) {
        const clampedAnchor = min$2(max$2(sel.anchor, 0), tr.doc.content.size);
        const clampedHead = min$2(max$2(sel.head, 0), tr.doc.content.size);
        tr.setSelection(TextSelection.create(tr.doc, clampedAnchor, clampedHead));
      }
      this.prosemirrorView.dispatch(
        tr.setMeta(ySyncPluginKey, { isChangeOrigin: true, binding: this })
      );
    });
  }
  /**
   * @param {Y.Snapshot|Uint8Array} snapshot
   * @param {Y.Snapshot|Uint8Array} prevSnapshot
   * @param {Object} pluginState
   */
  _renderSnapshot(snapshot, prevSnapshot, pluginState) {
    let historyDoc = this.doc;
    let historyType = this.type;
    if (!snapshot) {
      snapshot = Y.snapshot(this.doc);
    }
    if (snapshot instanceof Uint8Array || prevSnapshot instanceof Uint8Array) {
      if (!(snapshot instanceof Uint8Array) || !(prevSnapshot instanceof Uint8Array)) {
        unexpectedCase();
      }
      historyDoc = new Y.Doc({ gc: false });
      Y.applyUpdateV2(historyDoc, prevSnapshot);
      prevSnapshot = Y.snapshot(historyDoc);
      Y.applyUpdateV2(historyDoc, snapshot);
      snapshot = Y.snapshot(historyDoc);
      if (historyType._item === null) {
        const rootKey = Array.from(this.doc.share.keys()).find(
          (key) => this.doc.share.get(key) === this.type
        );
        historyType = historyDoc.getXmlFragment(rootKey);
      } else {
        const historyStructs = historyDoc.store.clients.get(historyType._item.id.client) ?? [];
        const itemIndex = Y.findIndexSS(
          historyStructs,
          historyType._item.id.clock
        );
        const item = (
          /** @type {Y.Item} */
          historyStructs[itemIndex]
        );
        const content = (
          /** @type {Y.ContentType} */
          item.content
        );
        historyType = /** @type {Y.XmlFragment} */
        content.type;
      }
    }
    this.mapping.clear();
    this.mux(() => {
      historyDoc.transact((transaction) => {
        const pud = pluginState.permanentUserData;
        if (pud) {
          pud.dss.forEach((ds) => {
            Y.iterateDeletedStructs(transaction, ds, (_item) => {
            });
          });
        }
        const computeYChange = (type, id) => {
          const user = type === "added" ? pud.getUserByClientId(id.client) : pud.getUserByDeletedId(id);
          return {
            user,
            type,
            color: getUserColor(
              pluginState.colorMapping,
              pluginState.colors,
              user
            )
          };
        };
        const fragmentContent = Y.typeListToArraySnapshot(
          historyType,
          new Y.Snapshot(prevSnapshot.ds, snapshot.sv)
        ).map((t) => {
          if (!t._item.deleted || isVisible(t._item, snapshot) || isVisible(t._item, prevSnapshot)) {
            return createNodeFromYElement(
              t,
              this.prosemirrorView.state.schema,
              { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() },
              snapshot,
              prevSnapshot,
              computeYChange
            );
          } else {
            return null;
          }
        }).filter((n) => n !== null);
        const tr = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new Slice(Fragment.from(fragmentContent), 0, 0)
        );
        this.prosemirrorView.dispatch(
          tr.setMeta(ySyncPluginKey, { isChangeOrigin: true })
        );
      }, ySyncPluginKey);
    });
  }
  /**
   * @param {Array<Y.YEvent<any>>} events
   * @param {Y.Transaction} transaction
   */
  _typeChanged(events, transaction) {
    if (this.prosemirrorView == null) return;
    const syncState = ySyncPluginKey.getState(this.prosemirrorView.state);
    if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {
      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);
      return;
    }
    this.mux(() => {
      const delType = (_, type) => this.mapping.delete(type);
      Y.iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        (struct) => {
          if (struct.constructor === Y.Item) {
            const type = (
              /** @type {Y.ContentType} */
              /** @type {Y.Item} */
              struct.content.type
            );
            type && this.mapping.delete(type);
          }
        }
      );
      transaction.changed.forEach(delType);
      transaction.changedParentTypes.forEach(delType);
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeIfNotExists(
          /** @type {Y.XmlElement | Y.XmlHook} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      let tr = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment.from(fragmentContent), 0, 0)
      );
      restoreRelativeSelection(tr, this.beforeTransactionSelection, this);
      tr = tr.setMeta(ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof Y.UndoManager });
      if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {
        tr.scrollIntoView();
      }
      this.prosemirrorView.dispatch(tr);
    });
  }
  /**
   * @param {import('prosemirror-model').Node} doc
   */
  _prosemirrorChanged(doc2) {
    this.doc.transact(() => {
      updateYFragment(this.doc, this.type, doc2, this);
      this.beforeTransactionSelection = getRelativeSelection(
        this,
        this.prosemirrorView.state
      );
    }, ySyncPluginKey);
  }
  /**
   * View is ready to listen to changes. Register observers.
   * @param {any} prosemirrorView
   */
  initView(prosemirrorView) {
    if (this.prosemirrorView != null) this.destroy();
    this.prosemirrorView = prosemirrorView;
    this.doc.on("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.on("afterAllTransactions", this.afterAllTransactions);
    this.type.observeDeep(this._observeFunction);
  }
  destroy() {
    if (this.prosemirrorView == null) return;
    this.prosemirrorView = null;
    this.type.unobserveDeep(this._observeFunction);
    this.doc.off("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.off("afterAllTransactions", this.afterAllTransactions);
  }
}
const createNodeIfNotExists = (el, schema, meta, snapshot, prevSnapshot, computeYChange) => {
  const node = (
    /** @type {PModel.Node} */
    meta.mapping.get(el)
  );
  if (node === void 0) {
    if (el instanceof Y.XmlElement) {
      return createNodeFromYElement(
        el,
        schema,
        meta,
        snapshot,
        prevSnapshot,
        computeYChange
      );
    } else {
      throw methodUnimplemented();
    }
  }
  return node;
};
const createNodeFromYElement = (el, schema, meta, snapshot, prevSnapshot, computeYChange) => {
  const children = [];
  const createChildren = (type) => {
    if (type instanceof Y.XmlElement) {
      const n = createNodeIfNotExists(
        type,
        schema,
        meta,
        snapshot,
        prevSnapshot,
        computeYChange
      );
      if (n !== null) {
        children.push(n);
      }
    } else {
      const nextytext = (
        /** @type {Y.ContentType} */
        type._item.right?.content?.type
      );
      if (nextytext instanceof Y.Text && !nextytext._item.deleted && nextytext._item.id.client === nextytext.doc.clientID) {
        type.applyDelta([
          { retain: type.length },
          ...nextytext.toDelta()
        ]);
        nextytext.doc.transact((tr) => {
          nextytext._item.delete(tr);
        });
      }
      const ns = createTextNodesFromYText(
        type,
        schema,
        meta,
        snapshot,
        prevSnapshot,
        computeYChange
      );
      if (ns !== null) {
        ns.forEach((textchild) => {
          if (textchild !== null) {
            children.push(textchild);
          }
        });
      }
    }
  };
  if (snapshot === void 0 || prevSnapshot === void 0) {
    el.toArray().forEach(createChildren);
  } else {
    Y.typeListToArraySnapshot(el, new Y.Snapshot(prevSnapshot.ds, snapshot.sv)).forEach(createChildren);
  }
  try {
    const attrs = el.getAttributes(snapshot);
    if (snapshot !== void 0) {
      if (!isVisible(
        /** @type {Y.Item} */
        el._item,
        snapshot
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "removed",
          /** @type {Y.Item} */
          el._item.id
        ) : { type: "removed" };
      } else if (!isVisible(
        /** @type {Y.Item} */
        el._item,
        prevSnapshot
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "added",
          /** @type {Y.Item} */
          el._item.id
        ) : { type: "added" };
      }
    }
    const node = schema.node(el.nodeName, attrs, children);
    meta.mapping.set(el, node);
    return node;
  } catch (e) {
    el.doc.transact((transaction) => {
      el._item.delete(transaction);
    }, ySyncPluginKey);
    meta.mapping.delete(el);
    return null;
  }
};
const createTextNodesFromYText = (text, schema, _meta, snapshot, prevSnapshot, computeYChange) => {
  const nodes = [];
  const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange);
  try {
    for (let i = 0; i < deltas.length; i++) {
      const delta = deltas[i];
      nodes.push(schema.text(delta.insert, attributesToMarks(delta.attributes, schema)));
    }
  } catch (e) {
    text.doc.transact((transaction) => {
      text._item.delete(transaction);
    }, ySyncPluginKey);
    return null;
  }
  return nodes;
};
const createTypeFromTextNodes = (nodes, meta) => {
  const type = new Y.XmlText();
  const delta = nodes.map((node) => ({
    // @ts-ignore
    insert: node.text,
    attributes: marksToAttributes(node.marks, meta)
  }));
  type.applyDelta(delta);
  meta.mapping.set(type, nodes);
  return type;
};
const createTypeFromElementNode = (node, meta) => {
  const type = new Y.XmlElement(node.type.name);
  for (const key in node.attrs) {
    const val = node.attrs[key];
    if (val !== null && key !== "ychange") {
      type.setAttribute(key, val);
    }
  }
  type.insert(
    0,
    normalizePNodeContent(node).map(
      (n) => createTypeFromTextOrElementNode(n, meta)
    )
  );
  meta.mapping.set(type, node);
  return type;
};
const createTypeFromTextOrElementNode = (node, meta) => node instanceof Array ? createTypeFromTextNodes(node, meta) : createTypeFromElementNode(node, meta);
const isObject = (val) => typeof val === "object" && val !== null;
const equalAttrs = (pattrs, yattrs) => {
  const keys2 = Object.keys(pattrs).filter((key) => pattrs[key] !== null);
  let eq = keys2.length === (yattrs == null ? 0 : Object.keys(yattrs).filter((key) => yattrs[key] !== null).length);
  for (let i = 0; i < keys2.length && eq; i++) {
    const key = keys2[i];
    const l = pattrs[key];
    const r2 = yattrs[key];
    eq = key === "ychange" || l === r2 || isObject(l) && isObject(r2) && equalAttrs(l, r2);
  }
  return eq;
};
const normalizePNodeContent = (pnode) => {
  const c = pnode.content.content;
  const res = [];
  for (let i = 0; i < c.length; i++) {
    const n = c[i];
    if (n.isText) {
      const textNodes = [];
      for (let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]) {
        textNodes.push(tnode);
      }
      i--;
      res.push(textNodes);
    } else {
      res.push(n);
    }
  }
  return res;
};
const equalYTextPText = (ytext, ptexts) => {
  const delta = ytext.toDelta();
  return delta.length === ptexts.length && delta.every(
    /** @type {(d:any,i:number) => boolean} */
    (d, i) => d.insert === /** @type {any} */
    ptexts[i].text && keys(d.attributes || {}).length === ptexts[i].marks.length && every(d.attributes, (attr, yattrname) => {
      const markname = yattr2markname(yattrname);
      const pmarks = ptexts[i].marks;
      return equalAttrs(attr, pmarks.find(
        /** @param {any} mark */
        (mark) => mark.type.name === markname
      )?.attrs);
    })
  );
};
const equalYTypePNode = (ytype, pnode) => {
  if (ytype instanceof Y.XmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {
    const normalizedContent = normalizePNodeContent(pnode);
    return ytype._length === normalizedContent.length && equalAttrs(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every(
      (ychild, i) => equalYTypePNode(ychild, normalizedContent[i])
    );
  }
  return ytype instanceof Y.XmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);
};
const mappedIdentity = (mapped, pcontent) => mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every(
  (a, i) => pcontent[i] === a
);
const computeChildEqualityFactor = (ytype, pnode, meta) => {
  const yChildren = ytype.toArray();
  const pChildren = normalizePNodeContent(pnode);
  const pChildCnt = pChildren.length;
  const yChildCnt = yChildren.length;
  const minCnt = min$2(yChildCnt, pChildCnt);
  let left2 = 0;
  let right2 = 0;
  let foundMappedChild = false;
  for (; left2 < minCnt; left2++) {
    const leftY = yChildren[left2];
    const leftP = pChildren[left2];
    if (mappedIdentity(meta.mapping.get(leftY), leftP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(leftY, leftP)) {
      break;
    }
  }
  for (; left2 + right2 < minCnt; right2++) {
    const rightY = yChildren[yChildCnt - right2 - 1];
    const rightP = pChildren[pChildCnt - right2 - 1];
    if (mappedIdentity(meta.mapping.get(rightY), rightP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(rightY, rightP)) {
      break;
    }
  }
  return {
    equalityFactor: left2 + right2,
    foundMappedChild
  };
};
const ytextTrans = (ytext) => {
  let str = "";
  let n = ytext._start;
  const nAttrs = {};
  while (n !== null) {
    if (!n.deleted) {
      if (n.countable && n.content instanceof Y.ContentString) {
        str += n.content.str;
      } else if (n.content instanceof Y.ContentFormat) {
        nAttrs[n.content.key] = null;
      }
    }
    n = n.right;
  }
  return {
    str,
    nAttrs
  };
};
const updateYText = (ytext, ptexts, meta) => {
  meta.mapping.set(ytext, ptexts);
  const { nAttrs, str } = ytextTrans(ytext);
  const content = ptexts.map((p) => ({
    insert: (
      /** @type {any} */
      p.text
    ),
    attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks, meta))
  }));
  const { insert, remove, index: index2 } = simpleDiff(
    str,
    content.map((c) => c.insert).join("")
  );
  ytext.delete(index2, remove);
  ytext.insert(index2, insert);
  ytext.applyDelta(
    content.map((c) => ({ retain: c.insert.length, attributes: c.attributes }))
  );
};
const hashedMarkNameRegex = /(.*)(--[a-zA-Z0-9+/=]{8})$/;
const yattr2markname = (attrName) => hashedMarkNameRegex.exec(attrName)?.[1] ?? attrName;
const attributesToMarks = (attrs, schema) => {
  const marks = [];
  for (const markName in attrs) {
    marks.push(schema.mark(yattr2markname(markName), attrs[markName]));
  }
  return marks;
};
const marksToAttributes = (marks, meta) => {
  const pattrs = {};
  marks.forEach((mark) => {
    if (mark.type.name !== "ychange") {
      const isOverlapping = setIfUndefined(meta.isOMark, mark.type, () => !mark.type.excludes(mark.type));
      pattrs[isOverlapping ? `${mark.type.name}--${hashOfJSON(mark.toJSON())}` : mark.type.name] = mark.attrs;
    }
  });
  return pattrs;
};
const updateYFragment = (y, yDomFragment, pNode, meta) => {
  if (yDomFragment instanceof Y.XmlElement && yDomFragment.nodeName !== pNode.type.name) {
    throw new Error("node name mismatch!");
  }
  meta.mapping.set(yDomFragment, pNode);
  if (yDomFragment instanceof Y.XmlElement) {
    const yDomAttrs = yDomFragment.getAttributes();
    const pAttrs = pNode.attrs;
    for (const key in pAttrs) {
      if (pAttrs[key] !== null) {
        if (yDomAttrs[key] !== pAttrs[key] && key !== "ychange") {
          yDomFragment.setAttribute(key, pAttrs[key]);
        }
      } else {
        yDomFragment.removeAttribute(key);
      }
    }
    for (const key in yDomAttrs) {
      if (pAttrs[key] === void 0) {
        yDomFragment.removeAttribute(key);
      }
    }
  }
  const pChildren = normalizePNodeContent(pNode);
  const pChildCnt = pChildren.length;
  const yChildren = yDomFragment.toArray();
  const yChildCnt = yChildren.length;
  const minCnt = min$2(pChildCnt, yChildCnt);
  let left2 = 0;
  let right2 = 0;
  for (; left2 < minCnt; left2++) {
    const leftY = yChildren[left2];
    const leftP = pChildren[left2];
    if (!mappedIdentity(meta.mapping.get(leftY), leftP)) {
      if (equalYTypePNode(leftY, leftP)) {
        meta.mapping.set(leftY, leftP);
      } else {
        break;
      }
    }
  }
  for (; right2 + left2 < minCnt; right2++) {
    const rightY = yChildren[yChildCnt - right2 - 1];
    const rightP = pChildren[pChildCnt - right2 - 1];
    if (!mappedIdentity(meta.mapping.get(rightY), rightP)) {
      if (equalYTypePNode(rightY, rightP)) {
        meta.mapping.set(rightY, rightP);
      } else {
        break;
      }
    }
  }
  y.transact(() => {
    while (yChildCnt - left2 - right2 > 0 && pChildCnt - left2 - right2 > 0) {
      const leftY = yChildren[left2];
      const leftP = pChildren[left2];
      const rightY = yChildren[yChildCnt - right2 - 1];
      const rightP = pChildren[pChildCnt - right2 - 1];
      if (leftY instanceof Y.XmlText && leftP instanceof Array) {
        if (!equalYTextPText(leftY, leftP)) {
          updateYText(leftY, leftP, meta);
        }
        left2 += 1;
      } else {
        let updateLeft = leftY instanceof Y.XmlElement && matchNodeName(leftY, leftP);
        let updateRight = rightY instanceof Y.XmlElement && matchNodeName(rightY, rightP);
        if (updateLeft && updateRight) {
          const equalityLeft = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            meta
          );
          const equalityRight = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            meta
          );
          if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {
            updateRight = false;
          } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {
            updateLeft = false;
          } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {
            updateLeft = false;
          } else {
            updateRight = false;
          }
        }
        if (updateLeft) {
          updateYFragment(
            y,
            /** @type {Y.XmlFragment} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            meta
          );
          left2 += 1;
        } else if (updateRight) {
          updateYFragment(
            y,
            /** @type {Y.XmlFragment} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            meta
          );
          right2 += 1;
        } else {
          meta.mapping.delete(yDomFragment.get(left2));
          yDomFragment.delete(left2, 1);
          yDomFragment.insert(left2, [
            createTypeFromTextOrElementNode(leftP, meta)
          ]);
          left2 += 1;
        }
      }
    }
    const yDelLen = yChildCnt - left2 - right2;
    if (yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof Y.XmlText) {
      meta.mapping.delete(yChildren[0]);
      yChildren[0].delete(0, yChildren[0].length);
    } else if (yDelLen > 0) {
      yDomFragment.slice(left2, left2 + yDelLen).forEach((type) => meta.mapping.delete(type));
      yDomFragment.delete(left2, yDelLen);
    }
    if (left2 + right2 < pChildCnt) {
      const ins = [];
      for (let i = left2; i < pChildCnt - right2; i++) {
        ins.push(createTypeFromTextOrElementNode(pChildren[i], meta));
      }
      yDomFragment.insert(left2, ins);
    }
  }, ySyncPluginKey);
};
const matchNodeName = (yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name;
let viewsToUpdate = null;
const updateMetas = () => {
  const ups = (
    /** @type {Map<EditorView, Map<any, any>>} */
    viewsToUpdate
  );
  viewsToUpdate = null;
  ups.forEach((metas, view) => {
    const tr = view.state.tr;
    const syncState = ySyncPluginKey.getState(view.state);
    if (syncState && syncState.binding && !syncState.binding.isDestroyed) {
      metas.forEach((val, key) => {
        tr.setMeta(key, val);
      });
      view.dispatch(tr);
    }
  });
};
const setMeta = (view, key, value) => {
  if (!viewsToUpdate) {
    viewsToUpdate = /* @__PURE__ */ new Map();
    timeout(0, updateMetas);
  }
  setIfUndefined(viewsToUpdate, view, create).set(key, value);
};
const absolutePositionToRelativePosition = (pos, type, mapping) => {
  if (pos === 0) {
    return Y.createRelativePositionFromTypeIndex(type, 0, type.length === 0 ? -1 : 0);
  }
  let n = type._first === null ? null : (
    /** @type {Y.ContentType} */
    type._first.content.type
  );
  while (n !== null && type !== n) {
    if (n instanceof Y.XmlText) {
      if (n._length >= pos) {
        return Y.createRelativePositionFromTypeIndex(n, pos, type.length === 0 ? -1 : 0);
      } else {
        pos -= n._length;
      }
      if (n._item !== null && n._item.next !== null) {
        n = /** @type {Y.ContentType} */
        n._item.next.content.type;
      } else {
        do {
          n = n._item === null ? null : n._item.parent;
          pos--;
        } while (n !== type && n !== null && n._item !== null && n._item.next === null);
        if (n !== null && n !== type) {
          n = n._item === null ? null : (
            /** @type {Y.ContentType} */
            /** @type Y.Item */
            n._item.next.content.type
          );
        }
      }
    } else {
      const pNodeSize = (
        /** @type {any} */
        (mapping.get(n) || { nodeSize: 0 }).nodeSize
      );
      if (n._first !== null && pos < pNodeSize) {
        n = /** @type {Y.ContentType} */
        n._first.content.type;
        pos--;
      } else {
        if (pos === 1 && n._length === 0 && pNodeSize > 1) {
          return new Y.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y.findRootTypeKey(n) : null, null);
        }
        pos -= pNodeSize;
        if (n._item !== null && n._item.next !== null) {
          n = /** @type {Y.ContentType} */
          n._item.next.content.type;
        } else {
          if (pos === 0) {
            n = n._item === null ? n : n._item.parent;
            return new Y.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y.findRootTypeKey(n) : null, null);
          }
          do {
            n = /** @type {Y.Item} */
            n._item.parent;
            pos--;
          } while (n !== type && /** @type {Y.Item} */
          n._item.next === null);
          if (n !== type) {
            n = /** @type {Y.ContentType} */
            /** @type {Y.Item} */
            /** @type {Y.Item} */
            n._item.next.content.type;
          }
        }
      }
    }
    if (n === null) {
      throw unexpectedCase();
    }
    if (pos === 0 && n.constructor !== Y.XmlText && n !== type) {
      return createRelativePosition(n._item.parent, n._item);
    }
  }
  return Y.createRelativePositionFromTypeIndex(type, type._length, type.length === 0 ? -1 : 0);
};
const createRelativePosition = (type, item) => {
  let typeid = null;
  let tname = null;
  if (type._item === null) {
    tname = Y.findRootTypeKey(type);
  } else {
    typeid = Y.createID(type._item.id.client, type._item.id.clock);
  }
  return new Y.RelativePosition(typeid, tname, item.id);
};
const relativePositionToAbsolutePosition = (y, documentType, relPos, mapping) => {
  const decodedPos = Y.createAbsolutePositionFromRelativePosition(relPos, y);
  if (decodedPos === null || decodedPos.type !== documentType && !Y.isParentOf(documentType, decodedPos.type._item)) {
    return null;
  }
  let type = decodedPos.type;
  let pos = 0;
  if (type.constructor === Y.XmlText) {
    pos = decodedPos.index;
  } else if (type._item === null || !type._item.deleted) {
    let n = type._first;
    let i = 0;
    while (i < type._length && i < decodedPos.index && n !== null) {
      if (!n.deleted) {
        const t = (
          /** @type {Y.ContentType} */
          n.content.type
        );
        i++;
        if (t instanceof Y.XmlText) {
          pos += t._length;
        } else {
          pos += /** @type {any} */
          mapping.get(t).nodeSize;
        }
      }
      n = /** @type {Y.Item} */
      n.right;
    }
    pos += 1;
  }
  while (type !== documentType && type._item !== null) {
    const parent = type._item.parent;
    if (parent._item === null || !parent._item.deleted) {
      pos += 1;
      let n = (
        /** @type {Y.AbstractType} */
        parent._first
      );
      while (n !== null) {
        const contentType = (
          /** @type {Y.ContentType} */
          n.content.type
        );
        if (contentType === type) {
          break;
        }
        if (!n.deleted) {
          if (contentType instanceof Y.XmlText) {
            pos += contentType._length;
          } else {
            pos += /** @type {any} */
            mapping.get(contentType).nodeSize;
          }
        }
        n = n.right;
      }
    }
    type = /** @type {Y.AbstractType} */
    parent;
  }
  return pos - 1;
};
const yXmlFragmentToProseMirrorFragment = (yXmlFragment, schema) => {
  const fragmentContent = yXmlFragment.toArray().map(
    (t) => createNodeFromYElement(
      /** @type {Y.XmlElement} */
      t,
      schema,
      createEmptyMeta()
    )
  ).filter((n) => n !== null);
  return Fragment.fromArray(fragmentContent);
};
const yXmlFragmentToProseMirrorRootNode = (yXmlFragment, schema) => schema.topNodeType.create(null, yXmlFragmentToProseMirrorFragment(yXmlFragment, schema));
function prosemirrorToYDoc(doc2, xmlFragment = "prosemirror") {
  const ydoc = new Y.Doc();
  const type = (
    /** @type {Y.XmlFragment} */
    ydoc.get(xmlFragment, Y.XmlFragment)
  );
  if (!type.doc) {
    return ydoc;
  }
  prosemirrorToYXmlFragment(doc2, type);
  return type.doc;
}
function prosemirrorToYXmlFragment(doc2, xmlFragment) {
  const type = xmlFragment || new Y.XmlFragment();
  const ydoc = type.doc ? type.doc : { transact: (transaction) => transaction(void 0) };
  updateYFragment(ydoc, type, doc2, { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() });
  return type;
}
const defaultAwarenessStateFilter = (currentClientId, userClientId, _user) => currentClientId !== userClientId;
const defaultCursorBuilder = (user) => {
  const cursor = document.createElement("span");
  cursor.classList.add("ProseMirror-yjs-cursor");
  cursor.setAttribute("style", `border-color: ${user.color}`);
  const userDiv = document.createElement("div");
  userDiv.setAttribute("style", `background-color: ${user.color}`);
  userDiv.insertBefore(document.createTextNode(user.name), null);
  const nonbreakingSpace1 = document.createTextNode("");
  const nonbreakingSpace2 = document.createTextNode("");
  cursor.insertBefore(nonbreakingSpace1, null);
  cursor.insertBefore(userDiv, null);
  cursor.insertBefore(nonbreakingSpace2, null);
  return cursor;
};
const defaultSelectionBuilder = (user) => {
  return {
    style: `background-color: ${user.color}70`,
    class: "ProseMirror-yjs-selection"
  };
};
const rxValidColor = /^#[0-9a-fA-F]{6}$/;
const createDecorations = (state, awareness, awarenessFilter, createCursor, createSelection) => {
  const ystate = ySyncPluginKey.getState(state);
  const y = ystate.doc;
  const decorations = [];
  if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding.mapping.size === 0) {
    return DecorationSet.create(state.doc, []);
  }
  awareness.getStates().forEach((aw, clientId) => {
    if (!awarenessFilter(y.clientID, clientId, aw)) {
      return;
    }
    if (aw.cursor != null) {
      const user = aw.user || {};
      if (user.color == null) {
        user.color = "#ffa500";
      } else if (!rxValidColor.test(user.color)) {
        console.warn("A user uses an unsupported color format", user);
      }
      if (user.name == null) {
        user.name = `User: ${clientId}`;
      }
      let anchor = relativePositionToAbsolutePosition(
        y,
        ystate.type,
        Y.createRelativePositionFromJSON(aw.cursor.anchor),
        ystate.binding.mapping
      );
      let head = relativePositionToAbsolutePosition(
        y,
        ystate.type,
        Y.createRelativePositionFromJSON(aw.cursor.head),
        ystate.binding.mapping
      );
      if (anchor !== null && head !== null) {
        const maxsize = max$2(state.doc.content.size - 1, 0);
        anchor = min$2(anchor, maxsize);
        head = min$2(head, maxsize);
        decorations.push(
          Decoration.widget(head, () => createCursor(user, clientId), {
            key: clientId + "",
            side: 10
          })
        );
        const from2 = min$2(anchor, head);
        const to = max$2(anchor, head);
        decorations.push(
          Decoration.inline(from2, to, createSelection(user, clientId), {
            inclusiveEnd: true,
            inclusiveStart: false
          })
        );
      }
    }
  });
  return DecorationSet.create(state.doc, decorations);
};
const yCursorPlugin = (awareness, {
  awarenessStateFilter = defaultAwarenessStateFilter,
  cursorBuilder = defaultCursorBuilder,
  selectionBuilder = defaultSelectionBuilder,
  getSelection: getSelection2 = (state) => state.selection
} = {}, cursorStateField = "cursor") => new Plugin({
  key: yCursorPluginKey,
  state: {
    init(_, state) {
      return createDecorations(
        state,
        awareness,
        awarenessStateFilter,
        cursorBuilder,
        selectionBuilder
      );
    },
    apply(tr, prevState, _oldState, newState) {
      const ystate = ySyncPluginKey.getState(newState);
      const yCursorState = tr.getMeta(yCursorPluginKey);
      if (ystate && ystate.isChangeOrigin || yCursorState && yCursorState.awarenessUpdated) {
        return createDecorations(
          newState,
          awareness,
          awarenessStateFilter,
          cursorBuilder,
          selectionBuilder
        );
      }
      return prevState.map(tr.mapping, tr.doc);
    }
  },
  props: {
    decorations: (state) => {
      return yCursorPluginKey.getState(state);
    }
  },
  view: (view) => {
    const awarenessListener = () => {
      if (view.docView) {
        setMeta(view, yCursorPluginKey, { awarenessUpdated: true });
      }
    };
    const updateCursorInfo = () => {
      const ystate = ySyncPluginKey.getState(view.state);
      const current = awareness.getLocalState() || {};
      if (view.hasFocus()) {
        const selection = getSelection2(view.state);
        const anchor = absolutePositionToRelativePosition(
          selection.anchor,
          ystate.type,
          ystate.binding.mapping
        );
        const head = absolutePositionToRelativePosition(
          selection.head,
          ystate.type,
          ystate.binding.mapping
        );
        if (current.cursor == null || !Y.compareRelativePositions(
          Y.createRelativePositionFromJSON(current.cursor.anchor),
          anchor
        ) || !Y.compareRelativePositions(
          Y.createRelativePositionFromJSON(current.cursor.head),
          head
        )) {
          awareness.setLocalStateField(cursorStateField, {
            anchor,
            head
          });
        }
      } else if (current.cursor != null && relativePositionToAbsolutePosition(
        ystate.doc,
        ystate.type,
        Y.createRelativePositionFromJSON(current.cursor.anchor),
        ystate.binding.mapping
      ) !== null) {
        awareness.setLocalStateField(cursorStateField, null);
      }
    };
    awareness.on("change", awarenessListener);
    view.dom.addEventListener("focusin", updateCursorInfo);
    view.dom.addEventListener("focusout", updateCursorInfo);
    return {
      update: updateCursorInfo,
      destroy: () => {
        view.dom.removeEventListener("focusin", updateCursorInfo);
        view.dom.removeEventListener("focusout", updateCursorInfo);
        awareness.off("change", awarenessListener);
        awareness.setLocalStateField(cursorStateField, null);
      }
    };
  }
});
const undo = (state) => yUndoPluginKey.getState(state)?.undoManager?.undo() != null;
const redo = (state) => yUndoPluginKey.getState(state)?.undoManager?.redo() != null;
const defaultProtectedNodes = /* @__PURE__ */ new Set(["paragraph"]);
const defaultDeleteFilter = (item, protectedNodes) => !(item instanceof Item$1) || !(item.content instanceof ContentType) || !(item.content.type instanceof Text$1 || item.content.type instanceof XmlElement && protectedNodes.has(item.content.type.nodeName)) || item.content.type._length === 0;
const yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new Plugin({
  key: yUndoPluginKey,
  state: {
    init: (initargs, state) => {
      const ystate = ySyncPluginKey.getState(state);
      const _undoManager = undoManager || new UndoManager(ystate.type, {
        trackedOrigins: new Set([ySyncPluginKey].concat(trackedOrigins)),
        deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes),
        captureTransaction: (tr) => tr.meta.get("addToHistory") !== false
      });
      return {
        undoManager: _undoManager,
        prevSel: null,
        hasUndoOps: _undoManager.undoStack.length > 0,
        hasRedoOps: _undoManager.redoStack.length > 0
      };
    },
    apply: (tr, val, oldState, state) => {
      const binding = ySyncPluginKey.getState(state).binding;
      const undoManager2 = val.undoManager;
      const hasUndoOps = undoManager2.undoStack.length > 0;
      const hasRedoOps = undoManager2.redoStack.length > 0;
      if (binding) {
        return {
          undoManager: undoManager2,
          prevSel: getRelativeSelection(binding, oldState),
          hasUndoOps,
          hasRedoOps
        };
      } else {
        if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {
          return Object.assign({}, val, {
            hasUndoOps: undoManager2.undoStack.length > 0,
            hasRedoOps: undoManager2.redoStack.length > 0
          });
        } else {
          return val;
        }
      }
    }
  },
  view: (view) => {
    const ystate = ySyncPluginKey.getState(view.state);
    const undoManager2 = yUndoPluginKey.getState(view.state).undoManager;
    undoManager2.on("stack-item-added", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        stackItem.meta.set(binding, yUndoPluginKey.getState(view.state).prevSel);
      }
    });
    undoManager2.on("stack-item-popped", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection;
      }
    });
    return {
      destroy: () => {
        undoManager2.destroy();
      }
    };
  }
});
class EventEmitter {
  constructor() {
    __privateAdd(this, _events, /* @__PURE__ */ new Map());
  }
  /**
   * Subscribe to the event.
   * @param {string} name Event name.
   * @param {(...args: any[]) => void} fn Callback.
   * @returns {void}
   */
  on(name, fn2) {
    const callbacks = __privateGet(this, _events).get(name);
    if (callbacks) callbacks.push(fn2);
    else __privateGet(this, _events).set(name, [fn2]);
  }
  /**
   * Emit event.
   * @param {string} name Event name.
   * @param {...any} args  Arguments to pass to each listener.
   * @returns {void}
   */
  emit(name, ...args) {
    const callbacks = __privateGet(this, _events).get(name);
    if (!callbacks) return;
    for (const fn2 of callbacks) {
      fn2.apply(this, args);
    }
  }
  /**
   * Remove a specific callback from event
   * or all event subscriptions.
   * @param {string} name Event name.
   * @param {(...args: any[]) => void} fn Callback.
   * @returns {void}
   */
  off(name, fn2) {
    const callbacks = __privateGet(this, _events).get(name);
    if (!callbacks) return;
    if (fn2) {
      __privateGet(this, _events).set(
        name,
        callbacks.filter((cb) => cb !== fn2)
      );
    } else {
      __privateGet(this, _events).delete(name);
    }
  }
  /**
   * Subscribe to an event that will be called only once.
   * @param {string} name Event name.
   * @param {(...args: any[]) => void} fn Callback.
   * @returns {void}
   */
  once(name, fn2) {
    const wrapper = (...args) => {
      this.off(name, wrapper);
      fn2.apply(this, args);
    };
    this.on(name, wrapper);
  }
  /**
   * Remove all registered events and subscriptions.
   */
  removeAllListeners() {
    __privateSet(this, _events, /* @__PURE__ */ new Map());
  }
}
_events = new WeakMap();
var base = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i);
for (var i = 1; i <= 24; i++) base[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code];
function keyName(event) {
  var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}
const mac = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
const windows = typeof navigator != "undefined" && /Win/.test(navigator.platform);
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map2) {
  let copy = /* @__PURE__ */ Object.create(null);
  for (let prop in map2)
    copy[normalizeKeyName(prop)] = map2[prop];
  return copy;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map2 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map2[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map2[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(windows && event.ctrlKey && event.altKey) && (baseName = base[event.keyCode]) && baseName != name) {
        let fromCode = map2[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
const _ExtensionService = class _ExtensionService {
  constructor(extensions, userExtensions, editor) {
    __privateAdd(this, _ExtensionService_instances);
    __publicField(this, "editor");
    __publicField(this, "schema");
    __publicField(this, "extensions");
    __publicField(this, "externalExtensions", []);
    __publicField(this, "splittableMarks", []);
    this.editor = editor;
    this.externalExtensions = userExtensions || [];
    this.externalExtensions = this.externalExtensions.map((extension) => {
      return {
        ...extension,
        isExternal: true
      };
    });
    this.extensions = _ExtensionService.getResolvedExtensions([...extensions, ...this.externalExtensions]);
    this.schema = Schema.createSchemaByExtensions(this.extensions, editor);
    __privateMethod(this, _ExtensionService_instances, setupExtensions_fn).call(this);
  }
  /**
   * Static method for creating ExtensionService.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new _ExtensionService(...args);
  }
  /**
   * Get an array of resolved extensions (e.g. sorted by priority).
   * @param extensions Array of extensions.
   * @returns Array of resolved extensions.
   */
  static getResolvedExtensions(extensions) {
    const resolvedExtensions = _ExtensionService.sortByPriority(extensions);
    return resolvedExtensions;
  }
  /**
   * Sort extensions by priority.
   * @param extensions Array of extensions.
   * @returns Array of sorted extensions by priority.
   */
  static sortByPriority(extensions) {
    const defaultValue = 100;
    return extensions.sort((a, b) => {
      const priorityA = getExtensionConfigField(a, "priority") || defaultValue;
      const priorityB = getExtensionConfigField(b, "priority") || defaultValue;
      if (priorityA > priorityB) return -1;
      if (priorityA < priorityB) return 1;
      return 0;
    });
  }
  /**
   * Get all attributes defined in the extensions.
   * @returns Array of attributes.
   */
  get attributes() {
    return Attribute.getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all commands defined in the extensions.
   * @returns Object with commands (key - command name, value - function).
   */
  get commands() {
    let commandsObject = {};
    for (const extension of this.extensions) {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionConfigField(extension, "addCommands", context);
      if (addCommands) {
        commandsObject = {
          ...commandsObject,
          ...addCommands()
        };
      }
    }
    return commandsObject;
  }
  /**
   * Get all helper methods defined in the extensions.
   * Each extension can define its own helper methods.
   * Example: editor.helpers.linkedStyles.getStyles()
   * @returns {Object} Object with helper methods for extensions.
   */
  get helpers() {
    const helpersObject = {};
    for (const extension of this.extensions) {
      const name = extension.name;
      if (!name) continue;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addHelpers = getExtensionConfigField(extension, "addHelpers", context);
      if (addHelpers) {
        helpersObject[name] = addHelpers();
      }
    }
    return helpersObject;
  }
  /**
   * Get all PM plugins defined in the extensions.
   * And also keyboard shortcuts.
   * @returns Array of PM plugins.
   */
  get plugins() {
    const editor = this.editor;
    const extensions = _ExtensionService.sortByPriority([...this.extensions].reverse());
    const inputRules = [];
    const allPlugins = extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addShortcuts = getExtensionConfigField(extension, "addShortcuts", context);
      let bindingsObject = {};
      if (addShortcuts) {
        const entries = Object.entries(addShortcuts()).map(([shortcut, method]) => {
          return [shortcut, (...args) => method({ editor, keymapArgs: args })];
        });
        bindingsObject = { ...Object.fromEntries(entries) };
      }
      plugins.push(keymap(bindingsObject));
      const addInputRules = getExtensionConfigField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPmPlugins = getExtensionConfigField(extension, "addPmPlugins", context);
      if (addPmPlugins) {
        const pmPlugins = addPmPlugins();
        plugins.push(...pmPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...allPlugins
    ];
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views.
   */
  get nodeViews() {
    const { editor } = this;
    const nodeExtensions = this.extensions.filter((e) => e.type === "node");
    const entries = nodeExtensions.filter((extension) => !!getExtensionConfigField(extension, "addNodeView")).map((extension) => {
      const extensionAttrs = this.attributes.filter((a) => a.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionConfigField(extension, "addNodeView", context);
      if (!addNodeView) return [];
      const nodeview = (node, _view, getPos, decorations) => {
        const htmlAttributes = Attribute.getAttributesToRender(node, extensionAttrs);
        return addNodeView()({
          editor,
          node,
          getPos,
          decorations,
          htmlAttributes,
          extension
        });
      };
      return [extension.name, nodeview];
    });
    return Object.fromEntries(entries);
  }
};
_ExtensionService_instances = new WeakSet();
/**
 * Install all extensions.
 * Create extension storage in the editor, attach editor events.
 */
setupExtensions_fn = function() {
  for (const extension of this.extensions) {
    this.editor.extensionStorage[extension.name] = extension.storage;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor: this.editor,
      type: getSchemaTypeByName(extension.name, this.schema)
    };
    if (extension.type === "mark") {
      const keepOnSplit = callOrGet(getExtensionConfigField(extension, "keepOnSplit", context)) ?? true;
      if (keepOnSplit) {
        this.splittableMarks.push(extension.name);
      }
    }
    __privateMethod(this, _ExtensionService_instances, attachEditorEvents_fn).call(this, extension);
  }
};
/**
 * Attach editor events to extension
 * if callbacks are defined in the extension config.
 * @param extension Extension.
 */
attachEditorEvents_fn = function(extension) {
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage,
    editor: this.editor,
    type: getSchemaTypeByName(extension.name, this.schema)
  };
  const onBeforeCreate = getExtensionConfigField(extension, "onBeforeCreate", context);
  const onCreate2 = getExtensionConfigField(extension, "onCreate", context);
  const onUpdate = getExtensionConfigField(extension, "onUpdate", context);
  const onSelectionUpdate = getExtensionConfigField(extension, "onSelectionUpdate", context);
  const onTransaction = getExtensionConfigField(extension, "onTransaction", context);
  const onFocus = getExtensionConfigField(extension, "onFocus", context);
  const onBlur = getExtensionConfigField(extension, "onBlur", context);
  const onDestroy2 = getExtensionConfigField(extension, "onDestroy", context);
  if (onBeforeCreate) this.editor.on("beforeCreate", onBeforeCreate);
  if (onCreate2) this.editor.on("create", onCreate2);
  if (onUpdate) this.editor.on("update", onUpdate);
  if (onSelectionUpdate) this.editor.on("selectionUpdate", onSelectionUpdate);
  if (onTransaction) this.editor.on("transaction", onTransaction);
  if (onFocus) this.editor.on("focus", onFocus);
  if (onBlur) this.editor.on("blur", onBlur);
  if (onDestroy2) this.editor.on("destroy", onDestroy2);
};
let ExtensionService = _ExtensionService;
const findTrackedMarkBetween = ({
  tr,
  from: from2,
  to,
  markName,
  attrs = {},
  offset: offset2 = 1
  // To get non-inclusive marks.
}) => {
  const { doc: doc2 } = tr;
  const startPos = Math.max(from2 - offset2, 0);
  const endPos = Math.min(to + offset2, doc2.content.size);
  let markFound;
  doc2.nodesBetween(startPos, endPos, (node, pos) => {
    if (!node || node?.nodeSize === void 0) {
      return;
    }
    const mark = node.marks.find(
      (mark2) => mark2.type.name === markName && Object.keys(attrs).every((attr) => mark2.attrs[attr] === attrs[attr])
    );
    if (mark && !markFound) {
      markFound = {
        from: pos,
        to: pos + node.nodeSize,
        mark
      };
    }
  });
  return markFound;
};
const markInsertion = ({ tr, from: from2, to, user, date }) => {
  tr.removeMark(from2, to, tr.doc.type.schema.marks[TrackDeleteMarkName]);
  tr.removeMark(from2, to, tr.doc.type.schema.marks[TrackInsertMarkName]);
  let trackedMark = findTrackedMarkBetween({
    tr,
    from: from2,
    to,
    markName: TrackInsertMarkName,
    attrs: { authorEmail: user.email }
  });
  let id;
  if (trackedMark) {
    id = trackedMark.mark.attrs.id;
  } else {
    id = v4();
  }
  const insertionMark = tr.doc.type.schema.marks[TrackInsertMarkName].create({
    id,
    author: user.name,
    authorEmail: user.email,
    date
  });
  tr.addMark(from2, to, insertionMark);
  tr.doc.nodesBetween(from2, to, (node, pos) => {
    if (pos < from2 || ["bulletList", "orderedList"].includes(node.type.name)) {
      return true;
    } else if (node.isInline || ["tableRow", "tableCell"].includes(node.type.name)) {
      return false;
    }
    if (node.attrs.track) ;
    if (node.type.name === "table") {
      return false;
    }
  });
  return insertionMark;
};
const markDeletion = ({ tr, from: from2, to, user, date }) => {
  let trackedMark = findTrackedMarkBetween({
    tr,
    from: from2,
    to,
    markName: TrackDeleteMarkName,
    attrs: { authorEmail: user.email }
  });
  let id;
  if (trackedMark) {
    id = trackedMark.mark.attrs.id;
  } else {
    id = v4();
  }
  const deletionMark = tr.doc.type.schema.marks[TrackDeleteMarkName].create({
    id,
    author: user.name,
    authorEmail: user.email,
    date
  });
  const deletionMap = new Mapping();
  let nodes = [];
  tr.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.type.name.includes("table")) {
      return;
    }
    if (node.isInline && node.marks.find((mark) => mark.type.name === TrackInsertMarkName && mark.attrs.authorEmail === user.email)) {
      const removeStep = new ReplaceStep(
        deletionMap.map(Math.max(from2, pos)),
        deletionMap.map(Math.min(to, pos + node.nodeSize)),
        Slice.empty
      );
      if (!tr.maybeStep(removeStep).failed) {
        deletionMap.appendMap(removeStep.getMap());
      }
    } else if (node.isInline && !node.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
      nodes.push(node);
      tr.addMark(
        deletionMap.map(Math.max(from2, pos)),
        deletionMap.map(Math.min(to, pos + node.nodeSize)),
        deletionMark
      );
    } else if (node.attrs.track && !node.attrs.track.find((trackAttr) => trackAttr.type === TrackDeleteMarkName) && !["bulletList", "orderedList"].includes(node.type.name)) ;
  });
  return { deletionMark, deletionMap, nodes };
};
const findMarkPosition = (doc2, pos, markName) => {
  const $pos = doc2.resolve(pos);
  const parent = $pos.parent;
  const start2 = parent.childAfter($pos.parentOffset);
  if (!start2.node) {
    return null;
  }
  const actualMark = start2.node.marks.find((mark) => mark.type.name === markName);
  let startIndex = $pos.index();
  let startPos = $pos.start() + start2.offset;
  while (startIndex > 0 && actualMark.isInSet(parent.child(startIndex - 1).marks)) {
    startPos -= parent.child(--startIndex).nodeSize;
  }
  let endIndex = $pos.index() + 1;
  let endPos = $pos.start() + start2.offset + start2.node.nodeSize;
  while (endIndex < parent.childCount && actualMark.isInSet(parent.child(endIndex).marks)) {
    endPos += parent.child(endIndex++).nodeSize;
  }
  return {
    from: startPos,
    to: endPos,
    attrs: actualMark.attrs
  };
};
const flatten = (node, descend = true) => {
  if (!node) {
    throw new Error('Invalid "node" parameter');
  }
  const result = [];
  node.descendants((child, pos) => {
    result.push({ node: child, pos });
    if (!descend) {
      return false;
    }
  });
  return result;
};
const findChildren$4 = (node, predicate, descend) => {
  if (!node) {
    throw new Error('Invalid "node" parameter');
  } else if (!predicate) {
    throw new Error('Invalid "predicate" parameter');
  }
  return flatten(node, descend).filter((child) => predicate(child.node));
};
const findInlineNodes = (node, descend) => {
  return findChildren$4(node, (child) => child.isInline, descend);
};
const documentHelpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  findChildren: findChildren$4,
  findInlineNodes,
  findMarkPosition,
  flatten
}, Symbol.toStringTag, { value: "Module" }));
const getTrackChanges = (state, id = null) => {
  const trackedChanges = [];
  const allInlineNodes = findInlineNodes(state.doc);
  if (!allInlineNodes.length) {
    return trackedChanges;
  }
  allInlineNodes.forEach(({ node, pos }) => {
    const { marks } = node;
    const trackedMarks = [TrackInsertMarkName, TrackDeleteMarkName, TrackFormatMarkName];
    if (marks.length > 0) {
      marks.forEach((mark) => {
        if (trackedMarks.includes(mark.type.name)) {
          trackedChanges.push({
            mark,
            from: pos,
            to: pos + node.nodeSize
          });
        }
      });
    }
  });
  if (id) {
    return trackedChanges.filter(({ mark }) => mark.attrs.id === id);
  }
  return trackedChanges;
};
const TrackChangesBasePluginKey = new PluginKey("TrackChangesBase");
const TrackChangesBasePlugin = () => {
  return new Plugin({
    key: TrackChangesBasePluginKey,
    state: {
      init(_, state) {
        const decorations = getTrackChangesDecorations(state, false, false);
        return {
          isTrackChangesActive: false,
          onlyOriginalShown: false,
          onlyModifiedShown: false,
          decorations
        };
      },
      apply(tr, oldState, prevEditorState, newEditorState) {
        const meta = tr.getMeta(TrackChangesBasePluginKey);
        if (!meta) {
          return {
            ...oldState,
            decorations: getTrackChangesDecorations(
              newEditorState,
              oldState.onlyOriginalShown,
              oldState.onlyModifiedShown
            )
          };
        }
        if (meta.type === "TRACK_CHANGES_ENABLE") {
          return {
            ...oldState,
            isTrackChangesActive: meta.value === true,
            decorations: getTrackChangesDecorations(
              newEditorState,
              oldState.onlyOriginalShown,
              oldState.onlyModifiedShown
            )
          };
        }
        if (meta.type === "SHOW_ONLY_ORIGINAL") {
          return {
            ...oldState,
            onlyOriginalShown: meta.value === true,
            onlyModifiedShown: false,
            decorations: getTrackChangesDecorations(newEditorState, meta.value === true, false)
          };
        }
        if (meta.type === "SHOW_ONLY_MODIFIED") {
          return {
            ...oldState,
            onlyOriginalShown: false,
            onlyModifiedShown: meta.value === true,
            decorations: getTrackChangesDecorations(newEditorState, false, meta.value === true)
          };
        }
        return {
          ...oldState,
          decorations: getTrackChangesDecorations(
            newEditorState,
            oldState.onlyOriginalShown,
            oldState.onlyModifiedShown
          )
        };
      }
    },
    props: {
      decorations(state) {
        return this.getState(state)?.decorations;
      }
    }
  });
};
const getTrackChangesDecorations = (state, onlyOriginalShown, onlyModifiedShown) => {
  if (!state.doc || !state.doc.nodeSize || onlyModifiedShown && onlyOriginalShown) {
    return DecorationSet.empty;
  }
  const decorations = [];
  const trackedChanges = getTrackChanges(state);
  if (!trackedChanges.length) {
    return DecorationSet.empty;
  }
  trackedChanges.forEach(({ mark, from: from2, to }) => {
    if (mark.type.name === TrackInsertMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-insert-dec hidden"
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-insert-dec normal"
        });
        decorations.push(decoration);
      } else {
        const decoration = Decoration.inline(from2, to, {
          class: "track-insert-dec highlighted"
        });
        decorations.push(decoration);
      }
    }
    if (mark.type.name === TrackDeleteMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-delete-dec normal"
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-delete-dec hidden"
        });
        decorations.push(decoration);
      } else {
        const decorationInline = Decoration.inline(from2, to, {
          class: "track-delete-dec highlighted"
          // 'hidden'
        });
        decorations.push(decorationInline);
        const decorationWidget = Decoration.widget(
          from2,
          () => {
            const span = document.createElement("span");
            span.classList.add("track-delete-widget");
            span.contentEditable = false;
            return span;
          },
          { ignoreSelection: true }
        );
        decorations.push(decorationWidget);
      }
    }
    if (mark.type.name === TrackFormatMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-format-dec before"
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-format-dec normal"
        });
        decorations.push(decoration);
      } else {
        const decoration = Decoration.inline(from2, to, {
          class: "track-format-dec highlighted"
        });
        decorations.push(decoration);
      }
    }
  });
  return DecorationSet.create(state.doc, decorations);
};
const CommentMarkName = "commentMark";
const removeCommentsById = ({ commentId, state, tr, dispatch }) => {
  const positions = getCommentPositionsById(commentId, state.doc);
  positions.forEach(({ from: from2, to }) => {
    tr.removeMark(from2, to, state.schema.marks[CommentMarkName]);
  });
  dispatch(tr);
};
const getCommentPositionsById = (commentId, doc2) => {
  const positions = [];
  doc2.descendants((node, pos) => {
    const { marks } = node;
    const commentMark = marks.find((mark) => mark.type.name === CommentMarkName);
    if (commentMark) {
      const { attrs } = commentMark;
      const { commentId: currentCommentId } = attrs;
      if (commentId === currentCommentId) {
        positions.push({ from: pos, to: pos + node.nodeSize });
      }
    }
  });
  return positions;
};
const prepareCommentsForExport = (doc2, tr, schema, comments = []) => {
  const startNodes = [];
  const endNodes = [];
  const seen = /* @__PURE__ */ new Set();
  doc2.descendants((node, pos) => {
    const commentMarks = node.marks?.filter((mark) => mark.type.name === CommentMarkName);
    commentMarks.forEach((commentMark) => {
      if (commentMark) {
        const { attrs = {} } = commentMark;
        const { commentId } = attrs;
        if (commentId === "pending") return;
        if (seen.has(commentId)) return;
        seen.add(commentId);
        const commentStartNodeAttrs = getPreparedComment(commentMark.attrs);
        const startNode = schema.nodes.commentRangeStart.create(commentStartNodeAttrs);
        startNodes.push({
          pos,
          node: startNode
        });
        const endNode = schema.nodes.commentRangeEnd.create(commentStartNodeAttrs);
        endNodes.push({
          pos: pos + node.nodeSize,
          node: endNode
        });
        const parentId = commentId;
        if (parentId) {
          const childComments = comments.filter((c) => c.parentCommentId === parentId).sort((a, b) => a.createdTime - b.createdTime);
          childComments.forEach((c) => {
            const childMark = getPreparedComment(c);
            const childStartNode = schema.nodes.commentRangeStart.create(childMark);
            seen.add(c.commentId);
            startNodes.push({
              pos,
              node: childStartNode
            });
            const childEndNode = schema.nodes.commentRangeEnd.create(childMark);
            endNodes.push({
              pos: pos + node.nodeSize,
              node: childEndNode
            });
          });
        }
      }
    });
  });
  startNodes.forEach((n) => {
    const { pos, node } = n;
    const mappedPos = tr.mapping.map(pos);
    tr.insert(mappedPos, node);
  });
  endNodes.forEach((n) => {
    const { pos, node } = n;
    const mappedPos = tr.mapping.map(pos);
    tr.insert(mappedPos, node);
  });
  return tr;
};
const getPreparedComment = (attrs) => {
  const { commentId, internal } = attrs;
  return {
    "w:id": commentId,
    internal
  };
};
const prepareCommentsForImport = (doc2, tr, schema, converter) => {
  const toMark = [];
  const toDelete = [];
  doc2.descendants((node, pos) => {
    const { type } = node;
    const commentNodes = ["commentRangeStart", "commentRangeEnd", "commentReference"];
    if (!commentNodes.includes(type.name)) return;
    const matchingImportedComment = converter.comments?.find((c) => c.importedId == node.attrs["w:id"]) || {};
    const { commentId } = matchingImportedComment;
    if (!commentId) return;
    if (type.name === "commentRangeStart") {
      toMark.push({
        "w:id": commentId,
        importedId: node.attrs["w:id"],
        internal: false,
        start: pos
      });
      toDelete.push({ start: pos, end: pos + 1 });
    } else if (type.name === "commentRangeEnd") {
      const itemToMark = toMark.find((p) => p.importedId === node.attrs["w:id"]);
      if (!itemToMark) return;
      const { start: start2 } = itemToMark;
      const markAttrs = {
        commentId,
        importedId: node.attrs["w:id"],
        internal: itemToMark.internal
      };
      tr.addMark(start2, pos + 1, schema.marks[CommentMarkName].create(markAttrs));
      toDelete.push({ start: pos, end: pos + 1 });
    } else if (type.name === "commentReference") {
      toDelete.push({ start: pos, end: pos + 1 });
    }
  });
  toDelete.sort((a, b) => b.start - a.start).forEach(({ start: start2, end: end2 }) => {
    tr.delete(start2, end2);
  });
};
const translateFormatChangesToEnglish = (attrs = {}) => {
  const { before = [], after = [] } = attrs;
  const beforeTypes = new Set(before.map((mark) => mark.type));
  const afterTypes = new Set(after.map((mark) => mark.type));
  const added = [...afterTypes].filter((type) => !beforeTypes.has(type));
  const removed = [...beforeTypes].filter((type) => !afterTypes.has(type));
  const messages = [];
  const nonTextStyleAdded = added.filter((type) => !["textStyle", "commentMark"].includes(type));
  if (nonTextStyleAdded.length) {
    messages.push(`Added formatting: ${nonTextStyleAdded.join(", ")}`);
  }
  const nonTextStyleRemoved = removed.filter((type) => !["textStyle", "commentMark"].includes(type));
  if (nonTextStyleRemoved.length) {
    messages.push(`Removed formatting: ${nonTextStyleRemoved.join(", ")}`);
  }
  const beforeTextStyle = before.find((mark) => mark.type === "textStyle")?.attrs || {};
  const afterTextStyle = after.find((mark) => mark.type === "textStyle")?.attrs || {};
  const textStyleChanges = [];
  const formatAttrName = (attr) => attr.replace(/([a-z])([A-Z])/g, "$1 $2").toLowerCase();
  Object.keys({ ...beforeTextStyle, ...afterTextStyle }).forEach((attr) => {
    const beforeValue = beforeTextStyle[attr];
    const afterValue = afterTextStyle[attr];
    if (beforeValue !== afterValue) {
      if (afterValue === null) {
        return;
      } else if (attr === "color") {
        textStyleChanges.push(`Changed color`);
      } else {
        const label = formatAttrName(attr);
        if (beforeValue === void 0 || beforeValue === null) {
          textStyleChanges.push(`Set ${label} to ${afterValue}`);
        } else {
          textStyleChanges.push(`Changed ${label} from ${beforeValue} to ${afterValue}`);
        }
      }
    }
  });
  if (textStyleChanges.length) {
    messages.push(`Modified text style: ${textStyleChanges.join(", ")}`);
  }
  return messages.length ? messages.join(". ") : "No formatting changes.";
};
const getHighlightColor = ({ activeThreadId, threadId, isInternal, editor }) => {
  if (!editor.options.isInternal && isInternal) return "transparent";
  const pluginState = CommentsPluginKey.getState(editor.state);
  const color = isInternal ? pluginState.internalColor : pluginState.externalColor;
  const alpha = activeThreadId == threadId ? "44" : "22";
  return `${color}${alpha}`;
};
const updateYdocDocxData = async (editor, ydoc) => {
  ydoc = ydoc || editor.options.ydoc;
  if (!ydoc) return;
  const metaMap = ydoc.getMap("meta");
  const docx = [...metaMap.get("docx")];
  const newXml = await editor.exportDocx({ getUpdatedDocs: true });
  Object.keys(newXml).forEach((key) => {
    const fileIndex = docx.findIndex((item) => item.name === key);
    if (fileIndex > -1) {
      docx.splice(fileIndex, 1);
    }
    docx.push({
      name: key,
      content: newXml[key]
    });
  });
  ydoc.transact(
    () => {
      metaMap.set("docx", docx);
    },
    { event: "docx-update", user: editor.options.user }
  );
};
const PaginationPluginKey = new PluginKey("paginationPlugin");
const initPaginationData = async (editor) => {
  if (!editor.converter) return;
  const sectionData = { headers: {}, footers: {} };
  const headerIds = editor.converter.headerIds.ids;
  const footerIds = editor.converter.footerIds.ids;
  for (let key in headerIds) {
    const sectionId = headerIds[key];
    if (!sectionId) continue;
    const dataForThisSection = editor.converter.headers[sectionId];
    if (!sectionData.headers[sectionId]) sectionData.headers[sectionId] = {};
    sectionData.headers[sectionId].data = dataForThisSection;
    const { height, sectionEditor, sectionContainer } = await getSectionHeight(editor, dataForThisSection);
    sectionData.headers[sectionId].height = height;
    sectionData.headers[sectionId].sectionEditor = sectionEditor;
    sectionData.headers[sectionId].sectionContainer = sectionContainer;
  }
  for (let key in footerIds) {
    const sectionId = footerIds[key];
    if (!sectionId) continue;
    const dataForThisSection = editor.converter.footers[sectionId];
    if (!sectionData.headers[sectionId]) sectionData.footers[sectionId] = {};
    sectionData.footers[sectionId].data = dataForThisSection;
    const { height, sectionEditor, sectionContainer } = await getSectionHeight(editor, dataForThisSection);
    sectionData.footers[sectionId].height = height;
    sectionData.footers[sectionId].sectionEditor = sectionEditor;
    sectionData.footers[sectionId].sectionContainer = sectionContainer;
  }
  return sectionData;
};
const getSectionHeight = async (editor, data) => {
  if (!data) return {};
  return new Promise((resolve) => {
    const editorContainer = document.createElement("div");
    editorContainer.className = "super-editor";
    editorContainer.style.padding = "0";
    editorContainer.style.margin = "0";
    const sectionEditor = createHeaderFooterEditor({ editor, data, editorContainer });
    sectionEditor.on("create", () => {
      sectionEditor.setEditable(false, false);
      requestAnimationFrame(() => {
        const height = editorContainer.offsetHeight;
        document.body.removeChild(editorContainer);
        resolve({ height, sectionEditor, sectionContainer: editorContainer });
      });
    });
  });
};
const createHeaderFooterEditor = ({
  editor,
  data,
  editorContainer,
  appendToBody = true,
  sectionId,
  type,
  availableHeight,
  currentPageNumber
}) => {
  const parentStyles = editor.converter.getDocumentDefaultStyles();
  const { fontSizePt, typeface } = parentStyles;
  const fontSizeInPixles = fontSizePt * 1.3333;
  const lineHeight = fontSizeInPixles * 1.2;
  Object.assign(editorContainer.style, {
    padding: "0",
    margin: "0",
    border: "none",
    boxSizing: "border-box",
    position: "absolute",
    top: "0",
    left: "0",
    width: "auto",
    maxWidth: "none",
    fontFamily: typeface,
    fontSize: `${fontSizeInPixles}px`,
    lineHeight: `${lineHeight}px`
  });
  Object.assign(editorContainer.style, {
    padding: "0",
    margin: "0",
    border: "none",
    boxSizing: "border-box",
    height: availableHeight + "px",
    overflow: "hidden"
  });
  if (appendToBody) document.body.appendChild(editorContainer);
  const headerFooterEditor = new Editor({
    role: editor.options.role,
    loadFromSchema: true,
    mode: "docx",
    element: editorContainer,
    content: data,
    extensions: getStarterExtensions(),
    documentId: sectionId || "sectionId",
    media: editor.storage.image.media,
    mediaFiles: editor.storage.image.media,
    fonts: editor.options.fonts,
    isHeaderOrFooter: true,
    isHeadless: editor.options.isHeadless,
    annotations: true,
    currentPageNumber,
    parentEditor: editor,
    editable: false,
    documentMode: "viewing",
    onCreate: (evt) => setEditorToolbar(evt, editor),
    onBlur: (evt) => onHeaderFooterDataUpdate(evt, editor, sectionId, type)
  });
  headerFooterEditor.setEditable(false, false);
  const pm = editorContainer.querySelector(".ProseMirror");
  if (pm) {
    pm.style.maxHeight = "100%";
    pm.style.minHeight = "100%";
    pm.style.outline = "none";
    pm.style.border = "none";
    pm.setAttribute("role", "textbox");
    pm.setAttribute("aria-multiline", true);
    pm.setAttribute("aria-label", `${type} content area. Double click to start typing.`);
  }
  return headerFooterEditor;
};
const broadcastEditorEvents = (editor, sectionEditor) => {
  const eventNames = [
    "fieldAnnotationDropped",
    "fieldAnnotationPaste",
    "fieldAnnotationSelected",
    "fieldAnnotationClicked",
    "fieldAnnotationDoubleClicked",
    "fieldAnnotationDeleted"
  ];
  eventNames.forEach((eventName) => {
    sectionEditor.on(eventName, (...args) => {
      editor.emit(eventName, ...args);
      console.debug("broadcastEditorEvents", { eventName, args });
    });
  });
};
const toggleHeaderFooterEditMode = ({ editor, focusedSectionEditor, isEditMode, documentMode }) => {
  editor.converter.headerEditors.forEach((item) => {
    item.editor.setEditable(isEditMode, false);
    item.editor.view.dom.setAttribute("aria-readonly", !isEditMode);
    item.editor.view.dom.setAttribute("documentmode", documentMode);
  });
  editor.converter.footerEditors.forEach((item) => {
    item.editor.setEditable(isEditMode, false);
    item.editor.view.dom.setAttribute("aria-readonly", !isEditMode);
    item.editor.view.dom.setAttribute("documentmode", documentMode);
  });
  if (isEditMode) {
    const pm = document.querySelector(".ProseMirror");
    pm.classList.add("header-footer-edit");
    pm.setAttribute("aria-readonly", true);
  }
  if (focusedSectionEditor) {
    focusedSectionEditor.view.focus();
  }
};
const onHeaderFooterDataUpdate = async ({ editor, transaction }, mainEditor, sectionId, type) => {
  if (!type || !sectionId) return;
  const updatedData = editor.getUpdatedJson();
  mainEditor.converter[`${type}Editors`].forEach((item) => {
    if (item.id === sectionId) {
      item.editor.setOptions({
        media: editor.options.media,
        mediaFiles: editor.options.mediaFiles
      });
      item.editor.replaceContent(updatedData);
    }
    item.editor.setOptions({
      lastSelection: transaction?.selection
    });
  });
  mainEditor.converter[`${type}s`][sectionId] = updatedData;
  mainEditor.setOptions({ isHeaderFooterChanged: editor.docChanged });
  await updateYdocDocxData(mainEditor);
};
const setEditorToolbar = ({ editor }, mainEditor) => {
  editor.setToolbar(mainEditor.toolbar);
};
const TRACK_CHANGE_MARKS = [TrackInsertMarkName, TrackDeleteMarkName, TrackFormatMarkName];
const CommentsPluginKey = new PluginKey("comments");
const CommentsPlugin = Extension.create({
  name: "comments",
  addCommands() {
    return {
      insertComment: (conversation) => ({ tr, dispatch }) => {
        const { selection } = tr;
        const { $from, $to } = selection;
        const { commentId, isInternal } = conversation;
        tr.setMeta(CommentsPluginKey, { event: "add" });
        tr.addMark(
          $from.pos,
          $to.pos,
          this.editor.schema.marks[CommentMarkName].create({
            commentId,
            internal: isInternal
          })
        );
        dispatch(tr);
        return true;
      },
      removeComment: ({ commentId, importedId }) => ({ tr, dispatch, state }) => {
        tr.setMeta(CommentsPluginKey, { event: "deleted" });
        removeCommentsById({ commentId, state, tr, dispatch });
      },
      setActiveComment: ({ commentId }) => ({ tr }) => {
        tr.setMeta(CommentsPluginKey, { type: "setActiveComment", activeThreadId: commentId, forceUpdate: true });
        return true;
      },
      setCommentInternal: ({ commentId, isInternal }) => ({ tr, dispatch, state }) => {
        const { doc: doc2 } = state;
        let foundStartNode;
        let foundPos;
        tr.setMeta(CommentsPluginKey, { event: "update" });
        doc2.descendants((node, pos) => {
          if (foundStartNode) return;
          const { marks = [] } = node;
          const commentMark = marks.find((mark) => mark.type.name === CommentMarkName);
          if (commentMark) {
            const { attrs } = commentMark;
            const wid = attrs.commentId;
            if (wid === commentId) {
              foundStartNode = node;
              foundPos = pos;
            }
          }
        });
        if (!foundStartNode) return false;
        tr.addMark(
          foundPos,
          foundPos + foundStartNode.nodeSize,
          this.editor.schema.marks[CommentMarkName].create({
            commentId,
            internal: isInternal
          })
        );
        tr.setMeta(CommentsPluginKey, { type: "setCommentInternal" });
        dispatch(tr);
        return true;
      },
      resolveComment: ({ commentId }) => ({ tr, dispatch, state }) => {
        tr.setMeta(CommentsPluginKey, { event: "update" });
        removeCommentsById({ commentId, state, tr, dispatch });
      },
      setCursorById: (id) => ({ state, editor }) => {
        const { from: from2 } = findRangeById(state.doc, id) || {};
        if (from2 != null) {
          state.tr.setSelection(TextSelection.create(state.doc, from2));
          editor.view.focus();
          return true;
        }
        return false;
      }
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    let shouldUpdate;
    if (editor.options.isHeadless) return [];
    const commentsPlugin = new Plugin({
      key: CommentsPluginKey,
      state: {
        init() {
          return {
            activeThreadId: null,
            externalColor: "#B1124B",
            internalColor: "#078383",
            decorations: DecorationSet.empty,
            allCommentPositions: {},
            allCommentIds: [],
            changedActiveThread: false,
            trackedChanges: {}
          };
        },
        apply(tr, pluginState, _, newEditorState) {
          const paginationMeta = tr.getMeta(PaginationPluginKey);
          const isPaginationInit = paginationMeta?.isReadyToInit;
          if (isPaginationInit) shouldUpdate = true;
          const meta = tr.getMeta(CommentsPluginKey);
          const { type } = meta || {};
          if (type === "force" || type === "forceTrackChanges") shouldUpdate = true;
          if (type === "setActiveComment") {
            shouldUpdate = true;
            pluginState.activeThreadId = meta.activeThreadId;
            return {
              ...pluginState,
              activeThreadId: meta.activeThreadId,
              changedActiveThread: true
            };
          }
          if (!isPaginationInit && !shouldUpdate && meta && meta.decorations) {
            return {
              ...pluginState,
              decorations: meta.decorations,
              allCommentPositions: meta.allCommentPositions
            };
          }
          const trackedChangeMeta = tr.getMeta(TrackChangesBasePluginKey);
          const currentTrackedChanges = pluginState.trackedChanges;
          if (trackedChangeMeta) {
            pluginState.trackedChanges = handleTrackedChangeTransaction(
              trackedChangeMeta,
              currentTrackedChanges,
              newEditorState,
              editor
            );
          }
          const trChangedActiveComment = meta?.type === "setActiveComment";
          if (!tr.docChanged && tr.selectionSet || trChangedActiveComment) {
            const { selection } = tr;
            let currentActiveThread = getActiveCommentId(newEditorState.doc, selection);
            if (trChangedActiveComment) currentActiveThread = meta.activeThreadId;
            const previousSelectionId = pluginState.activeThreadId;
            if (previousSelectionId !== currentActiveThread) {
              pluginState.activeThreadId = currentActiveThread;
              const update = {
                type: comments_module_events.SELECTED,
                activeCommentId: currentActiveThread ? currentActiveThread : null
              };
              shouldUpdate = true;
              editor.emit("commentsUpdate", update);
              const { tr: newTr } = editor.view.state;
              const { dispatch } = editor.view;
              newTr.setMeta(CommentsPluginKey, { type: "force" });
              dispatch(newTr);
            }
          }
          return pluginState;
        }
      },
      props: {
        decorations(state) {
          return this.getState(state).decorations;
        }
      },
      view() {
        let prevDoc;
        let prevActiveThreadId;
        return {
          update(view) {
            const { state } = view;
            const { doc: doc2, tr } = state;
            const pluginState = CommentsPluginKey.getState(state);
            const currentActiveThreadId = pluginState.activeThreadId;
            const meta = tr.getMeta(CommentsPluginKey);
            if (meta?.type === "setActiveComment" || meta?.forceUpdate) {
              shouldUpdate = true;
            }
            if (prevDoc && !prevDoc.eq(doc2)) shouldUpdate = true;
            if (prevActiveThreadId !== currentActiveThreadId) {
              shouldUpdate = true;
              prevActiveThreadId = currentActiveThreadId;
            }
            if (!shouldUpdate) return;
            prevDoc = doc2;
            shouldUpdate = false;
            const decorations = [];
            const allCommentPositions = {};
            doc2.descendants((node, pos) => {
              const { marks = [] } = node;
              const commentMarks = marks.filter((mark) => mark.type.name === CommentMarkName);
              let hasActive = false;
              commentMarks.forEach((commentMark) => {
                const { attrs } = commentMark;
                const threadId = attrs.commentId || attrs.importedId;
                const currentBounds = view.coordsAtPos(pos);
                updatePosition({
                  allCommentPositions,
                  threadId,
                  pos,
                  currentBounds,
                  node
                });
                const isInternal = attrs.internal;
                if (!hasActive) hasActive = currentActiveThreadId === threadId;
                let color = getHighlightColor({
                  activeThreadId: currentActiveThreadId,
                  threadId,
                  isInternal,
                  editor
                });
                const deco = Decoration.inline(pos, pos + node.nodeSize, {
                  style: `background-color: ${color};`,
                  "data-thread-id": threadId,
                  class: "sd-editor-comment-highlight"
                });
                if (hasActive && currentActiveThreadId !== threadId) return;
                decorations.push(deco);
              });
              const trackedChangeMark = findTrackedMark({
                doc: doc2,
                from: pos,
                to: pos + node.nodeSize
              });
              if (trackedChangeMark) {
                const currentBounds = view.coordsAtPos(pos);
                const { id } = trackedChangeMark.mark.attrs;
                updatePosition({
                  allCommentPositions,
                  threadId: id,
                  pos,
                  currentBounds,
                  node
                });
                const isActiveTrackedChange = currentActiveThreadId === id;
                if (isActiveTrackedChange) {
                  const trackedChangeDeco = Decoration.inline(pos, pos + node.nodeSize, {
                    style: `border-width: 2px;`,
                    "data-thread-id": id,
                    class: "sd-editor-tracked-change-highlight"
                  });
                  decorations.push(trackedChangeDeco);
                }
              }
            });
            const decorationSet = DecorationSet.create(doc2, decorations);
            const oldDecorations = pluginState.decorations;
            const same = oldDecorations.eq(decorationSet);
            if (!same) {
              const tr2 = state.tr.setMeta(CommentsPluginKey, {
                decorations: decorationSet,
                allCommentPositions,
                forceUpdate: true
              });
              view.dispatch(tr2);
            }
            editor.emit("comment-positions", { allCommentPositions });
          }
        };
      }
    });
    return [commentsPlugin];
  }
});
const updatePosition = ({ allCommentPositions, threadId, pos, currentBounds, node }) => {
  let bounds = {};
  if (currentBounds instanceof DOMRect) {
    bounds = {
      top: currentBounds.top,
      bottom: currentBounds.bottom,
      left: currentBounds.left,
      right: currentBounds.right
    };
  } else {
    bounds = { ...currentBounds };
  }
  if (!allCommentPositions[threadId]) {
    allCommentPositions[threadId] = {
      threadId,
      start: pos,
      end: pos + node.nodeSize,
      bounds
    };
  } else {
    const existing = allCommentPositions[threadId];
    existing.start = Math.min(existing.start, pos);
    existing.end = Math.max(existing.end, pos + node.nodeSize);
    existing.bounds.top = Math.min(existing.bounds.top, currentBounds.top);
    existing.bounds.bottom = Math.max(existing.bounds.bottom, currentBounds.bottom);
  }
};
const getActiveCommentId = (doc2, selection) => {
  if (!selection) return;
  const { $from, $to } = selection;
  if ($from.pos !== $to.pos) return;
  const nodeAtPos = doc2.nodeAt($from.pos);
  if (!nodeAtPos) return;
  const trackedChangeMark = findTrackedMark({
    doc: doc2,
    from: $from.pos,
    to: $to.pos
  });
  if (trackedChangeMark) {
    return trackedChangeMark.mark.attrs.id;
  }
  const overlaps = [];
  let found = false;
  doc2.descendants((node, pos) => {
    if (found) return;
    const end2 = pos + node.nodeSize;
    if ($from.pos < pos || $from.pos >= end2) {
      return;
    }
    const { marks = [] } = node;
    const commentMark = marks.find((mark) => mark.type.name === CommentMarkName);
    if (commentMark) {
      overlaps.push({
        node,
        pos,
        size: node.nodeSize
      });
    }
    if (pos > $from.pos) {
      found = true;
    }
  });
  let closest = null;
  let closestCommentRangeStart = null;
  overlaps.forEach(({ pos, node }) => {
    if (!closest) closest = $from.pos - pos;
    const diff = $from.pos - pos;
    if (diff >= 0 && diff <= closest) {
      closestCommentRangeStart = node;
      closest = diff;
    }
  });
  const { marks: closestMarks = [] } = closestCommentRangeStart || {};
  const closestCommentMark = closestMarks.find((mark) => mark.type.name === CommentMarkName);
  return closestCommentMark?.attrs?.commentId || closestCommentMark?.attrs?.importedId;
};
const findTrackedMark = ({
  doc: doc2,
  from: from2,
  to,
  offset: offset2 = 1
  // To get non-inclusive marks.
}) => {
  const startPos = Math.max(from2 - offset2, 0);
  const endPos = Math.min(to + offset2, doc2.content.size);
  let markFound;
  doc2.nodesBetween(startPos, endPos, (node, pos) => {
    if (!node || node?.nodeSize === void 0) {
      return;
    }
    const mark = node.marks.find((mark2) => TRACK_CHANGE_MARKS.includes(mark2.type.name));
    if (mark && !markFound) {
      markFound = {
        from: pos,
        to: pos + node.nodeSize,
        mark
      };
    }
  });
  return markFound;
};
const handleTrackedChangeTransaction = (trackedChangeMeta, trackedChanges, newEditorState, editor) => {
  const { insertedMark, deletionMark, formatMark, deletionNodes } = trackedChangeMeta;
  if (!insertedMark && !deletionMark && !formatMark) {
    return;
  }
  const newTrackedChanges = { ...trackedChanges };
  let id = insertedMark?.attrs?.id || deletionMark?.attrs?.id || formatMark?.attrs?.id;
  if (!id) {
    return trackedChanges;
  }
  let isNewChange = false;
  if (!newTrackedChanges[id]) {
    newTrackedChanges[id] = {};
    isNewChange = true;
  }
  if (insertedMark) newTrackedChanges[id].insertion = id;
  if (deletionMark) newTrackedChanges[id].deletion = deletionMark.attrs?.id;
  if (formatMark) newTrackedChanges[id].format = formatMark.attrs?.id;
  const { step } = trackedChangeMeta;
  let nodes = step?.slice?.content?.content || [];
  if (!nodes.length) {
    newEditorState.doc.descendants((node) => {
      const hasFormatMark = node.marks.find((mark) => mark.type.name === TrackFormatMarkName);
      if (hasFormatMark) {
        nodes = [node];
        return false;
      }
    });
  }
  const emitParams = createOrUpdateTrackedChangeComment({
    documentId: editor.options.documentId,
    event: isNewChange ? "add" : "update",
    marks: {
      insertedMark,
      deletionMark,
      formatMark
    },
    deletionNodes,
    nodes,
    newEditorState
  });
  if (emitParams) editor.emit("commentsUpdate", emitParams);
  return newTrackedChanges;
};
const getTrackedChangeText = ({ state, node, mark, marks, trackedChangeType, isDeletionInsertion }) => {
  let trackedChangeText = "";
  let deletionText = "";
  if (trackedChangeType === TrackInsertMarkName) {
    trackedChangeText = node?.text ?? "";
  }
  if (trackedChangeType === TrackFormatMarkName) {
    trackedChangeText = translateFormatChangesToEnglish(mark.attrs);
  }
  if (trackedChangeType === TrackDeleteMarkName || isDeletionInsertion) {
    deletionText = node?.text ?? "";
    if (isDeletionInsertion) {
      let { id } = marks.deletionMark.attrs;
      let deletionNode = findNode$1(state.doc, (node2) => {
        const { marks: marks2 = [] } = node2;
        const changeMarks = marks2.filter((mark2) => TRACK_CHANGE_MARKS.includes(mark2.type.name));
        if (!changeMarks.length) return false;
        const hasMatchingId = changeMarks.find((mark2) => mark2.attrs.id === id);
        if (hasMatchingId) return true;
      });
      deletionText = deletionNode?.node.text ?? "";
    }
  }
  return {
    deletionText,
    trackedChangeText
  };
};
const createOrUpdateTrackedChangeComment = ({ event, marks, deletionNodes, nodes, newEditorState, documentId }) => {
  const trackedMark = marks.insertedMark || marks.deletionMark || marks.formatMark;
  const { type, attrs } = trackedMark;
  const { name: trackedChangeType } = type;
  const { author, authorEmail, date, importedAuthor } = attrs;
  const id = attrs.id;
  const node = nodes[0];
  const isDeletionInsertion = !!(marks.insertedMark && marks.deletionMark);
  let existingNode;
  newEditorState.doc.descendants((node2) => {
    const { marks: marks2 = [] } = node2;
    const changeMarks = marks2.filter((mark) => TRACK_CHANGE_MARKS.includes(mark.type.name));
    if (!changeMarks.length) return;
    const hasMatchingId = changeMarks.find((mark) => mark.attrs.id === id);
    if (hasMatchingId) existingNode = node2;
    if (existingNode) return false;
  });
  const { deletionText, trackedChangeText } = getTrackedChangeText({
    state: newEditorState,
    node: existingNode || node,
    mark: trackedMark,
    marks,
    trackedChangeType,
    isDeletionInsertion
  });
  if (!deletionText && !trackedChangeText) {
    return;
  }
  const params2 = {
    event: comments_module_events.ADD,
    type: "trackedChange",
    documentId,
    changeId: id,
    trackedChangeType: isDeletionInsertion ? "both" : trackedChangeType,
    trackedChangeText,
    deletedText: marks.deletionMark ? deletionText : null,
    author,
    authorEmail,
    date,
    ...importedAuthor && {
      importedAuthor: {
        name: importedAuthor
      }
    }
  };
  if (event === "add") params2.event = comments_module_events.ADD;
  else if (event === "update") params2.event = comments_module_events.UPDATE;
  return params2;
};
function findNode$1(node, predicate) {
  let found = null;
  node.descendants((node2, pos) => {
    if (predicate(node2)) found = { node: node2, pos };
    if (found) return false;
  });
  return found;
}
function findRangeById(doc2, id) {
  let from2 = null, to = null;
  doc2.descendants((node, pos) => {
    const trackedMark = node.marks.find((m) => TRACK_CHANGE_MARKS.includes(m.type.name) && m.attrs.id === id);
    if (trackedMark) {
      if (from2 === null || pos < from2) from2 = pos;
      if (to === null || pos + node.nodeSize > to) to = pos + node.nodeSize;
    }
    const commentMark = node.marks.find(
      (m) => m.type.name === CommentMarkName && (m.attrs.commentId === id || m.attrs.importedId === id)
    );
    if (commentMark) {
      if (from2 === null || pos < from2) from2 = pos;
      if (to === null || pos + node.nodeSize > to) to = pos + node.nodeSize;
    }
  });
  return from2 !== null && to !== null ? { from: from2, to } : null;
}
const replaceStep = ({ state, tr, step, newTr, map: map2, user, date, originalStep, originalStepIndex }) => {
  const deletionMarkSchema = state.schema.marks[TrackDeleteMarkName];
  const deletionMark = findMark(state, deletionMarkSchema, false);
  const positionTo = deletionMark ? deletionMark.to : step.to;
  const newStep = new ReplaceStep(
    positionTo,
    // We insert all the same steps, but with "from"/"to" both set to "to" in order not to delete content. Mapped as needed.
    positionTo,
    step.slice,
    step.structure
  );
  const invertStep = originalStep.invert(tr.docs[originalStepIndex]).map(map2);
  map2.appendMap(invertStep.getMap());
  const meta = {};
  if (newStep) {
    const trTemp = state.apply(newTr).tr;
    if (trTemp.maybeStep(newStep).failed) {
      return;
    }
    const mappedNewStepTo = newStep.getMap().map(newStep.to);
    const insertedMark = markInsertion({
      tr: trTemp,
      from: newStep.from,
      to: mappedNewStepTo,
      user,
      date
    });
    const condensedStep = new ReplaceStep(newStep.from, newStep.to, trTemp.doc.slice(newStep.from, mappedNewStepTo));
    newTr.step(condensedStep);
    const mirrorIndex = map2.maps.length - 1;
    map2.appendMap(condensedStep.getMap(), mirrorIndex);
    if (newStep.from !== mappedNewStepTo) {
      meta.insertedMark = insertedMark;
      meta.step = condensedStep;
    }
    if (!newTr.selection.eq(trTemp.selection)) {
      newTr.setSelection(trTemp.selection);
    }
  }
  if (step.from !== step.to) {
    const {
      deletionMark: deletionMark2,
      deletionMap,
      nodes: deletionNodes
    } = markDeletion({
      tr: newTr,
      from: step.from,
      to: step.to,
      user,
      date
    });
    meta.deletionNodes = deletionNodes;
    meta.deletionMark = deletionMark2;
    map2.appendMapping(deletionMap);
  }
  newTr.setMeta(TrackChangesBasePluginKey, meta);
  newTr.setMeta(CommentsPluginKey, { type: "force" });
};
const addMarkStep = ({ state, step, newTr, doc: doc2, user, date }) => {
  const meta = {};
  doc2.nodesBetween(step.from, step.to, (node, pos) => {
    if (!node.isInline) {
      return;
    }
    if (node.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
      return false;
    }
    const existingChangeMark = node.marks.find(
      (mark) => [TrackDeleteMarkName, TrackFormatMarkName].includes(mark.type.name)
    );
    const wid = existingChangeMark ? existingChangeMark.attrs.id : v4();
    newTr.addMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), step.mark);
    const allowedMarks = ["bold", "italic", "strike", "underline", "textStyle"];
    if (allowedMarks.includes(step.mark.type.name) && !node.marks.find((mark) => mark.type === step.mark.type)) {
      const formatChangeMark = node.marks.find((mark) => mark.type.name === TrackFormatMarkName);
      let after = [];
      let before = [];
      if (formatChangeMark) {
        let foundBefore = formatChangeMark.attrs.before.find((mark) => {
          if (mark.type === "textStyle") {
            return mark.type === step.mark.type.name && objectIncludes(mark.attrs, step.mark.attrs);
          }
          return mark.type === step.mark.type.name;
        });
        if (foundBefore) {
          before = [...formatChangeMark.attrs.before.filter((mark) => mark.type !== step.mark.type.name)];
          after = [...formatChangeMark.attrs.after];
        } else {
          before = [...formatChangeMark.attrs.before];
          after = [
            ...formatChangeMark.attrs.after,
            {
              type: step.mark.type.name,
              attrs: { ...step.mark.attrs }
            }
          ];
        }
      } else {
        before = node.marks.map((mark) => ({
          type: mark.type.name,
          attrs: { ...mark.attrs }
        }));
        after = [
          {
            type: step.mark.type.name,
            attrs: { ...step.mark.attrs }
          }
        ];
      }
      if (after.length || before.length) {
        const newFormatMark = state.schema.marks[TrackFormatMarkName].create({
          id: wid,
          author: user.name,
          authorEmail: user.email,
          date,
          before,
          after
        });
        newTr.addMark(
          step.from,
          // Math.max(step.from, pos)
          step.to,
          // Math.min(step.to, pos + node.nodeSize),
          newFormatMark
        );
        meta.formatMark = newFormatMark;
        meta.step = step;
        newTr.setMeta(TrackChangesBasePluginKey, meta);
        newTr.setMeta(CommentsPluginKey, { type: "force" });
      } else if (formatChangeMark) {
        newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), formatChangeMark);
      }
    }
  });
};
const removeMarkStep = ({ state, step, newTr, doc: doc2, user, date }) => {
  const meta = {};
  doc2.nodesBetween(step.from, step.to, (node, pos) => {
    if (!node.isInline) {
      return true;
    }
    if (node.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
      return false;
    }
    newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), step.mark);
    const allowedMarks = ["bold", "italic", "strike", "underline", "textStyle"];
    if (allowedMarks.includes(step.mark.type.name) && node.marks.find((mark) => mark.type === step.mark.type)) {
      const formatChangeMark = node.marks.find((mark) => mark.type.name === TrackFormatMarkName);
      let after = [];
      let before = [];
      if (formatChangeMark) {
        let foundAfter = formatChangeMark.attrs.after.find((mark) => mark.type === step.mark.type.name);
        if (foundAfter) {
          after = [...formatChangeMark.attrs.after.filter((mark) => mark.type !== step.mark.type.name)];
          before = [...formatChangeMark.attrs.before];
        } else {
          after = [...formatChangeMark.attrs.after];
          before = [
            ...formatChangeMark.attrs.before,
            {
              type: step.mark.type.name,
              attrs: { ...step.mark.attrs }
            }
          ];
        }
      } else {
        after = [];
        before = [
          {
            type: step.mark.type.name,
            attrs: { ...step.mark.attrs }
          }
        ];
      }
      if (after.length || before.length) {
        const newFormatMark = state.schema.marks[TrackFormatMarkName].create({
          id: v4(),
          author: user.name,
          authorEmail: user.email,
          date,
          before,
          after
        });
        newTr.addMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), newFormatMark);
        meta.formatMark = newFormatMark;
        meta.step = step;
        newTr.setMeta(TrackChangesBasePluginKey, meta);
        newTr.setMeta(CommentsPluginKey, { type: "force" });
      } else if (formatChangeMark) {
        newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node.nodeSize), formatChangeMark);
      }
    }
  });
};
const trackedTransaction = ({ tr, state, user }) => {
  const onlyInputTypeMeta = ["inputType", "uiEvent", "paste", "pointer"];
  const notAllowedMeta = ["historyUndo", "historyRedo", "acceptReject"];
  if (!tr.steps.length || tr.meta && !Object.keys(tr.meta).every((meta) => onlyInputTypeMeta.includes(meta)) || notAllowedMeta.includes(tr.getMeta("inputType")) || tr.getMeta(CommentsPluginKey)) {
    return tr;
  }
  const newTr = state.tr;
  const map2 = new Mapping();
  const fixedTimeTo10Mins = Math.floor(Date.now() / 6e5) * 6e5;
  const date = new Date(fixedTimeTo10Mins).toISOString();
  tr.steps.forEach((originalStep, originalStepIndex) => {
    const step = originalStep.map(map2);
    const { doc: doc2 } = newTr;
    if (!step) {
      return;
    }
    if (step instanceof ReplaceStep) {
      replaceStep({
        state,
        tr,
        step,
        newTr,
        map: map2,
        user,
        date,
        originalStep,
        originalStepIndex
      });
      console.debug("[track-changes]: replaceStep");
    } else if (step instanceof AddMarkStep) {
      addMarkStep({
        state,
        step,
        newTr,
        doc: doc2,
        user,
        date
      });
      console.debug("[track-changes]: addMarkStep");
    } else if (step instanceof RemoveMarkStep) {
      removeMarkStep({
        state,
        step,
        newTr,
        doc: doc2,
        user,
        date
      });
      console.debug("[track-changes]: removeMarkStep");
    } else {
      newTr.step(step);
      console.log("[track-changes]: otherStep");
    }
  });
  if (tr.getMeta("inputType")) {
    newTr.setMeta(tr.getMeta("inputType"));
  }
  if (tr.getMeta("uiEvent")) {
    newTr.setMeta(tr.getMeta("uiEvent"));
  }
  if (tr.selectionSet) {
    const deletionMarkSchema = state.schema.marks[TrackDeleteMarkName];
    const deletionMark = findMark(state, deletionMarkSchema, false);
    if (tr.selection instanceof TextSelection && (tr.selection.from < state.selection.from || tr.getMeta("inputType") === "deleteContentBackward")) {
      const caretPos = map2.map(tr.selection.from, -1);
      newTr.setSelection(new TextSelection(newTr.doc.resolve(caretPos)));
    } else if (tr.selection.from > state.selection.from && deletionMark) {
      const caretPos = map2.map(deletionMark.to + 1, 1);
      newTr.setSelection(new TextSelection(newTr.doc.resolve(caretPos)));
    } else {
      newTr.setSelection(tr.selection.map(newTr.doc, map2));
    }
  } else if (state.selection.from - tr.selection.from > 1 && tr.selection.$head.depth > 1) {
    const caretPos = map2.map(tr.selection.from - 2, -1);
    newTr.setSelection(new TextSelection(newTr.doc.resolve(caretPos)));
  } else ;
  if (tr.storedMarksSet) {
    newTr.setStoredMarks(tr.storedMarks);
  }
  if (tr.scrolledIntoView) {
    newTr.scrollIntoView();
  }
  return newTr;
};
const migration_after_0_4_14 = (editor) => {
  const { state } = editor;
  const { dispatch } = editor.view;
  const { tr } = state;
  if (!dispatch) return;
  state.doc.descendants((node, pos) => {
    if (node.type.name === "paragraph") {
      const { attrs } = node;
      const { spacing } = attrs;
      if (!spacing) return;
      const newSpacing = {
        line: twipsToLines(pixelsToTwips(spacing.line)),
        lineSpaceBefore: twipsToLines(pixelsToTwips(spacing.lineSpaceBefore)),
        lineSpaceAfter: twipsToLines(pixelsToTwips(spacing.lineSpaceAfter))
      };
      tr.setNodeMarkup(pos, void 0, {
        ...attrs,
        spacing: {
          ...spacing,
          ...newSpacing
        }
      });
    }
  });
  dispatch(tr);
  return true;
};
const DOCUMENT_MIGRATIONS = {
  initial: migration_after_0_4_14
};
const getNecessaryMigrations = (version2) => {
  if (version2 === "initial" || version2 === "0.4.14") return Object.values(DOCUMENT_MIGRATIONS);
};
const getFieldAttrs = (field, value, input) => {
  const { type } = field.attrs;
  const annotatorHandlers = {
    html: annotateHtml,
    text: annotateText,
    checkbox: annotateCheckbox,
    image: annotateImage,
    link: annotateLink,
    yesno: annotateYesNo,
    date: annotateDate
  };
  const handler = annotatorHandlers[type];
  if (!handler) return {};
  return handler(value, input);
};
const annotateHtml = (value) => ({ rawHtml: value });
const annotateText = (value) => ({ displayLabel: value });
const annotateImage = (value) => ({ imageSrc: value });
const annotateCheckbox = (value) => ({ displayLabel: value });
const annotateDate = (value, input) => {
  const formatted = getFormattedDate(value, input.input_format);
  return { displayLabel: formatted };
};
const annotateLink = (value) => {
  if (!value.startsWith("http")) value = `http://${value}`;
  return { linkUrl: value };
};
const annotateYesNo = (value) => {
  const yesNoValues = {
    YES: "Yes",
    NO: "No"
  };
  const parsedValue = yesNoValues[value[0].toUpperCase()];
  return { displayLabel: parsedValue };
};
const processTables = ({ state, tr, annotationValues }) => {
  const { doc: doc2 } = state;
  const tables = [];
  doc2.descendants((node, pos) => {
    if (node.type.name === "table") tables.push({ node, pos });
  });
  tables.reverse().forEach(({ pos }) => {
    const currentTableNode = tr.doc.nodeAt(pos);
    if (!currentTableNode || currentTableNode.type.name !== "table") return;
    try {
      generateTableIfNecessary({ tableNode: { node: currentTableNode, pos }, annotationValues, tr, state });
    } catch (error) {
      console.error("Error generating table at pos", pos, ":", error);
    }
  });
  return tr;
};
const generateTableIfNecessary = ({ tableNode, annotationValues, tr, state }) => {
  const {
    tableRow: RowType,
    tableCell: CellType,
    fieldAnnotation: FieldType,
    paragraph: ParaType
  } = state.schema.nodes;
  const rows = [];
  tableNode.node.descendants((node, pos) => {
    if (node.type === RowType) {
      rows.push({ node, pos });
    }
  });
  let rowNodeToGenerate = null;
  for (const row of rows) {
    let hasArrayAnnotation = false;
    row.node.descendants((node) => {
      if (node.type === FieldType) {
        const annotationValue = getAnnotationValue(node.attrs.fieldId, annotationValues);
        if (Array.isArray(annotationValue) && node.attrs.generatorIndex === null) {
          hasArrayAnnotation = true;
        }
      }
    });
    if (hasArrayAnnotation) {
      rowNodeToGenerate = row;
      break;
    }
  }
  if (!rowNodeToGenerate) return;
  const { node: rowNode, pos: rowStartPos } = rowNodeToGenerate;
  const absoluteRowStart = tableNode.pos + 1 + rowStartPos;
  let rowsToGenerate = 0;
  rowNode.descendants((childNode) => {
    if (childNode.type === FieldType) {
      const annotationValue = getAnnotationValue(childNode.attrs.fieldId, annotationValues);
      if (Array.isArray(annotationValue)) {
        rowsToGenerate = Math.max(rowsToGenerate, annotationValue.length);
      }
    }
  });
  if (rowsToGenerate <= 1) return;
  const validateAttributes = (attrs) => {
    const cleaned = {};
    for (const [key, value] of Object.entries(attrs)) {
      if (value !== void 0 && value !== null) {
        if (key === "displayLabel") {
          cleaned[key] = String(value);
        } else if (key === "rawHtml" || key === "linkUrl" || key === "imageSrc") {
          cleaned[key] = String(value);
        } else if (typeof value === "string" && value.length > 0) {
          cleaned[key] = value;
        } else if (typeof value !== "string") {
          cleaned[key] = value;
        }
      }
    }
    return cleaned;
  };
  const rebuildCell = (cellNode, rowIndex) => {
    try {
      const updatedBlocks = cellNode.content.content.map((blockNode) => {
        if (blockNode.type !== ParaType) return blockNode;
        const updatedInlines = blockNode.content.content.map((inlineNode) => {
          if (inlineNode.type !== FieldType) return inlineNode;
          let matchedAnnotationValues = getAnnotationValue(inlineNode.attrs.fieldId, annotationValues);
          if (!Array.isArray(matchedAnnotationValues)) {
            matchedAnnotationValues = [matchedAnnotationValues];
          }
          const value = matchedAnnotationValues[rowIndex];
          let extraAttrs = {};
          try {
            const rawExtraAttrs = getFieldAttrs(inlineNode, value, null);
            extraAttrs = validateAttributes(rawExtraAttrs || {});
          } catch (error) {
            console.error("Error getting field attrs:", error);
            extraAttrs = {};
          }
          const baseAttrs = validateAttributes(inlineNode.attrs || {});
          const newAttrs = {
            ...baseAttrs,
            ...extraAttrs,
            generatorIndex: rowIndex
          };
          try {
            return FieldType.create(newAttrs, inlineNode.content || Fragment.empty, inlineNode.marks || []);
          } catch (error) {
            console.error("Error creating field node:", error);
            try {
              const fallbackAttrs = {
                ...baseAttrs,
                generatorIndex: rowIndex,
                displayLabel: String(value || "")
              };
              return FieldType.create(
                validateAttributes(fallbackAttrs),
                inlineNode.content || Fragment.empty,
                inlineNode.marks || []
              );
            } catch (fallbackError) {
              console.error("Fallback also failed:", fallbackError);
              return inlineNode;
            }
          }
        });
        try {
          return ParaType.create(
            validateAttributes(blockNode.attrs || {}),
            Fragment.from(updatedInlines),
            blockNode.marks || []
          );
        } catch (error) {
          console.error("Error creating paragraph node:", error);
          return blockNode;
        }
      });
      return CellType.create(
        validateAttributes(cellNode.attrs || {}),
        Fragment.from(updatedBlocks),
        cellNode.marks || []
      );
    } catch (error) {
      console.error(`Failed to rebuild cell for row ${rowIndex}:`, error);
      throw error;
    }
  };
  try {
    const newRows = [];
    for (let rowIndex = 0; rowIndex < rowsToGenerate; rowIndex++) {
      const newCells = rowNode.content.content.map((cellNode) => rebuildCell(cellNode, rowIndex));
      const newRow = RowType.create(
        validateAttributes(rowNode.attrs || {}),
        Fragment.from(newCells),
        rowNode.marks || []
      );
      newRows.push(newRow);
    }
    const mappedRowStart = tr.mapping.map(absoluteRowStart);
    const rowEnd = mappedRowStart + rowNode.nodeSize;
    tr.replaceWith(mappedRowStart, rowEnd, Fragment.from(newRows));
  } catch (error) {
    console.error("Error during row generation:", error);
    throw error;
  }
};
const getAnnotationValue = (id, annotationValues) => {
  return annotationValues.find((value) => value.input_id === id)?.input_value || null;
};
const getAllHeaderFooterEditors = (editor) => {
  const sections = {
    header: editor.converter.headers || {},
    footer: editor.converter.footers || {}
  };
  const allEditors = [];
  Object.entries(sections).forEach(([type, items]) => {
    const editorsKey = `${type}Editors`;
    Object.entries(items).forEach(([sectionId, data]) => {
      let sectionEditor = editor.converter[editorsKey][sectionId];
      if (!sectionEditor) {
        sectionEditor = {
          id: sectionId,
          editor: createHeaderFooterEditor({
            editor,
            data,
            editorContainer: document.createElement("div"),
            appendToBody: false,
            sectionId,
            type
          })
        };
        editor.converter[editorsKey].push(sectionEditor);
        allEditors.push({
          ...sectionEditor,
          key: editorsKey,
          type,
          sectionId
        });
      }
    });
  });
  return allEditors;
};
const annotateHeadersAndFooters = ({
  editor,
  annotationValues = [],
  hiddenFieldIds = [],
  removeEmptyFields = false
}) => {
  const allEditors = getAllHeaderFooterEditors(editor);
  allEditors.forEach(({ sectionId, editor: sectionEditor, type }) => {
    sectionEditor.annotate(annotationValues, hiddenFieldIds, removeEmptyFields);
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type);
  });
};
const annotateDocument = ({
  annotationValues = [],
  hiddenFieldIds = [],
  removeEmptyFields = false,
  schema,
  tr,
  editor
}) => {
  annotateHeadersAndFooters({ editor, annotationValues, hiddenFieldIds, removeEmptyFields });
  const annotations = [];
  const FieldType = schema.nodes.fieldAnnotation;
  tr.doc.descendants((node, pos) => {
    if (node.type === FieldType) {
      annotations.push({ node, pos, size: node.nodeSize });
    }
  });
  const toDelete = /* @__PURE__ */ new Set();
  if (hiddenFieldIds.length) {
    for (const { node, pos } of annotations) {
      if (hiddenFieldIds.includes(node.attrs.fieldId)) {
        toDelete.add(pos);
      }
    }
  }
  for (const { node, pos } of annotations) {
    const { type, fieldType, fieldId } = node.attrs;
    if (toDelete.has(pos)) continue;
    let newValue = null;
    const input = annotationValues.find((i) => i.input_id === fieldId);
    if (!input) {
      const checkboxInputs = annotationValues.filter((i) => i.input_field_type === "CHECKBOXINPUT");
      inputsLoop: for (const cb of checkboxInputs) {
        for (const opt of cb.input_options) {
          if (opt.itemid === fieldId) {
            newValue = cb.input_link_value[opt.itemid] || " ";
            break inputsLoop;
          }
        }
      }
    }
    newValue = newValue || input?.input_value || null;
    if (Array.isArray(newValue) && node.attrs.generatorIndex != null) {
      continue;
    }
    if (type === "checkbox" || fieldType === "CHECKBOXINPUT") {
      const isEmptyOrSquare = !newValue || typeof newValue === "string" && newValue.codePointAt(0) === 9744;
      if (isEmptyOrSquare) newValue = " ";
    }
    if (!newValue) {
      toDelete.add(pos);
    } else {
      const attrs = getFieldAttrs(node, newValue, input);
      tr = tr.setNodeMarkup(pos, void 0, {
        ...node.attrs,
        ...attrs
      });
    }
  }
  if (removeEmptyFields) {
    Array.from(toDelete).sort((a, b) => b - a).forEach((pos) => {
      const ann = annotations.find((a) => a.pos === pos);
      if (!ann) return;
      tr = tr.delete(pos, pos + ann.node.nodeSize);
    });
  }
  return tr;
};
const getFormattedDate = (input = null, format = "") => {
  const date = input ? new Date(input) : /* @__PURE__ */ new Date();
  if (isNaN(date.getTime())) {
    return input;
  }
  if (format) return dateFormat(date, format);
  return date.toLocaleDateString("en-US", {
    month: "short",
    // e.g. May
    day: "2-digit",
    // e.g. 05
    year: "numeric"
    // e.g. 2025
  });
};
const updateHeaderFooterFieldAnnotations = ({ editor, fieldIdOrArray, attrs = {} }) => {
  if (!editor) return;
  const sectionEditors = getAllHeaderFooterEditors(editor);
  sectionEditors.forEach(({ editor: sectionEditor, sectionId, type }) => {
    sectionEditor.commands.updateFieldAnnotations(fieldIdOrArray, attrs);
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type);
  });
};
const deleteHeaderFooterFieldAnnotations = ({ editor, fieldIdOrArray }) => {
  if (!editor) return;
  const sectionEditors = getAllHeaderFooterEditors(editor);
  sectionEditors.forEach(({ editor: sectionEditor, sectionId, type }) => {
    sectionEditor.commands.deleteFieldAnnotations(fieldIdOrArray);
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type);
  });
};
const resetHeaderFooterFieldAnnotations = ({ editor }) => {
  if (!editor) return;
  const sectionEditors = getAllHeaderFooterEditors(editor);
  sectionEditors.forEach(({ editor: sectionEditor, sectionId, type }) => {
    sectionEditor.commands.resetFieldAnnotations();
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type);
  });
};
const AnnotatorHelpers = {
  getFieldAttrs,
  processTables,
  annotateDocument,
  annotateHeadersAndFooters,
  getAllHeaderFooterEditors,
  updateHeaderFooterFieldAnnotations,
  deleteHeaderFooterFieldAnnotations,
  resetHeaderFooterFieldAnnotations
};
const CollaborationPluginKey = new PluginKey("collaboration");
const Collaboration = Extension.create({
  name: "collaboration",
  priority: 1e3,
  addOptions() {
    return {
      ydoc: null,
      field: "supereditor",
      fragment: null,
      isReady: false
    };
  },
  addPmPlugins() {
    if (!this.editor.options.ydoc) return [];
    this.options.ydoc = this.editor.options.ydoc;
    const undoPlugin = createUndoPlugin();
    initSyncListener(this.options.ydoc, this.editor, this);
    initDocumentListener({ ydoc: this.options.ydoc, editor: this.editor });
    const [syncPlugin, fragment] = createSyncPlugin(this.options.ydoc, this.editor);
    this.options.fragment = fragment;
    const metaMap = this.options.ydoc.getMap("media");
    metaMap.observe((event) => {
      event.changes.keys.forEach((_, key) => {
        if (!(key in this.editor.storage.image.media)) {
          const fileData = metaMap.get(key);
          this.editor.storage.image.media[key] = fileData;
        }
      });
    });
    return [syncPlugin, undoPlugin];
  },
  addCommands() {
    return {
      undo: () => ({ tr, state, dispatch }) => {
        tr.setMeta("preventDispatch", true);
        tr.setMeta("inputType", "historyUndo");
        const undoManager = yUndoPluginKey.getState(state).undoManager;
        if (undoManager.undoStack.length === 0) return false;
        if (!dispatch) return true;
        return undo(state);
      },
      redo: () => ({ tr, state, dispatch }) => {
        tr.setMeta("preventDispatch", true);
        tr.setMeta("inputType", "historyRedo");
        const undoManager = yUndoPluginKey.getState(state).undoManager;
        if (undoManager.redoStack.length === 0) return false;
        if (!dispatch) return true;
        return redo(state);
      },
      addImageToCollaboration: ({ mediaPath, fileData }) => () => {
        if (!this.options.ydoc) return;
        const mediaMap = this.options.ydoc.getMap("media");
        mediaMap.set(mediaPath, fileData);
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-Shift-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo()
    };
  }
});
const createSyncPlugin = (ydoc, editor) => {
  const fragment = ydoc.getXmlFragment("supereditor");
  const onFirstRender = () => {
    if (!editor.options.isNewFile) return;
    initializeMetaMap(ydoc, editor);
  };
  return [ySyncPlugin(fragment, { onFirstRender }), fragment];
};
const initializeMetaMap = (ydoc, editor) => {
  const metaMap = ydoc.getMap("meta");
  metaMap.set("docx", editor.options.content);
  metaMap.set("fonts", editor.options.fonts);
  const mediaMap = ydoc.getMap("media");
  Object.entries(editor.options.mediaFiles).forEach(([key, value]) => {
    mediaMap.set(key, value);
  });
};
const createUndoPlugin = () => {
  const yUndoPluginInstance = yUndoPlugin();
  return yUndoPluginInstance;
};
const checkDocxChanged = (transaction) => {
  if (!transaction.changed) return false;
  for (const [, value] of transaction.changed.entries()) {
    if (value instanceof Set && value.has("docx")) {
      return true;
    }
  }
  return false;
};
const initDocumentListener = ({ ydoc, editor }) => {
  const debouncedUpdate = debounce$2((editor2) => {
    updateYdocDocxData(editor2);
  }, 1e3);
  ydoc.on("afterTransaction", (transaction) => {
    const { local } = transaction;
    const hasChangedDocx = checkDocxChanged(transaction);
    if (!hasChangedDocx && transaction.changed?.size && local) {
      debouncedUpdate(editor);
    }
  });
};
const debounce$2 = (fn2, wait) => {
  let timeout2 = null;
  return (...args) => {
    clearTimeout(timeout2);
    timeout2 = setTimeout(() => fn2.apply(void 0, args), wait);
  };
};
const initSyncListener = (ydoc, editor, extension) => {
  const provider = editor.options.collaborationProvider;
  if (!provider) return;
  const emit = () => {
    extension.options.isReady = true;
    provider.off("synced", emit);
    editor.emit("collaborationReady", { editor, ydoc });
  };
  if (provider.synced) {
    setTimeout(() => {
      emit();
    }, 250);
    return;
  }
  provider.on("synced", emit);
};
const generateCollaborationData = async (editor) => {
  const ydoc = prosemirrorToYDoc(editor.state.doc, "supereditor");
  initializeMetaMap(ydoc, editor);
  await updateYdocDocxData(editor, ydoc);
  return encodeStateAsUpdate(ydoc);
};
const isHighContrastMode = ref(false);
function useHighContrastMode() {
  const setHighContrastMode = (value) => {
    isHighContrastMode.value = value;
  };
  return {
    isHighContrastMode,
    setHighContrastMode
  };
}
const findWordBounds = (doc2, pos) => {
  const $pos = doc2.resolve(pos);
  const parent = $pos.parent;
  const offsetInParent = $pos.parentOffset;
  let offset2 = 0;
  let targetNode = null;
  let nodeStart = 0;
  parent.forEach((child, childOffset) => {
    if (child.isText) {
      const start2 = offset2;
      const end2 = offset2 + child.nodeSize;
      if (start2 <= offsetInParent && offsetInParent <= end2) {
        targetNode = child;
        nodeStart = childOffset;
      }
      offset2 = end2;
    } else {
      offset2 += child.nodeSize;
    }
  });
  if (!targetNode) return;
  const text = targetNode.text;
  const cursorOffset = offsetInParent - nodeStart;
  const isWordChar = (ch) => /\w/.test(ch);
  const isPunctOrSpace = (ch) => /[.,;:!-?=()[\]{}"'\s]/.test(ch);
  let from2, to;
  if (isPunctOrSpace(text[cursorOffset])) {
    from2 = $pos.start() + nodeStart + cursorOffset;
    to = from2 + 1;
  } else {
    let start2 = cursorOffset;
    while (start2 > 0 && isWordChar(text[start2 - 1])) start2--;
    let end2 = cursorOffset;
    while (end2 < text.length && isWordChar(text[end2])) end2++;
    if (start2 === end2) return;
    from2 = $pos.start() + nodeStart + start2;
    to = $pos.start() + nodeStart + end2;
  }
  return { from: from2, to };
};
const setWordSelection = (view, pos) => {
  const { state, dispatch } = view;
  const word = findWordBounds(state.doc, pos);
  if (!word) return;
  const tr = state.tr.setSelection(TextSelection.create(state.doc, word.from, word.to));
  dispatch(tr);
};
const setImageNodeSelection = (view, pos) => {
  const { doc: doc2 } = view.state;
  const node = doc2.nodeAt(pos);
  if (node && node.type.name === "image") {
    const tr = view.state.tr.setSelection(NodeSelection.create(doc2, pos));
    view.dispatch(tr);
    return true;
  }
  return false;
};
const { findChildren: findChildren$3 } = helpers;
function getAllFieldAnnotations(state) {
  let fieldAnnotations = findChildren$3(state.doc, (node) => node.type.name === "fieldAnnotation");
  return fieldAnnotations;
}
function getAllFieldAnnotationsWithRect(view, state) {
  let fieldAnnotations = getAllFieldAnnotations(state).map(({ node, pos }) => {
    let rect = posToDOMRect(view, pos, pos + node.nodeSize);
    return {
      node,
      pos,
      rect
    };
  });
  return fieldAnnotations;
}
function findFieldAnnotations(predicate, state) {
  let allFieldAnnotations = getAllFieldAnnotations(state);
  let fieldAnnotations = [];
  allFieldAnnotations.forEach((annotation) => {
    if (predicate(annotation.node)) {
      fieldAnnotations.push(annotation);
    }
  });
  return fieldAnnotations;
}
const { findChildren: findChildren$2 } = helpers;
function findFieldAnnotationsByFieldId(fieldIdOrArray, state) {
  let fieldAnnotations = findChildren$2(state.doc, (node) => {
    let isFieldAnnotation = node.type.name === "fieldAnnotation";
    if (Array.isArray(fieldIdOrArray)) {
      return isFieldAnnotation && fieldIdOrArray.includes(node.attrs.fieldId);
    } else {
      return isFieldAnnotation && node.attrs.fieldId === fieldIdOrArray;
    }
  });
  return fieldAnnotations;
}
function findFirstFieldAnnotationByFieldId(fieldId, state) {
  let fieldAnnotation = findNode(state.doc, (node) => {
    return node.type.name === "fieldAnnotation" && node.attrs.fieldId === fieldId;
  });
  return fieldAnnotation;
}
function findNode(node, predicate) {
  let found = null;
  node.descendants((node2, pos) => {
    if (predicate(node2)) found = { node: node2, pos };
    if (found) return false;
  });
  return found;
}
function findFieldAnnotationsBetween(from2, to, doc2) {
  let fieldAnnotations = [];
  doc2.nodesBetween(from2, to, (node, pos) => {
    if (!node || node?.nodeSize === void 0) {
      return;
    }
    if (node.type.name === "fieldAnnotation") {
      fieldAnnotations.push({
        node,
        pos
      });
    }
  });
  return fieldAnnotations;
}
function findRemovedFieldAnnotations(tr) {
  let removedNodes = [];
  if (!tr.steps.length || tr.meta && !Object.keys(tr.meta).every((meta) => ["inputType", "uiEvent", "paste"].includes(meta)) || ["historyUndo", "historyRedo"].includes(tr.getMeta("inputType")) || ["drop"].includes(tr.getMeta("uiEvent")) || tr.getMeta("fieldAnnotationUpdate") === true) {
    return removedNodes;
  }
  const hasDeletion = transactionDeletedAnything(tr);
  if (!hasDeletion) return removedNodes;
  tr.steps.forEach((step, stepIndex) => {
    if (step instanceof ReplaceStep && step.from !== step.to) {
      let mapping = tr.mapping.maps[stepIndex];
      let originalDoc = tr.before;
      originalDoc.nodesBetween(step.from, step.to, (node, pos) => {
        if (node.type.name === "fieldAnnotation") {
          let mappedPos = mapping.mapResult(pos);
          if (mappedPos.deleted) {
            removedNodes.push({ node, pos });
          }
        }
      });
    }
  });
  return removedNodes;
}
function transactionDeletedAnything(tr) {
  return tr.steps.some((step) => {
    if (step instanceof ReplaceStep || step instanceof ReplaceAroundStep) {
      return step.from !== step.to;
    }
    return false;
  });
}
function trackFieldAnnotationsDeletion(editor, tr) {
  let removedAnnotations = [];
  try {
    removedAnnotations = findRemovedFieldAnnotations(tr);
  } catch {
  }
  if (removedAnnotations.length > 0) {
    setTimeout(() => {
      editor.emit("fieldAnnotationDeleted", {
        editor,
        removedNodes: removedAnnotations
      });
    }, 0);
  }
}
const getHeaderFooterAnnotations = (editor) => {
  const editors = getAllHeaderFooterEditors(editor);
  const allAnnotations = [];
  editors.forEach(({ editor: editor2 }) => {
    const annotations = getAllFieldAnnotations(editor2.state);
    allAnnotations.push(...annotations);
  });
  return allAnnotations;
};
const { findChildren: findChildren$1 } = helpers;
function findHeaderFooterAnnotationsByFieldId(fieldIdOrArray, editor, activeSectionEditor) {
  const sectionEditors = getAllHeaderFooterEditors(editor);
  const annotations = [];
  sectionEditors.forEach(({ editor: sectionEditor }) => {
    const state = activeSectionEditor.options.documentId === sectionEditor.options.documentId ? activeSectionEditor.state : sectionEditor.state;
    const fieldAnnotations = findChildren$1(state.doc, (node) => {
      let isFieldAnnotation = node.type.name === "fieldAnnotation";
      if (Array.isArray(fieldIdOrArray)) {
        return isFieldAnnotation && fieldIdOrArray.includes(node.attrs.fieldId);
      } else {
        return isFieldAnnotation && node.attrs.fieldId === fieldIdOrArray;
      }
    });
    annotations.push(...fieldAnnotations);
  });
  return annotations;
}
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  findFieldAnnotations,
  findFieldAnnotationsBetween,
  findFieldAnnotationsByFieldId,
  findFirstFieldAnnotationByFieldId,
  findHeaderFooterAnnotationsByFieldId,
  findRemovedFieldAnnotations,
  getAllFieldAnnotations,
  getAllFieldAnnotationsWithRect,
  getHeaderFooterAnnotations,
  trackFieldAnnotationsDeletion
}, Symbol.toStringTag, { value: "Module" }));
const migrateListsToV2IfNecessary = (editor) => {
  const replacements = [];
  const numbering = editor.converter.numbering;
  if (!numbering) return replacements;
  const { state } = editor;
  const { doc: doc2 } = state;
  const { dispatch } = editor.view;
  const LIST_TYPES = ["orderedList", "bulletList"];
  let lastListEndPos = 0;
  doc2.descendants((node, pos) => {
    if (!LIST_TYPES.includes(node.type.name)) return;
    if (pos < lastListEndPos) return;
    const extracted = flattenListCompletely(node, editor, 0);
    if (extracted.length > 0) {
      replacements.push({
        from: pos,
        to: pos + node.nodeSize,
        listNode: node,
        replacement: extracted
      });
    }
    lastListEndPos = pos + node.nodeSize;
  });
  let tr = state.tr;
  if (replacements.length > 0) {
    for (let i = replacements.length - 1; i >= 0; i--) {
      const { from: from2, to, replacement, listNode } = replacements[i];
      const nodesToInsert = [];
      for (const item of replacement) {
        if (item.node.type.name === "listItem") {
          const singleItemList = listNode.type.create(listNode.attrs, [item.node]);
          nodesToInsert.push(singleItemList);
        } else {
          nodesToInsert.push(item.node);
        }
      }
      tr = tr.replaceWith(from2, to, nodesToInsert);
    }
  }
  tr.setMeta("listsv2migration", replacements);
  editor.options.migrated = true;
  dispatch(tr);
  return replacements;
};
function flattenListCompletely(listNode, editor, baseLevel = 0, sharedNumId = null) {
  const result = [];
  const listTypes = ["orderedList", "bulletList"];
  const currentListType = listNode.type.name;
  const needsMigration = shouldMigrateList(listNode);
  const hasValidDefinition = checkValidDefinition(listNode, editor);
  if (!needsMigration) {
    if (!hasValidDefinition) {
      return generateMissingListDefinition(listNode, editor);
    } else {
      return result;
    }
  }
  let numId = parseInt(listNode.attrs?.listId);
  if (!numId || Number.isNaN(numId)) numId = ListHelpers.getNewListId(editor);
  const listHasDef = ListHelpers.getListDefinitionDetails({ numId, level: baseLevel, editor });
  if (!listHasDef || !sharedNumId && !numId) {
    numId = ListHelpers.getNewListId(editor);
    ListHelpers.generateNewListDefinition({
      numId,
      listType: currentListType,
      editor
    });
  }
  if (!sharedNumId) sharedNumId = numId;
  for (const listItem of listNode.content.content) {
    if (!listItem.content.content?.length) {
      result.push({ node: listItem, baseLevel });
    } else if (listItem.content.content.length === 1) {
      const contentNode = listItem.content.content[0];
      if (listTypes.includes(contentNode.type.name)) {
        const flattened = flattenListCompletely(contentNode, editor, baseLevel + 1, sharedNumId);
        result.push(...flattened);
      } else {
        const newList = ListHelpers.createSchemaOrderedListNode({
          level: baseLevel,
          numId: sharedNumId,
          listType: listNode.type.name,
          editor,
          contentNode: contentNode.toJSON(),
          listLevel: listItem.attrs.listLevel || [1]
        });
        result.push({ node: newList, baseLevel });
      }
    } else {
      const firstItem = listItem.content.content[0];
      if (listTypes.includes(firstItem.type.name)) {
        const flattened = flattenListCompletely(firstItem, editor, baseLevel + 1, sharedNumId);
        result.push(...flattened);
      } else {
        if (firstItem.type.name === "paragraph" || firstItem.isTextblock) {
          const newList = ListHelpers.createSchemaOrderedListNode({
            level: baseLevel,
            numId: sharedNumId,
            listType: listNode.type.name,
            editor,
            contentNode: firstItem.toJSON(),
            listLevel: listItem.attrs.listLevel || [1]
          });
          result.push({ node: newList, baseLevel });
        } else {
          result.push({ node: firstItem });
        }
      }
      for (let contentItem of listItem.content.content.slice(1)) {
        if (listTypes.includes(contentItem.type.name)) {
          const flattened = flattenListCompletely(contentItem, editor, baseLevel + 1, sharedNumId);
          result.push(...flattened);
        } else {
          result.push({ node: contentItem });
        }
      }
    }
  }
  return result;
}
const shouldMigrateList = (listItem) => {
  const content = listItem.content;
  if (content?.content?.length > 1) {
    return true;
  }
  const firstChild = content.firstChild;
  if (firstChild && firstChild.type.name === "listItem") {
    const { attrs } = firstChild;
    const { level, listNumberingType } = attrs || {};
    if (typeof level === "undefined" || !listNumberingType) {
      return true;
    }
    const childContent = firstChild?.content?.content;
    const nestedLists = childContent.filter((child) => ["bulletList", "orderedList"].includes(child.type.name));
    return nestedLists.length > 0;
  }
  return false;
};
const checkValidDefinition = (listNode, editor) => {
  const listType = listNode.type.name;
  const listItem = listNode.content.firstChild;
  const { attrs } = listItem;
  const { numId, level } = attrs || {};
  const listDef = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  const { abstract } = listDef || {};
  if (abstract) return true;
  return false;
};
const generateMissingListDefinition = (listNode, editor) => {
  const listType = listNode.type.name;
  const listItem = listNode.content.firstChild;
  const { attrs } = listItem;
  const { numId } = attrs || {};
  return ListHelpers.generateNewListDefinition({
    numId,
    listType,
    editor
  });
};
const migrateParagraphFieldsListsV2 = async (annotationValues = [], editor) => {
  const annotations = getAllFieldAnnotations(editor.state);
  const newValues = [];
  if (!annotations.length) {
    return annotationValues;
  }
  for (const annotation of annotations) {
    const type = annotation.node?.attrs?.type;
    const matchedAnnotation = annotationValues.find((v) => v.input_id === annotation.node.attrs.fieldId);
    if (!!matchedAnnotation && (!type || type !== "html")) {
      newValues.push(matchedAnnotation);
      continue;
    }
    const value = matchedAnnotation?.input_value;
    if (!value) continue;
    await new Promise((resolve, reject) => {
      const element = document.createElement("div");
      editor.createChildEditor({
        element,
        html: value,
        onCreate: ({ editor: localEditor }) => {
          const { migrated } = localEditor.options;
          if (migrated) {
            const newHTML = localEditor.getHTML();
            matchedAnnotation.input_value = newHTML;
            newValues.push(matchedAnnotation);
          }
          resolve();
        },
        onError: (error) => {
          reject(error);
        }
      });
    });
  }
  return newValues;
};
const createLinkedChildEditor = (currentEditor, options = {}) => {
  if (currentEditor.options.isChildEditor) {
    return null;
  }
  const editor = new Editor({
    ...currentEditor.options,
    pagination: false,
    suppressDefaultDocxStyles: true,
    ydoc: null,
    collaborationProvider: null,
    fileSource: null,
    initialState: null,
    documentId: null,
    isCommentsEnabled: false,
    isNewFile: false,
    fragment: false,
    onCreate: () => null,
    onListDefinitionsChange: linkListDefinitionsChange,
    // Options overrides
    ...options,
    isChildEditor: true,
    parentEditor: currentEditor
  });
  return editor;
};
const linkListDefinitionsChange = (options) => {
  const { editor, numbering } = options;
  const { parentEditor = {} } = editor.options;
  const { converter: parentConverter } = parentEditor;
  if (!parentConverter) return;
  parentConverter.numbering = numbering;
  const { tr } = parentEditor.state;
  const { dispatch } = parentEditor.view;
  tr.setMeta("updatedListItemNodeViews", true);
  dispatch(tr);
};
function createLogger(debug, additionalPrefixes = []) {
  const basePrefix = "[SuperValidator]";
  const style = "color: teal; font-weight: bold;";
  const allPrefixes = [basePrefix, ...additionalPrefixes.map((p) => `[${p}]`)];
  const format = allPrefixes.map(() => "%c%s").join(" ");
  const styledPrefixes = allPrefixes.map((p) => [style, p]).flat();
  return {
    debug: (...args) => {
      if (!debug) return;
      console.debug(format, ...styledPrefixes, ...args);
    },
    withPrefix: (prefix) => createLogger(debug, [...additionalPrefixes, prefix])
  };
}
function ensureValidImageRID(images, editor, tr, logger) {
  let modified = false;
  const results = [];
  images.forEach(({ node, pos }) => {
    const { rId, src } = node.attrs;
    if (!rId && src) {
      let newId = editor.converter.docxHelpers.findRelationshipIdFromTarget(src, editor);
      if (newId) logger.debug("Reusing existing rId for image:", newId, "at pos:", pos);
      if (!newId) {
        newId = editor.converter.docxHelpers.insertNewRelationship(src, "image", editor);
        logger.debug("Creating new rId for image at pos:", pos, "with src:", src);
      }
      tr.setNodeMarkup(pos, void 0, {
        ...node.attrs,
        rId: newId
      });
      results.push(`Added missing rId to image at pos ${pos}`);
      modified = true;
    }
  });
  return { modified, results };
}
function createImageNodeValidator({ editor, logger }) {
  const validator = (tr, analysis) => {
    const images = analysis.image || [];
    const ruleResults = [ensureValidImageRID(images, editor, tr, logger)];
    const modified = ruleResults.some((r2) => r2.modified);
    const results = ruleResults.flatMap((r2) => r2.results);
    return { modified, results };
  };
  validator.requiredElements = {
    nodes: ["image"]
  };
  return validator;
}
function ensureValidLinkRID(links, editor, tr, logger) {
  let modified = false;
  const results = [];
  links.forEach(({ mark, from: from2, to }) => {
    const { rId, href } = mark.attrs;
    if (!rId && href) {
      let newId = editor.converter.docxHelpers.findRelationshipIdFromTarget(href, editor);
      if (newId) logger.debug("Reusing existing rId for link:", newId, "from pos:", from2, "to pos:", to);
      if (!newId) {
        newId = editor.converter.docxHelpers.insertNewRelationship(href, "hyperlink", editor);
        logger.debug("Creating new rId for link from pos:", from2, "to pos:", to, "with href:", href);
      }
      if (newId) {
        const linkMarkType = editor.schema.marks.link;
        const newMark = linkMarkType.create({
          ...mark.attrs,
          rId: newId
        });
        tr.removeMark(from2, to, linkMarkType);
        tr.addMark(from2, to, newMark);
        results.push(`Added missing rId to link from pos ${from2} to ${to}`);
        modified = true;
      }
    }
  });
  return { modified, results };
}
function createLinkMarkValidator({ editor, logger }) {
  const validator = (tr, analysis) => {
    const links = analysis.link || [];
    const ruleResults = [ensureValidLinkRID(links, editor, tr, logger)];
    const modified = ruleResults.some((r2) => r2.modified);
    const results = ruleResults.flatMap((r2) => r2.results);
    return { modified, results };
  };
  validator.requiredElements = {
    marks: ["link"]
  };
  return validator;
}
const StateValidators = {
  imageNodeValidator: createImageNodeValidator,
  linkMarkValidator: createLinkMarkValidator
};
class SuperValidator {
  /**
   * Create a SuperValidator instance.
   * @param {SuperValidatorOptions} options - Options for the validator.
   */
  constructor(options) {
    __privateAdd(this, _SuperValidator_instances);
    /** @type {Editor} */
    __privateAdd(this, _editor);
    /** @type {any} */
    __privateAdd(this, _stateValidators);
    /** @type {Set<string>} */
    __privateAdd(this, _requiredNodeTypes);
    /** @type {Set<string>} */
    __privateAdd(this, _requiredMarkTypes);
    __privateSet(this, _editor, options.editor);
    this.dryRun = options.dryRun || false;
    this.debug = options.debug || false;
    this.logger = createLogger(this.debug);
    const { validators, nodeTypes, markTypes } = __privateMethod(this, _SuperValidator_instances, initializeValidators_fn).call(this);
    __privateSet(this, _stateValidators, validators);
    __privateSet(this, _requiredNodeTypes, nodeTypes);
    __privateSet(this, _requiredMarkTypes, markTypes);
  }
  /**
   * Validate the active document in the editor. Triggered automatically on editor initialization.
   * @returns {{ modified: boolean, results: Array<{ key: string, results: string[] }> }}
   */
  validateActiveDocument() {
    const { tr } = __privateGet(this, _editor).state;
    const { dispatch } = __privateGet(this, _editor).view;
    const documentAnalysis = __privateMethod(this, _SuperValidator_instances, analyzeDocument_fn).call(this);
    this.logger.debug("Document analysis:", documentAnalysis);
    let hasModifiedDocument = false;
    const validationResults = [];
    Object.entries(__privateGet(this, _stateValidators)).forEach(([key, validator]) => {
      this.logger.debug(` Validating with ${key}...`);
      const { results, modified } = validator(tr, documentAnalysis);
      validationResults.push({ key, results });
      hasModifiedDocument = hasModifiedDocument || modified;
    });
    if (!this.dryRun) dispatch(tr);
    else this.logger.debug("DRY RUN: No changes applied to the document.");
    this.logger.debug("Results:", validationResults);
    return { modified: hasModifiedDocument, results: validationResults };
  }
}
_editor = new WeakMap();
_stateValidators = new WeakMap();
_requiredNodeTypes = new WeakMap();
_requiredMarkTypes = new WeakMap();
_SuperValidator_instances = new WeakSet();
/**
 * Initialize all validators and collect their element requirements
 * @returns {{ validators: Record<string, ValidatorFunction>, nodeTypes: Set<string>, markTypes: Set<string> }}
 */
initializeValidators_fn = function() {
  const requiredNodes = /* @__PURE__ */ new Set();
  const requiredMarks = /* @__PURE__ */ new Set();
  const validators = Object.fromEntries(
    Object.entries(StateValidators).map(([key, factory]) => {
      const validatorLogger = this.logger.withPrefix(key);
      const validator = factory({ editor: __privateGet(this, _editor), logger: validatorLogger });
      __privateMethod(this, _SuperValidator_instances, collectValidatorRequirements_fn).call(this, validator, requiredNodes, requiredMarks);
      return [key, validator];
    })
  );
  return {
    validators,
    nodeTypes: requiredNodes,
    markTypes: requiredMarks
  };
};
/**
 * Extract and collect requirements from a validator
 * @param {ValidatorFunction} validator
 * @param {Set<string>} requiredNodes
 * @param {Set<string>} requiredMarks
 */
collectValidatorRequirements_fn = function(validator, requiredNodes, requiredMarks) {
  if (!validator.requiredElements) return;
  if (typeof validator.requiredElements === "object") {
    if (validator.requiredElements.nodes) {
      validator.requiredElements.nodes.forEach((nodeType) => {
        requiredNodes.add(nodeType);
      });
    }
    if (validator.requiredElements.marks) {
      validator.requiredElements.marks.forEach((markType) => {
        requiredMarks.add(markType);
      });
    }
  }
};
/**
 * Analyze the document to collect all required elements
 * @returns {DocumentAnalysis}
 */
analyzeDocument_fn = function() {
  const { doc: doc2 } = __privateGet(this, _editor).state;
  const analysis = {};
  __privateGet(this, _requiredNodeTypes).forEach((type) => analysis[type] = []);
  __privateGet(this, _requiredMarkTypes).forEach((type) => analysis[type] = []);
  const collectElements = (node, pos) => {
    if (__privateGet(this, _requiredNodeTypes).has(node.type.name)) {
      analysis[node.type.name].push({ node, pos });
    }
    if (node.isText && node.marks) {
      node.marks.forEach(
        /** @param {Mark} mark */
        (mark) => {
          if (__privateGet(this, _requiredMarkTypes).has(mark.type.name)) {
            analysis[mark.type.name].push({
              mark,
              node,
              pos,
              from: pos,
              to: pos + node.nodeSize
            });
          }
        }
      );
    }
  };
  doc2.descendants(collectElements);
  return analysis;
};
const _Editor = class _Editor extends EventEmitter {
  /**
   * Create a new Editor instance
   * @param {EditorOptions} options - Editor configuration options
   * @returns {void}
   */
  constructor(options) {
    super();
    __privateAdd(this, _Editor_instances);
    /**
     * Command service for handling editor commands
     * @type {CommandService}
     */
    __privateAdd(this, _commandService);
    /**
     * Service for managing extensions
     * @type {Object}
     */
    __publicField(this, "extensionService");
    /**
     * Storage for extension data
     * @type {Object}
     */
    __publicField(this, "extensionStorage", {});
    /**
     * ProseMirror schema for the editor
     * @type {Object}
     */
    __publicField(this, "schema");
    /**
     * ProseMirror view instance
     * @type {Object}
     */
    __publicField(this, "view");
    /**
     * Whether the editor currently has focus
     * @type {boolean}
     */
    __publicField(this, "isFocused", false);
    __publicField(this, "options", {
      element: null,
      selector: null,
      isHeadless: false,
      mockDocument: null,
      mockWindow: null,
      content: "",
      // XML content
      user: null,
      users: [],
      media: {},
      mediaFiles: {},
      fonts: {},
      documentMode: "editing",
      mode: "docx",
      role: "editor",
      colors: [],
      converter: null,
      fileSource: null,
      initialState: null,
      documentId: null,
      extensions: [],
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      isCommentsEnabled: false,
      isNewFile: false,
      scale: 1,
      annotations: false,
      isInternal: false,
      externalExtensions: [],
      numbering: {},
      isHeaderOrFooter: false,
      lastSelection: null,
      suppressDefaultDocxStyles: false,
      jsonOverride: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onTrackedChangesUpdate: () => null,
      onCommentsUpdate: () => null,
      onCommentsLoaded: () => null,
      onCommentClicked: () => null,
      onCommentLocationsUpdate: () => null,
      onDocumentLocked: () => null,
      onFirstRender: () => null,
      onCollaborationReady: () => null,
      onPaginationUpdate: () => null,
      onException: () => null,
      onListDefinitionsChange: () => null,
      // async (file) => url;
      handleImageUpload: null,
      // telemetry
      telemetry: null,
      // Docx xml updated by User
      customUpdatedFiles: {},
      isHeaderFooterChanged: false,
      isCustomXmlChanged: false,
      focusTarget: null
    });
    __privateMethod(this, _Editor_instances, initContainerElement_fn).call(this, options);
    __privateMethod(this, _Editor_instances, checkHeadless_fn).call(this, options);
    this.setOptions(options);
    let modes = {
      docx: () => __privateMethod(this, _Editor_instances, init_fn).call(this),
      text: () => __privateMethod(this, _Editor_instances, initRichText_fn).call(this),
      html: () => __privateMethod(this, _Editor_instances, initRichText_fn).call(this),
      default: () => {
        console.log("Not implemented.");
      }
    };
    let initMode = modes[this.options.mode] ?? modes.default;
    const { setHighContrastMode } = useHighContrastMode();
    this.setHighContrastMode = setHighContrastMode;
    initMode();
  }
  /**
   * Getter which indicates if any changes happen in Editor
   * @returns {boolean}
   */
  get docChanged() {
    return this.options.isHeaderFooterChanged || this.options.isCustomXmlChanged || !this.options.initialState.doc.eq(this.state.doc);
  }
  mount(el) {
    __privateMethod(this, _Editor_instances, createView_fn).call(this, el);
    window.setTimeout(() => {
      if (this.isDestroyed) return;
      this.emit("create", { editor: this });
    }, 0);
  }
  unmount() {
    if (this.view) {
      this.view.destroy();
    }
    this.view = null;
  }
  /**
   * Set the toolbar for this editor
   * @param {Object} toolbar - The toolbar instance
   * @returns {void}
   */
  setToolbar(toolbar) {
    this.toolbar = toolbar;
  }
  /**
   * Focus the editor.
   * @returns {void}
   */
  focus() {
    this.view?.focus();
  }
  /**
   * Get the editor state
   * @returns {Object} ProseMirror state
   */
  get state() {
    return this.view?.state;
  }
  /**
   * Get the editor storage.
   * @returns {Object} Editor storage object
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * Get object of registered commands.
   * @returns {import('./commands/types/index.js').EditorCommands} Commands object
   */
  get commands() {
    return __privateGet(this, _commandService)?.commands;
  }
  /**
   * Get extension helpers.
   * @returns {EditorHelpers} Object with helper methods for extensions
   */
  get helpers() {
    return this.extensionService.helpers;
  }
  /**
   * Check if the editor is editable.
   * @returns {boolean}
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Check if editor is destroyed.
   * @returns {boolean}
   */
  get isDestroyed() {
    return this.view?.isDestroyed ?? true;
  }
  /**
   * Get the editor element
   * @returns {HTMLElement} The editor element
   */
  get element() {
    return this.options.element;
  }
  /**
   * Get possible users of the editor.
   * @returns {Array.<User>} List of users
   */
  get users() {
    return this.options.users;
  }
  /**
   * Create a chain of commands to call multiple commands at once.
   * @returns {Object} Command chain
   */
  chain() {
    return __privateGet(this, _commandService).chain();
  }
  /**
   * Check if a command or a chain of commands can be executed. Without executing it.
   * @returns {Object} Object with methods to check command availability
   */
  can() {
    return __privateGet(this, _commandService).can();
  }
  /**
   * Set the document mode
   * @param {string} documentMode - The document mode ('editing', 'viewing', 'suggesting')
   */
  setDocumentMode(documentMode) {
    let cleanedMode = documentMode?.toLowerCase() || "editing";
    if (!this.extensionService || !this.state) return;
    const pm = document.querySelector(".ProseMirror");
    if (this.options.role === "viewer") cleanedMode = "viewing";
    if (this.options.role === "suggester" && cleanedMode === "editing") cleanedMode = "suggesting";
    if (cleanedMode === "viewing") {
      this.commands.toggleTrackChangesShowOriginal();
      this.setEditable(false, false);
      this.setOptions({ documentMode: "viewing" });
      toggleHeaderFooterEditMode({
        editor: this,
        focusedSectionEditor: null,
        isEditMode: false,
        documentMode: cleanedMode
      });
      if (!this.options.isHeaderOrFooter && pm) pm.classList.add("view-mode");
    } else if (cleanedMode === "suggesting") {
      __privateMethod(this, _Editor_instances, registerPluginByNameIfNotExists_fn).call(this, "TrackChangesBase");
      this.commands.disableTrackChangesShowOriginal();
      this.commands.enableTrackChanges();
      this.setOptions({ documentMode: "suggesting" });
      this.setEditable(true, false);
      if (pm) pm.classList.remove("view-mode");
    } else if (cleanedMode === "editing") {
      __privateMethod(this, _Editor_instances, registerPluginByNameIfNotExists_fn).call(this, "TrackChangesBase");
      this.commands.disableTrackChangesShowOriginal();
      this.commands.disableTrackChanges();
      this.setEditable(true, false);
      this.setOptions({ documentMode: "editing" });
      toggleHeaderFooterEditMode({
        editor: this,
        focusedSectionEditor: null,
        isEditMode: false,
        documentMode: cleanedMode
      });
      if (pm) pm.classList.remove("view-mode");
    }
  }
  /**
   * Export the yjs binary from the current state.
   * @returns {Promise<Uint8Array>} The exported yjs binary
   */
  async generateCollaborationUpdate() {
    return await generateCollaborationData(this);
  }
  /**
   * Initialize data for collaborative editing
   * If we are replacing data and have a valid provider, listen for synced event
   * so that we can initialize the data
   * @returns {void}
   */
  initializeCollaborationData() {
    if (!this.options.isNewFile || !this.options.collaborationProvider) return;
    const { collaborationProvider: provider } = this.options;
    const postSyncInit = () => {
      provider.off("synced", postSyncInit);
      __privateMethod(this, _Editor_instances, insertNewFileData_fn).call(this);
    };
    if (provider.synced) __privateMethod(this, _Editor_instances, insertNewFileData_fn).call(this);
    else provider.on("synced", postSyncInit);
  }
  /**
   * Replace content of editor that was created with loadFromSchema option
   * Used to replace content of other header/footer when one of it was edited
   *
   * @param {object} content - new editor content json (retrieved from editor.getUpdatedJson)
   * @returns {void}
   */
  replaceContent(content) {
    this.setOptions({
      content
    });
    __privateMethod(this, _Editor_instances, createConverter_fn).call(this);
    this.initDefaultStyles();
    __privateMethod(this, _Editor_instances, createConverter_fn).call(this);
    __privateMethod(this, _Editor_instances, initMedia_fn).call(this);
    const doc2 = __privateMethod(this, _Editor_instances, generatePmData_fn).call(this);
    const tr = this.state.tr.replaceWith(0, this.state.doc.content.size, doc2);
    tr.setMeta("replaceContent", true);
    this.view.dispatch(tr);
  }
  /**
   * Set editor options and update state.
   * @param {EditorOptions} options - Editor options
   * @returns {void}
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (this.options.collaborationProvider && this.options.ydoc) {
      const nonCollabHistoryIndex = this.options.extensions.findIndex((e) => e.name === "history");
      if (nonCollabHistoryIndex !== -1) {
        this.options.extensions.splice(nonCollabHistoryIndex, 1);
      }
    }
    if ((this.options.isNewFile || !this.options.ydoc) && this.options.isCommentsEnabled) {
      this.options.shouldLoadComments = true;
    }
    if (!this.view || !this.state || this.ifsDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Set whether the editor is editable
   * @param {boolean} [editable=true] - Whether the editor is editable
   * @param {boolean} [emitUpdate=true] - Whether to emit an update event
   * @returns {void}
   */
  setEditable(editable = true, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Register PM plugin.
   * @param plugin PM plugin.
   * @param handlePlugins Optional function for handling plugin merge.
   * @returns {void}
   */
  registerPlugin(plugin, handlePlugins) {
    if (!this.state?.plugins) return;
    const plugins = typeof handlePlugins === "function" ? handlePlugins(plugin, [...this.state.plugins]) : [...this.state.plugins, plugin];
    const state = this.state.reconfigure({ plugins });
    this.view.updateState(state);
  }
  /**
   * Unregister a PM plugin
   * @param {string|Object} nameOrPluginKey - Plugin name or plugin instance
   * @returns {void}
   */
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) return;
    const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
    const state = this.state.reconfigure({
      plugins: this.state.plugins.filter((plugin) => !plugin.key.startsWith(name))
    });
    this.view.updateState(state);
  }
  /**
   * Load the data from DOCX to be used in the schema.
   * Expects a DOCX file.
   * @static
   * @async
   * @param {File|Blob|Buffer} fileSource - The DOCX file to load (File/Blob in browser, Buffer in Node.js)
   * @param {boolean} [isNode=false] - Whether the method is being called in a Node.js environment
   * @returns {Promise<Array>} - A promise that resolves to an array containing:
   *   - [0] xmlFiles - Array of XML files extracted from the DOCX
   *   - [1] mediaFiles - Object containing media files with URLs (browser only)
   *   - [2] mediaFiles - Object containing media files with base64 data
   *   - [3] fonts - Object containing font files from the DOCX
   */
  static async loadXmlData(fileSource, isNode2 = false) {
    if (!fileSource) return;
    const zipper = new DocxZipper();
    const xmlFiles = await zipper.getDocxData(fileSource, isNode2);
    const mediaFiles = zipper.media;
    return [xmlFiles, mediaFiles, zipper.mediaFiles, zipper.fonts];
  }
  /**
   * Get the document version
   * @static
   * @param {Object} doc - Document object
   * @returns {string} Document version
   */
  static getDocumentVersion(doc2) {
    const version2 = SuperConverter.getStoredSuperdocVersion(doc2);
    return version2;
  }
  /**
   * Update the document version
   * @static
   * @param {Object} doc - Document object
   * @param {string} version - New version
   * @returns {Object}
   */
  static updateDocumentVersion(doc2, version2) {
    const updatedContent = SuperConverter.updateDocumentVersion(doc2, version2);
    return updatedContent;
  }
  /**
   * Creates all node views.
   * @returns {void}
   */
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionService.nodeViews
    });
  }
  /**
   * Get the maximum content size
   * @returns {Object} Size object with width and height
   */
  getMaxContentSize() {
    if (!this.converter) return {};
    const { pageSize = {}, pageMargins = {} } = this.converter.pageStyles ?? {};
    const { width, height } = pageSize;
    const { top: top2 = 0, bottom: bottom2 = 0, left: left2 = 0, right: right2 = 0 } = pageMargins;
    if (!width || !height) return {};
    const maxHeight = height * 96 - top2 * 96 - bottom2 * 96 - 50;
    const maxWidth = width * 96 - left2 * 96 - right2 * 96 - 20;
    return {
      width: maxWidth,
      height: maxHeight
    };
  }
  /**
   * Attach styles and attributes to the editor element
   */
  updateEditorStyles(element, proseMirror, hasPaginationEnabled = true) {
    const { pageSize, pageMargins } = this.converter.pageStyles ?? {};
    if (!proseMirror || !element) {
      return;
    }
    proseMirror.setAttribute("role", "document");
    proseMirror.setAttribute("aria-multiline", true);
    proseMirror.setAttribute("aria-label", "Main content area, start typing to enter text.");
    proseMirror.setAttribute("aria-description", "");
    proseMirror.classList.remove("view-mode");
    if (pageSize) {
      element.style.width = pageSize.width + "in";
      element.style.minWidth = pageSize.width + "in";
      element.style.minHeight = pageSize.height + "in";
    }
    if (pageMargins) {
      element.style.paddingLeft = pageMargins.left + "in";
      element.style.paddingRight = pageMargins.right + "in";
    }
    element.style.boxSizing = "border-box";
    element.style.isolation = "isolate";
    proseMirror.style.outline = "none";
    proseMirror.style.border = "none";
    const { typeface, fontSizePt } = this.converter.getDocumentDefaultStyles() ?? {};
    if (typeface) {
      element.style.fontFamily = typeface;
    }
    if (fontSizePt) {
      element.style.fontSize = `${fontSizePt}pt`;
    }
    element.style.transformOrigin = "top left";
    element.style.touchAction = "auto";
    element.style.webkitOverflowScrolling = "touch";
    const defaultLineHeight = 1.2;
    proseMirror.style.lineHeight = defaultLineHeight;
    if (!hasPaginationEnabled) {
      proseMirror.style.paddingTop = "1in";
      proseMirror.style.paddingBottom = "1in";
    } else {
      proseMirror.style.paddingTop = "0";
      proseMirror.style.paddingBottom = "0";
    }
  }
  /**
   * Initialize default styles for the editor container and ProseMirror.
   * Get page size and margins from the converter.
   * Set document default font and font size.
   *
   * @param {HTMLElement} [element=this.element] - The DOM element to apply styles to
   * @returns {void}
   */
  initDefaultStyles(element = this.element, isPaginationEnabled = true) {
    if (this.options.isHeadless || this.options.suppressDefaultDocxStyles) return;
    const proseMirror = element?.querySelector(".ProseMirror");
    this.updateEditorStyles(element, proseMirror, isPaginationEnabled);
    this.initMobileStyles(element);
  }
  /**
   * Initializes responsive styles for mobile devices.
   * Sets up scaling based on viewport width and handles orientation changes.
   *
   * @param {HTMLElement|void} element - The DOM element to apply mobile styles to
   * @returns {void}
   */
  initMobileStyles(element) {
    if (!element) {
      return;
    }
    const initialWidth = element.offsetWidth;
    const updateScale = () => {
      const minPageSideMargin = 10;
      const elementWidth = initialWidth;
      const availableWidth = document.documentElement.clientWidth - minPageSideMargin;
      this.options.scale = Math.min(1, availableWidth / elementWidth);
      const superEditorElement = element.closest(".super-editor");
      const superEditorContainer = element.closest(".super-editor-container");
      if (!superEditorElement || !superEditorContainer) {
        return;
      }
      if (this.options.scale < 1) {
        superEditorElement.style.maxWidth = `${elementWidth * this.options.scale}px`;
        superEditorContainer.style.minWidth = "0px";
        element.style.transform = `scale(${this.options.scale})`;
      } else {
        superEditorElement.style.maxWidth = "";
        superEditorContainer.style.minWidth = "";
        element.style.transform = "none";
      }
    };
    updateScale();
    const handleResize = () => {
      setTimeout(() => {
        updateScale();
      }, 150);
    };
    if ("orientation" in screen && "addEventListener" in screen.orientation) {
      screen.orientation.addEventListener("change", handleResize);
    } else {
      window.matchMedia("(orientation: portrait)").addEventListener("change", handleResize);
    }
    window.addEventListener("resize", () => handleResize);
  }
  /**
   * Get attrs of the currently selected node or mark.
   * @param {String} nameOrType
   * @example
   * editor.getAttributes('textStyle').color
   */
  getAttributes(nameOrType) {
    return Attribute.getAttributes(this.state, nameOrType);
  }
  /**
   * Returns if the currently selected node or mark is active.
   * @param {String|Object} nameOrAttributes - The name of the node/mark or an attributes object
   * @param {Object} [attributesOrUndefined] - Optional attributes to check when first parameter is a name
   * @returns {Boolean} Whether the node or mark is active with the specified attributes
   * @example
   * editor.isActive('bold')
   * editor.isActive('textStyle', { color: 'purple' })
   * editor.isActive({ textAlign: 'center' })
   */
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the editor content as JSON
   * @returns {Object} Editor content as JSON
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the editor content as HTML
   * @returns {string} Editor content as HTML
   */
  getHTML({ unflattenLists = false } = {}) {
    const tempDocument = document.implementation.createHTMLDocument();
    const container = tempDocument.createElement("div");
    const fragment = DOMSerializer.fromSchema(this.schema).serializeFragment(this.state.doc.content);
    container.appendChild(fragment);
    let html = container.innerHTML;
    if (unflattenLists) {
      html = unflattenListsInHtml(html);
    }
    return html;
  }
  /**
   * Create a child editor linked to this editor.
   * This is useful for creating header/footer editors that are linked to the main editor.
   * Or paragraph fields that rely on the same underlying document and list defintions
   * @param {EditorOptions} options - Options for the child editor
   * @returns {Editor} A new child editor instance linked to this editor
   */
  createChildEditor(options) {
    return createLinkedChildEditor(this, options);
  }
  /**
   * Get page styles
   * @returns {Object} Page styles
   */
  getPageStyles() {
    return this.converter?.pageStyles || {};
  }
  /**
   * Update page styles
   *
   * @param {Object} param0
   * @param {Object} param0.pageMargins The new page margins
   * @returns {void}
   */
  updatePageStyle({ pageMargins }) {
    if (!this.converter) return;
    let hasMadeUpdate = false;
    if (pageMargins) {
      this.converter.pageStyles.pageMargins = pageMargins;
      this.initDefaultStyles();
      hasMadeUpdate = true;
    }
    if (hasMadeUpdate) {
      const newTr = this.view.state.tr;
      newTr.setMeta("forceUpdatePagination", true);
      this.view.dispatch(newTr);
    }
  }
  migrateListsToV2() {
    if (this.options.isHeaderOrFooter) return [];
    const replacements = migrateListsToV2IfNecessary(this);
    return replacements;
  }
  getUpdatedJson() {
    return __privateMethod(this, _Editor_instances, prepareDocumentForExport_fn).call(this);
  }
  /**
   * Export the editor document to DOCX.
   * @async
   * @param {Object} options - The export options
   * @param {boolean} [options.isFinalDoc=false] - Whether this is the final document version
   * @param {string} [options.commentsType] - The type of comments to include
   * @param {Array} [options.comments=[]] - Array of comments to include in the document
   * @param {boolean} [options.getUpdatedDocs=false] - When set to true return only updated docx files
   * @returns {Promise<Blob|ArrayBuffer|Object>} The exported DOCX file or updated docx files
   */
  async exportDocx({
    isFinalDoc = false,
    commentsType = "external",
    exportJsonOnly = false,
    exportXmlOnly = false,
    comments = [],
    getUpdatedDocs = false,
    fieldsHighlightColor = null
  } = {}) {
    const json = __privateMethod(this, _Editor_instances, prepareDocumentForExport_fn).call(this, comments);
    const documentXml = await this.converter.exportToDocx(
      json,
      this.schema,
      this.storage.image.media,
      isFinalDoc,
      commentsType,
      comments,
      this,
      exportJsonOnly,
      fieldsHighlightColor
    );
    if (exportXmlOnly || exportJsonOnly) return documentXml;
    const customXml = this.converter.schemaToXml(this.converter.convertedXml["docProps/custom.xml"].elements[0]);
    const styles = this.converter.schemaToXml(this.converter.convertedXml["word/styles.xml"].elements[0]);
    const customSettings = this.converter.schemaToXml(this.converter.convertedXml["word/settings.xml"].elements[0]);
    const rels = this.converter.schemaToXml(this.converter.convertedXml["word/_rels/document.xml.rels"].elements[0]);
    const media = this.converter.addedMedia;
    const updatedHeadersFooters = {};
    Object.entries(this.converter.convertedXml).forEach(([name, json2]) => {
      if (name.includes("header") || name.includes("footer")) {
        const resultXml = this.converter.schemaToXml(json2.elements[0]);
        updatedHeadersFooters[name] = String(resultXml);
      }
    });
    const numberingData = this.converter.convertedXml["word/numbering.xml"];
    const numbering = this.converter.schemaToXml(numberingData.elements[0]);
    const updatedDocs = {
      ...this.options.customUpdatedFiles,
      "word/document.xml": String(documentXml),
      "docProps/custom.xml": String(customXml),
      "word/settings.xml": String(customSettings),
      "word/_rels/document.xml.rels": String(rels),
      "word/numbering.xml": String(numbering),
      // Replace & with &amp; in styles.xml as DOCX viewers can't handle it
      "word/styles.xml": String(styles).replace(/&/gi, "&amp;"),
      ...updatedHeadersFooters
    };
    if (comments.length) {
      const commentsXml = this.converter.schemaToXml(this.converter.convertedXml["word/comments.xml"].elements[0]);
      const commentsExtendedXml = this.converter.schemaToXml(
        this.converter.convertedXml["word/commentsExtended.xml"].elements[0]
      );
      const commentsExtensibleXml = this.converter.schemaToXml(
        this.converter.convertedXml["word/commentsExtensible.xml"].elements[0]
      );
      const commentsIdsXml = this.converter.schemaToXml(
        this.converter.convertedXml["word/commentsIds.xml"].elements[0]
      );
      updatedDocs["word/comments.xml"] = String(commentsXml);
      updatedDocs["word/commentsExtended.xml"] = String(commentsExtendedXml);
      updatedDocs["word/commentsExtensible.xml"] = String(commentsExtensibleXml);
      updatedDocs["word/commentsIds.xml"] = String(commentsIdsXml);
    }
    const zipper = new DocxZipper();
    if (getUpdatedDocs) {
      updatedDocs["[Content_Types].xml"] = await zipper.updateContentTypes(
        {
          files: this.options.content
        },
        media,
        true
      );
      return updatedDocs;
    }
    const result = await zipper.updateZip({
      docx: this.options.content,
      updatedDocs,
      originalDocxFile: this.options.fileSource,
      media,
      fonts: this.options.fonts,
      isHeadless: this.options.isHeadless
    });
    this.options.telemetry?.trackUsage("document_export", {
      documentType: "docx",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    return result;
  }
  /**
   * Destroy the editor and clean up resources
   * @returns {void}
   */
  destroy() {
    this.emit("destroy");
    this.unmount();
    this.destroyHeaderFooterEditors();
    __privateMethod(this, _Editor_instances, endCollaboration_fn).call(this);
    this.removeAllListeners();
  }
  destroyHeaderFooterEditors() {
    try {
      const editors = [...this.converter.headerEditors, ...this.converter.footerEditors];
      for (let editorData of editors) {
        editorData.editor.destroy();
      }
      this.converter.headerEditors.length = 0;
      this.converter.footerEditors.length = 0;
    } catch {
    }
  }
  /**
   * Check if migrations are needed for the data
   * @static
   * @param {Object} data - Document data
   * @returns {boolean} Whether migrations are needed
   */
  static checkIfMigrationsNeeded() {
    const dataVersion = version || "initial";
    const migrations = getNecessaryMigrations(dataVersion) || [];
    console.debug("[checkVersionMigrations] Migrations needed:", dataVersion, migrations.length);
    return migrations.length > 0;
  }
  /**
   * Process collaboration migrations
   * @returns {Object | void} Migration results
   */
  processCollaborationMigrations() {
    console.debug("[checkVersionMigrations] Current editor version", "0.15.17-next.11");
    if (!this.options.ydoc) return;
    const metaMap = this.options.ydoc.getMap("meta");
    let docVersion = metaMap.get("version");
    if (!docVersion) docVersion = "initial";
    console.debug("[checkVersionMigrations] Document version", docVersion);
    const migrations = getNecessaryMigrations(docVersion) || [];
    const plugins = this.state.plugins;
    const syncPlugin = plugins.find((p) => p.key.startsWith("y-sync"));
    if (!syncPlugin) return this.options.ydoc;
    let hasRunMigrations = false;
    for (let migration of migrations) {
      console.debug(" Running migration", migration.name);
      const result = migration(this);
      if (!result) throw new Error("Migration failed at " + migration.name);
      else hasRunMigrations = true;
    }
    if (!hasRunMigrations) return;
    const pluginState = syncPlugin?.getState(this.state);
    return pluginState.doc;
  }
  /**
   * Replace the current file
   * @async
   * @param {Object} newFile - New file data
   * @returns {Promise<void>}
   */
  async replaceFile(newFile) {
    this.setOptions({ annotations: true });
    const [docx, media, mediaFiles, fonts] = await _Editor.loadXmlData(newFile);
    this.setOptions({
      fileSource: newFile,
      content: docx,
      media,
      mediaFiles,
      fonts,
      isNewFile: true,
      shouldLoadComments: true,
      replacedFile: true
    });
    __privateMethod(this, _Editor_instances, createConverter_fn).call(this);
    __privateMethod(this, _Editor_instances, initMedia_fn).call(this);
    this.initDefaultStyles();
    if (this.options.ydoc && this.options.collaborationProvider) {
      updateYdocDocxData(this);
      this.initializeCollaborationData(true);
    } else {
      __privateMethod(this, _Editor_instances, insertNewFileData_fn).call(this);
    }
    if (!this.options.ydoc) {
      __privateMethod(this, _Editor_instances, initPagination_fn).call(this);
      __privateMethod(this, _Editor_instances, initComments_fn).call(this);
    }
  }
  /**
   * Get internal docx file content
   * @param {string} name - File name
   * @param {string} type - type of result (json, string)
   * @returns {Object|String} - file content
   */
  getInternalXmlFile(name, type = "json") {
    if (!this.converter.convertedXml[name]) {
      console.warn("Cannot find file in docx");
      return null;
    }
    if (type === "json") {
      return this.converter.convertedXml[name].elements[0] || null;
    }
    return this.converter.schemaToXml(this.converter.convertedXml[name].elements[0]);
  }
  /**
   * Update internal docx file content
   * @param {string} name - File name
   * @param {string} updatedContent - new file content
   */
  updateInternalXmlFile(name, updatedContent) {
    if (typeof updatedContent === "string") {
      this.options.customUpdatedFiles[name] = String(updatedContent);
    } else {
      const internalFileXml = this.converter.schemaToXml(updatedContent);
      this.options.customUpdatedFiles[name] = String(internalFileXml);
    }
    this.options.isCustomXmlChanged = true;
  }
  /**
   * Get all nodes of a specific type
   * @param {string} type - Node type
   * @returns {Array} Array of nodes
   */
  getNodesOfType(type) {
    const { findChildren: findChildren2 } = helpers;
    return findChildren2(this.state.doc, (node) => node.type.name === type);
  }
  /**
   * Replace a node with HTML content
   * @param {Object} targetNode - The node to replace
   * @param {string} html - HTML content to replace with
   * @returns {void}
   */
  replaceNodeWithHTML(targetNode, html) {
    const { tr } = this.state;
    const { dispatch } = this.view;
    if (!targetNode || !html) return;
    const start2 = targetNode.pos;
    const end2 = start2 + targetNode.node.nodeSize;
    const htmlNode = createDocFromHTML(html, this.schema);
    tr.replaceWith(start2, end2, htmlNode);
    dispatch(tr);
  }
  /**
   * A command to prepare the editor to receive annotations. This will
   * pre-process the document as needed prior to running in the annotator.
   *
   * Currently this is only used for table generation but additional pre-processing can be done here.
   *
   * @param {FieldValue[]} annotationValues
   * @returns {void}
   */
  prepareForAnnotations(annotationValues = []) {
    const { tr } = this.state;
    const newTr = AnnotatorHelpers.processTables({ state: this.state, tr, annotationValues });
    this.view.dispatch(newTr);
  }
  /**
   * Migrate paragraph fields to lists V2 structure if necessary.
   * @param {FieldValue[]} annotationValues - List of field values to migrate.
   * @returns {Promise<FieldValue[]>} - Returns a promise that resolves to the migrated
   */
  async migrateParagraphFields(annotationValues = []) {
    if (!Array.isArray(annotationValues) || !annotationValues.length) return annotationValues;
    const result = await migrateParagraphFieldsListsV2(annotationValues, this);
    return result;
  }
  /**
   * Annotate the document with the given annotation values.
   *
   * @param {FieldValue[]} annotationValues List of field values to apply.
   * @param {String[]} hiddenIds List of field ids to remove from the document.
   * @returns {void}
   */
  annotate(annotationValues = [], hiddenIds = [], removeEmptyFields = false) {
    const { state, view, schema } = this;
    let tr = state.tr;
    tr = AnnotatorHelpers.processTables({ state: this.state, tr, annotationValues });
    tr = AnnotatorHelpers.annotateDocument({
      tr,
      schema,
      annotationValues,
      hiddenFieldIds: hiddenIds,
      removeEmptyFields,
      editor: this
    });
    if (tr.docChanged) view.dispatch(tr.scrollIntoView());
  }
  /**
   * Preview annotations in the editor. It stores a copy of the original state.
   * This can be reverted via closePreview()
   *
   * @param {Object[]} annotationValues
   * @param {string[]} hiddenIds
   * @returns {void}
   */
  previewAnnotations(annotationValues = [], hiddenIds = []) {
    this.originalState = this.view.state;
    this.annotate(annotationValues, hiddenIds);
  }
  /**
   * If there is a preview active, this will revert the editor to the original state.
   *
   * @returns {void}
   */
  closePreview() {
    if (!this.originalState) return;
    this.view.updateState(this.originalState);
  }
};
_commandService = new WeakMap();
_Editor_instances = new WeakSet();
/**
 * Initialize the container element for the editor
 * @param {EditorOptions} options - Editor options
 * @returns {void}
 */
initContainerElement_fn = function(options) {
  if (!options.element && options.selector) {
    const { selector } = options;
    if (selector.startsWith("#") || selector.startsWith(".")) {
      options.element = document.querySelector(selector);
    } else {
      options.element = document.getElementById(selector);
    }
    const textModes = ["text", "html"];
    if (textModes.includes(options.mode) && options.element) {
      options.element.classList.add("sd-super-editor-html");
    }
  }
  options.element = options.isHeadless ? null : options.element || document.createElement("div");
};
/**
 * Initialize the editor with the given options
 * @returns {void}
 */
init_fn = function() {
  __privateMethod(this, _Editor_instances, createExtensionService_fn).call(this);
  __privateMethod(this, _Editor_instances, createCommandService_fn).call(this);
  __privateMethod(this, _Editor_instances, createSchema_fn).call(this);
  __privateMethod(this, _Editor_instances, createConverter_fn).call(this);
  __privateMethod(this, _Editor_instances, initMedia_fn).call(this);
  if (!this.options.isHeadless) {
    __privateMethod(this, _Editor_instances, initFonts_fn).call(this);
  }
  this.on("beforeCreate", this.options.onBeforeCreate);
  this.emit("beforeCreate", { editor: this });
  this.on("contentError", this.options.onContentError);
  this.on("exception", this.options.onException);
  this.mount(this.options.element);
  this.on("create", this.options.onCreate);
  this.on("update", this.options.onUpdate);
  this.on("selectionUpdate", this.options.onSelectionUpdate);
  this.on("transaction", this.options.onTransaction);
  this.on("focus", __privateMethod(this, _Editor_instances, onFocus_fn));
  this.on("blur", this.options.onBlur);
  this.on("destroy", this.options.onDestroy);
  this.on("trackedChangesUpdate", this.options.onTrackedChangesUpdate);
  this.on("commentsLoaded", this.options.onCommentsLoaded);
  this.on("commentClick", this.options.onCommentClicked);
  this.on("commentsUpdate", this.options.onCommentsUpdate);
  this.on("locked", this.options.onDocumentLocked);
  this.on("collaborationReady", __privateMethod(this, _Editor_instances, onCollaborationReady_fn));
  this.on("paginationUpdate", this.options.onPaginationUpdate);
  this.on("comment-positions", this.options.onCommentLocationsUpdate);
  this.on("list-definitions-change", this.options.onListDefinitionsChange);
  if (!this.options.isHeadless) {
    this.initializeCollaborationData();
    this.initDefaultStyles();
  }
  if (!this.options.ydoc) this.migrateListsToV2();
  this.setDocumentMode(this.options.documentMode);
  if (!this.options.ydoc) {
    if (!this.options.isChildEditor) {
      __privateMethod(this, _Editor_instances, initPagination_fn).call(this);
      __privateMethod(this, _Editor_instances, initComments_fn).call(this);
      __privateMethod(this, _Editor_instances, validateDocumentInit_fn).call(this);
    }
  }
};
/**
 * Initialize the editor in rich text mode
 * @param {EditorOptions} options - Editor options
 * @returns {void}
 */
initRichText_fn = function() {
  if (!this.options.extensions || !this.options.extensions.length) {
    this.options.extensions = getRichTextExtensions();
  }
  __privateMethod(this, _Editor_instances, createExtensionService_fn).call(this);
  __privateMethod(this, _Editor_instances, createCommandService_fn).call(this);
  __privateMethod(this, _Editor_instances, createSchema_fn).call(this);
  this.on("beforeCreate", this.options.onBeforeCreate);
  this.emit("beforeCreate", { editor: this });
  this.on("contentError", this.options.onContentError);
  this.mount(this.options.element);
  this.on("create", this.options.onCreate);
  this.on("update", this.options.onUpdate);
  this.on("selectionUpdate", this.options.onSelectionUpdate);
  this.on("transaction", this.options.onTransaction);
  this.on("focus", __privateMethod(this, _Editor_instances, onFocus_fn));
  this.on("blur", this.options.onBlur);
  this.on("destroy", this.options.onDestroy);
  this.on("commentsLoaded", this.options.onCommentsLoaded);
  this.on("commentClick", this.options.onCommentClicked);
  this.on("locked", this.options.onDocumentLocked);
  this.on("list-definitions-change", this.options.onListDefinitionsChange);
};
/**
 *
 * @param {Object} param0
 * @param {Object} param0.editor
 * @param {Object} param0.event
 * @returns {void}
 */
onFocus_fn = function({ editor, event }) {
  this.toolbar?.setActiveEditor(editor);
  this.options.onFocus({ editor, event });
};
/**
 * Check if the editor should run in headless mode
 * @param {EditorOptions} options - Editor options
 * @returns {void}
 */
checkHeadless_fn = function(options) {
  if (!options.isHeadless) return;
  if (typeof navigator === "undefined") {
    global.navigator = { isHeadless: true };
  }
  if (options.mockDocument) {
    global.document = options.mockDocument;
    global.window = options.mockWindow;
  }
};
/**
 * Replace the current document with new data. Necessary for initializing a new collaboration file,
 * since we need to insert the data only after the provider has synced.
 */
/**
 * Insert data for a new file
 * @returns {void}
 */
insertNewFileData_fn = function() {
  if (!this.options.isNewFile) return;
  this.options.isNewFile = false;
  const doc2 = __privateMethod(this, _Editor_instances, generatePmData_fn).call(this);
  const tr = this.state.tr.replaceWith(0, this.state.doc.content.size, doc2).setMeta("addToHistory", false);
  this.view.dispatch(tr);
  setTimeout(() => {
    __privateMethod(this, _Editor_instances, initPagination_fn).call(this);
    __privateMethod(this, _Editor_instances, initComments_fn).call(this);
  }, 50);
};
/**
 * Register a plugin by name if it doesn't already exist
 * @param {string} name - Plugin name
 * @returns {string|void}
 */
registerPluginByNameIfNotExists_fn = function(name) {
  const plugin = this.extensionService?.plugins.find((p) => p.key.startsWith(name));
  const hasPlugin = this.state?.plugins?.find((p) => p.key.startsWith(name));
  if (plugin && !hasPlugin) this.registerPlugin(plugin);
  return plugin?.key;
};
/**
 * Creates extension service.
 * @returns {void}
 */
createExtensionService_fn = function() {
  const allowedExtensions = ["extension", "node", "mark"];
  const coreExtensions = [Editable, Commands, EditorFocus, Keymap];
  const externalExtensions = this.options.externalExtensions || [];
  const allExtensions = [...coreExtensions, ...this.options.extensions].filter(
    (e) => allowedExtensions.includes(e?.type)
  );
  this.extensionService = ExtensionService.create(allExtensions, externalExtensions, this);
};
/**
 * Creates a command service.
 * @returns {void}
 */
createCommandService_fn = function() {
  __privateSet(this, _commandService, CommandService.create({
    editor: this
  }));
};
/**
 * Creates a SuperConverter.
 */
/**
 * Create the document converter as this.converter.
 * @returns {void}
 */
createConverter_fn = function() {
  if (this.options.converter) {
    this.converter = this.options.converter;
  } else {
    this.converter = new SuperConverter({
      docx: this.options.content,
      media: this.options.mediaFiles,
      fonts: this.options.fonts,
      debug: true,
      telemetry: this.options.telemetry,
      fileSource: this.options.fileSource,
      documentId: this.options.documentId
    });
  }
};
/**
 * Initialize media.
 * @returns {void}
 */
initMedia_fn = function() {
  if (this.options.isChildEditor) return;
  if (!this.options.ydoc) return this.storage.image.media = this.options.mediaFiles;
  const mediaMap = this.options.ydoc.getMap("media");
  if (this.options.isNewFile) {
    Object.entries(this.options.mediaFiles).forEach(([key, value]) => {
      mediaMap.set(key, value);
    });
    this.storage.image.media = this.options.mediaFiles;
  } else {
    this.storage.image.media = Object.fromEntries(mediaMap.entries());
  }
};
/**
 * Initialize fonts
 * @returns {void}
 */
initFonts_fn = function() {
  const styleString = this.converter.getDocumentFonts();
  if (styleString?.length) {
    const style = document.createElement("style");
    style.textContent = styleString;
    document.head.appendChild(style);
  }
};
/**
 * Creates document PM schema.
 * @returns {void
 */
createSchema_fn = function() {
  this.schema = this.extensionService.schema;
};
/**
 * Generate ProseMirror data from file
 * @returns {Object} ProseMirror data
 */
generatePmData_fn = function() {
  let doc2;
  try {
    const { mode, fragment, content, loadFromSchema } = this.options;
    if (mode === "docx") {
      if (loadFromSchema && !this.options.jsonOverride) {
        doc2 = this.schema.nodeFromJSON(content);
        doc2 = __privateMethod(this, _Editor_instances, prepareDocumentForImport_fn).call(this, doc2);
      } else {
        doc2 = createDocument(this.converter, this.schema, this);
        doc2 = __privateMethod(this, _Editor_instances, prepareDocumentForImport_fn).call(this, doc2);
        if (this.options.markdown) {
          doc2 = createDocFromMarkdown(this.options.markdown, this.schema);
        } else if (this.options.html) doc2 = createDocFromHTML(this.options.html, this.schema);
        else if (this.options.jsonOverride) doc2 = this.schema.nodeFromJSON(this.options.jsonOverride);
        if (fragment) doc2 = yXmlFragmentToProseMirrorRootNode(fragment, this.schema);
      }
    } else if (mode === "text" || mode === "html") {
      if (loadFromSchema) doc2 = this.schema.nodeFromJSON(content);
      else if (content) doc2 = createDocFromHTML(content, this.schema);
      else doc2 = this.schema.topNodeType.createAndFill();
    }
  } catch (err) {
    console.error(err);
    this.emit("contentError", { editor: this, error: err });
  }
  return doc2;
};
/**
 * Create the PM editor view
 * @returns {void}
 */
createView_fn = function(element) {
  let doc2 = __privateMethod(this, _Editor_instances, generatePmData_fn).call(this);
  const state = { schema: this.schema };
  if (!this.options.ydoc) state.doc = doc2;
  this.options.initialState = EditorState.create(state);
  this.view = new EditorView(element, {
    ...this.options.editorProps,
    dispatchTransaction: __privateMethod(this, _Editor_instances, dispatchTransaction_fn).bind(this),
    state: this.options.initialState,
    handleClick: __privateMethod(this, _Editor_instances, handleNodeSelection_fn).bind(this),
    handleDoubleClick: async (view, pos, event) => {
      if (this.options.documentMode !== "editing") return;
      const isHeader = hasSomeParentWithClass(event.target, "pagination-section-header");
      const isFooter = hasSomeParentWithClass(event.target, "pagination-section-footer");
      if (isHeader || isFooter) {
        const eventClone = new event.constructor(event.type);
        event.target.dispatchEvent(eventClone);
        if (this.options.isHeaderOrFooter && this.options.editable) setWordSelection(view, pos);
        return;
      }
      event.stopPropagation();
      if (!this.options.editable) {
        this.setEditable(true, false);
        toggleHeaderFooterEditMode({
          editor: this,
          focusedSectionEditor: null,
          isEditMode: false,
          documentMode: this.options.documentMode
        });
        const pm = document.querySelector(".ProseMirror");
        pm.classList.remove("header-footer-edit");
        pm.setAttribute("aria-readonly", false);
      }
      setWordSelection(view, pos);
    }
  });
  const newState = this.state.reconfigure({
    plugins: [...this.extensionService.plugins]
  });
  this.view.updateState(newState);
  this.createNodeViews();
  this.options.telemetry?.sendReport();
};
/**
 * Handler called when collaboration is ready.
 * Initializes pagination and comments if not a new file.
 *
 * @param {Object} params - Collaboration parameters
 * @param {Editor} params.editor - The editor instance
 * @param {Object} params.ydoc - The Yjs document
 * @returns {void}
 */
onCollaborationReady_fn = function({ editor, ydoc }) {
  if (this.options.collaborationIsReady) return;
  console.debug(" [super-editor] Collaboration ready");
  __privateMethod(this, _Editor_instances, validateDocumentInit_fn).call(this);
  this.options.onCollaborationReady({ editor, ydoc });
  this.options.collaborationIsReady = true;
  this.options.initialState = this.state;
  const { tr } = this.state;
  tr.setMeta("collaborationReady", true);
  this.view.dispatch(tr);
  if (!this.options.isNewFile) {
    __privateMethod(this, _Editor_instances, initPagination_fn).call(this);
    __privateMethod(this, _Editor_instances, initComments_fn).call(this);
    updateYdocDocxData(this);
  }
};
/**
 * Initialize comments plugin
 * @returns {void}
 */
initComments_fn = function() {
  if (!this.options.isCommentsEnabled) return;
  if (this.options.isHeadless) return;
  if (!this.options.shouldLoadComments) return;
  const replacedFile = this.options.replacedFile;
  this.emit("commentsLoaded", { editor: this, replacedFile, comments: this.converter.comments || [] });
  setTimeout(() => {
    this.options.replacedFile = false;
    const { state, dispatch } = this.view;
    const tr = state.tr.setMeta(CommentsPluginKey, { type: "force" });
    dispatch(tr);
  }, 50);
};
initPagination_fn = async function() {
  if (this.options.isHeadless || !this.extensionService || this.options.isHeaderOrFooter) {
    return;
  }
  const pagination = this.options.extensions.find((e) => e.name === "pagination");
  if (pagination && this.options.pagination) {
    const sectionData = await initPaginationData(this);
    this.storage.pagination.sectionData = sectionData;
    const { state, dispatch } = this.view;
    const tr = state.tr.setMeta(PaginationPluginKey, { isReadyToInit: true });
    dispatch(tr);
  }
};
/**
 * Dispatch a transaction to update the editor state
 * @param {Object} transaction - ProseMirror transaction
 */
dispatchTransaction_fn = function(transaction) {
  if (this.isDestroyed) return;
  const start2 = Date.now();
  let state;
  try {
    const trackChangesState = TrackChangesBasePluginKey.getState(this.view.state);
    const isTrackChangesActive = trackChangesState?.isTrackChangesActive ?? false;
    const tr = isTrackChangesActive ? trackedTransaction({
      tr: transaction,
      state: this.state,
      user: this.options.user
    }) : transaction;
    const { state: newState } = this.view.state.applyTransaction(tr);
    state = newState;
  } catch (error) {
    state = this.state.apply(transaction);
    console.log(error);
  }
  const selectionHasChanged = !this.state.selection.eq(state.selection);
  this.view.updateState(state);
  const end2 = Date.now();
  this.emit("transaction", {
    editor: this,
    transaction,
    duration: end2 - start2
  });
  if (selectionHasChanged) {
    this.emit("selectionUpdate", {
      editor: this,
      transaction
    });
  }
  const focus = transaction.getMeta("focus");
  if (focus) {
    this.emit("focus", {
      editor: this,
      event: focus.event,
      transaction
    });
  }
  const blur = transaction.getMeta("blur");
  if (blur) {
    this.emit("blur", {
      editor: this,
      event: blur.event,
      transaction
    });
  }
  if (!transaction.docChanged) {
    return;
  }
  this.emit("update", {
    editor: this,
    transaction
  });
};
/**
 * Handles image node selection for header/footer editor
 */
handleNodeSelection_fn = function(view, pos) {
  this.setOptions({
    lastSelection: null
  });
  if (this.options.isHeaderOrFooter) {
    return setImageNodeSelection(view, pos);
  }
};
/**
 * Perform any post conversion pre prosemirror import processing.
 * Comments are processed here.
 * @param {Object} doc The prosemirror document
 * @returns {Object} The updated prosemirror document
 */
prepareDocumentForImport_fn = function(doc2) {
  const newState = EditorState.create({
    schema: this.schema,
    doc: doc2
  });
  const { tr, doc: newDoc } = newState;
  prepareCommentsForImport(newDoc, tr, this.schema, this.converter);
  const updatedState = newState.apply(tr);
  return updatedState.doc;
};
/**
 * Prepare the document for export. Any necessary pre-export processing to the state
 * can happen here.
 * @returns {Object} The updated document in JSON
 */
prepareDocumentForExport_fn = function(comments = []) {
  const newState = EditorState.create({
    schema: this.schema,
    doc: this.state.doc,
    plugins: this.state.plugins
  });
  const { tr, doc: doc2 } = newState;
  prepareCommentsForExport(doc2, tr, this.schema, comments);
  const updatedState = newState.apply(tr);
  return updatedState.doc.toJSON();
};
/**
 * Destroy collaboration provider and ydoc
 * @returns {void}
 */
endCollaboration_fn = function() {
  if (!this.options.ydoc) return;
  try {
    console.debug(" [super-editor] Ending collaboration");
    if (this.options.collaborationProvider) this.options.collaborationProvider.disconnect();
    if (this.options.ydoc) this.options.ydoc.destroy();
  } catch {
  }
};
/**
 * Run the SuperValidator's active document validation to check and fix potential known issues.
 * @returns {void}
 */
validateDocumentInit_fn = function() {
  if (this.options.isHeaderOrFooter || this.options.isChildEditor) return;
  const validator = new SuperValidator({ editor: this, dryRun: false, debug: false });
  validator.validateActiveDocument();
};
let Editor = _Editor;
const Color = Extension.create({
  name: "color",
  addOptions() {
    return {
      /**
       * @typedef {Object} ColorOptions
       * @category Options
       * @property {string[]} [types=['textStyle']] - Mark types to add color support to
       */
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {ColorValue} [color] - Text color value
           */
          color: {
            default: null,
            parseDOM: (el) => el.style.color?.replace(/['"]+/g, ""),
            renderDOM: (attrs) => {
              if (!attrs.color) return {};
              return { style: `color: ${attrs.color}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      /**
       * Set text color
       * @category Command
       * @param {ColorValue} color - Color value to apply
       * @returns {Function} Command function
       * @example
       * // Set to red using hex
       * setColor('#ff0000')
       *
       * // Set using rgb
       * setColor('rgb(255, 0, 0)')
       *
       * // Set using named color
       * setColor('blue')
       * @note Preserves other text styling attributes
       */
      setColor: (color) => ({ chain }) => {
        return chain().setMark("textStyle", { color }).run();
      },
      /**
       * Remove text color
       * @category Command
       * @returns {Function} Command function
       * @example
       * unsetColor()
       * @note Removes color while preserving other text styles
       */
      unsetColor: () => ({ chain }) => {
        return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const FontFamily = Extension.create({
  name: "fontFamily",
  addOptions() {
    return {
      /**
       * @typedef {Object} FontFamilyOptions
       * @category Options
       * @property {string[]} [types=['textStyle']] - Mark types to add font family support to
       */
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {FontFamilyValue} [fontFamily] - Font family for text
           */
          fontFamily: {
            default: null,
            parseDOM: (el) => el.style.fontFamily?.replace(/['"]+/g, ""),
            renderDOM: (attrs) => {
              if (!attrs.fontFamily) return {};
              return { style: `font-family: ${attrs.fontFamily}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      /**
       * Set font family
       * @category Command
       * @param {FontFamilyValue} fontFamily - Font family to apply
       * @returns {Function} Command function
       * @example
       * // Set to Arial
       * setFontFamily('Arial')
       *
       * // Set to serif font
       * setFontFamily('Georgia, serif')
       * @note Preserves other text styling attributes
       */
      setFontFamily: (fontFamily) => ({ chain }) => {
        return chain().setMark("textStyle", { fontFamily }).run();
      },
      /**
       * Remove font family
       * @category Command
       * @returns {Function} Command function
       * @example
       * unsetFontFamily()
       * @note Reverts to default document font
       */
      unsetFontFamily: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const FontSize = Extension.create({
  name: "fontSize",
  addOptions() {
    return {
      /**
       * @typedef {Object} FontSizeOptions
       * @category Options
       * @property {string[]} [types=['textStyle', 'tableCell']] - Node/mark types to add font size support to
       * @property {FontSizeDefaults} [defaults] - Default size configuration
       */
      types: ["textStyle", "tableCell"],
      defaults: {
        value: 12,
        unit: "pt",
        min: 8,
        max: 96
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {FontSizeValue} [fontSize] - Font size with unit
           */
          fontSize: {
            default: null,
            parseDOM: (el) => el.style.fontSize,
            renderDOM: (attrs) => {
              if (!attrs.fontSize) return {};
              let [value, unit] = parseSizeUnit(attrs.fontSize);
              if (Number.isNaN(value)) return {};
              unit = unit ? unit : this.options.defaults.unit;
              return { style: `font-size: ${value}${unit}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      /**
       * Set font size
       * @category Command
       * @param {FontSizeValue} fontSize - Size to apply (with optional unit)
       * @returns {Function} Command function
       * @example
       * // Set to 14pt
       * setFontSize('14pt')
       *
       * // Set to 18px
       * setFontSize('18px')
       *
       * // Set without unit (uses default)
       * setFontSize(16)
       * @note Automatically clamps to min/max values
       */
      setFontSize: (fontSize) => ({ chain }) => {
        let value, unit;
        if (typeof fontSize === "number") {
          value = fontSize;
          unit = null;
        } else {
          [value, unit] = parseSizeUnit(fontSize);
        }
        if (Number.isNaN(value)) {
          return false;
        }
        let { min: min2, max: max2, unit: defaultUnit } = this.options.defaults;
        value = minMax(Number(value), min2, max2);
        unit = unit ? unit : defaultUnit;
        return chain().setMark("textStyle", { fontSize: `${value}${unit}` }).run();
      },
      /**
       * Remove font size
       * @category Command
       * @returns {Function} Command function
       * @example
       * unsetFontSize()
       * @note Reverts to default document size
       */
      unsetFontSize: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const TextAlign = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      types: ["heading", "paragraph"],
      alignments: ["left", "center", "right", "justify"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseDOM: (el) => {
              const alignment = el.style.textAlign || this.options.defaultAlignment;
              const containsAlignment = this.options.alignments.includes(alignment);
              return containsAlignment ? alignment : this.options.defaultAlignment;
            },
            renderDOM: (attrs) => {
              if (attrs.textAlign === this.options.defaultAlignment) return {};
              const textAlign = attrs.textAlign === "both" ? "justify" : attrs.textAlign;
              if (!textAlign) return {};
              return { style: `text-align: ${textAlign}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (alignment) => ({ commands: commands2 }) => {
        const containsAlignment = this.options.alignments.includes(alignment);
        if (!containsAlignment) return false;
        return this.options.types.map((type) => commands2.updateAttributes(type, { textAlign: alignment })).every((result) => result);
      },
      unsetTextAlign: () => ({ commands: commands2 }) => {
        return this.options.types.map((type) => commands2.resetAttributes(type, "textAlign")).every((result) => result);
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
const TextIndent = Extension.create({
  name: "textIndent",
  addOptions() {
    return {
      types: ["heading", "paragraph"],
      defaults: {
        unit: "in",
        increment: 0.125
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textIndent: {
            default: null,
            parseDOM: (el) => el.style.textIndent,
            renderDOM: (attrs) => {
              if (!attrs.textIndent) return {};
              let [value, unit] = parseSizeUnit(attrs.textIndent);
              if (Number.isNaN(value) || !value) return {};
              unit = unit ? unit : this.options.defaults.unit;
              return { style: `margin-left: ${value}${unit}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextIndent: (indent) => ({ commands: commands2 }) => {
        if (!indent) return false;
        return this.options.types.map((type) => commands2.updateAttributes(type, { textIndent: indent })).every((result) => result);
      },
      unsetTextIndent: () => ({ commands: commands2 }) => {
        return this.options.types.map((type) => commands2.resetAttributes(type, "textIndent")).every((result) => result);
      },
      increaseTextIndent: () => ({ commands: commands2 }) => {
        return this.options.types.map((type) => {
          let { textIndent } = this.editor.getAttributes(type);
          if (!textIndent) {
            let { increment, unit: unit2 } = this.options.defaults;
            return commands2.updateAttributes(type, {
              textIndent: `${increment}${unit2}`
            });
          }
          let [value, unit] = parseSizeUnit(textIndent);
          value = value + this.options.defaults.increment;
          unit = unit ? unit : this.options.defaults.unit;
          if (Number.isNaN(value)) return false;
          return commands2.updateAttributes(type, {
            textIndent: `${value}${unit}`
          });
        }).every((result) => result);
      },
      decreaseTextIndent: () => ({ commands: commands2 }) => {
        return this.options.types.map((type) => {
          let { textIndent } = this.editor.getAttributes(type);
          if (!textIndent) return false;
          let [value, unit] = parseSizeUnit(textIndent);
          value = value - this.options.defaults.increment;
          unit = unit ? unit : this.options.defaults.unit;
          if (Number.isNaN(value)) return false;
          if (value <= 0) {
            return commands2.unsetTextIndent();
          }
          return commands2.updateAttributes(type, {
            textIndent: `${value}${unit}`
          });
        }).every((result) => result);
      }
    };
  }
});
const LineHeight = Extension.create({
  name: "lineHeight",
  addOptions() {
    return {
      /**
       * @typedef {Object} LineHeightOptions
       * @category Options
       * @property {string[]} [types=['heading', 'paragraph']] - Block types to add line height support to
       * @property {Object} [defaults] - Default configuration
       * @property {string} [defaults.unit=''] - Default unit for line height values
       */
      types: ["heading", "paragraph"],
      defaults: {
        unit: ""
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {LineHeightValue} [lineHeight] - Line height value
           */
          lineHeight: {
            default: null,
            parseDOM: (el) => el.style.lineHeight,
            renderDOM: (attrs) => {
              if (!attrs.lineHeight) return {};
              const lineHeightStyle = getLineHeightValueString(
                attrs.lineHeight,
                this.options.defaults.unit,
                attrs.spacing?.lineRule
              );
              return {
                style: `${lineHeightStyle}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      /**
       * Set line height for blocks
       * @category Command
       * @param {LineHeightValue} lineHeight - Line height to apply
       * @returns {Function} Command function
       * @example
       * // Set to 1.5x spacing
       * setLineHeight(1.5)
       *
       * // Set to 24px spacing
       * setLineHeight('24px')
       *
       * // Set to double spacing
       * setLineHeight(2)
       * @note Applies to paragraphs and headings
       */
      setLineHeight: (lineHeight) => ({ commands: commands2 }) => {
        if (!lineHeight) return false;
        return this.options.types.map((type) => commands2.updateAttributes(type, { lineHeight })).every((result) => result);
      },
      /**
       * Remove line height
       * @category Command
       * @returns {Function} Command function
       * @example
       * unsetLineHeight()
       * @note Reverts to default line spacing
       */
      unsetLineHeight: () => ({ commands: commands2 }) => {
        return this.options.types.map((type) => commands2.resetAttributes(type, "lineHeight")).every((result) => result);
      }
    };
  }
});
const FormatCommands = Extension.create({
  name: "formatCommands",
  addOptions() {
    return {};
  },
  addStorage() {
    return {
      /**
       * @private
       * @type {StoredStyle[]|null}
       */
      storedStyle: null
    };
  },
  addCommands() {
    return {
      /**
       * Clear all formatting (nodes and marks)
       * @category Command
       * @returns {Function} Command function
       * @example
       * clearFormat()
       * @note Removes all marks and resets nodes to default paragraph
       */
      clearFormat: () => ({ chain }) => {
        return chain().clearNodes().unsetAllMarks().run();
      },
      /**
       * Clear only mark formatting
       * @category Command
       * @returns {Function} Command function
       * @example
       * clearMarksFormat()
       * @note Removes bold, italic, underline, colors, etc. but preserves block structure
       */
      clearMarksFormat: () => ({ chain }) => {
        return chain().unsetAllMarks().run();
      },
      /**
       * Clear only node formatting
       * @category Command
       * @returns {Function} Command function
       * @example
       * clearNodesFormat()
       * @note Converts headings, lists, etc. to paragraphs but preserves text marks
       */
      clearNodesFormat: () => ({ chain }) => {
        return chain().clearNodes().run();
      },
      /**
       * Copy format from selection or apply copied format
       * @category Command
       * @returns {Function} Command function
       * @example
       * // First call: copy format from selection
       * copyFormat()
       *
       * // Second call: apply copied format to new selection
       * copyFormat()
       * @note Works like format painter - first click copies, second click applies
       */
      copyFormat: () => ({ chain }) => {
        if (!this.storage.storedStyle) {
          const marks = getMarksFromSelection(this.editor.state);
          this.storage.storedStyle = marks;
          return true;
        }
        if (!this.storage.storedStyle.length) {
          this.storage.storedStyle = null;
          return chain().clearFormat().run();
        }
        const storedMarks = this.storage.storedStyle;
        const processedMarks = [];
        storedMarks.forEach((mark) => {
          const { type, attrs } = mark;
          const { name } = type;
          if (name === "textStyle") {
            Object.keys(attrs).forEach((key) => {
              if (!attrs[key]) return;
              const attributes = {};
              attributes[key] = attrs[key];
              processedMarks.push({ name: key, attrs: attributes });
            });
          } else {
            processedMarks.push({ name, attrs });
          }
        });
        const marksToCommands = {
          bold: ["setBold", "unsetBold"],
          italic: ["setItalic", "unsetItalic"],
          underline: ["setUnderline", "unsetUnderline"],
          color: ["setColor", "setColor", null],
          fontSize: ["setFontSize", "unsetFontSize"],
          fontFamily: ["setFontFamily", "unsetFontFamily"]
        };
        let result = chain();
        Object.keys(marksToCommands).forEach((key) => {
          const [setCommand, unsetCommand, defaultParam] = marksToCommands[key];
          const markToApply = processedMarks.find((mark) => mark.name === key);
          const hasEmptyAttrs = markToApply?.attrs && markToApply?.attrs[key];
          let cmd = {};
          if (!markToApply && !hasEmptyAttrs) cmd = { command: unsetCommand, argument: defaultParam };
          else cmd = { command: setCommand, argument: markToApply.attrs[key] || defaultParam };
          result = result[cmd.command](cmd.argument);
        });
        this.storage.storedStyle = null;
        return result;
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.clearFormat()
    };
  }
});
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
class DropCursorView {
  constructor(editorView, options) {
    var _a;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
    let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node) {
          let nodeRect = node.getBoundingClientRect();
          let top2 = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          let halfWidth = this.width / 2 * scaleY;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - halfWidth, bottom: top2 + halfWidth };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      let halfWidth = this.width / 2 * scaleX;
      rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
      parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
      parentTop = rect2.top - parent.scrollTop * parentScaleY;
    }
    this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
    this.element.style.top = (rect.top - parentTop) / scaleY + "px";
    this.element.style.width = (rect.right - rect.left) / scaleX + "px";
    this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
  }
  scheduleRemoval(timeout2) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout2);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node && node.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (!this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
}
const DropCursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 2,
      class: void 0
    };
  },
  addPmPlugins() {
    return [dropCursor(this.options)];
  }
});
class GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc2, mapping) {
    let $pos = doc2.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new GapCursor(doc2.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search: for (; ; ) {
      if (!mustMove && GapCursor.valid($pos))
        return $pos;
      let pos = $pos.pos, next = null;
      for (let d = $pos.depth; ; d--) {
        let parent = $pos.node(d);
        if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);
          break;
        } else if (d == 0) {
          return null;
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      for (; ; ) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search;
          }
          break;
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      return null;
    }
  }
}
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
class GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new GapBookmark(mapping.map(this.pos));
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
}
function closedBefore($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.index(d), parent = $pos.node(d);
    if (index2 == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index2 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d = $pos.depth; d >= 0; d--) {
    let index2 = $pos.indexAfter(d), parent = $pos.node(d);
    if (index2 == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index2); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown: handleKeyDown$1,
      handleDOMEvents: { beforeinput }
    }
  });
}
const handleKeyDown$1 = keydownHandler({
  "ArrowLeft": arrow$3("horiz", -1),
  "ArrowRight": arrow$3("horiz", 1),
  "ArrowUp": arrow$3("vert", -1),
  "ArrowDown": arrow$3("vert", 1)
});
function arrow$3(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state, dispatch, view) {
    let sel = state.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment.from(insert[i].createAndFill(null, frag));
  let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));
  view.dispatch(tr);
  return false;
}
function drawGapCursor(state) {
  if (!(state.selection instanceof GapCursor))
    return null;
  let node = document.createElement("div");
  node.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: "gapcursor" })]);
}
const Gapcursor = Extension.create({
  name: "gapCursor",
  addPmPlugins() {
    return [gapCursor()];
  },
  extendNodeSchema(extension) {
    return {
      allowGapCursor: callOrGet(
        getExtensionConfigField(extension, "allowGapCursor", {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        })
      ) ?? null
    };
  }
});
const CollaborationCursor = Extension.create({
  name: "collaborationCursor",
  priority: 999,
  addOptions() {
    return {
      provider: null,
      user: {
        name: null,
        color: null
      }
    };
  },
  addStorage() {
    return {
      users: []
    };
  },
  addPmPlugins() {
    const { collaborationProvider: provider = null } = this.editor.options;
    if (!provider) return [];
    return [yCursorPlugin(provider.awareness, { cursorBuilder: customCursors })];
  }
});
const customCursors = (user) => {
  const cursor = document.createElement("span");
  cursor.classList.add("ProseMirror-yjs-cursor");
  cursor.setAttribute("style", `border-color: ${user.color}`);
  const userDiv = document.createElement("div");
  userDiv.setAttribute("style", `background-color: ${user.color}`);
  userDiv.insertBefore(document.createTextNode(user.name || user.email), null);
  cursor.insertBefore(userDiv, null);
  return cursor;
};
const AiMarkName = "aiMark";
const AiAnimationMarkName = "aiAnimationMark";
const AiLoaderNodeName = "aiLoaderNode";
const AiMark = Mark.create({
  name: AiMarkName,
  group: "ai",
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: { class: "sd-ai-highlight" }
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: AiMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [AiMarkName, Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  }
});
const AiAnimationMark = Mark.create({
  name: AiAnimationMarkName,
  group: "ai",
  inclusive: false,
  spanning: false,
  excludes: AiAnimationMarkName,
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        rendered: false
      },
      class: {
        default: null,
        rendered: true
      },
      dataMarkId: {
        default: null,
        rendered: true
      }
    };
  },
  parseDOM() {
    return [{ tag: AiAnimationMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [AiAnimationMarkName, Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  }
});
const dotsLoader = "data:image/svg+xml,%3csvg%20fill='hsla(278,%2077.40%25,%2020.80%25,%200.65)'%20viewBox='0%200%2024%2024'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='4'%20cy='12'%20r='0'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_lo66'%20begin='spinner_Aguh.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_z0Or'%20begin='spinner_lo66.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='4'%20cy='12'%20r='3'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_JsnR'%20begin='spinner_UHR2.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_Aguh'%20begin='spinner_JsnR.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='12'%20cy='12'%20r='3'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_hSjk'%20begin='spinner_OLMs.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_UHR2'%20begin='spinner_hSjk.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='20'%20cy='12'%20r='3'%3e%3canimate%20id='spinner_4v5M'%20begin='0;spinner_z0Or.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_OLMs'%20begin='spinner_4v5M.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3c/circle%3e%3c/svg%3e";
const AiLoaderNode = Node$1.create({
  name: AiLoaderNodeName,
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-ai-loader",
        contentEditable: "false",
        "aria-label": "AI loader node"
      }
    };
  },
  parseDOM() {
    return [{ tag: "span.sd-ai-loader" }];
  },
  renderDOM({ htmlAttributes }) {
    const span = document.createElement("span");
    Object.entries(Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)).forEach(
      ([k, v]) => span.setAttribute(k, v)
    );
    const img = document.createElement("img");
    img.src = dotsLoader;
    img.alt = "loading...";
    img.width = 100;
    img.height = 50;
    span.appendChild(img);
    return span;
  }
});
const AiPluginKey = new PluginKey("ai");
const AiPlugin = Extension.create({
  name: "ai",
  addCommands() {
    return {
      insertAiMark: () => ({ tr, dispatch }) => {
        const { selection } = tr;
        const { $from, $to } = selection;
        if ($from.pos === $to.pos) return false;
        tr.addMark(
          $from.pos,
          $to.pos,
          this.editor.schema.marks[AiMarkName].create({
            id: "ai-highlight"
          })
        );
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Remove selection before ai pulse styles
       */
      removeSelectionAfterAiPulse: () => ({ tr, dispatch, state }) => {
        const { selection } = tr;
        const { $to } = selection;
        tr.setSelection(state.selection.constructor.create(tr.doc, $to.pos, $to.pos));
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Update the AI highlights with custom styling
       * @remarks This is to avoid manipulating the DOM directly - use Prosemirror state. Avoids re-rendering the entire document
       * @param {String} className - The CSS class to add to the AI highlights
       * @returns {Boolean} - True if the highlight style was updated
       */
      updateAiHighlightStyle: (className) => ({ tr, dispatch }) => {
        tr.setMeta(AiPluginKey, { type: "updateStyle", className });
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Clear any custom styling from AI highlights
       * @returns {Boolean} - True if the highlight style was cleared
       */
      clearAiHighlightStyle: () => ({ tr, dispatch }) => {
        tr.setMeta(AiPluginKey, { type: "updateStyle", className: null });
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Remove all AI marks from the document
       * @param {String} markName - The name of the mark to remove - defaults to AiMarkName
       * Can also be used to remove the ai animation mark after streams are complete
       * @returns {Boolean} - True if the mark was removed, false otherwise
       */
      removeAiMark: (markName = AiMarkName) => ({ tr, dispatch, state }) => {
        const { doc: doc2 } = state;
        let markFound = false;
        doc2.descendants((node, pos) => {
          const { marks = [] } = node;
          const aiMark = marks.find((mark) => mark.type.name === markName);
          if (aiMark) {
            markFound = true;
            tr.removeMark(pos, pos + node.nodeSize, state.schema.marks[markName]);
          }
        });
        if (markFound) {
          if (dispatch) dispatch(tr);
          return true;
        }
        return false;
      },
      /**
       * Remove all AI nodes of a specific type from the document
       * @param {String} nodeName - The name of the node to remove
       * @returns {Boolean} - True if any nodes were removed, false otherwise
       */
      removeAiNode: (nodeName = AiLoaderNodeName) => ({ tr, dispatch, state }) => {
        const { doc: doc2 } = state;
        const positions = [];
        doc2.descendants((node, pos) => {
          if (node.type.name === nodeName) {
            positions.push(pos);
          }
        });
        if (positions.length === 0) {
          return false;
        }
        positions.sort((a, b) => b - a);
        positions.forEach((pos) => {
          const node = doc2.nodeAt(pos);
          if (node) {
            tr.delete(pos, pos + node.nodeSize);
          }
        });
        if (dispatch) dispatch(tr);
        return true;
      }
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    const aiPlugin = new Plugin({
      key: AiPluginKey,
      state: {
        init() {
          return {
            decorations: DecorationSet.empty,
            highlightColor: "#6366f1",
            // Indigo color, matches AiLayer
            customClass: null
            // Pulse animation class spot (later)
          };
        },
        apply(tr, oldState, _, newEditorState) {
          const meta = tr.getMeta(AiPluginKey);
          let customClass = oldState.customClass;
          if (meta && meta.type === "updateStyle") {
            customClass = meta.className;
          }
          if (tr.docChanged && customClass === "sd-ai-highlight-pulse") {
            let hasTextChanges = false;
            tr.steps.forEach((step) => {
              if (step.slice && step.slice.content.size > 0) {
                hasTextChanges = true;
              }
            });
            if (hasTextChanges) {
              customClass = null;
            }
          }
          if (!tr.docChanged && !meta) return oldState;
          const { decorations } = processAiHighlights(editor, newEditorState.doc, oldState.highlightColor, customClass) || {};
          const decorationSet = DecorationSet.create(newEditorState.doc, decorations);
          return {
            ...oldState,
            decorations: decorationSet,
            customClass
          };
        }
      },
      props: {
        decorations(state) {
          return this.getState(state).decorations;
        }
      }
    });
    return [aiPlugin];
  }
});
const processAiHighlights = (editor, doc2, highlightColor, customClass = null) => {
  const decorations = [];
  doc2.descendants((node, pos) => {
    const { marks = [] } = node;
    const aiMark = marks.find((mark) => mark.type.name === AiMarkName);
    if (aiMark) {
      const attrs = {
        style: `background-color: ${highlightColor}33; border-radius: 4px; transition: background-color 250ms ease;`,
        // 33 is 20% opacity in hex
        class: "sd-ai-highlight-element"
      };
      if (customClass) {
        attrs.class += ` ${customClass}`;
      }
      const deco = Decoration.inline(pos, pos + node.nodeSize, attrs);
      decorations.push(deco);
    }
  });
  return { decorations };
};
function getCursorPositionRelativeToContainer(view, eventLocation) {
  const { state, dom } = view;
  const { selection } = state;
  const containerRect = dom.getBoundingClientRect();
  let x, y;
  if (typeof eventLocation.clientX === "number" && typeof eventLocation.clientY === "number") {
    x = eventLocation.clientX - containerRect.left;
    y = eventLocation.clientY - containerRect.top;
  } else {
    const cursorCoords = view.coordsAtPos(selection.from);
    x = cursorCoords.left - containerRect.left;
    y = cursorCoords.top - containerRect.top;
  }
  return { left: x, top: y };
}
const SlashMenuPluginKey = new PluginKey("slashMenu");
const SlashMenu = Extension.create({
  name: "slashMenu",
  addPmPlugins() {
    if (this.editor.options?.disableContextMenu) {
      return [];
    }
    const editor = this.editor;
    let slashCooldown = false;
    let slashCooldownTimeout = null;
    const slashMenuPlugin = new Plugin({
      key: SlashMenuPluginKey,
      state: {
        init() {
          return {
            open: false,
            selected: null,
            anchorPos: null,
            menuPosition: null
          };
        },
        apply(tr, value) {
          const meta = tr.getMeta(SlashMenuPluginKey);
          if (!meta) return value;
          switch (meta.type) {
            case "open": {
              const pos = getCursorPositionRelativeToContainer(editor.view, meta);
              const menuPosition = {
                left: `${pos.left + 100}px`,
                top: `${pos.top + 28}px`
              };
              const newState = {
                ...value,
                open: true,
                anchorPos: meta.pos,
                menuPosition
              };
              editor.emit("slashMenu:open", { menuPosition });
              return newState;
            }
            case "select": {
              return { ...value, selected: meta.id };
            }
            case "close": {
              editor.emit("slashMenu:close");
              return { ...value, open: false, anchorPos: null };
            }
            default:
              return value;
          }
        }
      },
      view(editorView) {
        const updatePosition2 = () => {
          const state = SlashMenuPluginKey.getState(editorView.state);
          if (state.open) {
            editorView.dispatch(
              editorView.state.tr.setMeta(SlashMenuPluginKey, {
                type: "updatePosition"
              })
            );
          }
        };
        window.addEventListener("scroll", updatePosition2, true);
        window.addEventListener("resize", updatePosition2);
        return {
          destroy() {
            window.removeEventListener("scroll", updatePosition2, true);
            window.removeEventListener("resize", updatePosition2);
            if (slashCooldownTimeout) {
              clearTimeout(slashCooldownTimeout);
              slashCooldownTimeout = null;
            }
          }
        };
      },
      props: {
        handleKeyDown(view, event) {
          const pluginState = this.getState(view.state);
          if (event.key === "/" && slashCooldown) {
            return false;
          }
          if (event.key === "/" && !pluginState.open) {
            const { $cursor } = view.state.selection;
            if (!$cursor) return false;
            const isParagraph = $cursor.parent.type.name === "paragraph";
            if (!isParagraph) return false;
            const textBefore = $cursor.parent.textContent.slice(0, $cursor.parentOffset);
            const isEmptyOrAfterSpace = !textBefore || textBefore.endsWith(" ");
            if (!isEmptyOrAfterSpace) return false;
            event.preventDefault();
            slashCooldown = true;
            if (slashCooldownTimeout) clearTimeout(slashCooldownTimeout);
            slashCooldownTimeout = setTimeout(() => {
              slashCooldown = false;
              slashCooldownTimeout = null;
            }, 5e3);
            view.dispatch(
              view.state.tr.setMeta(SlashMenuPluginKey, {
                type: "open",
                pos: $cursor.pos
              })
            );
            return true;
          }
          if (pluginState.open && (event.key === "Escape" || event.key === "ArrowLeft")) {
            const { anchorPos } = pluginState;
            view.dispatch(
              view.state.tr.setMeta(SlashMenuPluginKey, {
                type: "close"
              })
            );
            if (anchorPos !== null) {
              const tr = view.state.tr.setSelection(
                view.state.selection.constructor.near(view.state.doc.resolve(anchorPos))
              );
              view.dispatch(tr);
              view.focus();
            }
            return true;
          }
          return false;
        }
      }
    });
    return this.editor.options.isHeadless ? [] : [slashMenuPlugin];
  }
});
const Document = Node$1.create({
  name: "doc",
  topNode: true,
  content: "block+",
  parseDOM() {
    return [{ tag: "doc" }];
  },
  renderDOM() {
    return ["doc", 0];
  },
  addAttributes() {
    return {
      /**
       * @private
       * @category Attribute
       * @param {Object} [attributes] - Internal document attributes
       */
      attributes: {
        rendered: false,
        "aria-label": "Document node"
      }
    };
  },
  addCommands() {
    return {
      /**
       * Get document statistics
       * @category Command
       * @returns {Function} Command function
       * @example
       * // Get word and character count
       * getDocumentStats()
       * @note Returns word count, character count, and paragraph count
       */
      getDocumentStats: () => ({ editor }) => {
        const text = editor.getText();
        const words = text.split(/\s+/).filter((word) => word.length > 0).length;
        const characters = text.length;
        const paragraphs = editor.state.doc.content.childCount;
        return {
          words,
          characters,
          paragraphs
        };
      },
      /**
       * Clear entire document
       * @category Command
       * @returns {Function} Command function
       * @example
       * clearDocument()
       * @note Replaces all content with an empty paragraph
       */
      clearDocument: () => ({ commands: commands2 }) => {
        return commands2.setContent("<p></p>");
      }
    };
  }
});
const Text = Node$1.create({
  name: "text",
  group: "inline",
  inline: true
});
const RunItem = Node$1.create({
  name: "run",
  group: "inline",
  content: "text*",
  inline: true,
  parseDOM() {
    return [{ tag: "run" }];
  },
  renderDOM() {
    return ["run", 0];
  },
  addAttributes() {
    return {
      attributes: {
        rendered: false,
        "aria-label": "Run node"
      }
    };
  }
});
const inputRegex$1 = /^\s*([-+*])\s$/;
const BulletList = Node$1.create({
  name: "bulletList",
  group: "block list",
  selectable: false,
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addOptions() {
    return {
      /**
       * @typedef {Object} BulletListOptions
       * @category Options
       * @property {string} [itemTypeName='listItem'] - Name of the list item node type
       * @property {Object} [htmlAttributes] - HTML attributes for the ul element
       * @property {boolean} [keepMarks=true] - Whether to preserve marks when splitting
       * @property {boolean} [keepAttributes=false] - Whether to preserve attributes when splitting
       */
      itemTypeName: "listItem",
      htmlAttributes: {
        "aria-label": "Bullet list node"
      },
      keepMarks: true,
      keepAttributes: false
    };
  },
  parseDOM() {
    return [{ tag: "ul" }];
  },
  renderDOM({ htmlAttributes }) {
    const attributes = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    return ["ul", attributes, 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [list-style-type='bullet'] - List style type for this list
       */
      "list-style-type": {
        default: "bullet",
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [listId] - Internal list identifier for numbering
       */
      listId: {
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking ID
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      /**
       * @private
       * @category Attribute
       * @param {Object} [attributes] - Additional attributes for the list
       */
      attributes: {
        rendered: false,
        keepOnSplit: true
      }
    };
  },
  addCommands() {
    return {
      /**
       * Toggle a bullet list at the current selection
       * @category Command
       * @returns {Function} Command function
       * @example
       * // Toggle bullet list on selected text
       * toggleBulletList()
       * @note Converts selected paragraphs to list items or removes list formatting
       */
      toggleBulletList: () => (params2) => {
        return toggleList(this.type)(params2);
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-8": () => {
        return this.editor.commands.toggleBulletList();
      }
    };
  },
  addInputRules() {
    return [
      new InputRule({
        match: inputRegex$1,
        handler: ({ state, range }) => {
          const $pos = state.selection.$from;
          const listItemType = state.schema.nodes.listItem;
          for (let depth = $pos.depth; depth >= 0; depth--) {
            if ($pos.node(depth).type === listItemType) {
              return null;
            }
          }
          const { tr } = state;
          tr.delete(range.from, range.to);
          ListHelpers.createNewList({
            listType: this.type,
            tr,
            editor: this.editor
          });
        }
      })
    ];
  }
});
const inputRegex = /^(\d+)\.\s$/;
const OrderedList = Node$1.create({
  name: "orderedList",
  group: "block list",
  selectable: false,
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addOptions() {
    return {
      itemTypeName: "listItem",
      htmlAttributes: {
        "aria-label": "Ordered list node"
      },
      keepMarks: true,
      keepAttributes: false,
      listStyleTypes: ["decimal", "lowerAlpha", "lowerRoman"]
    };
  },
  addAttributes() {
    return {
      order: {
        default: 1,
        parseDOM: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        },
        renderDOM: (attrs) => {
          return {
            start: attrs.order
          };
        }
      },
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      syncId: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-sync-id"),
        renderDOM: (attrs) => {
          if (!attrs.syncId) return {};
          return {
            "data-sync-id": attrs.syncId
          };
        }
        // rendered: false,
      },
      listId: {
        keepOnSplit: true,
        parseDOM: (elem) => elem.getAttribute("data-list-id"),
        renderDOM: (attrs) => {
          if (!attrs.listId) return {};
          return {
            "data-list-id": attrs.listId
          };
        }
      },
      "list-style-type": {
        default: "decimal",
        rendered: false
      },
      attributes: {
        rendered: false,
        keepOnSplit: true
      }
    };
  },
  parseDOM() {
    return [{ tag: "ol" }];
  },
  renderDOM({ htmlAttributes }) {
    const { start: start2, ...restAttributes } = htmlAttributes;
    return start2 === 1 ? ["ol", Attribute.mergeAttributes(this.options.htmlAttributes, restAttributes), 0] : ["ol", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => (params2) => {
        return toggleList(this.type)(params2);
      },
      restartListNodes: (followingNodes, pos) => ({ tr }) => {
        let currentNodePos = pos;
        const nodes = followingNodes.map((node) => {
          const resultNode = {
            node,
            pos: currentNodePos
          };
          currentNodePos += node.nodeSize;
          return resultNode;
        });
        nodes.forEach((item) => {
          const { pos: pos2 } = item;
          const newPos = tr.mapping.map(pos2);
          tr.setNodeMarkup(newPos, void 0, {});
        });
        return true;
      },
      /**
       * Updates ordered list style type when sink or lift `listItem`.
       * @example 1,2,3 -> a,b,c -> i,ii,iii -> 1,2,3 -> etc
       */
      updateOrderedListStyleType: () => ({ dispatch, tr }) => {
        let list = findParentNode((node) => node.type.name === this.name)(tr.selection);
        if (!list) {
          return true;
        }
        if (dispatch) {
          let listLevel = (list.depth - 1) / 2;
          let listStyleTypes = this.options.listStyleTypes;
          let listStyle = listStyleTypes[listLevel % listStyleTypes.length];
          let currentListStyle = list.node.attrs["list-style-type"];
          let nodeAtPos = tr.doc.nodeAt(list.pos);
          if (currentListStyle !== listStyle && nodeAtPos.eq(list.node)) {
            tr.setNodeMarkup(list.pos, void 0, {
              ...list.node.attrs,
              ...{
                "list-style-type": listStyle
              }
            });
          }
        }
        return true;
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-7": () => {
        return this.editor.commands.toggleOrderedList();
      }
    };
  },
  addInputRules() {
    return [
      new InputRule({
        match: inputRegex,
        handler: ({ state, range }) => {
          const $pos = state.selection.$from;
          const listItemType = state.schema.nodes.listItem;
          for (let depth = $pos.depth; depth >= 0; depth--) {
            if ($pos.node(depth).type === listItemType) {
              return null;
            }
          }
          const { tr } = state;
          tr.delete(range.from, range.to);
          ListHelpers.createNewList({
            listType: this.type,
            tr,
            editor: this.editor
          });
        }
      })
    ];
  }
});
const CustomSelectionPluginKey = new PluginKey("CustomSelection");
const handleClickOutside = (event, editor) => {
  const editorElem = editor?.options?.element;
  if (!editorElem) return;
  const isInsideEditor = editorElem?.contains(event.target);
  if (!isInsideEditor) {
    editor.setOptions({
      focusTarget: event.target
    });
  } else {
    editor.setOptions({
      focusTarget: null
    });
  }
};
function getFocusMeta(tr) {
  return tr.getMeta(CustomSelectionPluginKey);
}
function setFocusMeta(tr, value) {
  return tr.setMeta(CustomSelectionPluginKey, value);
}
function getFocusState(state) {
  return CustomSelectionPluginKey.getState(state);
}
const isToolbarInput = (target) => {
  return !!target?.closest(".button-text-input") || target?.classList?.contains("button-text-input");
};
const isToolbarButton = (target) => {
  return !!target?.closest(".toolbar-button") || target?.classList?.contains("toolbar-button");
};
const CustomSelection = Extension.create({
  name: "customSelection",
  addPmPlugins() {
    const editor = this.editor;
    const customSelectionPlugin = new Plugin({
      key: CustomSelectionPluginKey,
      state: {
        init: () => ({
          focused: false,
          preservedSelection: null,
          showVisualSelection: false
        }),
        apply: (tr, value) => {
          const meta = getFocusMeta(tr);
          if (meta !== void 0) {
            return { ...value, ...meta };
          }
          return value;
        }
      },
      view: () => {
        const clickHandler = (event) => handleClickOutside(event, editor);
        document?.addEventListener("mousedown", clickHandler);
        return {
          destroy: () => {
            document?.removeEventListener("mousedown", clickHandler);
          }
        };
      },
      props: {
        handleDOMEvents: {
          contextmenu: (view, event) => {
            event.preventDefault();
            const { selection } = view.state;
            if (!selection.empty) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: selection,
                  showVisualSelection: true
                })
              );
            }
            setTimeout(() => {
              view.focus();
            }, 0);
            return false;
          },
          mousedown: (view, event) => {
            if (event.button === 2) {
              event.preventDefault();
              const { selection: selection2 } = view.state;
              if (!selection2.empty) {
                view.dispatch(
                  setFocusMeta(view.state.tr, {
                    focused: true,
                    preservedSelection: selection2,
                    showVisualSelection: true
                  })
                );
                this.editor.setOptions({
                  lastSelection: selection2,
                  preservedSelection: selection2
                });
              }
              return false;
            }
            const { selection } = view.state;
            const target = event.target;
            const isElement2 = target instanceof Element;
            const isToolbarBtn = isElement2 && isToolbarButton(target);
            const isToolbarInp = isElement2 && isToolbarInput(target);
            this.editor.setOptions({
              focusTarget: target
            });
            if (isToolbarInp && !selection.empty) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: selection,
                  showVisualSelection: true
                })
              );
              this.editor.setOptions({
                lastSelection: selection,
                preservedSelection: selection
              });
              return false;
            }
            if (isToolbarBtn && !isToolbarInp) {
              if (!selection.empty) {
                this.editor.setOptions({
                  lastSelection: selection
                });
                view.dispatch(
                  setFocusMeta(view.state.tr, {
                    focused: true,
                    preservedSelection: selection,
                    showVisualSelection: true
                  })
                );
              }
              return false;
            }
            if (!isToolbarBtn && !isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false
                })
              );
              if (!selection.empty && !this.editor.options.element?.contains(target)) {
                this.editor.setOptions({
                  lastSelection: selection
                });
                const clearSelectionTr = view.state.tr.setSelection(TextSelection.create(view.state.doc, 0));
                view.dispatch(clearSelectionTr);
              }
            }
          },
          focus: (view) => {
            const target = this.editor.options.focusTarget;
            const isElement2 = target instanceof Element;
            const isToolbarBtn = isElement2 && isToolbarButton(target);
            const isToolbarInp = isElement2 && isToolbarInput(target);
            if (!isToolbarBtn && !isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false
                })
              );
            }
          },
          blur: (view) => {
            const target = this.editor.options.focusTarget;
            const isElement2 = target instanceof Element;
            const isToolbarBtn = isElement2 && isToolbarButton(target);
            const isToolbarInp = isElement2 && isToolbarInput(target);
            const state = getFocusState(view.state);
            if (isToolbarBtn || isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: state.preservedSelection || view.state.selection,
                  showVisualSelection: true
                })
              );
            } else {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false
                })
              );
            }
          }
        },
        decorations: (state) => {
          const { selection, doc: doc2 } = state;
          const focusState = getFocusState(state);
          const shouldShowSelection = focusState.showVisualSelection && (focusState.preservedSelection || !selection.empty && focusState.focused);
          if (!shouldShowSelection) {
            return null;
          }
          const targetSelection = focusState.preservedSelection || selection;
          if (targetSelection.empty) {
            return null;
          }
          return DecorationSet.create(doc2, [
            Decoration.inline(targetSelection.from, targetSelection.to, {
              class: "sd-custom-selection"
            })
          ]);
        }
      }
    });
    return [customSelectionPlugin];
  },
  addCommands() {
    return {
      /**
       * Restore the preserved selection
       * @category Command
       * @returns {Function} Command function
       * @example
       * // Restore selection after toolbar interaction
       * restorePreservedSelection()
       * @note Used internally to maintain selection when interacting with toolbar
       */
      restorePreservedSelection: () => ({ tr, state }) => {
        const focusState = getFocusState(state);
        if (focusState.preservedSelection) {
          return tr.setSelection(focusState.preservedSelection);
        }
        const lastSelection = this.editor.options.lastSelection;
        if (lastSelection) {
          return tr.setSelection(lastSelection);
        }
        return tr;
      }
    };
  }
});
const getLinkedStyle = (styleId, styles = []) => {
  const linkedStyle = styles.find((style) => style.id === styleId);
  const basedOn = linkedStyle?.definition?.attrs?.basedOn;
  const basedOnStyle = styles.find((style) => style.id === basedOn);
  return { linkedStyle, basedOnStyle };
};
const getSpacingStyle = (spacing) => {
  const { lineSpaceBefore, lineSpaceAfter, line, lineRule } = spacing;
  return {
    "margin-top": lineSpaceBefore + "px",
    "margin-bottom": lineSpaceAfter + "px",
    ...getLineHeightValueString(line, "", lineRule, true)
  };
};
const getSpacingStyleString = (spacing) => {
  const { lineSpaceBefore, lineSpaceAfter, line } = spacing;
  return `
    ${lineSpaceBefore ? `margin-top: ${lineSpaceBefore}px;` : ""}
    ${lineSpaceAfter ? `margin-bottom: ${lineSpaceAfter}px;` : ""}
    ${line ? getLineHeightValueString(line, "") : ""}
  `.trim();
};
const getMarksStyle = (attrs) => {
  let styles = "";
  for (const attr of attrs) {
    switch (attr.type) {
      case "bold":
        styles += `font-weight: bold; `;
        break;
      case "italic":
        styles += `font-style: italic; `;
        break;
      case "underline":
        styles += `text-decoration: underline; `;
        break;
      case "highlight":
        styles += `background-color: ${attr.attrs.color}; `;
        break;
      case "textStyle":
        const { fontFamily, fontSize } = attr.attrs;
        styles += `${fontFamily ? `font-family: ${fontFamily};` : ""} ${fontSize ? `font-size: ${fontSize};` : ""}`;
    }
  }
  return styles.trim();
};
const getQuickFormatList = (editor) => {
  if (!editor?.converter) return [];
  const styles = editor.converter.linkedStyles || [];
  return styles.filter((style) => {
    return style.type === "paragraph" && style.definition.attrs;
  }).sort((a, b) => {
    return a.definition.attrs?.name.localeCompare(b.definition.attrs?.name);
  });
};
const generateLinkedStyleString = (linkedStyle, basedOnStyle, node, parent, includeSpacing = true) => {
  if (!linkedStyle?.definition?.styles) return "";
  const markValue = {};
  const linkedDefinitionStyles = { ...linkedStyle.definition.styles };
  const basedOnDefinitionStyles = { ...basedOnStyle?.definition?.styles };
  const resultStyles = { ...linkedDefinitionStyles };
  if (!linkedDefinitionStyles["font-size"] && basedOnDefinitionStyles["font-size"]) {
    resultStyles["font-size"] = basedOnDefinitionStyles["font-size"];
  }
  if (!linkedDefinitionStyles["text-transform"] && basedOnDefinitionStyles["text-transform"]) {
    resultStyles["text-transform"] = basedOnDefinitionStyles["text-transform"];
  }
  Object.entries(resultStyles).forEach(([k, value]) => {
    const key = kebabCase(k);
    const flattenedMarks = [];
    node?.marks?.forEach((n) => {
      if (n.type.name === "textStyle") {
        Object.entries(n.attrs).forEach(([styleKey, value2]) => {
          const parsedKey = kebabCase(styleKey);
          if (!value2) return;
          flattenedMarks.push({ key: parsedKey, value: value2 });
        });
        return;
      }
      flattenedMarks.push({ key: n.type.name, value: n.attrs[key] });
    });
    const mark = flattenedMarks.find((n) => n.key === key);
    const hasParentIndent = Object.keys(parent?.attrs?.indent || {});
    const hasParentSpacing = Object.keys(parent?.attrs?.spacing || {});
    const listTypes = ["orderedList", "listItem"];
    if (!mark) {
      if (key === "spacing" && includeSpacing && !hasParentSpacing) {
        const space = getSpacingStyle(value);
        Object.entries(space).forEach(([k2, v]) => {
          markValue[k2] = v;
        });
      } else if (key === "indent" && includeSpacing && !hasParentIndent) {
        const { leftIndent, rightIndent, firstLine } = value;
        if (leftIndent) markValue["margin-left"] = leftIndent + "px";
        if (rightIndent) markValue["margin-right"] = rightIndent + "px";
        if (firstLine) markValue["text-indent"] = firstLine + "px";
      } else if (key === "bold" && node) {
        const val = value?.value;
        if (!listTypes.includes(node.type.name) && val !== "0") {
          markValue["font-weight"] = "bold";
        }
      } else if (key === "text-transform" && node) {
        if (!listTypes.includes(node.type.name)) {
          markValue[key] = value;
        }
      } else if (key === "font-size" && node) {
        if (!listTypes.includes(node.type.name)) {
          markValue[key] = value;
        }
      } else if (key === "color" && node) {
        if (!listTypes.includes(node.type.name)) {
          markValue[key] = value;
        }
      } else if (typeof value === "string") {
        markValue[key] = value;
      }
    }
  });
  const final = Object.entries(markValue).map(([key, value]) => `${key}: ${value}`).join(";");
  return final;
};
const applyLinkedStyleToTransaction = (tr, editor, style) => {
  if (!style) return false;
  let selection = tr.selection;
  const state = editor.state;
  const focusState = CustomSelectionPluginKey.getState(state);
  if (selection.empty && focusState?.preservedSelection) {
    selection = focusState.preservedSelection;
    tr.setSelection(selection);
  } else if (selection.empty && editor.options.lastSelection) {
    selection = editor.options.lastSelection;
    tr.setSelection(selection);
  }
  const { from: from2, to } = selection;
  const getCleanParagraphAttrs = (node) => {
    const cleanAttrs = {};
    const preservedAttrs = ["id", "class"];
    preservedAttrs.forEach((attr) => {
      if (node.attrs[attr] !== void 0) {
        cleanAttrs[attr] = node.attrs[attr];
      }
    });
    cleanAttrs.styleId = style.id;
    return cleanAttrs;
  };
  const clearFormattingMarks = (startPos, endPos) => {
    tr.doc.nodesBetween(startPos, endPos, (node, pos) => {
      if (node.isText && node.marks.length > 0) {
        const marksToRemove = [
          "textStyle",
          "bold",
          "italic",
          "underline",
          "strike",
          "subscript",
          "superscript",
          "highlight"
        ];
        node.marks.forEach((mark) => {
          if (marksToRemove.includes(mark.type.name)) {
            tr.removeMark(pos, pos + node.nodeSize, mark);
          }
        });
      }
      return true;
    });
  };
  if (from2 === to) {
    let pos = from2;
    let paragraphNode = tr.doc.nodeAt(from2);
    if (paragraphNode?.type.name !== "paragraph") {
      const parentNode2 = findParentNode((node) => node.type.name === "paragraph")(selection);
      if (!parentNode2) return false;
      pos = parentNode2.pos;
      paragraphNode = parentNode2.node;
    }
    clearFormattingMarks(pos + 1, pos + paragraphNode.nodeSize - 1);
    tr.setNodeMarkup(pos, void 0, getCleanParagraphAttrs(paragraphNode));
    return true;
  }
  const paragraphPositions = [];
  tr.doc.nodesBetween(from2, to, (node, pos) => {
    if (node.type.name === "paragraph") {
      paragraphPositions.push({ node, pos });
    }
    return true;
  });
  paragraphPositions.forEach(({ node, pos }) => {
    clearFormattingMarks(pos + 1, pos + node.nodeSize - 1);
    tr.setNodeMarkup(pos, void 0, getCleanParagraphAttrs(node));
  });
  return true;
};
const LinkedStylesPluginKey = new PluginKey("linkedStyles");
const createLinkedStylesPlugin = (editor) => {
  return new Plugin({
    key: LinkedStylesPluginKey,
    state: {
      init() {
        if (!editor.converter || editor.options.mode !== "docx") return {};
        const styles = editor.converter?.linkedStyles || [];
        return {
          styles,
          decorations: generateDecorations(editor.state, styles)
        };
      },
      apply(tr, prev, oldEditorState, newEditorState) {
        if (!editor.converter || editor.options.mode !== "docx") return { ...prev };
        let decorations = prev.decorations || DecorationSet.empty;
        if (tr.docChanged) {
          const styles = LinkedStylesPluginKey.getState(editor.state).styles;
          decorations = generateDecorations(newEditorState, styles);
        }
        return { ...prev, decorations };
      }
    },
    props: {
      decorations(state) {
        return LinkedStylesPluginKey.getState(state)?.decorations;
      }
    }
  });
};
const generateDecorations = (state, styles) => {
  const decorations = [];
  let lastStyleId = null;
  const doc2 = state?.doc;
  doc2.descendants((node, pos) => {
    const { name } = node.type;
    if (node?.attrs?.styleId) lastStyleId = node.attrs.styleId;
    if (name === "paragraph" && !node.attrs?.styleId) lastStyleId = null;
    if (name !== "text" && name !== "listItem" && name !== "orderedList") return;
    for (const mark of node.marks) {
      if (mark.type.name === "textStyle" && mark.attrs.styleId) {
        lastStyleId = mark.attrs.styleId;
      }
    }
    const { linkedStyle, basedOnStyle } = getLinkedStyle(lastStyleId, styles);
    if (!linkedStyle) return;
    const $pos = state.doc.resolve(pos);
    const parent = $pos.parent;
    const styleString = generateLinkedStyleString(linkedStyle, basedOnStyle, node, parent);
    if (!styleString) return;
    const decoration = Decoration.inline(pos, pos + node.nodeSize, { style: styleString });
    decorations.push(decoration);
  });
  return DecorationSet.create(doc2, decorations);
};
const LinkedStyles = Extension.create({
  name: "linkedStyles",
  priority: 1,
  // We need this plugin to run before the list plugins
  addPmPlugins() {
    return [createLinkedStylesPlugin(this.editor)];
  },
  addCommands() {
    return {
      setLinkedStyle: (style) => (params2) => {
        const { tr } = params2;
        return applyLinkedStyleToTransaction(tr, this.editor, style);
      },
      setStyleById: (styleId) => (params2) => {
        const { state, tr } = params2;
        const pluginState = LinkedStylesPluginKey.getState(state);
        if (!pluginState) return false;
        const style = pluginState.styles?.find((s) => s.id === styleId);
        if (!style) return false;
        return applyLinkedStyleToTransaction(tr, this.editor, style);
      }
    };
  },
  addHelpers() {
    return {
      getStyles: () => {
        const styles = LinkedStylesPluginKey.getState(this.editor.state)?.styles || [];
        return styles;
      },
      getStyleById: (styleId) => {
        const styles = this.getStyles();
        return styles.find((s) => s.id === styleId);
      },
      getLinkedStyleString: (styleId) => {
        const styles = this.editor.helpers.linkedStyles.getStyles();
        const style = styles.find((s) => s.id === styleId);
        if (!style) return "";
        return generateLinkedStyleString(style);
      }
    };
  }
});
const generateOrderedListIndex = ({ listLevel, lvlText, listNumberingType, customFormat }) => {
  const handler = listIndexMap[listNumberingType];
  return handler ? handler(listLevel, lvlText, customFormat) : null;
};
const handleDecimal = (path, lvlText) => generateNumbering(path, lvlText, String);
const handleRoman = (path, lvlText) => generateNumbering(path, lvlText, intToRoman);
const handleLowerRoman = (path, lvlText) => handleRoman(path, lvlText).toLowerCase();
const handleLowerAlpha = (path, lvlText) => handleAlpha(path, lvlText).toLowerCase();
const handleAlpha = (path, lvlText) => generateNumbering(path, lvlText, (p) => intToAlpha(p));
const handleOrdinal = (path, lvlText) => generateNumbering(path, lvlText, ordinalFormatter);
const handleCustom = (path, lvlText, customFormat) => generateFromCustom(path, lvlText, customFormat);
const listIndexMap = {
  decimal: handleDecimal,
  lowerRoman: handleLowerRoman,
  upperRoman: handleRoman,
  lowerLetter: handleLowerAlpha,
  upperLetter: handleAlpha,
  ordinal: handleOrdinal,
  custom: handleCustom
};
const createNumbering = (values, lvlText) => {
  return values.reduce((acc, value, index2) => {
    return value > 9 ? acc.replace(/^0/, "").replace(`%${index2 + 1}`, value) : acc.replace(`%${index2 + 1}`, value);
  }, lvlText);
};
const generateNumbering = (path, lvlText, formatter) => {
  const formattedValues = path.map(formatter);
  return createNumbering(formattedValues, lvlText);
};
const ordinalFormatter = (level) => {
  const suffixes = ["th", "st", "nd", "rd"];
  const value = level % 100;
  const suffix = suffixes[(value - 20) % 10] || suffixes[value] || suffixes[0];
  const p = level + suffix;
  return p;
};
const generateFromCustom = (path, lvlText, customFormat) => {
  if (customFormat !== "001, 002, 003, ...") return generateNumbering(path, lvlText, String);
  const match = customFormat.match(/(\d+)/);
  if (!match) throw new Error("Invalid format string: no numeric pattern found");
  const sample = match[1];
  const digitCount = sample.length;
  const index2 = path.pop();
  return String(index2).padStart(digitCount, "0");
};
const intToRoman = (num) => {
  const romanNumeralMap = [
    { value: 1e3, numeral: "M" },
    { value: 900, numeral: "CM" },
    { value: 500, numeral: "D" },
    { value: 400, numeral: "CD" },
    { value: 100, numeral: "C" },
    { value: 90, numeral: "XC" },
    { value: 50, numeral: "L" },
    { value: 40, numeral: "XL" },
    { value: 10, numeral: "X" },
    { value: 9, numeral: "IX" },
    { value: 5, numeral: "V" },
    { value: 4, numeral: "IV" },
    { value: 1, numeral: "I" }
  ];
  let result = "";
  for (const { value, numeral } of romanNumeralMap) {
    while (num >= value) {
      result += numeral;
      num -= value;
    }
  }
  return result;
};
const intToAlpha = (num) => {
  let result = "";
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  while (num > 0) {
    let index2 = (num - 1) % 26;
    result = alphabet[index2] + result;
    num = Math.floor((num - 1) / 26);
  }
  return result;
};
const MARKER_PADDING = 6;
const MARKER_OFFSET_RIGHT = 4;
const MIN_MARKER_WIDTH = 20;
const POINT_TO_PIXEL_CONVERSION_FACTOR = 1.33;
const DEFAULT_FONT_FAMILY = "Arial, sans-serif";
const DEFAULT_FONT_SIZE = "10pt";
const activeListItemNodeViews = /* @__PURE__ */ new Set();
class ListItemNodeView {
  constructor(node, getPos, decorations, editor) {
    __privateAdd(this, _ListItemNodeView_instances);
    __publicField(this, "handleNumberingClick", () => {
    });
    this.node = node;
    this.editor = editor;
    this.decorations = decorations;
    this.view = editor.view;
    this.getPos = getPos;
    activeListItemNodeViews.add(this);
    __privateMethod(this, _ListItemNodeView_instances, init_fn2).call(this);
  }
  refreshIndentStyling() {
    const { attrs } = this.node;
    const { styleId, numId, level, indent: inlineIndent } = attrs;
    const defs = getListItemStyleDefinitions({ styleId, node: this.node, numId, level, editor: this.editor });
    const visibleIndent = getVisibleIndent(defs.stylePpr, defs.numDefPpr, inlineIndent);
    const lvlJc = defs.numLvlJs?.attributes?.["w:val"] || "left";
    const contentLeft = visibleIndent.left || 0;
    const hanging = visibleIndent.hanging || 0;
    const handlers2 = {
      right: () => {
        const calculatedWidth = calculateMarkerWidth(this.dom, this.numberingDOM, this.editor);
        const minMarkerWidth = Math.max(calculatedWidth, MIN_MARKER_WIDTH);
        const effectiveHanging = Math.max(hanging, minMarkerWidth);
        const markerLeft = contentLeft - effectiveHanging - MARKER_OFFSET_RIGHT;
        this.contentDOM.style.marginLeft = `${contentLeft}px`;
        this.numberingDOM.style.left = `${markerLeft}px`;
        this.numberingDOM.style.width = `${effectiveHanging}px`;
        this.numberingDOM.style.textAlign = "right";
      },
      left: () => {
        const calculatedWidth = calculateMarkerWidth(this.dom, this.numberingDOM, this.editor);
        const minMarkerWidth = Math.max(calculatedWidth, MIN_MARKER_WIDTH);
        let markerLeft = contentLeft - hanging;
        if (markerLeft === contentLeft) {
          markerLeft -= minMarkerWidth;
        } else if (minMarkerWidth > hanging) {
          const diff = minMarkerWidth - hanging;
          markerLeft -= diff;
        }
        this.contentDOM.style.marginLeft = `${contentLeft}px`;
        this.numberingDOM.style.left = `${markerLeft}px`;
        this.numberingDOM.style.width = "";
        this.numberingDOM.style.textAlign = "";
      }
    };
    const handleStyles = handlers2[lvlJc] ?? handlers2.left;
    handleStyles();
  }
  update(node, decorations) {
    this.node = node;
    this.decorations = decorations;
    const { fontSize, fontFamily, lineHeight } = getTextStyleMarksFromLinkedStyles({
      node,
      pos: this.getPos(),
      editor: this.editor
    });
    this.dom.style.fontSize = fontSize;
    this.dom.style.fontFamily = fontFamily || "inherit";
    this.dom.style.lineHeight = lineHeight || "";
  }
  destroy() {
    activeListItemNodeViews.delete(this);
    this.numberingDOM.removeEventListener("click", this.handleNumberingClick);
  }
}
_ListItemNodeView_instances = new WeakSet();
init_fn2 = function() {
  const { attrs } = this.node;
  const { listLevel, listNumberingType, lvlText, numId, level, customFormat } = attrs;
  let orderMarker = "";
  if (listLevel) {
    if (listNumberingType !== "bullet") {
      orderMarker = generateOrderedListIndex({
        listLevel,
        lvlText,
        listNumberingType,
        customFormat
      });
    } else {
      orderMarker = docxNumberigHelpers.normalizeLvlTextChar(lvlText);
    }
  }
  const pos = this.getPos();
  const { fontSize, fontFamily, lineHeight } = getTextStyleMarksFromLinkedStyles({
    node: this.node,
    pos,
    editor: this.editor
  });
  this.dom = document.createElement("li");
  this.dom.className = "sd-editor-list-item-node-view";
  this.dom.style.fontSize = fontSize;
  this.dom.style.fontFamily = fontFamily ? fontFamily : "inherit";
  this.dom.style.lineHeight = lineHeight || "";
  this.dom.setAttribute("data-marker-type", orderMarker);
  this.dom.setAttribute("data-num-id", numId);
  this.dom.setAttribute("data-list-level", JSON.stringify(listLevel));
  this.dom.setAttribute("data-list-numbering-type", listNumberingType);
  this.dom.setAttribute("data-level", level);
  this.numberingDOM = document.createElement("span");
  this.numberingDOM.className = "sd-editor-list-item-numbering";
  this.numberingDOM.textContent = orderMarker;
  this.numberingDOM.setAttribute("contenteditable", "false");
  this.numberingDOM.addEventListener("click", this.handleNumberingClick);
  this.contentDOM = document.createElement("div");
  this.contentDOM.className = "sd-editor-list-item-content-dom";
  this.dom.appendChild(this.numberingDOM);
  this.dom.appendChild(this.contentDOM);
  this.refreshIndentStyling();
};
function refreshAllListItemNodeViews() {
  activeListItemNodeViews.forEach((nodeView) => {
    try {
      nodeView.refreshIndentStyling();
    } catch (error) {
      console.error("Error refreshing list item node view:", error);
      activeListItemNodeViews.delete(nodeView);
    }
  });
}
function getListItemTextStyleMarks(listItem, markType) {
  let textStyleMarks = [];
  let attrs = {};
  listItem.forEach((childNode) => {
    if (childNode.type.name !== "paragraph") return;
    attrs.lineHeight = childNode.attrs.lineHeight;
    childNode.forEach((textNode) => {
      let isTextNode = textNode.type.name === "text";
      let hasTextStyleMarks = markType.isInSet(textNode.marks);
      if (isTextNode && hasTextStyleMarks) {
        let marks = textNode.marks.filter((mark) => mark.type === markType);
        textStyleMarks.push(...marks);
      }
    });
  });
  return {
    marks: textStyleMarks,
    attrs
  };
}
function getTextStyleMarksFromLinkedStyles({ node, pos, editor }) {
  const { font: defaultFont, size: defaultSize } = getStylesFromLinkedStyles({ node, pos, editor });
  const textStyleType = getMarkType("textStyle", editor.schema);
  const { marks: allMarks, attrs: allAttrs } = getListItemTextStyleMarks(node, textStyleType);
  const styleMarks = allMarks.filter((m) => m.type === textStyleType);
  const sizeMark = styleMarks.find((m) => m.attrs.fontSize);
  const familyMark = styleMarks.find((m) => m.attrs.fontFamily);
  const lineHeight = allAttrs.lineHeight;
  let fontSize = sizeMark ? (() => {
    const [value, unit = "pt"] = parseSizeUnit(sizeMark.attrs.fontSize);
    return Number.isNaN(value) ? defaultSize : `${value}${unit}`;
  })() : defaultSize;
  let fontFamily = familyMark?.attrs.fontFamily ?? defaultFont;
  const firstChild = node.firstChild;
  const hasOnlyOnePar = node.childCount === 1 && firstChild?.type.name === "paragraph";
  if (hasOnlyOnePar) {
    const par = firstChild;
    const parFirstChild = par?.firstChild;
    if (par?.childCount === 1 && parFirstChild?.type.name === "fieldAnnotation") {
      const aFontSize = parFirstChild.attrs.fontSize;
      const aFontFamily = parFirstChild.attrs.fontFamily;
      if (!sizeMark && aFontSize) fontSize = aFontSize;
      if (!familyMark && aFontFamily) fontFamily = aFontFamily;
    }
  }
  return { fontSize, fontFamily, lineHeight };
}
const getStylesFromLinkedStyles = ({ node, pos, editor }) => {
  const { state } = editor.view;
  const linkedStyles = LinkedStylesPluginKey.getState(state)?.decorations;
  const decorationsInPlace = linkedStyles?.find(pos, pos + node.nodeSize);
  const predicates = [
    (style2) => style2.includes("font-size") && style2.includes("font-family"),
    (style2) => style2.includes("font-size"),
    (style2) => style2.includes("font-family")
  ];
  let styleDeco;
  for (const predicateFn of predicates) {
    styleDeco = decorationsInPlace?.find((dec) => {
      const style2 = dec.type.attrs?.style || "";
      return style2 && predicateFn(style2);
    });
    if (styleDeco) break;
  }
  const style = styleDeco?.type.attrs?.style;
  const stylesArray = style?.split(";") || [];
  const fontSizeFromStyles = stylesArray.find((s) => s.includes("font-size"))?.split(":")[1].trim();
  const fontFamilyFromStyles = stylesArray.find((s) => s.includes("font-family"))?.split(":")[1].trim();
  return {
    font: fontFamilyFromStyles,
    size: fontSizeFromStyles
  };
};
const getVisibleIndent = (stylePpr, numDefPpr, inlineIndent) => {
  const styleIndentTag = stylePpr?.elements?.find((el) => el.name === "w:ind") || {};
  const styleIndent = parseIndentElement(styleIndentTag);
  const numDefIndentTag = numDefPpr?.elements?.find((el) => el.name === "w:ind") || {};
  const numDefIndent = parseIndentElement(numDefIndentTag);
  const indent = combineIndents(styleIndent, numDefIndent);
  const result = combineIndents(indent, inlineIndent);
  return result;
};
function calculateMarkerWidth(dom, numberingDOM, editor, { withPadding = true } = {}) {
  const markerText = numberingDOM.textContent || "";
  const fontSize = dom.style.fontSize || DEFAULT_FONT_SIZE;
  const fontValue = dom.style.fontFamily;
  const fontFamily = fontValue && fontValue !== "inherit" ? fontValue : DEFAULT_FONT_FAMILY;
  if (!markerText.trim()) return 0;
  try {
    if (editor?.options?.isHeadless) return 0;
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    const fontSizePx = fontSize.includes("pt") ? Number.parseFloat(fontSize) * POINT_TO_PIXEL_CONVERSION_FACTOR : Number.parseFloat(fontSize);
    context.font = `${fontSizePx}px ${fontFamily}`;
    const textWidth = context.measureText(markerText).width;
    const resultWidth = withPadding ? Math.ceil(textWidth + MARKER_PADDING) : Math.ceil(textWidth);
    return resultWidth;
  } catch {
    return 0;
  }
}
const orderedListSyncPluginKey = new PluginKey("orderedListSync");
function orderedListSync(editor) {
  let hasInitialized = false;
  const docx = editor.converter.convertedXml;
  return new Plugin({
    key: orderedListSyncPluginKey,
    appendTransaction(transactions, oldState, newState) {
      const updateNodeViews = transactions.some((tr2) => tr2.getMeta("updatedListItemNodeViews"));
      if (updateNodeViews || !hasInitialized) refreshAllListItemNodeViews();
      const isFromPlugin = transactions.some((tr2) => tr2.getMeta("orderedListSync"));
      if (isFromPlugin || !transactions.some((tr2) => tr2.docChanged)) {
        return null;
      }
      hasInitialized = true;
      const tr = newState.tr;
      tr.setMeta("orderedListSync", true);
      const listMap = /* @__PURE__ */ new Map();
      const listInitialized = /* @__PURE__ */ new Map();
      const shouldProcess = transactions.some((tr2) => {
        return tr2.steps.some((step) => {
          const stepJSON = step.toJSON();
          const hasUpdateMeta = tr2.getMeta("updateListSync");
          return hasUpdateMeta || stepJSON && stepJSON.slice && JSON.stringify(stepJSON).includes('"listItem"');
        });
      });
      if (!shouldProcess) return null;
      newState.doc.descendants((node, pos) => {
        if (node.type.name !== "listItem") return;
        const { level: attrLvl, numId: attrNumId, styleId } = node.attrs;
        const level = parseInt(attrLvl);
        const numId = parseInt(attrNumId);
        let {
          lvlText,
          customFormat,
          listNumberingType,
          start: numberingDefStart
        } = ListHelpers.getListDefinitionDetails({ numId, level, editor });
        const start2 = parseInt(numberingDefStart) || 1;
        if (!listMap.has(numId)) {
          const generatedLevels = {};
          const initialPath = docxNumberigHelpers.generateListPath(level, numId, styleId, generatedLevels, docx);
          listMap.set(numId, initialPath || []);
          listInitialized.set(numId, false);
        }
        let currentListLevels = [...listMap.get(numId)];
        if (!listInitialized.get(numId)) {
          listInitialized.set(numId, true);
          if (typeof start2 === "number") {
            while (currentListLevels.length <= level) {
              currentListLevels.push(0);
            }
            currentListLevels[level] = start2;
            for (let i = level + 1; i < currentListLevels.length; i++) {
              currentListLevels[i] = 0;
            }
          }
        } else {
          while (currentListLevels.length <= level) {
            currentListLevels.push(0);
          }
          currentListLevels[level] = (currentListLevels[level] || 0) + 1;
          for (let i = level + 1; i < currentListLevels.length; i++) {
            currentListLevels[i] = 0;
          }
        }
        if (currentListLevels.length === 0) {
          currentListLevels = [1];
        }
        listMap.set(numId, currentListLevels);
        const updatedAttrs = {
          ...node.attrs,
          listLevel: [...currentListLevels],
          level,
          lvlText,
          listNumberingType,
          customFormat
        };
        const keysChanged = Object.keys(updatedAttrs).some((key) => node.attrs[key] !== updatedAttrs[key]);
        if (keysChanged) {
          tr.setNodeMarkup(pos, void 0, updatedAttrs);
        }
      });
      return tr;
    }
  });
}
const ListItem = Node$1.create({
  name: "listItem",
  content: "paragraph* block*",
  defining: true,
  priority: 101,
  // to run listItem commands first
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "List item node"
      },
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  parseDOM() {
    return [{ tag: "li" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["li", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addPmPlugins() {
    return this.editor?.converter?.convertedXml ? [orderedListSync(this.editor)] : [];
  },
  /**
   * Important: The listItem node uses a custom node view.
   * @returns {import('@core/NodeView.js').NodeView}
   */
  addNodeView() {
    return ({ node, editor, getPos, decorations }) => {
      return new ListItemNodeView(node, getPos, decorations, editor);
    };
  },
  addAttributes() {
    return {
      // Virtual attribute.
      markerType: {
        default: null,
        renderDOM: (attrs) => {
          let { listLevel, listNumberingType, lvlText } = attrs;
          let hasListLevel = !!listLevel?.length;
          if (!hasListLevel || !lvlText) {
            return {};
          }
          let orderMarker = generateOrderedListIndex({
            listLevel,
            lvlText,
            listNumberingType
          });
          if (!orderMarker) return {};
          return {
            "data-marker-type": orderMarker
          };
        }
      },
      lvlText: {
        default: null,
        keepOnSplit: true,
        parseDOM: (elem) => elem.getAttribute("data-lvl-text"),
        renderDOM: (attrs) => {
          if (!attrs.lvlText) return {};
          return {
            "data-lvl-text": attrs.lvlText
          };
        }
      },
      listNumberingType: {
        default: null,
        keepOnSplit: true,
        parseDOM: (elem) => elem.getAttribute("data-num-fmt"),
        renderDOM: (attrs) => {
          if (!attrs.listNumberingType) return {};
          return {
            "data-num-fmt": attrs.listNumberingType
          };
        }
      },
      listLevel: {
        default: null,
        parseDOM: (elem) => {
          let listLevel = elem.getAttribute("data-list-level");
          try {
            listLevel = JSON.parse(listLevel);
          } catch {
          }
          return listLevel;
        },
        renderDOM: (attrs) => {
          if (!attrs.listLevel) return {};
          return {
            "data-list-level": JSON.stringify(attrs.listLevel)
          };
        }
      },
      // JC = justification. Expect left, right, center
      lvlJc: {
        keepOnSplit: true,
        default: null,
        rendered: false
      },
      // This will contain indentation and space info.
      // ie: w:left (left indent), w:hanging (hanging indent)
      listParagraphProperties: {
        keepOnSplit: true,
        default: null,
        rendered: false
      },
      // This will contain run properties for the list item
      listRunProperties: {
        keepOnSplit: true,
        default: null,
        rendered: false
      },
      numId: {
        keepOnSplit: true,
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-num-id"),
        renderDOM: (attrs) => {
          if (!attrs.numId) return {};
          return {
            "data-num-id": attrs.numId
          };
        }
      },
      numPrType: {
        rendered: false,
        default: "inline",
        keepOnSplit: true
      },
      level: {
        parseDOM: (elem) => {
          return elem.getAttribute("data-level");
        },
        renderDOM: (attrs) => {
          if (attrs.level === void 0 || attrs.level === null) return {};
          return {
            "data-level": attrs.level
          };
        }
      },
      attributes: {
        keepOnSplit: true,
        rendered: false
      },
      spacing: {
        keepOnSplit: true,
        default: null,
        rendered: false
      },
      indent: {
        parseDOM: (elem) => JSON.parse(elem.getAttribute("data-indent")),
        keepOnSplit: true,
        default: null,
        rendered: false
      },
      markerStyle: {
        default: null,
        rendered: false,
        keepOnSplit: true
      },
      styleId: {
        rendered: false,
        keepOnSplit: true
      },
      customFormat: {
        default: null,
        rendered: false,
        keepOnSplit: true
      },
      importedFontFamily: {
        parseDOM: (elem) => elem.getAttribute("data-font-family"),
        renderDOM: (attrs) => {
          if (!attrs.importedFontFamily) return {};
          return {
            "data-font-family": attrs.importedFontFamily
          };
        }
      },
      importedFontSize: {
        parseDOM: (elem) => elem.getAttribute("data-font-size"),
        renderDOM: (attrs) => {
          if (!attrs.importedFontSize) return {};
          return {
            "data-font-size": attrs.importedFontSize
          };
        }
      }
    };
  },
  addShortcuts() {
    return {
      Enter: () => {
        return this.editor.commands.splitListItem();
      },
      "Shift-Enter": () => {
        return this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.createParagraphNear(),
          () => commands2.splitBlock()
        ]);
      },
      Tab: () => {
        return this.editor.commands.first(({ commands: commands2 }) => [() => commands2.increaseListIndent()]);
      },
      "Shift-Tab": () => {
        return this.editor.commands.first(({ commands: commands2 }) => [() => commands2.decreaseListIndent()]);
      }
    };
  }
});
const getDefaultSpacing = () => ({
  lineSpaceAfter: 0,
  lineSpaceBefore: 0,
  line: 0,
  lineRule: null
});
const Paragraph = Node$1.create({
  name: "paragraph",
  priority: 1e3,
  group: "block",
  content: "inline*",
  inline: false,
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      spacing: {
        default: getDefaultSpacing(),
        renderDOM: (attrs) => {
          const { spacing } = attrs;
          if (!spacing) return {};
          const spacingCopy = { ...spacing };
          if (attrs.lineHeight) delete spacingCopy.line;
          const style = getSpacingStyleString(spacingCopy);
          if (style) return { style };
          return {};
        }
      },
      extraAttrs: {
        default: {},
        parseDOM: (element) => {
          const extra = {};
          Array.from(element.attributes).forEach((attr) => {
            extra[attr.name] = attr.value;
          });
          return extra;
        },
        renderDOM: (attributes) => {
          return attributes.extraAttrs || {};
        }
      },
      marksAttrs: {
        renderDOM: (attrs) => {
          const { marksAttrs } = attrs;
          if (!marksAttrs?.length) return {};
          const style = getMarksStyle(marksAttrs);
          if (style) return { style };
          return {};
        }
      },
      indent: {
        default: null,
        renderDOM: ({ indent }) => {
          if (!indent) return {};
          const { left: left2, right: right2, firstLine, hanging } = indent;
          if (indent && Object.values(indent).every((v) => v === 0)) {
            return {};
          }
          let style = "";
          if (left2) style += `margin-left: ${left2}px;`;
          if (right2) style += `margin-right: ${right2}px;`;
          if (firstLine && !hanging) style += `text-indent: ${firstLine}px;`;
          if (firstLine && hanging) style += `text-indent: ${firstLine - hanging}px;`;
          if (!firstLine && hanging) style += `text-indent: ${-hanging}px;`;
          return { style };
        }
      },
      class: {
        renderDOM: (attributes) => {
          if (attributes.dropcap) {
            return { class: `sd-editor-dropcap` };
          }
          return null;
        }
      },
      styleId: {},
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      attributes: {
        rendered: false
      },
      filename: { rendered: false },
      rsidRDefault: { rendered: false },
      keepLines: { rendered: false },
      keepNext: { rendered: false },
      paragraphProperties: { rendered: false },
      dropcap: { rendered: false },
      pageBreakSource: { rendered: false },
      justify: {
        renderDOM: ({ justify }) => {
          const { val: jc } = justify || {};
          if (!jc) return {};
          let style = "";
          if (jc === "left") style += "text-align: left;";
          else if (jc === "right") style += "text-align: right;";
          else if (jc === "center") style += "text-align: center;";
          else if (jc === "both") style += "text-align: justify;";
          return { style };
        }
      },
      tabStops: { rendered: false }
    };
  },
  parseDOM() {
    return [
      {
        tag: "p",
        getAttrs: (node) => {
          let extra = {};
          Array.from(node.attributes).forEach((attr) => {
            extra[attr.name] = attr.value;
          });
          return { extraAttrs: extra };
        }
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["p", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addPmPlugins() {
    const { view } = this.editor;
    const dropcapPlugin = new Plugin({
      name: "dropcapPlugin",
      key: new PluginKey("dropcapPlugin"),
      state: {
        init(_, state) {
          let decorations = getDropcapDecorations(state, view);
          return DecorationSet.create(state.doc, decorations);
        },
        apply(tr, oldDecorationSet, oldState, newState) {
          if (!tr.docChanged) return oldDecorationSet;
          const decorations = getDropcapDecorations(newState, view);
          return DecorationSet.create(newState.doc, decorations);
        }
      },
      props: {
        decorations(state) {
          return this.getState(state);
        }
      }
    });
    return [dropcapPlugin];
  }
});
const getDropcapDecorations = (state, view) => {
  let decorations = [];
  state.doc.descendants((node, pos) => {
    if (node.type.name === "paragraph") {
      if (node.attrs.dropcap?.type === "margin") {
        const width = getDropcapWidth(view, pos);
        decorations.push(Decoration.inline(pos, pos + node.nodeSize, { style: `margin-left: -${width}px;` }));
      }
      return false;
    }
  });
  return decorations;
};
function getDropcapWidth(view, pos) {
  const domNode = view.nodeDOM(pos);
  if (domNode) {
    const range = document.createRange();
    range.selectNodeContents(domNode);
    return range.getBoundingClientRect().width;
  }
  return 0;
}
const Heading = Node$1.create({
  name: "heading",
  group: "block",
  content: "inline*",
  defining: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} HeadingOptions
       * @category Options
       * @property {number[]} [levels=[1,2,3,4,5,6]] - Supported heading levels
       * @property {Object} [htmlAttributes] - HTML attributes for heading elements
       */
      levels: [1, 2, 3, 4, 5, 6],
      htmlAttributes: {
        "aria-label": "Heading node"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {number} [level=1] - Heading level from 1 (largest) to 6 (smallest)
       */
      level: {
        default: 1,
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {Object} [tabStops] - Internal tab stop configuration
       */
      tabStops: { rendered: false },
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking ID
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      }
    };
  },
  parseDOM() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderDOM({ node, htmlAttributes }) {
    const hasLevel = this.options.levels.includes(node.attrs.level);
    const level = hasLevel ? node.attrs.level : this.options.levels[0];
    return [`h${level}`, Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Set a heading with specified level
       * @category Command
       * @param {HeadingAttributes} attributes - Heading attributes including level
       * @returns {Function} Command function
       * @example
       * // Set heading level 2
       * setHeading({ level: 2 })
       * @note Converts current block to heading
       */
      setHeading: (attributes) => ({ commands: commands2 }) => {
        const containsLevel = this.options.levels.includes(attributes.level);
        if (!containsLevel) return false;
        return commands2.setNode(this.name, attributes);
      },
      /**
       * Toggle between heading and paragraph
       * @category Command
       * @param {HeadingAttributes} attributes - Heading attributes including level
       * @returns {Function} Command function
       * @example
       * // Toggle heading level 1
       * toggleHeading({ level: 1 })
       *
       * // Toggle heading level 3
       * toggleHeading({ level: 3 })
       * @note Switches between heading and paragraph for the same level
       */
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        const containsLevel = this.options.levels.includes(attributes.level);
        if (!containsLevel) return false;
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addShortcuts() {
    return this.options.levels.reduce(
      (items, level) => ({
        ...items,
        ...{
          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
        }
      }),
      {}
    );
  }
});
const CommentRangeStart = Node$1.create({
  name: "commentRangeStart",
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  parseDOM() {
    return [{ tag: "commentRangeStart" }];
  },
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: "false",
        "aria-label": "Comment range start node"
      }
    };
  },
  renderDOM({ htmlAttributes }) {
    return ["commentRangeStart", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      "w:id": {
        rendered: false
      },
      internal: {
        default: true,
        rendered: false
      }
    };
  }
});
const CommentRangeEnd = Node$1.create({
  name: "commentRangeEnd",
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: "false",
        "aria-label": "Comment range end node"
      }
    };
  },
  parseDOM() {
    return [{ tag: "commentRangeEnd" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["commentRangeEnd", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      "w:id": {
        rendered: false
      }
    };
  }
});
const CommentReference = Node$1.create({
  name: "commentReference",
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: "false",
        "aria-label": "Comment reference node"
      }
    };
  },
  parseDOM() {
    return [{ tag: "commentReference" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["commentReference", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      attributes: {
        rendered: false
      }
    };
  }
});
const CommentsMark = Mark.create({
  name: CommentMarkName,
  group: "comments",
  excludes: "",
  addOptions() {
    return {
      htmlAttributes: { class: "sd-editor-comment" }
    };
  },
  addAttributes() {
    return {
      commentId: {},
      importedId: {},
      internal: {
        default: true,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: CommentMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [CommentMarkName, Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  }
});
const TabNode = Node$1.create({
  name: "tab",
  group: "inline",
  inline: true,
  // need this prop so Prosemirror doesn't treat tab as an
  // empty node and doesn't insert separator after
  content: "inline*",
  selectable: false,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-tab",
        // this works together with content prop:
        // since tab can't have content inside but content prop is defined I have to manually add attribute
        contentEditable: false
      }
    };
  },
  parseDOM() {
    return [{ tag: "span.sd-editor-tab" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      tabSize: {
        renderDOM: ({ tabSize }) => {
          if (!tabSize) return {};
          const style = `width: ${tabSize}px; min-width: ${tabSize}px;`;
          return { style };
        }
      }
    };
  },
  addPmPlugins() {
    const { view, schema } = this.editor;
    const domSerializer = DOMSerializer.fromSchema(schema);
    const tabPlugin = new Plugin({
      name: "tabPlugin",
      key: new PluginKey("tabPlugin"),
      state: {
        init() {
          return { decorations: false };
        },
        apply(tr, { decorations }, _oldState, newState) {
          if (!decorations) {
            decorations = DecorationSet.create(
              newState.doc,
              getTabDecorations(newState.doc, StepMap.empty, view, domSerializer)
            );
          }
          if (!tr.docChanged) {
            return { decorations };
          }
          decorations = decorations.map(tr.mapping, tr.doc);
          let rangesToRecalculate = [];
          tr.steps.forEach((step, index2) => {
            const stepMap = step.getMap();
            if (step instanceof ReplaceStep || step instanceof ReplaceAroundStep$1) {
              const $from = tr.docs[index2].resolve(step.from);
              const $to = tr.docs[index2].resolve(step.to);
              const start2 = $from.start(Math.min($from.depth, 1));
              const end2 = $to.end(Math.min($to.depth, 1));
              let addRange = false;
              tr.docs[index2].nodesBetween(start2, end2, (node) => {
                if (node.type.name === "tab") {
                  addRange = true;
                }
              });
              if (!addRange && step.slice?.content) {
                step.slice.content.descendants((node) => {
                  if (node.type.name === "tab") {
                    addRange = true;
                  }
                });
              }
              if (addRange) {
                rangesToRecalculate.push([start2, end2]);
              }
            }
            rangesToRecalculate = rangesToRecalculate.map(([from2, to]) => {
              const mappedFrom = stepMap.map(from2, -1);
              const mappedTo = stepMap.map(to, 1);
              return [mappedFrom, mappedTo];
            });
          });
          rangesToRecalculate.forEach(([start2, end2]) => {
            const oldDecorations = decorations.find(start2, end2);
            decorations = decorations.remove(oldDecorations);
            const invertMapping = tr.mapping.invert();
            const newDecorations = getTabDecorations(newState.doc, invertMapping, view, domSerializer, start2, end2);
            decorations = decorations.add(newState.doc, newDecorations);
          });
          return { decorations };
        }
      },
      props: {
        decorations(state) {
          return this.getState(state).decorations;
        }
      }
    });
    return [tabPlugin];
  }
});
const defaultTabDistance = 48;
const defaultLineLength = 816;
const getTabDecorations = (doc2, invertMapping, view, domSerializer, from2 = 0, to = null) => {
  if (!to) {
    to = doc2.content.size;
  }
  const nodeWidthCache = {};
  let decorations = [];
  doc2.nodesBetween(from2, to, (node, pos, parent) => {
    if (node.type.name === "tab") {
      let extraStyles = "";
      const $pos = doc2.resolve(pos);
      const tabIndex = $pos.index($pos.depth);
      const fistlineIndent = parent.attrs?.indent?.firstLine || 0;
      const currentWidth = calcChildNodesWidth(
        parent,
        pos - $pos.parentOffset,
        0,
        tabIndex,
        domSerializer,
        view,
        invertMapping,
        nodeWidthCache
      ) + fistlineIndent;
      let tabWidth;
      if ($pos.depth === 1 && parent.attrs.tabStops && parent.attrs.tabStops.length > 0) {
        const tabStop = parent.attrs.tabStops.find((tabStop2) => tabStop2.pos > currentWidth && tabStop2.val !== "clear");
        if (tabStop) {
          tabWidth = tabStop.pos - currentWidth;
          if (["end", "center"].includes(tabStop.val)) {
            let nextTabIndex = tabIndex + 1;
            while (nextTabIndex < parent.childCount && parent.child(nextTabIndex).type.name !== "tab") {
              nextTabIndex++;
            }
            const tabSectionWidth = calcChildNodesWidth(
              parent,
              pos - $pos.parentOffset,
              tabIndex,
              nextTabIndex,
              domSerializer,
              view,
              invertMapping,
              nodeWidthCache
            );
            tabWidth -= tabStop.val === "end" ? tabSectionWidth : tabSectionWidth / 2;
          } else if (["decimal", "num"].includes(tabStop.val)) {
            const breakChar = ".";
            let nodeIndex = tabIndex + 1;
            let integralWidth = 0;
            let nodePos = pos - $pos.parentOffset;
            while (nodeIndex < parent.childCount) {
              const node2 = parent.child(nodeIndex);
              if (node2.type.name === "tab") {
                break;
              }
              const oldPos = invertMapping.map(nodePos);
              if (node2.type.name === "text" && node2.text.includes(breakChar)) {
                const modifiedNode = node2.cut(0, node2.text.indexOf(breakChar));
                integralWidth += calcNodeWidth(domSerializer, modifiedNode, view, oldPos);
                break;
              }
              integralWidth += calcNodeWidth(domSerializer, node2, view, oldPos);
              nodeWidthCache[nodePos] = integralWidth;
              nodePos += node2.nodeSize;
              nodeIndex += 1;
            }
            tabWidth -= integralWidth;
          }
          if (tabStop.leader) {
            if (tabStop.leader === "dot") {
              extraStyles += `border-bottom: 1px dotted black;`;
            } else if (tabStop.leader === "heavy") {
              extraStyles += `border-bottom: 2px solid black;`;
            } else if (tabStop.leader === "hyphen") {
              extraStyles += `border-bottom: 1px solid black;`;
            } else if (tabStop.leader === "middleDot") {
              extraStyles += `border-bottom: 1px dotted black; margin-bottom: 2px;`;
            } else if (tabStop.leader === "underscore") {
              extraStyles += `border-bottom: 1px solid black;`;
            }
          }
        }
      }
      if (!tabWidth || tabWidth < 1) {
        tabWidth = defaultTabDistance - currentWidth % defaultLineLength % defaultTabDistance;
        if (tabWidth === 0) {
          tabWidth = defaultTabDistance;
        }
      }
      nodeWidthCache[pos] = tabWidth;
      const tabHeight = calcTabHeight($pos);
      decorations.push(
        Decoration.node(pos, pos + node.nodeSize, {
          style: `width: ${tabWidth}px; height: ${tabHeight};${extraStyles}`
        })
      );
    }
  });
  return decorations;
};
function calcNodeWidth(domSerializer, node, view, oldPos) {
  const oldDomNode = view.nodeDOM(oldPos);
  const styleReference = oldDomNode ? oldDomNode.nodeName === "#text" ? oldDomNode.parentNode : oldDomNode : view.dom;
  const temp = document.createElement("div");
  const style = window.getComputedStyle(styleReference);
  temp.style.cssText = `
        position: absolute;
        top: -9999px;
        left: -9999px;
        white-space: nowrap;
        font-family: ${style.fontFamily};
        font-size: ${style.fontSize};
        font-weight: ${style.fontWeight};
        font-style: ${style.fontStyle};
        letter-spacing: ${style.letterSpacing};
        word-spacing: ${style.wordSpacing};
        text-transform: ${style.textTransform};
        display: inline-block;
    `;
  const domNode = domSerializer.serializeNode(node);
  temp.appendChild(domNode);
  document.body.appendChild(temp);
  const width = temp.offsetWidth;
  document.body.removeChild(temp);
  return width;
}
function calcChildNodesWidth(parent, parentPos, startIndex, endIndex, domSerializer, view, invertMapping, nodeWidthCache) {
  let pos = parentPos;
  let width = 0;
  for (let i = 0; i < endIndex; i++) {
    const node = parent.child(i);
    if (i >= startIndex) {
      if (!nodeWidthCache[pos]) {
        nodeWidthCache[pos] = calcNodeWidth(domSerializer, node, view, invertMapping.map(pos));
      }
      width += nodeWidthCache[pos];
    }
    pos += node.nodeSize;
  }
  return width;
}
function calcTabHeight(pos) {
  const ptToPxRatio = 1.333;
  const defaultFontSize = 16;
  const defaultLineHeight = 1.1;
  const blockParent2 = pos.node(1);
  const parentTextStyleMark = blockParent2.firstChild.marks.find((mark) => mark.type.name === "textStyle");
  const fontSize = parseInt(parentTextStyleMark?.attrs.fontSize) * ptToPxRatio || defaultFontSize;
  return `${fontSize * defaultLineHeight}px`;
}
const LineBreak = Node$1.create({
  name: "lineBreak",
  group: "inline",
  inline: true,
  marks: "",
  defining: true,
  selectable: false,
  content: "",
  atom: true,
  parseDOM() {
    return [{ tag: "br" }];
  },
  renderDOM() {
    return ["br", {}];
  },
  addCommands() {
    return {
      /**
       * Insert a line break
       * @category Command
       * @returns {Function} Command function
       * @example
       * insertLineBreak()
       * @note Creates a soft break within the same paragraph
       */
      insertLineBreak: () => ({ commands: commands2 }) => {
        return commands2.insertContent({ type: "lineBreak" });
      }
    };
  }
});
const HardBreak = Node$1.create({
  name: "hardBreak",
  group: "inline",
  inline: true,
  selectable: false,
  atom: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} HardBreakOptions
       * @category Options
       * @property {Object} [htmlAttributes] - HTML attributes for the break element
       */
      htmlAttributes: {
        contentEditable: "false",
        lineBreakType: "page",
        "aria-hidden": "true",
        "aria-label": "Hard break node"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @private
       * @category Attribute
       * @param {string} [pageBreakSource] - Source of the page break
       */
      pageBreakSource: {
        rendered: false,
        default: null
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [pageBreakType] - Type of page break
       */
      pageBreakType: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: 'span[linebreaktype="page"]',
        getAttrs: (dom) => {
          if (!(dom instanceof HTMLElement)) return false;
          return {
            pageBreakSource: dom.getAttribute("pagebreaksource") || null,
            pageBreakType: dom.getAttribute("linebreaktype") || null
          };
        }
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      /**
       * Insert a page break
       * @category Command
       * @returns {Function} Command function
       * @example
       * insertPageBreak()
       * @note Forces content to start on a new page when printed
       */
      insertPageBreak: () => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: "hardBreak",
          attrs: { pageBreakType: "page" }
        });
      }
    };
  }
});
const createTableView = ({ editor }) => {
  return class TableView {
    constructor(node, cellMinWidth) {
      __publicField(this, "editor");
      __publicField(this, "node");
      __publicField(this, "dom");
      __publicField(this, "table");
      __publicField(this, "colgroup");
      __publicField(this, "contentDOM");
      __publicField(this, "cellMinWidth");
      this.editor = editor;
      this.node = node;
      this.cellMinWidth = cellMinWidth;
      this.dom = document.createElement("div");
      this.dom.className = "tableWrapper";
      this.table = this.dom.appendChild(document.createElement("table"));
      this.colgroup = this.table.appendChild(document.createElement("colgroup"));
      updateTable(this.editor, this.node, this.table);
      updateColumns(node, this.colgroup, this.table, cellMinWidth);
      this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      setTimeout(() => {
        updateTableWrapper(this.dom, this.table);
      }, 0);
    }
    update(node) {
      if (node.type !== this.node.type) {
        return false;
      }
      this.node = node;
      updateTable(this.editor, node, this.table);
      updateColumns(node, this.colgroup, this.table, this.cellMinWidth);
      updateTableWrapper(this.dom, this.table);
      return true;
    }
    ignoreMutation(mutation) {
      const tableWrapper = this.dom;
      if (mutation.target === tableWrapper && mutation.type === "attributes" && mutation.attributeName === "style") {
        return true;
      }
      return mutation.type === "attributes" && (mutation.target === this.table || this.colgroup.contains(mutation.target));
    }
  };
};
function updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node.firstChild;
  if (row !== null) {
    for (let i = 0, col = 0; i < row.childCount; i++) {
      const { colspan, colwidth } = row.child(i).attrs;
      for (let j = 0; j < colspan; j++, col++) {
        const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];
        const cssWidth = hasWidth ? `${hasWidth}px` : "";
        totalWidth += hasWidth || cellMinWidth;
        if (!hasWidth) fixedWidth = false;
        if (!nextDOM) {
          const col2 = document.createElement("col");
          const [propKey, propVal] = getColStyleDeclaration(cellMinWidth, hasWidth);
          col2.style.setProperty(propKey, propVal);
          colgroup.appendChild(col2);
        } else {
          if (nextDOM.style.width !== cssWidth) {
            const [propKey, propVal] = getColStyleDeclaration(cellMinWidth, hasWidth);
            nextDOM.style.setProperty(propKey, propVal);
          }
          nextDOM = nextDOM.nextSibling;
        }
      }
    }
  }
  while (nextDOM) {
    const after = nextDOM.nextSibling;
    nextDOM.parentNode?.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = `${totalWidth}px`;
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = `${totalWidth}px`;
  }
}
function updateTable(editor, node, table) {
  const allExtensionsAttrs = editor.extensionService.attributes;
  const tableExtensionAttrs = allExtensionsAttrs.filter((e) => e.type === "table");
  const htmlAttributes = Attribute.getAttributesToRender(node, tableExtensionAttrs);
  Object.entries(htmlAttributes).forEach(([key, value]) => {
    if (key === "style") {
      table.style.cssText = value;
    } else {
      table.setAttribute(key, value);
    }
  });
}
function updateTableWrapper(tableWrapper, table) {
  let defaultBorderWidth = 1;
  let borderWidth;
  if (!table) {
    return;
  }
  let borderLeftMax = parseFloat(table.style.borderLeftWidth || 0);
  let borderRightMax = parseFloat(table.style.borderRightWidth) || 0;
  let firstColumnCells = [...table.querySelectorAll(":scope > tbody > tr > td:first-child")];
  let lastColumnCells = [...table.querySelectorAll(":scope > tbody > tr > td:last-child")];
  for (let cell of firstColumnCells) {
    let borderLeft = parseFloat(cell.style.borderLeftWidth) || 0;
    borderLeftMax = Math.max(borderLeftMax, borderLeft);
  }
  for (let cell of lastColumnCells) {
    let borderRight = parseFloat(cell.style.borderRightWidth) || 0;
    borderRightMax = Math.max(borderRightMax, borderRight);
  }
  borderWidth = Math.ceil(Math.max(borderLeftMax, borderRightMax));
  tableWrapper.style.setProperty("--table-border-width", `${borderWidth || defaultBorderWidth}px`);
}
const createCell = (cellType, cellContent = null) => {
  if (cellContent) {
    return cellType.createChecked(null, cellContent);
  }
  return cellType.createAndFill();
};
const createTableBorders = ({ size = 0.66665, color = "#000000" } = {}) => {
  return {
    top: { size, color },
    left: { size, color },
    bottom: { size, color },
    right: { size, color },
    insideH: { size, color },
    insideV: { size, color }
  };
};
const createTable = (schema, rowsCount, colsCount, withHeaderRow, cellContent = null) => {
  const types = {
    table: getNodeType("table", schema),
    tableRow: getNodeType("tableRow", schema),
    tableCell: getNodeType("tableCell", schema),
    tableHeader: getNodeType("tableHeader", schema)
  };
  const headerCells = [];
  const cells = [];
  for (let index2 = 0; index2 < colsCount; index2++) {
    const cell = createCell(types.tableCell, cellContent);
    if (cell) cells.push(cell);
    if (withHeaderRow) {
      const headerCell = createCell(types.tableHeader, cellContent);
      if (headerCell) {
        headerCells.push(headerCell);
      }
    }
  }
  const rows = [];
  for (let index2 = 0; index2 < rowsCount; index2++) {
    const cellsToInsert = withHeaderRow && index2 === 0 ? headerCells : cells;
    rows.push(types.tableRow.createChecked(null, cellsToInsert));
  }
  const tableBorders = createTableBorders();
  return types.table.createChecked({ borders: tableBorders }, rows);
};
var readFromCache;
var addToCache;
if (typeof WeakMap != "undefined") {
  let cache = /* @__PURE__ */ new WeakMap();
  readFromCache = (key) => cache.get(key);
  addToCache = (key, value) => {
    cache.set(key, value);
    return value;
  };
} else {
  const cache = [];
  const cacheSize = 10;
  let cachePos = 0;
  readFromCache = (key) => {
    for (let i = 0; i < cache.length; i += 2)
      if (cache[i] == key) return cache[i + 1];
  };
  addToCache = (key, value) => {
    if (cachePos == cacheSize) cachePos = 0;
    cache[cachePos++] = key;
    return cache[cachePos++] = value;
  };
}
var TableMap = class {
  constructor(width, height, map2, problems) {
    this.width = width;
    this.height = height;
    this.map = map2;
    this.problems = problems;
  }
  // Find the dimensions of the cell at the given position.
  findCell(pos) {
    for (let i = 0; i < this.map.length; i++) {
      const curPos = this.map[i];
      if (curPos != pos) continue;
      const left2 = i % this.width;
      const top2 = i / this.width | 0;
      let right2 = left2 + 1;
      let bottom2 = top2 + 1;
      for (let j = 1; right2 < this.width && this.map[i + j] == curPos; j++) {
        right2++;
      }
      for (let j = 1; bottom2 < this.height && this.map[i + this.width * j] == curPos; j++) {
        bottom2++;
      }
      return { left: left2, top: top2, right: right2, bottom: bottom2 };
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(pos) {
    for (let i = 0; i < this.map.length; i++) {
      if (this.map[i] == pos) {
        return i % this.width;
      }
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(pos, axis, dir) {
    const { left: left2, right: right2, top: top2, bottom: bottom2 } = this.findCell(pos);
    if (axis == "horiz") {
      if (dir < 0 ? left2 == 0 : right2 == this.width) return null;
      return this.map[top2 * this.width + (dir < 0 ? left2 - 1 : right2)];
    } else {
      if (dir < 0 ? top2 == 0 : bottom2 == this.height) return null;
      return this.map[left2 + this.width * (dir < 0 ? top2 - 1 : bottom2)];
    }
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(a, b) {
    const {
      left: leftA,
      right: rightA,
      top: topA,
      bottom: bottomA
    } = this.findCell(a);
    const {
      left: leftB,
      right: rightB,
      top: topB,
      bottom: bottomB
    } = this.findCell(b);
    return {
      left: Math.min(leftA, leftB),
      top: Math.min(topA, topB),
      right: Math.max(rightA, rightB),
      bottom: Math.max(bottomA, bottomB)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(rect) {
    const result = [];
    const seen = {};
    for (let row = rect.top; row < rect.bottom; row++) {
      for (let col = rect.left; col < rect.right; col++) {
        const index2 = row * this.width + col;
        const pos = this.map[index2];
        if (seen[pos]) continue;
        seen[pos] = true;
        if (col == rect.left && col && this.map[index2 - 1] == pos || row == rect.top && row && this.map[index2 - this.width] == pos) {
          continue;
        }
        result.push(pos);
      }
    }
    return result;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(row, col, table) {
    for (let i = 0, rowStart = 0; ; i++) {
      const rowEnd = rowStart + table.child(i).nodeSize;
      if (i == row) {
        let index2 = col + row * this.width;
        const rowEndIndex = (row + 1) * this.width;
        while (index2 < rowEndIndex && this.map[index2] < rowStart) index2++;
        return index2 == rowEndIndex ? rowEnd - 1 : this.map[index2];
      }
      rowStart = rowEnd;
    }
  }
  // Find the table map for the given table node.
  static get(table) {
    return readFromCache(table) || addToCache(table, computeMap(table));
  }
};
function computeMap(table) {
  if (table.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + table.type.name);
  const width = findWidth(table), height = table.childCount;
  const map2 = [];
  let mapPos = 0;
  let problems = null;
  const colWidths = [];
  for (let i = 0, e = width * height; i < e; i++) map2[i] = 0;
  for (let row = 0, pos = 0; row < height; row++) {
    const rowNode = table.child(row);
    pos++;
    for (let i = 0; ; i++) {
      while (mapPos < map2.length && map2[mapPos] != 0) mapPos++;
      if (i == rowNode.childCount) break;
      const cellNode = rowNode.child(i);
      const { colspan, rowspan, colwidth } = cellNode.attrs;
      for (let h = 0; h < rowspan; h++) {
        if (h + row >= height) {
          (problems || (problems = [])).push({
            type: "overlong_rowspan",
            pos,
            n: rowspan - h
          });
          break;
        }
        const start2 = mapPos + h * width;
        for (let w = 0; w < colspan; w++) {
          if (map2[start2 + w] == 0) map2[start2 + w] = pos;
          else
            (problems || (problems = [])).push({
              type: "collision",
              row,
              pos,
              n: colspan - w
            });
          const colW = colwidth && colwidth[w];
          if (colW) {
            const widthIndex = (start2 + w) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    const expectedPos = (row + 1) * width;
    let missing = 0;
    while (mapPos < expectedPos) if (map2[mapPos++] == 0) missing++;
    if (missing)
      (problems || (problems = [])).push({ type: "missing", row, n: missing });
    pos++;
  }
  if (width === 0 || height === 0)
    (problems || (problems = [])).push({ type: "zero_sized" });
  const tableMap = new TableMap(width, height, map2, problems);
  let badWidths = false;
  for (let i = 0; !badWidths && i < colWidths.length; i += 2)
    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;
  if (badWidths) findBadColWidths(tableMap, colWidths, table);
  return tableMap;
}
function findWidth(table) {
  let width = -1;
  let hasRowSpan = false;
  for (let row = 0; row < table.childCount; row++) {
    const rowNode = table.child(row);
    let rowWidth = 0;
    if (hasRowSpan)
      for (let j = 0; j < row; j++) {
        const prevRow = table.child(j);
        for (let i = 0; i < prevRow.childCount; i++) {
          const cell = prevRow.child(i);
          if (j + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;
        }
      }
    for (let i = 0; i < rowNode.childCount; i++) {
      const cell = rowNode.child(i);
      rowWidth += cell.attrs.colspan;
      if (cell.attrs.rowspan > 1) hasRowSpan = true;
    }
    if (width == -1) width = rowWidth;
    else if (width != rowWidth) width = Math.max(width, rowWidth);
  }
  return width;
}
function findBadColWidths(map2, colWidths, table) {
  if (!map2.problems) map2.problems = [];
  const seen = {};
  for (let i = 0; i < map2.map.length; i++) {
    const pos = map2.map[i];
    if (seen[pos]) continue;
    seen[pos] = true;
    const node = table.nodeAt(pos);
    if (!node) {
      throw new RangeError(`No cell with offset ${pos} found`);
    }
    let updated = null;
    const attrs = node.attrs;
    for (let j = 0; j < attrs.colspan; j++) {
      const col = (i + j) % map2.width;
      const colWidth = colWidths[col * 2];
      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))
        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;
    }
    if (updated)
      map2.problems.unshift({
        type: "colwidth mismatch",
        pos,
        colwidth: updated
      });
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth) return attrs.colwidth.slice();
  const result = [];
  for (let i = 0; i < attrs.colspan; i++) result.push(0);
  return result;
}
function tableNodeTypes(schema) {
  let result = schema.cached.tableNodeTypes;
  if (!result) {
    result = schema.cached.tableNodeTypes = {};
    for (const name in schema.nodes) {
      const type = schema.nodes[name], role = type.spec.tableRole;
      if (role) result[role] = type;
    }
  }
  return result;
}
var tableEditingKey = new PluginKey("selectingCells");
function cellAround$1($pos) {
  for (let d = $pos.depth - 1; d > 0; d--)
    if ($pos.node(d).type.spec.tableRole == "row")
      return $pos.node(0).resolve($pos.before(d + 1));
  return null;
}
function cellWrapping$1($pos) {
  for (let d = $pos.depth; d > 0; d--) {
    const role = $pos.node(d).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") return $pos.node(d);
  }
  return null;
}
function isInTable(state) {
  const $head = state.selection.$head;
  for (let d = $head.depth; d > 0; d--)
    if ($head.node(d).type.spec.tableRole == "row") return true;
  return false;
}
function selectionCell(state) {
  const sel = state.selection;
  if ("$anchorCell" in sel && sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor;
  }
  const $cell = cellAround$1(sel.$head) || cellNear(sel.$head);
  if ($cell) {
    return $cell;
  }
  throw new RangeError(`No cell found around position ${sel.head}`);
}
function cellNear($pos) {
  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
    const role = after.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") return $pos.doc.resolve(pos);
  }
  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {
    const role = before.type.spec.tableRole;
    if (role == "cell" || role == "header_cell")
      return $pos.doc.resolve(pos - before.nodeSize);
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
}
function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
}
function inSameTable($cellA, $cellB) {
  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
}
function nextCell($pos, axis, dir) {
  const table = $pos.node(-1);
  const map2 = TableMap.get(table);
  const tableStart = $pos.start(-1);
  const moved = map2.nextCell($pos.pos - tableStart, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);
}
function removeColSpan(attrs, pos, n = 1) {
  const result = { ...attrs, colspan: attrs.colspan - n };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    result.colwidth.splice(pos, n);
    if (!result.colwidth.some((w) => w > 0)) result.colwidth = null;
  }
  return result;
}
function addColSpan(attrs, pos, n = 1) {
  const result = { ...attrs, colspan: attrs.colspan + n };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);
  }
  return result;
}
function columnIsHeader(map2, table, col) {
  const headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (let row = 0; row < map2.height; row++)
    if (table.nodeAt(map2.map[col + row * map2.width]).type != headerCell)
      return false;
  return true;
}
var CellSelection = class _CellSelection extends Selection {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const rect = map2.rectBetween(
      $anchorCell.pos - tableStart,
      $headCell.pos - tableStart
    );
    const doc2 = $anchorCell.node(0);
    const cells = map2.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);
    cells.unshift($headCell.pos - tableStart);
    const ranges = cells.map((pos) => {
      const cell = table.nodeAt(pos);
      if (!cell) {
        throw RangeError(`No cell with offset ${pos} found`);
      }
      const from2 = tableStart + pos + 1;
      return new SelectionRange(
        doc2.resolve(from2),
        doc2.resolve(from2 + cell.content.size)
      );
    });
    super(ranges[0].$from, ranges[0].$to, ranges);
    this.$anchorCell = $anchorCell;
    this.$headCell = $headCell;
  }
  map(doc2, mapping) {
    const $anchorCell = doc2.resolve(mapping.map(this.$anchorCell.pos));
    const $headCell = doc2.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection())
        return _CellSelection.rowSelection($anchorCell, $headCell);
      else if (tableChanged && this.isColSelection())
        return _CellSelection.colSelection($anchorCell, $headCell);
      else return new _CellSelection($anchorCell, $headCell);
    }
    return TextSelection.between($anchorCell, $headCell);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const table = this.$anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const rect = map2.rectBetween(
      this.$anchorCell.pos - tableStart,
      this.$headCell.pos - tableStart
    );
    const seen = {};
    const rows = [];
    for (let row = rect.top; row < rect.bottom; row++) {
      const rowContent = [];
      for (let index2 = row * map2.width + rect.left, col = rect.left; col < rect.right; col++, index2++) {
        const pos = map2.map[index2];
        if (seen[pos]) continue;
        seen[pos] = true;
        const cellRect = map2.findCell(pos);
        let cell = table.nodeAt(pos);
        if (!cell) {
          throw RangeError(`No cell with offset ${pos} found`);
        }
        const extraLeft = rect.left - cellRect.left;
        const extraRight = cellRect.right - rect.right;
        if (extraLeft > 0 || extraRight > 0) {
          let attrs = cell.attrs;
          if (extraLeft > 0) {
            attrs = removeColSpan(attrs, 0, extraLeft);
          }
          if (extraRight > 0) {
            attrs = removeColSpan(
              attrs,
              attrs.colspan - extraRight,
              extraRight
            );
          }
          if (cellRect.left < rect.left) {
            cell = cell.type.createAndFill(attrs);
            if (!cell) {
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(attrs)}`
              );
            }
          } else {
            cell = cell.type.create(attrs, cell.content);
          }
        }
        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
          const attrs = {
            ...cell.attrs,
            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
          };
          if (cellRect.top < rect.top) {
            cell = cell.type.createAndFill(attrs);
          } else {
            cell = cell.type.create(attrs, cell.content);
          }
        }
        rowContent.push(cell);
      }
      rows.push(table.child(row).copy(Fragment.from(rowContent)));
    }
    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
    return new Slice(Fragment.from(fragment), 1, 1);
  }
  replace(tr, content = Slice.empty) {
    const mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replace(
        mapping.map($from.pos),
        mapping.map($to.pos),
        i ? Slice.empty : content
      );
    }
    const sel = Selection.findFrom(
      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),
      -1
    );
    if (sel) tr.setSelection(sel);
  }
  replaceWith(tr, node) {
    this.replace(tr, new Slice(Fragment.from(node), 0, 0));
  }
  forEachCell(f) {
    const table = this.$anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const cells = map2.cellsInRect(
      map2.rectBetween(
        this.$anchorCell.pos - tableStart,
        this.$headCell.pos - tableStart
      )
    );
    for (let i = 0; i < cells.length; i++) {
      f(table.nodeAt(cells[i]), tableStart + cells[i]);
    }
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const anchorTop = this.$anchorCell.index(-1);
    const headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0) return false;
    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map2.findCell($anchorCell.pos - tableStart);
    const headRect = map2.findCell($headCell.pos - tableStart);
    const doc2 = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0)
        $anchorCell = doc2.resolve(tableStart + map2.map[anchorRect.left]);
      if (headRect.bottom < map2.height)
        $headCell = doc2.resolve(
          tableStart + map2.map[map2.width * (map2.height - 1) + headRect.right - 1]
        );
    } else {
      if (headRect.top > 0)
        $headCell = doc2.resolve(tableStart + map2.map[headRect.left]);
      if (anchorRect.bottom < map2.height)
        $anchorCell = doc2.resolve(
          tableStart + map2.map[map2.width * (map2.height - 1) + anchorRect.right - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const table = this.$anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const anchorLeft = map2.colCount(this.$anchorCell.pos - tableStart);
    const headLeft = map2.colCount(this.$headCell.pos - tableStart);
    if (Math.min(anchorLeft, headLeft) > 0) return false;
    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map2.width;
  }
  eq(other) {
    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map2 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map2.findCell($anchorCell.pos - tableStart);
    const headRect = map2.findCell($headCell.pos - tableStart);
    const doc2 = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0)
        $anchorCell = doc2.resolve(
          tableStart + map2.map[anchorRect.top * map2.width]
        );
      if (headRect.right < map2.width)
        $headCell = doc2.resolve(
          tableStart + map2.map[map2.width * (headRect.top + 1) - 1]
        );
    } else {
      if (headRect.left > 0)
        $headCell = doc2.resolve(tableStart + map2.map[headRect.top * map2.width]);
      if (anchorRect.right < map2.width)
        $anchorCell = doc2.resolve(
          tableStart + map2.map[map2.width * (anchorRect.top + 1) - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(doc2, json) {
    return new _CellSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  static create(doc2, anchorCell, headCell = anchorCell) {
    return new _CellSelection(doc2.resolve(anchorCell), doc2.resolve(headCell));
  }
  getBookmark() {
    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
  }
};
CellSelection.prototype.visible = false;
Selection.jsonID("cell", CellSelection);
var CellBookmark = class _CellBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    const $anchorCell = doc2.resolve(this.anchor), $headCell = doc2.resolve(this.head);
    if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
      return new CellSelection($anchorCell, $headCell);
    else return Selection.near($headCell, 1);
  }
};
function drawCellSelection(state) {
  if (!(state.selection instanceof CellSelection)) return null;
  const cells = [];
  state.selection.forEachCell((node, pos) => {
    cells.push(
      Decoration.node(pos, pos + node.nodeSize, { class: "selectedCell" })
    );
  });
  return DecorationSet.create(state.doc, cells);
}
function isCellBoundarySelection({ $from, $to }) {
  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;
  let afterFrom = $from.pos;
  let beforeTo = $to.pos;
  let depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++)
    if ($from.after(depth + 1) < $from.end(depth)) break;
  for (let d = $to.depth; d >= 0; d--, beforeTo--)
    if ($to.before(d + 1) > $to.start(d)) break;
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells({ $from, $to }) {
  let fromCellBoundaryNode;
  let toCellBoundaryNode;
  for (let i = $from.depth; i > 0; i--) {
    const node = $from.node(i);
    if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node;
      break;
    }
  }
  for (let i = $to.depth; i > 0; i--) {
    const node = $to.node(i);
    if (node.type.spec.tableRole === "cell" || node.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = node;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state, tr, allowTableNodeSelection) {
  const sel = (tr || state).selection;
  const doc2 = (tr || state).doc;
  let normalize2;
  let role;
  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize2 = CellSelection.create(doc2, sel.from);
    } else if (role == "row") {
      const $cell = doc2.resolve(sel.from + 1);
      normalize2 = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      const map2 = TableMap.get(sel.node);
      const start2 = sel.from + 1;
      const lastCell = start2 + map2.map[map2.width * map2.height - 1];
      normalize2 = CellSelection.create(doc2, start2 + 1, lastCell);
    }
  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {
    normalize2 = TextSelection.create(doc2, sel.from);
  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {
    normalize2 = TextSelection.create(doc2, sel.$from.start(), sel.$from.end());
  }
  if (normalize2) (tr || (tr = state.tr)).setSelection(normalize2);
  return tr;
}
var fixTablesKey = new PluginKey("fix-tables");
function changedDescendants(old, cur, offset2, f) {
  const oldSize = old.childCount, curSize = cur.childCount;
  outer: for (let i = 0, j = 0; i < curSize; i++) {
    const child = cur.child(i);
    for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {
      if (old.child(scan) == child) {
        j = scan + 1;
        offset2 += child.nodeSize;
        continue outer;
      }
    }
    f(child, offset2);
    if (j < oldSize && old.child(j).sameMarkup(child))
      changedDescendants(old.child(j), child, offset2 + 1, f);
    else child.nodesBetween(0, child.content.size, f, offset2 + 1);
    offset2 += child.nodeSize;
  }
}
function fixTables(state, oldState) {
  let tr;
  const check = (node, pos) => {
    if (node.type.spec.tableRole == "table")
      tr = fixTable(state, node, pos, tr);
  };
  if (!oldState) state.doc.descendants(check);
  else if (oldState.doc != state.doc)
    changedDescendants(oldState.doc, state.doc, 0, check);
  return tr;
}
function fixTable(state, table, tablePos, tr) {
  const map2 = TableMap.get(table);
  if (!map2.problems) return tr;
  if (!tr) tr = state.tr;
  const mustAdd = [];
  for (let i = 0; i < map2.height; i++) mustAdd.push(0);
  for (let i = 0; i < map2.problems.length; i++) {
    const prob = map2.problems[i];
    if (prob.type == "collision") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      const attrs = cell.attrs;
      for (let j = 0; j < attrs.rowspan; j++) mustAdd[prob.row + j] += prob.n;
      tr.setNodeMarkup(
        tr.mapping.map(tablePos + 1 + prob.pos),
        null,
        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)
      );
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        rowspan: cell.attrs.rowspan - prob.n
      });
    } else if (prob.type == "colwidth mismatch") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        colwidth: prob.colwidth
      });
    } else if (prob.type == "zero_sized") {
      const pos = tr.mapping.map(tablePos);
      tr.delete(pos, pos + table.nodeSize);
    }
  }
  let first2, last;
  for (let i = 0; i < mustAdd.length; i++)
    if (mustAdd[i]) {
      if (first2 == null) first2 = i;
      last = i;
    }
  for (let i = 0, pos = tablePos + 1; i < map2.height; i++) {
    const row = table.child(i);
    const end2 = pos + row.nodeSize;
    const add = mustAdd[i];
    if (add > 0) {
      let role = "cell";
      if (row.firstChild) {
        role = row.firstChild.type.spec.tableRole;
      }
      const nodes = [];
      for (let j = 0; j < add; j++) {
        const node = tableNodeTypes(state.schema)[role].createAndFill();
        if (node) nodes.push(node);
      }
      const side = (i == 0 || first2 == i - 1) && last == i ? pos + 1 : end2 - 1;
      tr.insert(tr.mapping.map(side), nodes);
    }
    pos = end2;
  }
  return tr.setMeta(fixTablesKey, { fixTables: true });
}
function selectedRect(state) {
  const sel = state.selection;
  const $pos = selectionCell(state);
  const table = $pos.node(-1);
  const tableStart = $pos.start(-1);
  const map2 = TableMap.get(table);
  const rect = sel instanceof CellSelection ? map2.rectBetween(
    sel.$anchorCell.pos - tableStart,
    sel.$headCell.pos - tableStart
  ) : map2.findCell($pos.pos - tableStart);
  return { ...rect, tableStart, map: map2, table };
}
function addColumn(tr, { map: map2, tableStart, table }, col) {
  let refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map2, table, col + refColumn)) {
    refColumn = col == 0 || col == map2.width ? null : 0;
  }
  for (let row = 0; row < map2.height; row++) {
    const index2 = row * map2.width + col;
    if (col > 0 && col < map2.width && map2.map[index2 - 1] == map2.map[index2]) {
      const pos = map2.map[index2];
      const cell = table.nodeAt(pos);
      tr.setNodeMarkup(
        tr.mapping.map(tableStart + pos),
        null,
        addColSpan(cell.attrs, col - map2.colCount(pos))
      );
      row += cell.attrs.rowspan - 1;
    } else {
      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map2.map[index2 + refColumn]).type;
      const pos = map2.positionAt(row, col, table);
      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());
    }
  }
  return tr;
}
function addColumnBefore(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.left));
  }
  return true;
}
function addColumnAfter(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addColumn(state.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr, { map: map2, table, tableStart }, col) {
  const mapStart = tr.mapping.maps.length;
  for (let row = 0; row < map2.height; ) {
    const index2 = row * map2.width + col;
    const pos = map2.map[index2];
    const cell = table.nodeAt(pos);
    const attrs = cell.attrs;
    if (col > 0 && map2.map[index2 - 1] == pos || col < map2.width - 1 && map2.map[index2 + 1] == pos) {
      tr.setNodeMarkup(
        tr.mapping.slice(mapStart).map(tableStart + pos),
        null,
        removeColSpan(attrs, col - map2.colCount(pos))
      );
    } else {
      const start2 = tr.mapping.slice(mapStart).map(tableStart + pos);
      tr.delete(start2, start2 + cell.nodeSize);
    }
    row += attrs.rowspan;
  }
}
function deleteColumn(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    const tr = state.tr;
    if (rect.left == 0 && rect.right == rect.map.width) return false;
    for (let i = rect.right - 1; ; i--) {
      removeColumn(tr, rect, i);
      if (i == rect.left) break;
      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(table);
    }
    dispatch(tr);
  }
  return true;
}
function rowIsHeader(map2, table, row) {
  var _a;
  const headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (let col = 0; col < map2.width; col++)
    if (((_a = table.nodeAt(map2.map[col + row * map2.width])) == null ? void 0 : _a.type) != headerCell)
      return false;
  return true;
}
function addRow(tr, { map: map2, tableStart, table }, row) {
  var _a;
  let rowPos = tableStart;
  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;
  const cells = [];
  let refRow = row > 0 ? -1 : 0;
  if (rowIsHeader(map2, table, row + refRow))
    refRow = row == 0 || row == map2.height ? null : 0;
  for (let col = 0, index2 = map2.width * row; col < map2.width; col++, index2++) {
    if (row > 0 && row < map2.height && map2.map[index2] == map2.map[index2 - map2.width]) {
      const pos = map2.map[index2];
      const attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tableStart + pos, null, {
        ...attrs,
        rowspan: attrs.rowspan + 1
      });
      col += attrs.colspan - 1;
    } else {
      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map2.map[index2 + refRow * map2.width])) == null ? void 0 : _a.type;
      const node = type == null ? void 0 : type.createAndFill();
      if (node) cells.push(node);
    }
  }
  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));
  return tr;
}
function addRowBefore(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.top));
  }
  return true;
}
function addRowAfter(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state);
    dispatch(addRow(state.tr, rect, rect.bottom));
  }
  return true;
}
function removeRow(tr, { map: map2, table, tableStart }, row) {
  let rowPos = 0;
  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;
  const nextRow = rowPos + table.child(row).nodeSize;
  const mapFrom = tr.mapping.maps.length;
  tr.delete(rowPos + tableStart, nextRow + tableStart);
  const seen = /* @__PURE__ */ new Set();
  for (let col = 0, index2 = row * map2.width; col < map2.width; col++, index2++) {
    const pos = map2.map[index2];
    if (seen.has(pos)) continue;
    seen.add(pos);
    if (row > 0 && pos == map2.map[index2 - map2.width]) {
      const attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {
        ...attrs,
        rowspan: attrs.rowspan - 1
      });
      col += attrs.colspan - 1;
    } else if (row < map2.height && pos == map2.map[index2 + map2.width]) {
      const cell = table.nodeAt(pos);
      const attrs = cell.attrs;
      const copy = cell.type.create(
        { ...attrs, rowspan: cell.attrs.rowspan - 1 },
        cell.content
      );
      const newPos = map2.positionAt(row + 1, col, table);
      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);
      col += attrs.colspan - 1;
    }
  }
}
function deleteRow(state, dispatch) {
  if (!isInTable(state)) return false;
  if (dispatch) {
    const rect = selectedRect(state), tr = state.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height) return false;
    for (let i = rect.bottom - 1; ; i--) {
      removeRow(tr, rect, i);
      if (i == rect.top) break;
      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(rect.table);
    }
    dispatch(tr);
  }
  return true;
}
function isEmpty(cell) {
  const c = cell.content;
  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;
}
function cellsOverlapRectangle({ width, height, map: map2 }, rect) {
  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;
  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
  for (let i = rect.top; i < rect.bottom; i++) {
    if (rect.left > 0 && map2[indexLeft] == map2[indexLeft - 1] || rect.right < width && map2[indexRight] == map2[indexRight + 1])
      return true;
    indexLeft += width;
    indexRight += width;
  }
  for (let i = rect.left; i < rect.right; i++) {
    if (rect.top > 0 && map2[indexTop] == map2[indexTop - width] || rect.bottom < height && map2[indexBottom] == map2[indexBottom + width])
      return true;
    indexTop++;
    indexBottom++;
  }
  return false;
}
function mergeCells(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)
    return false;
  const rect = selectedRect(state), { map: map2 } = rect;
  if (cellsOverlapRectangle(map2, rect)) return false;
  if (dispatch) {
    const tr = state.tr;
    const seen = {};
    let content = Fragment.empty;
    let mergedPos;
    let mergedCell;
    for (let row = rect.top; row < rect.bottom; row++) {
      for (let col = rect.left; col < rect.right; col++) {
        const cellPos = map2.map[row * map2.width + col];
        const cell = rect.table.nodeAt(cellPos);
        if (seen[cellPos] || !cell) continue;
        seen[cellPos] = true;
        if (mergedPos == null) {
          mergedPos = cellPos;
          mergedCell = cell;
        } else {
          if (!isEmpty(cell)) content = content.append(cell.content);
          const mapped = tr.mapping.map(cellPos + rect.tableStart);
          tr.delete(mapped, mapped + cell.nodeSize);
        }
      }
    }
    if (mergedPos == null || mergedCell == null) {
      return true;
    }
    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {
      ...addColSpan(
        mergedCell.attrs,
        mergedCell.attrs.colspan,
        rect.right - rect.left - mergedCell.attrs.colspan
      ),
      rowspan: rect.bottom - rect.top
    });
    if (content.size) {
      const end2 = mergedPos + 1 + mergedCell.content.size;
      const start2 = isEmpty(mergedCell) ? mergedPos + 1 : end2;
      tr.replaceWith(start2 + rect.tableStart, end2 + rect.tableStart, content);
    }
    tr.setSelection(
      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))
    );
    dispatch(tr);
  }
  return true;
}
function splitCell(state, dispatch) {
  const nodeTypes = tableNodeTypes(state.schema);
  return splitCellWithType(({ node }) => {
    return nodeTypes[node.type.spec.tableRole];
  })(state, dispatch);
}
function splitCellWithType(getCellType2) {
  return (state, dispatch) => {
    var _a;
    const sel = state.selection;
    let cellNode;
    let cellPos;
    if (!(sel instanceof CellSelection)) {
      cellNode = cellWrapping$1(sel.$from);
      if (!cellNode) return false;
      cellPos = (_a = cellAround$1(sel.$from)) == null ? void 0 : _a.pos;
    } else {
      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode == null || cellPos == null) {
      return false;
    }
    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
      return false;
    }
    if (dispatch) {
      let baseAttrs = cellNode.attrs;
      const attrs = [];
      const colwidth = baseAttrs.colwidth;
      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };
      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };
      const rect = selectedRect(state), tr = state.tr;
      for (let i = 0; i < rect.right - rect.left; i++)
        attrs.push(
          colwidth ? {
            ...baseAttrs,
            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null
          } : baseAttrs
        );
      let lastCell;
      for (let row = rect.top; row < rect.bottom; row++) {
        let pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row == rect.top) pos += cellNode.nodeSize;
        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {
          if (col == rect.left && row == rect.top) continue;
          tr.insert(
            lastCell = tr.mapping.map(pos + rect.tableStart, 1),
            getCellType2({ node: cellNode, row, col }).createAndFill(attrs[i])
          );
        }
      }
      tr.setNodeMarkup(
        cellPos,
        getCellType2({ node: cellNode, row: rect.top, col: rect.left }),
        attrs[0]
      );
      if (sel instanceof CellSelection)
        tr.setSelection(
          new CellSelection(
            tr.doc.resolve(sel.$anchorCell.pos),
            lastCell ? tr.doc.resolve(lastCell) : void 0
          )
        );
      dispatch(tr);
    }
    return true;
  };
}
function setCellAttr(name, value) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    const $cell = selectionCell(state);
    if ($cell.nodeAfter.attrs[name] === value) return false;
    if (dispatch) {
      const tr = state.tr;
      if (state.selection instanceof CellSelection)
        state.selection.forEachCell((node, pos) => {
          if (node.attrs[name] !== value)
            tr.setNodeMarkup(pos, null, {
              ...node.attrs,
              [name]: value
            });
        });
      else
        tr.setNodeMarkup($cell.pos, null, {
          ...$cell.nodeAfter.attrs,
          [name]: value
        });
      dispatch(tr);
    }
    return true;
  };
}
function deprecated_toggleHeader(type) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr = state.tr;
      const cells = rect.map.cellsInRect(
        type == "column" ? {
          left: rect.left,
          top: 0,
          right: rect.right,
          bottom: rect.map.height
        } : type == "row" ? {
          left: 0,
          top: rect.top,
          right: rect.map.width,
          bottom: rect.bottom
        } : rect
      );
      const nodes = cells.map((pos) => rect.table.nodeAt(pos));
      for (let i = 0; i < cells.length; i++)
        if (nodes[i].type == types.header_cell)
          tr.setNodeMarkup(
            rect.tableStart + cells[i],
            types.cell,
            nodes[i].attrs
          );
      if (tr.steps.length == 0)
        for (let i = 0; i < cells.length; i++)
          tr.setNodeMarkup(
            rect.tableStart + cells[i],
            types.header_cell,
            nodes[i].attrs
          );
      dispatch(tr);
    }
    return true;
  };
}
function isHeaderEnabledByType(type, rect, types) {
  const cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type == "row" ? rect.map.width : 1,
    bottom: type == "column" ? rect.map.height : 1
  });
  for (let i = 0; i < cellPositions.length; i++) {
    const cell = rect.table.nodeAt(cellPositions[i]);
    if (cell && cell.type !== types.header_cell) {
      return false;
    }
  }
  return true;
}
function toggleHeader(type, options) {
  options = options || { useDeprecatedLogic: false };
  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type);
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    if (dispatch) {
      const types = tableNodeTypes(state.schema);
      const rect = selectedRect(state), tr = state.tr;
      const isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types);
      const isHeaderColumnEnabled = isHeaderEnabledByType(
        "column",
        rect,
        types
      );
      const isHeaderEnabled = type === "column" ? isHeaderRowEnabled : type === "row" ? isHeaderColumnEnabled : false;
      const selectionStartsAt = isHeaderEnabled ? 1 : 0;
      const cellsRect = type == "column" ? {
        left: 0,
        top: selectionStartsAt,
        right: 1,
        bottom: rect.map.height
      } : type == "row" ? {
        left: selectionStartsAt,
        top: 0,
        right: rect.map.width,
        bottom: 1
      } : rect;
      const newType = type == "column" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == "row" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;
      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
        const cellPos = relativeCellPos + rect.tableStart;
        const cell = tr.doc.nodeAt(cellPos);
        if (cell) {
          tr.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });
      dispatch(tr);
    }
    return true;
  };
}
toggleHeader("row", {
  useDeprecatedLogic: true
});
toggleHeader("column", {
  useDeprecatedLogic: true
});
var toggleHeaderCell = toggleHeader("cell", {
  useDeprecatedLogic: true
});
function findNextCell($cell, dir) {
  if (dir < 0) {
    const before = $cell.nodeBefore;
    if (before) return $cell.pos - before.nodeSize;
    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
      const rowNode = $cell.node(-1).child(row);
      const lastChild = rowNode.lastChild;
      if (lastChild) {
        return rowEnd - 1 - lastChild.nodeSize;
      }
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) {
      return $cell.pos + $cell.nodeAfter.nodeSize;
    }
    const table = $cell.node(-1);
    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {
      const rowNode = table.child(row);
      if (rowNode.childCount) return rowStart + 1;
      rowStart += rowNode.nodeSize;
    }
  }
  return null;
}
function goToNextCell(direction) {
  return function(state, dispatch) {
    if (!isInTable(state)) return false;
    const cell = findNextCell(selectionCell(state), direction);
    if (cell == null) return false;
    if (dispatch) {
      const $cell = state.doc.resolve(cell);
      dispatch(
        state.tr.setSelection(TextSelection.between($cell, moveCellForward($cell))).scrollIntoView()
      );
    }
    return true;
  };
}
function deleteTable(state, dispatch) {
  const $pos = state.selection.$anchor;
  for (let d = $pos.depth; d > 0; d--) {
    const node = $pos.node(d);
    if (node.type.spec.tableRole == "table") {
      if (dispatch)
        dispatch(
          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()
        );
      return true;
    }
  }
  return false;
}
function deleteCellSelection(state, dispatch) {
  const sel = state.selection;
  if (!(sel instanceof CellSelection)) return false;
  if (dispatch) {
    const tr = state.tr;
    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;
    sel.forEachCell((cell, pos) => {
      if (!cell.content.eq(baseContent))
        tr.replace(
          tr.mapping.map(pos + 1),
          tr.mapping.map(pos + cell.nodeSize - 1),
          new Slice(baseContent, 0, 0)
        );
    });
    if (tr.docChanged) dispatch(tr);
  }
  return true;
}
function pastedCells(slice2) {
  if (!slice2.size) return null;
  let { content, openStart, openEnd } = slice2;
  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content = content.child(0).content;
  }
  const first2 = content.child(0);
  const role = first2.type.spec.tableRole;
  const schema = first2.type.schema, rows = [];
  if (role == "row") {
    for (let i = 0; i < content.childCount; i++) {
      let cells = content.child(i).content;
      const left2 = i ? 0 : Math.max(0, openStart - 1);
      const right2 = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left2 || right2)
        cells = fitSlice(
          tableNodeTypes(schema).row,
          new Slice(cells, left2, right2)
        ).content;
      rows.push(cells);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(
      openStart || openEnd ? fitSlice(
        tableNodeTypes(schema).row,
        new Slice(content, openStart, openEnd)
      ).content : content
    );
  } else {
    return null;
  }
  return ensureRectangular(schema, rows);
}
function ensureRectangular(schema, rows) {
  const widths = [];
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    for (let j = row.childCount - 1; j >= 0; j--) {
      const { rowspan, colspan } = row.child(j).attrs;
      for (let r2 = i; r2 < i + rowspan; r2++)
        widths[r2] = (widths[r2] || 0) + colspan;
    }
  }
  let width = 0;
  for (let r2 = 0; r2 < widths.length; r2++) width = Math.max(width, widths[r2]);
  for (let r2 = 0; r2 < widths.length; r2++) {
    if (r2 >= rows.length) rows.push(Fragment.empty);
    if (widths[r2] < width) {
      const empty2 = tableNodeTypes(schema).cell.createAndFill();
      const cells = [];
      for (let i = widths[r2]; i < width; i++) {
        cells.push(empty2);
      }
      rows[r2] = rows[r2].append(Fragment.from(cells));
    }
  }
  return { height: rows.length, width, rows };
}
function fitSlice(nodeType, slice2) {
  const node = nodeType.createAndFill();
  const tr = new Transform(node).replace(0, node.content.size, slice2);
  return tr.doc;
}
function clipCells({ width, height, rows }, newWidth, newHeight) {
  if (width != newWidth) {
    const added = [];
    const newRows = [];
    for (let row = 0; row < rows.length; row++) {
      const frag = rows[row], cells = [];
      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {
        let cell = frag.child(i % frag.childCount);
        if (col + cell.attrs.colspan > newWidth)
          cell = cell.type.createChecked(
            removeColSpan(
              cell.attrs,
              cell.attrs.colspan,
              col + cell.attrs.colspan - newWidth
            ),
            cell.content
          );
        cells.push(cell);
        col += cell.attrs.colspan;
        for (let j = 1; j < cell.attrs.rowspan; j++)
          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    const newRows = [];
    for (let row = 0, i = 0; row < newHeight; row++, i++) {
      const cells = [], source = rows[i % height];
      for (let j = 0; j < source.childCount; j++) {
        let cell = source.child(j);
        if (row + cell.attrs.rowspan > newHeight)
          cell = cell.type.create(
            {
              ...cell.attrs,
              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)
            },
            cell.content
          );
        cells.push(cell);
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    height = newHeight;
  }
  return { width, height, rows };
}
function growTable(tr, map2, table, start2, width, height, mapFrom) {
  const schema = tr.doc.type.schema;
  const types = tableNodeTypes(schema);
  let empty2;
  let emptyHead;
  if (width > map2.width) {
    for (let row = 0, rowEnd = 0; row < map2.height; row++) {
      const rowNode = table.child(row);
      rowEnd += rowNode.nodeSize;
      const cells = [];
      let add;
      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)
        add = empty2 || (empty2 = types.cell.createAndFill());
      else add = emptyHead || (emptyHead = types.header_cell.createAndFill());
      for (let i = map2.width; i < width; i++) cells.push(add);
      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start2), cells);
    }
  }
  if (height > map2.height) {
    const cells = [];
    for (let i = 0, start22 = (map2.height - 1) * map2.width; i < Math.max(map2.width, width); i++) {
      const header = i >= map2.width ? false : table.nodeAt(map2.map[start22 + i]).type == types.header_cell;
      cells.push(
        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty2 || (empty2 = types.cell.createAndFill())
      );
    }
    const emptyRow = types.row.create(null, Fragment.from(cells)), rows = [];
    for (let i = map2.height; i < height; i++) rows.push(emptyRow);
    tr.insert(tr.mapping.slice(mapFrom).map(start2 + table.nodeSize - 2), rows);
  }
  return !!(empty2 || emptyHead);
}
function isolateHorizontal(tr, map2, table, start2, left2, right2, top2, mapFrom) {
  if (top2 == 0 || top2 == map2.height) return false;
  let found = false;
  for (let col = left2; col < right2; col++) {
    const index2 = top2 * map2.width + col, pos = map2.map[index2];
    if (map2.map[index2 - map2.width] == pos) {
      found = true;
      const cell = table.nodeAt(pos);
      const { top: cellTop, left: cellLeft } = map2.findCell(pos);
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start2), null, {
        ...cell.attrs,
        rowspan: top2 - cellTop
      });
      tr.insert(
        tr.mapping.slice(mapFrom).map(map2.positionAt(top2, cellLeft, table)),
        cell.type.createAndFill({
          ...cell.attrs,
          rowspan: cellTop + cell.attrs.rowspan - top2
        })
      );
      col += cell.attrs.colspan - 1;
    }
  }
  return found;
}
function isolateVertical(tr, map2, table, start2, top2, bottom2, left2, mapFrom) {
  if (left2 == 0 || left2 == map2.width) return false;
  let found = false;
  for (let row = top2; row < bottom2; row++) {
    const index2 = row * map2.width + left2, pos = map2.map[index2];
    if (map2.map[index2 - 1] == pos) {
      found = true;
      const cell = table.nodeAt(pos);
      const cellLeft = map2.colCount(pos);
      const updatePos = tr.mapping.slice(mapFrom).map(pos + start2);
      tr.setNodeMarkup(
        updatePos,
        null,
        removeColSpan(
          cell.attrs,
          left2 - cellLeft,
          cell.attrs.colspan - (left2 - cellLeft)
        )
      );
      tr.insert(
        updatePos + cell.nodeSize,
        cell.type.createAndFill(
          removeColSpan(cell.attrs, 0, left2 - cellLeft)
        )
      );
      row += cell.attrs.rowspan - 1;
    }
  }
  return found;
}
function insertCells(state, dispatch, tableStart, rect, cells) {
  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;
  if (!table) {
    throw new Error("No table found");
  }
  let map2 = TableMap.get(table);
  const { top: top2, left: left2 } = rect;
  const right2 = left2 + cells.width, bottom2 = top2 + cells.height;
  const tr = state.tr;
  let mapFrom = 0;
  function recomp() {
    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
    if (!table) {
      throw new Error("No table found");
    }
    map2 = TableMap.get(table);
    mapFrom = tr.mapping.maps.length;
  }
  if (growTable(tr, map2, table, tableStart, right2, bottom2, mapFrom)) recomp();
  if (isolateHorizontal(tr, map2, table, tableStart, left2, right2, top2, mapFrom))
    recomp();
  if (isolateHorizontal(tr, map2, table, tableStart, left2, right2, bottom2, mapFrom))
    recomp();
  if (isolateVertical(tr, map2, table, tableStart, top2, bottom2, left2, mapFrom))
    recomp();
  if (isolateVertical(tr, map2, table, tableStart, top2, bottom2, right2, mapFrom))
    recomp();
  for (let row = top2; row < bottom2; row++) {
    const from2 = map2.positionAt(row, left2, table), to = map2.positionAt(row, right2, table);
    tr.replace(
      tr.mapping.slice(mapFrom).map(from2 + tableStart),
      tr.mapping.slice(mapFrom).map(to + tableStart),
      new Slice(cells.rows[row - top2], 0, 0)
    );
  }
  recomp();
  tr.setSelection(
    new CellSelection(
      tr.doc.resolve(tableStart + map2.positionAt(top2, left2, table)),
      tr.doc.resolve(tableStart + map2.positionAt(bottom2 - 1, right2 - 1, table))
    )
  );
  dispatch(tr);
}
var handleKeyDown = keydownHandler({
  ArrowLeft: arrow$2("horiz", -1),
  ArrowRight: arrow$2("horiz", 1),
  ArrowUp: arrow$2("vert", -1),
  ArrowDown: arrow$2("vert", 1),
  "Shift-ArrowLeft": shiftArrow("horiz", -1),
  "Shift-ArrowRight": shiftArrow("horiz", 1),
  "Shift-ArrowUp": shiftArrow("vert", -1),
  "Shift-ArrowDown": shiftArrow("vert", 1),
  Backspace: deleteCellSelection,
  "Mod-Backspace": deleteCellSelection,
  Delete: deleteCellSelection,
  "Mod-Delete": deleteCellSelection
});
function maybeSetSelection(state, dispatch, selection) {
  if (selection.eq(state.selection)) return false;
  if (dispatch) dispatch(state.tr.setSelection(selection).scrollIntoView());
  return true;
}
function arrow$2(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(
        state,
        dispatch,
        Selection.near(sel.$headCell, dir)
      );
    }
    if (axis != "horiz" && !sel.empty) return false;
    const end2 = atEndOfCell(view, axis, dir);
    if (end2 == null) return false;
    if (axis == "horiz") {
      return maybeSetSelection(
        state,
        dispatch,
        Selection.near(state.doc.resolve(sel.head + dir), dir)
      );
    } else {
      const $cell = state.doc.resolve(end2);
      const $next = nextCell($cell, axis, dir);
      let newSel;
      if ($next) newSel = Selection.near($next, 1);
      else if (dir < 0)
        newSel = Selection.near(state.doc.resolve($cell.before(-1)), -1);
      else newSel = Selection.near(state.doc.resolve($cell.after(-1)), 1);
      return maybeSetSelection(state, dispatch, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return (state, dispatch, view) => {
    if (!view) return false;
    const sel = state.selection;
    let cellSel;
    if (sel instanceof CellSelection) {
      cellSel = sel;
    } else {
      const end2 = atEndOfCell(view, axis, dir);
      if (end2 == null) return false;
      cellSel = new CellSelection(state.doc.resolve(end2));
    }
    const $head = nextCell(cellSel.$headCell, axis, dir);
    if (!$head) return false;
    return maybeSetSelection(
      state,
      dispatch,
      new CellSelection(cellSel.$anchorCell, $head)
    );
  };
}
function handleTripleClick(view, pos) {
  const doc2 = view.state.doc, $cell = cellAround$1(doc2.resolve(pos));
  if (!$cell) return false;
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _, slice2) {
  if (!isInTable(view.state)) return false;
  let cells = pastedCells(slice2);
  const sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells)
      cells = {
        width: 1,
        height: 1,
        rows: [
          Fragment.from(
            fitSlice(tableNodeTypes(view.state.schema).cell, slice2)
          )
        ]
      };
    const table = sel.$anchorCell.node(-1);
    const start2 = sel.$anchorCell.start(-1);
    const rect = TableMap.get(table).rectBetween(
      sel.$anchorCell.pos - start2,
      sel.$headCell.pos - start2
    );
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start2, rect, cells);
    return true;
  } else if (cells) {
    const $cell = selectionCell(view.state);
    const start2 = $cell.start(-1);
    insertCells(
      view.state,
      view.dispatch,
      start2,
      TableMap.get($cell.node(-1)).findCell($cell.pos - start2),
      cells
    );
    return true;
  } else {
    return false;
  }
}
function handleMouseDown(view, startEvent) {
  var _a;
  if (startEvent.ctrlKey || startEvent.metaKey) return;
  const startDOMCell = domInCell(view, startEvent.target);
  let $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround$1(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    return;
  }
  function setCellSelection($anchor2, event) {
    let $head = cellUnderMouse(view, event);
    const starting = tableEditingKey.getState(view.state) == null;
    if (!$head || !inSameTable($anchor2, $head)) {
      if (starting) $head = $anchor2;
      else return;
    }
    const selection = new CellSelection($anchor2, $head);
    if (starting || !view.state.selection.eq(selection)) {
      const tr = view.state.tr.setSelection(selection);
      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);
      view.dispatch(tr);
    }
  }
  function stop() {
    view.root.removeEventListener("mouseup", stop);
    view.root.removeEventListener("dragstart", stop);
    view.root.removeEventListener("mousemove", move);
    if (tableEditingKey.getState(view.state) != null)
      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
  }
  function move(_event) {
    const event = _event;
    const anchor = tableEditingKey.getState(view.state);
    let $anchor2;
    if (anchor != null) {
      $anchor2 = view.state.doc.resolve(anchor);
    } else if (domInCell(view, event.target) != startDOMCell) {
      $anchor2 = cellUnderMouse(view, startEvent);
      if (!$anchor2) return stop();
    }
    if ($anchor2) setCellSelection($anchor2, event);
  }
  view.root.addEventListener("mouseup", stop);
  view.root.addEventListener("dragstart", stop);
  view.root.addEventListener("mousemove", move);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection)) return null;
  const { $head } = view.state.selection;
  for (let d = $head.depth - 1; d >= 0; d--) {
    const parent = $head.node(d), index2 = dir < 0 ? $head.index(d) : $head.indexAfter(d);
    if (index2 != (dir < 0 ? 0 : parent.childCount)) return null;
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      const cellPos = $head.before(d);
      const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode) {
    if (dom.nodeName == "TD" || dom.nodeName == "TH") {
      return dom;
    }
  }
  return null;
}
function cellUnderMouse(view, event) {
  const mousePos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (!mousePos) return null;
  return mousePos ? cellAround$1(view.state.doc.resolve(mousePos.pos)) : null;
}
var TableView = class {
  constructor(node, defaultCellMinWidth) {
    this.node = node;
    this.defaultCellMinWidth = defaultCellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.table.style.setProperty(
      "--default-cell-min-width",
      `${defaultCellMinWidth}px`
    );
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumnsOnResize(node, this.colgroup, this.table, defaultCellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(node) {
    if (node.type != this.node.type) return false;
    this.node = node;
    updateColumnsOnResize(
      node,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    );
    return true;
  }
  ignoreMutation(record) {
    return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
  }
};
function updateColumnsOnResize(node, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {
  var _a;
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node.firstChild;
  if (!row) return;
  for (let i = 0, col = 0; i < row.childCount; i++) {
    const { colspan, colwidth } = row.child(i).attrs;
    for (let j = 0; j < colspan; j++, col++) {
      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];
      const cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || defaultCellMinWidth;
      if (!hasWidth) fixedWidth = false;
      if (!nextDOM) {
        const col2 = document.createElement("col");
        col2.style.width = cssWidth;
        colgroup.appendChild(col2);
      } else {
        if (nextDOM.style.width != cssWidth) {
          nextDOM.style.width = cssWidth;
        }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    const after = nextDOM.nextSibling;
    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = totalWidth + "px";
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = totalWidth + "px";
  }
}
var columnResizingPluginKey = new PluginKey(
  "tableColumnResizing"
);
function columnResizing({
  handleWidth = 5,
  cellMinWidth = 25,
  defaultCellMinWidth = 100,
  View = TableView,
  lastColumnResizable = true
} = {}) {
  const plugin = new Plugin({
    key: columnResizingPluginKey,
    state: {
      init(_, state) {
        var _a, _b;
        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;
        const tableName = tableNodeTypes(state.schema).table.name;
        if (View && nodeViews) {
          nodeViews[tableName] = (node, view) => {
            return new View(node, defaultCellMinWidth, view);
          };
        }
        return new ResizeState(-1, false);
      },
      apply(tr, prev) {
        return prev.apply(tr);
      }
    },
    props: {
      attributes: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        return pluginState && pluginState.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (view, event) => {
          handleMouseMove(view, event, handleWidth, lastColumnResizable);
        },
        mouseleave: (view) => {
          handleMouseLeave(view);
        },
        mousedown: (view, event) => {
          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);
        }
      },
      decorations: (state) => {
        const pluginState = columnResizingPluginKey.getState(state);
        if (pluginState && pluginState.activeHandle > -1) {
          return handleDecorations(state, pluginState.activeHandle);
        }
      },
      nodeViews: {}
    }
  });
  return plugin;
}
var ResizeState = class _ResizeState {
  constructor(activeHandle, dragging) {
    this.activeHandle = activeHandle;
    this.dragging = dragging;
  }
  apply(tr) {
    const state = this;
    const action = tr.getMeta(columnResizingPluginKey);
    if (action && action.setHandle != null)
      return new _ResizeState(action.setHandle, false);
    if (action && action.setDragging !== void 0)
      return new _ResizeState(state.activeHandle, action.setDragging);
    if (state.activeHandle > -1 && tr.docChanged) {
      let handle = tr.mapping.map(state.activeHandle, -1);
      if (!pointsAtCell(tr.doc.resolve(handle))) {
        handle = -1;
      }
      return new _ResizeState(handle, state.dragging);
    }
    return state;
  }
};
function handleMouseMove(view, event, handleWidth, lastColumnResizable) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState) return;
  if (!pluginState.dragging) {
    const target = domCellAround(event.target);
    let cell = -1;
    if (target) {
      const { left: left2, right: right2 } = target.getBoundingClientRect();
      if (event.clientX - left2 <= handleWidth)
        cell = edgeCell(view, event, "left", handleWidth);
      else if (right2 - event.clientX <= handleWidth)
        cell = edgeCell(view, event, "right", handleWidth);
    }
    if (cell != pluginState.activeHandle) {
      if (!lastColumnResizable && cell !== -1) {
        const $cell = view.state.doc.resolve(cell);
        const table = $cell.node(-1);
        const map2 = TableMap.get(table);
        const tableStart = $cell.start(-1);
        const col = map2.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;
        if (col == map2.width - 1) {
          return;
        }
      }
      updateHandle(view, cell);
    }
  }
}
function handleMouseLeave(view) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)
    updateHandle(view, -1);
}
function handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {
  var _a;
  if (!view.editable) return false;
  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)
    return false;
  const cell = view.state.doc.nodeAt(pluginState.activeHandle);
  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, {
      setDragging: { startX: event.clientX, startWidth: width }
    })
  );
  function finish(event2) {
    win.removeEventListener("mouseup", finish);
    win.removeEventListener("mousemove", move);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (pluginState2 == null ? void 0 : pluginState2.dragging) {
      updateColumnWidth(
        view,
        pluginState2.activeHandle,
        draggedWidth(pluginState2.dragging, event2, cellMinWidth)
      );
      view.dispatch(
        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })
      );
    }
  }
  function move(event2) {
    if (!event2.which) return finish(event2);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (!pluginState2) return;
    if (pluginState2.dragging) {
      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
      displayColumnWidth(
        view,
        pluginState2.activeHandle,
        dragged,
        defaultCellMinWidth
      );
    }
  }
  displayColumnWidth(
    view,
    pluginState.activeHandle,
    width,
    defaultCellMinWidth
  );
  win.addEventListener("mouseup", finish);
  win.addEventListener("mousemove", move);
  event.preventDefault();
  return true;
}
function currentColWidth(view, cellPos, { colspan, colwidth }) {
  const width = colwidth && colwidth[colwidth.length - 1];
  if (width) return width;
  const dom = view.domAtPos(cellPos);
  const node = dom.node.childNodes[dom.offset];
  let domWidth = node.offsetWidth, parts = colspan;
  if (colwidth) {
    for (let i = 0; i < colspan; i++)
      if (colwidth[i]) {
        domWidth -= colwidth[i];
        parts--;
      }
  }
  return domWidth / parts;
}
function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH")
    target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
  return target;
}
function edgeCell(view, event, side, handleWidth) {
  const offset2 = side == "right" ? -handleWidth : handleWidth;
  const found = view.posAtCoords({
    left: event.clientX + offset2,
    top: event.clientY
  });
  if (!found) return -1;
  const { pos } = found;
  const $cell = cellAround$1(view.state.doc.resolve(pos));
  if (!$cell) return -1;
  if (side == "right") return $cell.pos;
  const map2 = TableMap.get($cell.node(-1)), start2 = $cell.start(-1);
  const index2 = map2.map.indexOf($cell.pos - start2);
  return index2 % map2.width == 0 ? -1 : start2 + map2.map[index2 - 1];
}
function draggedWidth(dragging, event, resizeMinWidth) {
  const offset2 = event.clientX - dragging.startX;
  return Math.max(resizeMinWidth, dragging.startWidth + offset2);
}
function updateHandle(view, value) {
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })
  );
}
function updateColumnWidth(view, cell, width) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), map2 = TableMap.get(table), start2 = $cell.start(-1);
  const col = map2.colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  const tr = view.state.tr;
  for (let row = 0; row < map2.height; row++) {
    const mapIndex = row * map2.width + col;
    if (row && map2.map[mapIndex] == map2.map[mapIndex - map2.width]) continue;
    const pos = map2.map[mapIndex];
    const attrs = table.nodeAt(pos).attrs;
    const index2 = attrs.colspan == 1 ? 0 : col - map2.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index2] == width) continue;
    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index2] = width;
    tr.setNodeMarkup(start2 + pos, null, { ...attrs, colwidth });
  }
  if (tr.docChanged) view.dispatch(tr);
}
function displayColumnWidth(view, cell, width, defaultCellMinWidth) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), start2 = $cell.start(-1);
  const col = TableMap.get(table).colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  let dom = view.domAtPos($cell.start(-1)).node;
  while (dom && dom.nodeName != "TABLE") {
    dom = dom.parentNode;
  }
  if (!dom) return;
  updateColumnsOnResize(
    table,
    dom.firstChild,
    dom,
    defaultCellMinWidth,
    col,
    width
  );
}
function zeroes(n) {
  return Array(n).fill(0);
}
function handleDecorations(state, cell) {
  var _a;
  const decorations = [];
  const $cell = state.doc.resolve(cell);
  const table = $cell.node(-1);
  if (!table) {
    return DecorationSet.empty;
  }
  const map2 = TableMap.get(table);
  const start2 = $cell.start(-1);
  const col = map2.colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  for (let row = 0; row < map2.height; row++) {
    const index2 = col + row * map2.width;
    if ((col == map2.width - 1 || map2.map[index2] != map2.map[index2 + 1]) && (row == 0 || map2.map[index2] != map2.map[index2 - map2.width])) {
      const cellPos = map2.map[index2];
      const pos = start2 + cellPos + table.nodeAt(cellPos).nodeSize - 1;
      const dom = document.createElement("div");
      dom.className = "column-resize-handle";
      if ((_a = columnResizingPluginKey.getState(state)) == null ? void 0 : _a.dragging) {
        decorations.push(
          Decoration.node(
            start2 + cellPos,
            start2 + cellPos + table.nodeAt(cellPos).nodeSize,
            {
              class: "column-resize-dragging"
            }
          )
        );
      }
      decorations.push(Decoration.widget(pos, dom));
    }
  }
  return DecorationSet.create(state.doc, decorations);
}
function tableEditing({
  allowTableNodeSelection = false
} = {}) {
  return new Plugin({
    key: tableEditingKey,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(tr, cur) {
        const set = tr.getMeta(tableEditingKey);
        if (set != null) return set == -1 ? null : set;
        if (cur == null || !tr.docChanged) return cur;
        const { deleted, pos } = tr.mapping.mapResult(cur);
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      handleDOMEvents: {
        mousedown: handleMouseDown
      },
      createSelectionBetween(view) {
        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
      },
      handleTripleClick,
      handleKeyDown,
      handlePaste
    },
    appendTransaction(_, oldState, state) {
      return normalizeSelection(
        state,
        fixTables(state, oldState),
        allowTableNodeSelection
      );
    }
  });
}
const isCellSelection = (value) => value instanceof CellSelection;
const deleteTableWhenSelected = ({ editor }) => {
  const { selection } = editor.state;
  if (!isCellSelection(selection)) return false;
  let cellCount = 0;
  const table = findParentNodeClosestToPos(selection.ranges[0].$from, (node) => {
    return node.type.name === "table";
  });
  table?.node.descendants((node) => {
    if (node.type.name === "table") return false;
    if (["tableCell", "tableHeader"].includes(node.type.name)) {
      cellCount += 1;
    }
  });
  const allCellsSelected = cellCount === selection.ranges.length;
  if (!allCellsSelected) {
    return false;
  }
  editor.commands.deleteTable();
  return true;
};
const createCellBorders = ({ size = 0.66665, color = "#000000" } = {}) => {
  return {
    top: { size, color },
    left: { size, color },
    bottom: { size, color },
    right: { size, color }
  };
};
function cellAround($pos) {
  for (let d = $pos.depth - 1; d > 0; d--)
    if ($pos.node(d).type.spec.tableRole == "row") return $pos.node(0).resolve($pos.before(d + 1));
  return null;
}
function cellWrapping($pos) {
  for (let d = $pos.depth; d > 0; d--) {
    const role = $pos.node(d).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") return $pos.node(d);
  }
  return null;
}
const Table = Node$1.create({
  name: "table",
  content: "tableRow+",
  group: "block",
  isolating: true,
  tableRole: "table",
  /**
   * Table extension options
   * @category Options
   * @typedef {Object} TableOptions
   * @property {Object} [htmlAttributes={'aria-label': 'Table node'}] - Default HTML attributes for all tables
   * @property {boolean} [resizable=true] - Enable column resizing functionality
   * @property {number} [handleWidth=5] - Width of resize handles in pixels
   * @property {number} [cellMinWidth=10] - Minimum cell width constraint in pixels
   * @property {boolean} [lastColumnResizable=true] - Allow resizing of the last column
   * @property {boolean} [allowTableNodeSelection=false] - Enable selecting the entire table node
   */
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table node"
      },
      resizable: true,
      handleWidth: 5,
      cellMinWidth: 10,
      lastColumnResizable: true,
      allowTableNodeSelection: false
    };
  },
  addAttributes() {
    return {
      /* tableWidth: {
        renderDOM: ({ tableWidth }) => {
          if (!tableWidth) return {};
          const { width, type = 'auto' } = tableWidth;
          return { 
            style: `width: ${width}px` 
          };
        },
      }, */
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking ID (not user-configurable)
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      /**
       * @category Attribute
       * @param {TableIndent} [tableIndent] - Table indentation configuration
       */
      tableIndent: {
        renderDOM: ({ tableIndent }) => {
          if (!tableIndent) return {};
          const { width } = tableIndent;
          let style = "";
          if (width) style += `margin-left: ${width}px`;
          return {
            style
          };
        }
      },
      /**
       * @category Attribute
       * @param {import("./tableHelpers/createTableBorders.js").TableBorders} [borders] - Border styling for this table
       */
      borders: {
        default: {},
        renderDOM({ borders }) {
          if (!borders) return {};
          const style = Object.entries(borders).reduce((acc, [key, { size, color }]) => {
            return `${acc}border-${key}: ${Math.ceil(size)}px solid ${color || "black"};`;
          }, "");
          return {
            style
          };
        }
      },
      /**
       * @category Attribute
       * @param {string} [borderCollapse='collapse'] - CSS border-collapse property
       */
      borderCollapse: {
        default: null,
        renderDOM({ borderCollapse }) {
          return {
            style: `border-collapse: ${borderCollapse || "collapse"}`
          };
        }
      },
      /**
       * @category Attribute
       * @param {string} [justification] - Table alignment ('left', 'center', 'right')
       */
      justification: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.justification) return {};
          if (attrs.justification === "center") {
            return { style: `margin: 0 auto` };
          }
          if (attrs.justification === "right") {
            return { style: `margin-left: auto` };
          }
          return {};
        }
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [tableStyleId] - Internal reference to table style (not user-configurable)
       */
      tableStyleId: {
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [tableLayout] - CSS table-layout property (advanced usage)
       */
      tableLayout: {
        rendered: false
      },
      /**
       * @category Attribute
       * @param {number} [tableCellSpacing] - Cell spacing in pixels for this table
       */
      tableCellSpacing: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: "table" }];
  },
  renderDOM({ node, htmlAttributes }) {
    const { colgroup, tableWidth, tableMinWidth } = createColGroup(node, this.options.cellMinWidth);
    const attrs = Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, {
      style: tableWidth ? `width: ${tableWidth}` : `min-width: ${tableMinWidth}`
    });
    const table = ["table", attrs, colgroup, ["tbody", 0]];
    return table;
  },
  addCommands() {
    return {
      /**
       * Insert a new table into the document
       * @category Command
       * @param {TableConfig} [config] - Table configuration options
       * @returns {Function} Command
       * @example
       * // Using default values
       * insertTable() // Creates 3x3 table without header
       *
       * // Using custom values
       * insertTable({ rows: 3, cols: 3, withHeaderRow: true })
       *
       */
      insertTable: ({ rows = 3, cols = 3, withHeaderRow = false } = {}) => ({ tr, dispatch, editor }) => {
        const node = createTable(editor.schema, rows, cols, withHeaderRow);
        if (dispatch) {
          const offset2 = tr.selection.from + 1;
          tr.replaceSelectionWith(node).scrollIntoView().setSelection(TextSelection.near(tr.doc.resolve(offset2)));
        }
        return true;
      },
      /**
       * Delete the entire table containing the cursor
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteTable()
       */
      deleteTable: () => ({ state, dispatch }) => {
        return deleteTable(state, dispatch);
      },
      /**
       * Add a column before the current column
       * @category Command
       * @returns {Function} Command
       * @example
       * addColumnBefore()
       * @note Preserves cell attributes from current column
       */
      addColumnBefore: () => ({ state, dispatch, chain }) => {
        if (!addColumnBefore(state)) return false;
        let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state);
        return chain().command(() => addColumnBefore(state, dispatch)).command(({ tr }) => {
          let table = tr.doc.nodeAt(rect.tableStart - 1);
          if (!table) return false;
          let updatedMap = TableMap.get(table);
          let newColumnIndex = rect.left;
          if (newColumnIndex < 0 || newColumnIndex >= updatedMap.width) {
            return false;
          }
          for (let row = 0; row < updatedMap.height; row++) {
            let cellIndex = row * updatedMap.width + newColumnIndex;
            let cellPos = updatedMap.map[cellIndex];
            let cellAbsolutePos = rect.tableStart + cellPos;
            let cell = tr.doc.nodeAt(cellAbsolutePos);
            if (cell) {
              let attrs = {
                ...currentCellAttrs,
                colspan: cell.attrs.colspan,
                rowspan: cell.attrs.rowspan,
                colwidth: cell.attrs.colwidth
              };
              tr.setNodeMarkup(cellAbsolutePos, null, attrs);
            }
          }
          return true;
        }).run();
      },
      /**
       * Add a column after the current column
       * @category Command
       * @returns {Function} Command
       * @example
       * addColumnAfter()
       * @note Preserves cell attributes from current column
       */
      addColumnAfter: () => ({ state, dispatch, chain }) => {
        if (!addColumnAfter(state)) return false;
        let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state);
        return chain().command(() => addColumnAfter(state, dispatch)).command(({ tr }) => {
          let table = tr.doc.nodeAt(rect.tableStart - 1);
          if (!table) return false;
          let updatedMap = TableMap.get(table);
          let newColumnIndex = rect.left + 1;
          if (newColumnIndex < 0 || newColumnIndex >= updatedMap.width) {
            return false;
          }
          for (let row = 0; row < updatedMap.height; row++) {
            let cellIndex = row * updatedMap.width + newColumnIndex;
            let cellPos = updatedMap.map[cellIndex];
            let cellAbsolutePos = rect.tableStart + cellPos;
            let cell = tr.doc.nodeAt(cellAbsolutePos);
            if (cell) {
              let attrs = {
                ...currentCellAttrs,
                colspan: cell.attrs.colspan,
                rowspan: cell.attrs.rowspan,
                colwidth: cell.attrs.colwidth
              };
              tr.setNodeMarkup(cellAbsolutePos, null, attrs);
            }
          }
          return true;
        }).run();
      },
      /**
       * Delete the column containing the cursor
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteColumn()
       */
      deleteColumn: () => ({ state, dispatch }) => {
        return deleteColumn(state, dispatch);
      },
      /**
       * Add a row before the current row
       * @category Command
       * @returns {Function} Command
       * @example
       * addRowBefore()
       * @note Preserves cell attributes from current row
       */
      addRowBefore: () => ({ state, dispatch, chain }) => {
        if (!addRowBefore(state)) return false;
        let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state);
        return chain().command(() => addRowBefore(state, dispatch)).command(({ tr }) => {
          let table = tr.doc.nodeAt(rect.tableStart - 1);
          if (!table) return false;
          let updatedMap = TableMap.get(table);
          let newRowIndex = rect.top;
          if (newRowIndex < 0 || newRowIndex >= updatedMap.height) {
            return false;
          }
          for (let col = 0; col < updatedMap.width; col++) {
            let cellIndex = newRowIndex * updatedMap.width + col;
            let cellPos = updatedMap.map[cellIndex];
            let cellAbsolutePos = rect.tableStart + cellPos;
            let cell = tr.doc.nodeAt(cellAbsolutePos);
            if (cell) {
              let attrs = {
                ...currentCellAttrs,
                colspan: cell.attrs.colspan,
                rowspan: cell.attrs.rowspan,
                colwidth: cell.attrs.colwidth
              };
              tr.setNodeMarkup(cellAbsolutePos, null, attrs);
            }
          }
          return true;
        }).run();
      },
      /**
       * Add a row after the current row
       * @category Command
       * @returns {Function} Command
       * @example
       * addRowAfter()
       * @note Preserves cell attributes from current row
       */
      addRowAfter: () => ({ state, dispatch, chain }) => {
        if (!addRowAfter(state)) return false;
        let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state);
        return chain().command(() => addRowAfter(state, dispatch)).command(({ tr }) => {
          let table = tr.doc.nodeAt(rect.tableStart - 1);
          if (!table) return false;
          let updatedMap = TableMap.get(table);
          let newRowIndex = rect.top + 1;
          if (newRowIndex >= updatedMap.height) return false;
          for (let col = 0; col < updatedMap.width; col++) {
            let cellIndex = newRowIndex * updatedMap.width + col;
            let cellPos = updatedMap.map[cellIndex];
            let cellAbsolutePos = rect.tableStart + cellPos;
            let cell = tr.doc.nodeAt(cellAbsolutePos);
            if (cell) {
              let attrs = {
                ...currentCellAttrs,
                colspan: cell.attrs.colspan,
                rowspan: cell.attrs.rowspan,
                colwidth: cell.attrs.colwidth
              };
              tr.setNodeMarkup(cellAbsolutePos, null, attrs);
            }
          }
          return true;
        }).run();
      },
      /**
       * Delete the row containing the cursor
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteRow()
       */
      deleteRow: () => ({ state, dispatch }) => {
        return deleteRow(state, dispatch);
      },
      /**
       * Merge selected cells into one
       * @category Command
       * @returns {Function} Command
       * @example
       * mergeCells()
       * @note Content from all cells is preserved
       */
      mergeCells: () => ({ state, dispatch }) => {
        return mergeCells(state, dispatch);
      },
      /**
       * Split a merged cell back into individual cells
       * @category Command
       * @returns {Function} Command - true if split, false if position invalid
       * @example
       * splitCell()
       */
      splitCell: () => ({ state, dispatch, commands: commands2 }) => {
        if (splitCell(state, dispatch)) {
          return true;
        }
        return commands2.splitSingleCell();
      },
      /**
       * Split a single unmerged cell into two cells horizontally
       * @category Command
       * @returns {Function} Command - true if split, false if position invalid
       * @example
       * splitSingleCell()
       * @note This command splits a single cell (not merged) into two cells by:
       * - Dividing the cell width in half
       * - Inserting a new cell to the right
       * - Adjusting colspan for cells in other rows that span this column
       * - Only works on cells with colspan=1 and rowspan=1
       * @note Different from splitCell which splits merged cells back to original cells
       */
      splitSingleCell: () => ({ state, dispatch, tr }) => {
        const sel = state.selection;
        let cellNode;
        let cellPos;
        if (!(sel instanceof CellSelection)) {
          cellNode = cellWrapping(sel.$from);
          if (!cellNode) return false;
          cellPos = cellAround(sel.$from)?.pos;
        } else {
          if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
          cellNode = sel.$anchorCell.nodeAfter;
          cellPos = sel.$anchorCell.pos;
        }
        if (cellNode == null || cellPos == null) {
          return false;
        }
        if (cellNode.attrs.colspan != 1 || cellNode.attrs.rowspan != 1) {
          return false;
        }
        if (dispatch) {
          let rect = selectedRect(state);
          let currentRow = rect.top;
          let currentCol = rect.left;
          let baseAttrs = { ...cellNode.attrs };
          let currentColWidth2 = baseAttrs.colwidth;
          let newCellWidth = null;
          if (currentColWidth2 && currentColWidth2[0]) {
            newCellWidth = Math.ceil(currentColWidth2[0] / 2);
          }
          if (newCellWidth) {
            tr.setNodeMarkup(tr.mapping.map(cellPos, 1), null, { ...baseAttrs, colwidth: [newCellWidth] });
          }
          const newCellAttrs = { ...baseAttrs, colwidth: newCellWidth ? [newCellWidth] : null };
          const newCell = getCellType({ node: cellNode, state }).createAndFill(newCellAttrs);
          tr.insert(tr.mapping.map(cellPos + cellNode.nodeSize, 1), newCell);
          for (let row = 0; row < rect.map.height; row++) {
            if (row === currentRow) continue;
            let rowCells = /* @__PURE__ */ new Set();
            for (let col = 0; col < rect.map.width; col++) {
              let cellIndex = rect.map.map[row * rect.map.width + col];
              if (cellIndex != null) rowCells.add(cellIndex);
            }
            [...rowCells].forEach((cellIndex) => {
              let cellRect = rect.map.findCell(cellIndex);
              if (cellRect.left <= currentCol && cellRect.right > currentCol) {
                let cellPos2 = tr.mapping.map(rect.tableStart + cellIndex, 1);
                let cell = tr.doc.nodeAt(cellPos2);
                if (cell) {
                  let newColspan = (cell.attrs.colspan || 1) + 1;
                  let updatedColwidth = cell.attrs.colwidth;
                  if (updatedColwidth && newCellWidth) {
                    let originalColIndex = currentCol - cellRect.left;
                    updatedColwidth = [
                      ...updatedColwidth.slice(0, originalColIndex),
                      newCellWidth,
                      // current cell width
                      newCellWidth,
                      // new cell width
                      ...updatedColwidth.slice(originalColIndex + 1)
                    ];
                  }
                  let cellAttrs = { ...cell.attrs, colspan: newColspan, colwidth: updatedColwidth };
                  tr.setNodeMarkup(cellPos2, null, cellAttrs);
                }
              }
            });
          }
        }
        return true;
      },
      /**
       * Toggle between merge and split cells based on selection
       * @category Command
       * @returns {Function} Command
       * @example
       * mergeOrSplit()
       * @note Merges if multiple cells selected, splits if merged cell selected
       */
      mergeOrSplit: () => ({ state, dispatch, commands: commands2 }) => {
        if (mergeCells(state, dispatch)) {
          return true;
        }
        return commands2.splitCell();
      },
      /**
       * Toggle the first column as header column
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderColumn()
       */
      toggleHeaderColumn: () => ({ state, dispatch }) => {
        return toggleHeader("column")(state, dispatch);
      },
      /**
       * Toggle the first row as header row
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderRow()
       */
      toggleHeaderRow: () => ({ state, dispatch }) => {
        return toggleHeader("row")(state, dispatch);
      },
      /**
       * Toggle current cell as header cell
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderCell()
       */
      toggleHeaderCell: () => ({ state, dispatch }) => {
        return toggleHeaderCell(state, dispatch);
      },
      /**
       * Set an attribute on selected cells
       * @category Command
       * @param {string} name - Attribute name
       * @param {*} value - Attribute value
       * @returns {Function} Command
       * @example
       * setCellAttr('background', { color: 'ff0000' })
       * setCellAttr('verticalAlign', 'middle')
       */
      setCellAttr: (name, value) => ({ state, dispatch }) => {
        return setCellAttr(name, value)(state, dispatch);
      },
      /**
       * Navigate to the next cell (Tab behavior)
       * @category Command
       * @returns {Function} Command
       * @example
       * goToNextCell()
       */
      goToNextCell: () => ({ state, dispatch }) => {
        return goToNextCell(1)(state, dispatch);
      },
      /**
       * Navigate to the previous cell (Shift+Tab behavior)
       * @category Command
       * @returns {Function} Command
       * @example
       * goToPreviousCell()
       */
      goToPreviousCell: () => ({ state, dispatch }) => {
        return goToNextCell(-1)(state, dispatch);
      },
      /**
       * Fix table structure inconsistencies
       * @category Command
       * @returns {Function} Command
       * @example
       * fixTables()
       * @note Repairs malformed tables and normalizes structure
       */
      fixTables: () => ({ state, dispatch }) => {
        if (dispatch) {
          fixTables(state);
        }
        return true;
      },
      /**
       * Set cell selection programmatically
       * @category Command
       * @param {CellSelectionPosition} pos - Cell selection coordinates
       * @returns {Function} Command
       * @example
       * setCellSelection({ anchorCell: 10, headCell: 15 })
       */
      setCellSelection: (pos) => ({ tr, dispatch }) => {
        if (dispatch) {
          tr.setSelection(CellSelection.create(tr.doc, pos.anchorCell, pos.headCell));
        }
        return true;
      },
      /**
       * Set background color for selected cells
       * @category Command
       * @param {string} value - Color value (hex with or without #)
       * @returns {Function} Command
       * @example
       * setCellBackground('#ff0000')
       * setCellBackground('ff0000')
       */
      setCellBackground: (value) => ({ editor, commands: commands2, dispatch }) => {
        const { selection } = editor.state;
        if (!isCellSelection(selection)) {
          return false;
        }
        const color = value?.startsWith("#") ? value.slice(1) : value;
        if (dispatch) {
          return commands2.setCellAttr("background", { color });
        }
        return true;
      },
      /**
       * Remove all borders from table and its cells
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteCellAndTableBorders()
       * @note Sets all border sizes to 0
       */
      deleteCellAndTableBorders: () => ({ state, tr }) => {
        if (!isInTable$1(state)) {
          return false;
        }
        const table = findParentNode((node) => node.type.name === this.name)(state.selection);
        if (!table) {
          return false;
        }
        const from2 = table.pos;
        const to = table.pos + table.node.nodeSize;
        state.doc.nodesBetween(from2, to, (node, pos) => {
          if (["tableCell", "tableHeader"].includes(node.type.name)) {
            tr.setNodeMarkup(pos, void 0, {
              ...node.attrs,
              borders: createCellBorders({ size: 0 })
            });
          }
        });
        tr.setNodeMarkup(table.pos, void 0, {
          ...table.node.attrs,
          borders: createTableBorders({ size: 0 })
        });
        return true;
      }
    };
  },
  addShortcuts() {
    return {
      Tab: () => {
        if (this.editor.commands.goToNextCell()) {
          return true;
        }
        if (!this.editor.can().addRowAfter()) {
          return false;
        }
        return this.editor.chain().addRowAfter().goToNextCell().run();
      },
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: deleteTableWhenSelected,
      "Mod-Backspace": deleteTableWhenSelected,
      Delete: deleteTableWhenSelected,
      "Mod-Delete": deleteTableWhenSelected
    };
  },
  addPmPlugins() {
    const resizable = this.options.resizable && this.editor.isEditable;
    return [
      ...resizable ? [
        columnResizing({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          lastColumnResizable: this.options.lastColumnResizable,
          View: createTableView({
            editor: this.editor
          })
        })
      ] : [],
      tableEditing({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(extension) {
    return {
      tableRole: callOrGet(
        getExtensionConfigField(extension, "tableRole", {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        })
      )
    };
  }
});
function getCellType({ node, state }) {
  const nodeTypes = tableNodeTypes(state.schema);
  return nodeTypes[node.type.spec.tableRole];
}
function copyCellAttrs(node) {
  const { colspan, rowspan, colwidth, ...attrs } = node.attrs;
  return attrs;
}
function getCurrentCellAttrs(state) {
  let rect = selectedRect(state);
  let index2 = rect.top * rect.map.width + rect.left;
  let pos = rect.map.map[index2];
  let cell = rect.table.nodeAt(pos);
  let attrs = copyCellAttrs(cell);
  return { rect, cell, attrs };
}
const TableHeader = Node$1.create({
  name: "tableHeader",
  content: "block+",
  tableRole: "header_cell",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table head node"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {number} [colspan=1] - Number of columns this header spans
       */
      colspan: {
        default: 1
      },
      /**
       * @category Attribute
       * @param {number} [rowspan=1] - Number of rows this header spans
       */
      rowspan: {
        default: 1
      },
      /**
       * @category Attribute
       * @param {number[]} [colwidth] - Column widths array in pixels
       */
      colwidth: {
        default: null,
        parseDOM: (element) => {
          const colwidth = element.getAttribute("data-colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        },
        renderDOM: (attrs) => {
          if (!attrs.colwidth) return {};
          return {
            "data-colwidth": attrs.colwidth.join(",")
          };
        }
      }
    };
  },
  parseDOM() {
    return [{ tag: "th" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["th", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const TableRow = Node$1.create({
  name: "tableRow",
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table row node"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {number} [rowHeight] - Fixed row height in pixels
       */
      rowHeight: {
        renderDOM({ rowHeight }) {
          if (!rowHeight) return {};
          const style = `height: ${rowHeight}px`;
          return { style };
        }
      }
    };
  },
  parseDOM() {
    return [{ tag: "tr" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["tr", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const TableCell = Node$1.create({
  name: "tableCell",
  content: "block+",
  tableRole: "cell",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table cell node"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {number} [colspan=1] - Number of columns this cell spans
       */
      colspan: {
        default: 1
      },
      /**
       * @category Attribute
       * @param {number} [rowspan=1] - Number of rows this cell spans
       */
      rowspan: {
        default: 1
      },
      /**
       * @category Attribute
       * @param {number[]} [colwidth=[100]] - Column widths array in pixels
       */
      colwidth: {
        default: [100],
        parseDOM: (elem) => {
          const colwidth = elem.getAttribute("data-colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        },
        renderDOM: (attrs) => {
          if (!attrs.colwidth) return {};
          return {
            "data-colwidth": attrs.colwidth.join(",")
          };
        }
      },
      /**
       * @category Attribute
       * @param {CellBackground} [background] - Cell background color configuration
       */
      background: {
        renderDOM({ background }) {
          if (!background) return {};
          const { color } = background || {};
          const style = `background-color: ${color ? `#${color}` : "transparent"}`;
          return { style };
        }
      },
      /**
       * @category Attribute
       * @param {string} [verticalAlign] - Vertical content alignment (top, middle, bottom)
       */
      verticalAlign: {
        renderDOM({ verticalAlign }) {
          if (!verticalAlign) return {};
          const style = `vertical-align: ${verticalAlign}`;
          return { style };
        }
      },
      /**
       * @category Attribute
       * @param {CellMargins} [cellMargins] - Internal cell padding
       */
      cellMargins: {
        renderDOM({ cellMargins }) {
          if (!cellMargins) return {};
          const sides2 = ["top", "right", "bottom", "left"];
          const style = sides2.map((side) => {
            const margin = cellMargins?.[side];
            if (margin) return `padding-${side}: ${margin}px;`;
            return "";
          }).join(" ");
          return { style };
        }
      },
      /**
       * @category Attribute
       * @param {CellBorders} [borders] - Cell border configuration
       */
      borders: {
        default: () => createCellBorders(),
        renderDOM({ borders }) {
          if (!borders) return {};
          const sides2 = ["top", "right", "bottom", "left"];
          const style = sides2.map((side) => {
            const border = borders?.[side];
            if (border && border.val === "none") return `border-${side}: ${border.val};`;
            if (border) return `border-${side}: ${Math.ceil(border.size)}px solid ${border.color || "black"};`;
            return "";
          }).join(" ");
          return { style };
        }
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [widthType='auto'] - Internal width type
       */
      widthType: {
        default: "auto",
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [widthUnit='px'] - Internal width unit
       */
      widthUnit: {
        default: "px",
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: "td" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["td", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
class FieldAnnotationView {
  constructor(options) {
    __privateAdd(this, _FieldAnnotationView_instances);
    __publicField(this, "editor");
    __publicField(this, "node");
    __publicField(this, "decorations");
    __publicField(this, "getPos");
    __publicField(this, "htmlAttributes");
    __publicField(this, "dom");
    __publicField(this, "annotationClass");
    __publicField(this, "annotationContentClass");
    __publicField(this, "borderColor");
    this.editor = options.editor;
    this.node = options.node;
    this.decorations = options.decorations;
    this.getPos = options.getPos;
    this.htmlAttributes = options.htmlAttributes;
    this.annotationClass = options.annotationClass;
    this.annotationContentClass = options.annotationContentClass;
    this.borderColor = options.borderColor;
    this.handleAnnotationClick = this.handleAnnotationClick.bind(this);
    this.handleAnnotationDoubleClick = this.handleAnnotationDoubleClick.bind(this);
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);
    this.buildView();
    this.attachEventListeners();
  }
  buildView() {
    let { type } = this.node.attrs;
    let handlers2 = {
      text: (...args) => this.buildTextView(...args),
      image: (...args) => this.buildImageView(...args),
      signature: (...args) => this.buildSignatureView(...args),
      checkbox: (...args) => this.buildCheckboxView(...args),
      html: (...args) => this.buildHTMLView(...args),
      link: (...args) => this.buildLinkView(...args),
      default: (...args) => this.buildTextView(...args)
    };
    let buildHandler = handlers2[type] ?? handlers2.default;
    buildHandler();
  }
  buildTextView() {
    let { displayLabel } = this.node.attrs;
    let { annotation } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this, {
      displayLabel
    });
    this.dom = annotation;
  }
  buildImageView() {
    let { displayLabel, imageSrc } = this.node.attrs;
    let { annotation, content } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (imageSrc) {
      let img = document.createElement("img");
      img.src = imageSrc;
      img.alt = displayLabel;
      img.style.height = "auto";
      img.style.maxWidth = "100%";
      img.style.pointerEvents = "none";
      img.style.verticalAlign = "middle";
      content.append(img);
      annotation.style.display = "inline-block";
      content.style.display = "inline-block";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildSignatureView() {
    let { displayLabel, imageSrc } = this.node.attrs;
    displayLabel = displayLabel || "Signature";
    let { annotation, content } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (imageSrc) {
      let img = document.createElement("img");
      img.src = imageSrc;
      img.alt = displayLabel;
      img.style.height = "auto";
      img.style.maxWidth = "100%";
      img.style.maxHeight = "28px";
      img.style.pointerEvents = "none";
      img.style.verticalAlign = "middle";
      content.append(img);
      annotation.style.display = "inline-block";
      content.style.display = "inline-block";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildCheckboxView() {
    let { displayLabel } = this.node.attrs;
    let { annotation } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this, {
      displayLabel
    });
    this.dom = annotation;
  }
  buildHTMLView() {
    let { displayLabel, rawHtml } = this.node.attrs;
    if (!this.editor.options.isHeadless && !!rawHtml) {
      try {
        const tempDiv = document.createElement("div");
        const childEditor = this.editor.createChildEditor({
          element: tempDiv,
          html: rawHtml
        });
        rawHtml = childEditor.view.dom.innerHTML;
      } catch (error) {
        console.warn("Error parsing HTML in FieldAnnotationView:", error);
      }
    }
    let { annotation, content } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (rawHtml) {
      content.innerHTML = rawHtml.trim();
      annotation.style.display = "inline-block";
      content.style.display = "inline-block";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildLinkView() {
    let { displayLabel, linkUrl } = this.node.attrs;
    let { annotation, content } = __privateMethod(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (linkUrl) {
      let link = document.createElement("a");
      link.href = linkUrl;
      link.target = "_blank";
      link.textContent = linkUrl;
      link.style.textDecoration = "none";
      content.append(link);
      content.style.pointerEvents = "all";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  attachEventListeners() {
    this.dom.addEventListener("click", this.handleAnnotationClick);
    this.dom.addEventListener("dblclick", this.handleAnnotationDoubleClick);
    this.editor.on("selectionUpdate", this.handleSelectionUpdate);
  }
  removeEventListeners() {
    this.dom.removeEventListener("click", this.handleAnnotationClick);
    this.dom.removeEventListener("dblclick", this.handleAnnotationDoubleClick);
    this.editor.off("selectionUpdate", this.handleSelectionUpdate);
  }
  handleSelectionUpdate({ editor }) {
    if (!this.editor.isEditable) {
      return;
    }
    let { selection } = editor.state;
    if (selection instanceof NodeSelection) {
      let currentNode = selection.node;
      if (this.node.eq(currentNode)) {
        this.editor.emit("fieldAnnotationSelected", {
          editor: this.editor,
          node: this.node,
          nodePos: this.getPos(),
          target: this.dom
        });
      }
    }
  }
  handleAnnotationClick(event) {
    if (!this.editor.isEditable) {
      return;
    }
    this.editor.emit("fieldAnnotationClicked", {
      editor: this.editor,
      node: this.node,
      nodePos: this.getPos(),
      event,
      currentTarget: event.currentTarget
    });
  }
  handleAnnotationDoubleClick(event) {
    if (!this.editor.isEditable) {
      return;
    }
    this.editor.emit("fieldAnnotationDoubleClicked", {
      editor: this.editor,
      node: this.node,
      nodePos: this.getPos(),
      event,
      currentTarget: event.currentTarget
    });
  }
  stopEvent(event) {
    if (!this.editor.isEditable) {
      event.preventDefault();
      return true;
    }
    return false;
  }
  // Can be used to manually update the NodeView.
  // Otherwise the NodeView is recreated.
  update() {
    return false;
  }
  ignoreMutation() {
    return true;
  }
  destroy() {
    this.removeEventListeners();
  }
  updateAttributes(attributes) {
    this.editor.commands.command(({ tr }) => {
      tr.setNodeMarkup(this.getPos(), void 0, {
        ...this.node.attrs,
        ...attributes
      });
      return true;
    });
  }
}
_FieldAnnotationView_instances = new WeakSet();
createAnnotation_fn = function({ displayLabel } = {}) {
  let { highlighted } = this.node.attrs;
  let annotation = document.createElement("span");
  annotation.classList.add(this.annotationClass);
  let content = document.createElement("span");
  content.classList.add(this.annotationContentClass);
  content.style.pointerEvents = "none";
  content.contentEditable = "false";
  if (displayLabel) {
    content.textContent = displayLabel;
  }
  annotation.append(content);
  let omitHighlight = highlighted === false;
  let styles = [
    `border: 2px solid ${this.borderColor}`,
    `border-radius: 2px`,
    `padding: 1px 2px`,
    `box-sizing: border-box`
  ];
  let annotationStyle = styles.join("; ");
  let mergedAttrs = Attribute.mergeAttributes(this.htmlAttributes, {
    style: omitHighlight ? "" : annotationStyle
  });
  for (let [key, value] of Object.entries(mergedAttrs)) {
    if (key === "style") {
      annotation.style.cssText = value;
    } else {
      annotation.setAttribute(key, value);
    }
  }
  return {
    annotation,
    content
  };
};
const FieldAnnotationPlugin = (options = {}) => {
  let { editor, annotationClass: annotationClass2 } = options;
  return new Plugin({
    key: new PluginKey("fieldAnnotation"),
    state: {
      init() {
        return null;
      },
      apply(tr, prevState) {
        trackFieldAnnotationsDeletion(editor, tr);
        return prevState;
      }
    },
    props: {
      handleDrop(view, event, slice2, moved) {
        if (moved) return false;
        let fieldAnnotation = event?.dataTransfer.getData("fieldAnnotation");
        if (fieldAnnotation) {
          if (options.handleDropOutside) {
            handleDropOutside({
              fieldAnnotation,
              editor,
              view,
              event
            });
          } else {
            let annotationAttrs;
            try {
              let fieldAnnotationObj = JSON.parse(fieldAnnotation);
              annotationAttrs = fieldAnnotationObj.attributes;
            } catch {
              return false;
            }
            const coordinates = view.posAtCoords({
              left: event.clientX,
              top: event.clientY
            });
            if (coordinates) {
              editor.commands.addFieldAnnotation(coordinates.pos, {
                ...annotationAttrs
              });
            }
          }
          return true;
        }
        return false;
      },
      handlePaste(view, event, slice2) {
        const content = slice2.content.content.filter((item) => item.type.name === "fieldAnnotation");
        if (content.length) {
          editor.emit("fieldAnnotationPaste", {
            content,
            editor
          });
        }
        return false;
      },
      handleDOMEvents: {
        dragstart: (view, event) => {
          if (!event.target) return false;
          let { target } = event;
          let isAnnotationField = target.classList?.contains(annotationClass2);
          if (isAnnotationField) {
            event.dataTransfer?.setDragImage(target, 0, 0);
          }
          return false;
        }
        // drop: (view, event) => {
        //   console.log({ view, event });
        // },
      }
    },
    /// For y-prosemirror support.
    appendTransaction: (transactions, oldState, newState) => {
      let docChanges = transactions.some((tr2) => tr2.docChanged) && !oldState.doc.eq(newState.doc);
      if (!docChanges) {
        return;
      }
      let { tr } = newState;
      let changed = false;
      let annotations = getAllFieldAnnotations(newState);
      if (!annotations.length) {
        return;
      }
      annotations.forEach(({ node, pos }) => {
        let { marks } = node;
        let currentNode = tr.doc.nodeAt(pos);
        if (marks.length > 0 && node.eq(currentNode)) {
          tr.removeMark(pos, pos + node.nodeSize, null);
          changed = true;
        }
      });
      return changed ? tr : null;
    }
    ///
  });
};
function handleDropOutside({ fieldAnnotation, editor, view, event }) {
  let sourceField;
  try {
    let fieldAnnotationObj = JSON.parse(fieldAnnotation);
    sourceField = fieldAnnotationObj.sourceField;
  } catch {
    return;
  }
  let coordinates = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (coordinates) {
    editor.emit("fieldAnnotationDropped", {
      sourceField,
      editor,
      coordinates,
      pos: coordinates.pos
    });
  }
}
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
class ColorError extends Error {
  constructor(color) {
    super(`Failed to parse color: "${color}"`);
  }
}
var ColorError$1 = ColorError;
function parseToRgba(color) {
  if (typeof color !== "string") throw new ColorError$1(color);
  if (color.trim().toLowerCase() === "transparent") return [0, 0, 0, 0];
  let normalizedColor = color.trim();
  normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex.exec(normalizedColor);
  if (hslaMatch) {
    const [h, s, l, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s) !== s) throw new ColorError$1(color);
    if (guard(0, 100, l) !== l) throw new ColorError$1(color);
    return [...hslToRgb(h, s, l), Number.isNaN(a) ? 1 : a];
  }
  throw new ColorError$1(color);
}
function hash$2(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i) {
    hash2 = hash2 * 33 ^ str.charCodeAt(--i);
  }
  return (hash2 >>> 0) % 2341;
}
const colorToInt = (x) => parseInt(x.replace(/_/g, ""), 36);
const compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next) => {
  const key = colorToInt(next.substring(0, 3));
  const hex = colorToInt(next.substring(3)).toString(16);
  let prefix = "";
  for (let i = 0; i < 6 - hex.length; i++) {
    prefix += "0";
  }
  acc[key] = `${prefix}${hex}`;
  return acc;
}, {});
function nameToHex(color) {
  const normalizedColorName = color.toLowerCase().trim();
  const result = compressedColorMap[hash$2(normalizedColorName)];
  if (!result) throw new ColorError$1(color);
  return `#${result}`;
}
const r = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
const reducedHexRegex = new RegExp(`^#${r("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
const hexRegex = new RegExp(`^#${r("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
const rgbaRegex = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
const hslaRegex = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
const namedColorRegex = /^[a-z]+$/i;
const roundColor = (color) => {
  return Math.round(color * 255);
};
const hslToRgb = (hue, saturation, lightness) => {
  let l = lightness / 100;
  if (saturation === 0) {
    return [l, l, l].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function toHex(color) {
  const [r2, g, b, a] = parseToRgba(color);
  let hex = (x) => {
    const h = guard(0, 255, x).toString(16);
    return h.length === 1 ? `0${h}` : h;
  };
  return `#${hex(r2)}${hex(g)}${hex(b)}${a < 1 ? hex(Math.round(a * 255)) : ""}`;
}
const cleanUpListsWithAnnotations = (fieldsToDelete = []) => ({ dispatch, tr, state }) => {
  if (!dispatch) return true;
  if (!Array.isArray(fieldsToDelete)) fieldsToDelete = [fieldsToDelete];
  const { doc: doc2 } = state;
  const docxAnnotations = getAllFieldAnnotations(state) || [];
  const nodesToDelete = [];
  fieldsToDelete.forEach((fieldId) => {
    const matched = docxAnnotations.find((a) => a.node.attrs.fieldId === fieldId);
    if (!matched) return;
    const listItem = findParentNodeClosestToPos(doc2.resolve(matched.pos), (node2) => node2.type.name === "listItem");
    if (!listItem) return;
    let remainingNodes = 0;
    listItem.node.descendants((node2) => {
      if (node2.type.name === "fieldAnnotation") {
        remainingNodes += 1;
      }
    });
    let matchingNodesFound = 0;
    let hasOtherNodes = false;
    listItem.node.children.forEach((child) => {
      const { type } = child;
      if (type.name !== "paragraph" && type.name !== "fieldAnnotation") return;
      child.children.forEach((inline) => {
        const isFieldToDelete = fieldsToDelete.includes(inline.attrs.fieldId);
        const isFieldType = inline.type.name === "fieldAnnotation";
        const isMatchingField = isFieldType && isFieldToDelete;
        if (!isFieldType && !isMatchingField) hasOtherNodes = true;
        if (isMatchingField) matchingNodesFound += 1;
      });
    });
    if (!hasOtherNodes && matchingNodesFound > 0) {
      remainingNodes -= matchingNodesFound;
    }
    if (remainingNodes > 0) {
      return;
    }
    let { pos, node, depth } = listItem;
    let $pos = doc2.resolve(pos);
    while (depth > 0) {
      const parent = $pos.node(depth - 1);
      if (parent.childCount === 1) {
        depth -= 1;
        pos = $pos.before(depth);
        node = parent;
        $pos = doc2.resolve(pos);
      } else {
        break;
      }
    }
    if (!nodesToDelete.some((n) => n.pos === pos)) {
      nodesToDelete.push({ pos, node });
    }
  });
  if (!nodesToDelete.length) return true;
  nodesToDelete.sort((a, b) => b.pos - a.pos).forEach(({ pos, node }) => {
    tr.delete(pos, pos + node.nodeSize);
  });
  tr.setMeta("updateListSync", true);
  return true;
};
const cleanUpListsCommands = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cleanUpListsWithAnnotations
}, Symbol.toStringTag, { value: "Module" }));
const cleanUpParagraphWithAnnotations = (fieldsToDelete = []) => ({ dispatch, tr, state }) => {
  if (!dispatch) return true;
  const annotations = (typeof findFieldAnnotationsByFieldId === "function" ? findFieldAnnotationsByFieldId(fieldsToDelete, state) : []) || [];
  const toDelete = /* @__PURE__ */ new Map();
  const sizeOf = (doc2) => doc2.content.size;
  const inRange = (doc2, pos) => Number.isInteger(pos) && pos >= 0 && pos <= sizeOf(doc2);
  for (const annotation of annotations) {
    const origPos = annotation && annotation.pos;
    if (!Number.isInteger(origPos)) continue;
    const mappedPos = tr.mapping.map(origPos, 1);
    if (!inRange(tr.doc, mappedPos)) continue;
    let $pos;
    try {
      $pos = tr.doc.resolve(mappedPos);
    } catch {
      continue;
    }
    const parent = $pos.parent;
    if (!parent) continue;
    if (parent.childCount >= 2) continue;
    const currentNode = tr.doc.nodeAt(mappedPos);
    const annotatedNode = annotation && annotation.node;
    if (!currentNode) continue;
    if (annotatedNode && !annotatedNode.sameMarkup?.(currentNode) && annotatedNode.type !== currentNode.type) {
      continue;
    }
    const parentPos = $pos.before();
    if (!inRange(tr.doc, parentPos)) continue;
    toDelete.set(parentPos, true);
  }
  if (toDelete.size === 0) return true;
  const sorted = [...toDelete.keys()].sort((a, b) => b - a);
  let changed = false;
  for (const originalParentPos of sorted) {
    const mappedParentPos = tr.mapping.map(originalParentPos, -1);
    if (!inRange(tr.doc, mappedParentPos)) continue;
    const targetNode = tr.doc.nodeAt(mappedParentPos);
    if (!targetNode) continue;
    const from2 = mappedParentPos;
    const to = mappedParentPos + targetNode.nodeSize;
    if (!inRange(tr.doc, from2) || !inRange(tr.doc, to) || to <= from2) continue;
    try {
      tr.delete(from2, to);
      changed = true;
    } catch {
      continue;
    }
  }
  if (changed) dispatch(tr);
  return true;
};
const cleanUpParagraphCommands = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cleanUpParagraphWithAnnotations
}, Symbol.toStringTag, { value: "Module" }));
const commands = {
  ...cleanUpListsCommands,
  ...cleanUpParagraphCommands
};
const annotationClass = "annotation";
const annotationContentClass = "annotation-content";
const FieldAnnotation = Node$1.create({
  name: "fieldAnnotation",
  group: "inline",
  inline: true,
  atom: true,
  draggable: true,
  selectable: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: annotationClass,
        "aria-label": "Field annotation node"
      },
      annotationClass,
      annotationContentClass,
      types: ["text", "image", "signature", "checkbox", "html", "link"],
      // annotation types
      defaultType: "text",
      borderColor: "#b015b3",
      visibilityOptions: ["visible", "hidden"],
      handleDropOutside: true,
      /// for y-prosemirror support
      toggleFormatNames: ["bold", "italic", "underline"]
    };
  },
  addAttributes() {
    return {
      type: {
        default: this.options.defaultType,
        parseDOM: (elem) => elem.getAttribute("data-type"),
        renderDOM: (attrs) => {
          if (!attrs.type) return {};
          return {
            "data-type": attrs.type
          };
        }
      },
      defaultDisplayLabel: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-default-display-label"),
        renderDOM: (attrs) => {
          if (!attrs.defaultDisplayLabel) return {};
          return {
            "data-default-display-label": attrs.defaultDisplayLabel
          };
        }
      },
      displayLabel: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-display-label"),
        renderDOM: (attrs) => {
          if (!attrs.displayLabel) return {};
          return {
            "data-display-label": attrs.displayLabel
          };
        }
      },
      imageSrc: {
        default: null,
        rendered: false,
        parseDOM: (elem) => {
          let img = elem.querySelector("img");
          return img?.getAttribute("src") || null;
        }
      },
      rawHtml: {
        default: null,
        parseDOM: (elem) => {
          try {
            const isHtmlType = elem.getAttribute("data-type") === "html";
            if (!isHtmlType) return null;
            return JSON.parse(elem.getAttribute("data-raw-html"));
          } catch (e) {
            console.warn("Paste parse error", e);
          }
          return null;
        },
        renderDOM: (attrs) => {
          if (!attrs.rawHtml) return {};
          return {
            "data-raw-html": JSON.stringify(attrs.rawHtml)
          };
        }
      },
      linkUrl: {
        default: null,
        rendered: false,
        parseDOM: (elem) => {
          let link = elem.querySelector("a");
          return link?.getAttribute("href") || null;
        }
      },
      fieldId: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-field-id"),
        renderDOM: (attrs) => {
          if (!attrs.fieldId) return {};
          return {
            "data-field-id": attrs.fieldId
          };
        }
      },
      fieldType: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-field-type"),
        renderDOM: (attrs) => {
          if (!attrs.fieldType) return {};
          return {
            "data-field-type": attrs.fieldType
          };
        }
      },
      fieldColor: {
        default: "#980043",
        parseDOM: (elem) => elem.getAttribute("data-field-color") || elem.style.backgroundColor || null,
        renderDOM: (attrs) => {
          if (!attrs.fieldColor || attrs.fieldColor == "None") return {};
          let hexColor = toHex(attrs.fieldColor);
          let isSixValueSyntax = hexColor.slice(1).length === 6;
          if (isSixValueSyntax) {
            hexColor = `${hexColor}33`;
          }
          let omitHighlight = attrs.highlighted === false;
          if (omitHighlight) {
            return {
              "data-field-color": hexColor
            };
          }
          return {
            "data-field-color": hexColor,
            style: `background-color: ${hexColor}`
          };
        }
      },
      hidden: {
        default: false,
        parseDOM: (elem) => {
          let hasHiddenAttr = elem.hasAttribute("hidden");
          let hasDisplayNoneStyle = elem.style.display === "none";
          let isHidden = hasHiddenAttr || hasDisplayNoneStyle;
          return isHidden;
        },
        renderDOM: (attrs) => {
          if (!attrs.hidden) return {};
          return {
            style: "display: none"
          };
        }
      },
      visibility: {
        default: "visible",
        parseDOM: (el) => {
          let visibility = el.style.visibility || "visible";
          let containsVisibility = this.options.visibilityOptions.includes(visibility);
          return containsVisibility ? visibility : "visible";
        },
        renderDOM: (attrs) => {
          if (!attrs.visibility || attrs.visibility === "visible") return {};
          return { style: `visibility: ${attrs.visibility}` };
        }
      },
      highlighted: {
        default: true,
        rendered: false
      },
      multipleImage: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-multiple-image"),
        renderDOM: (attrs) => {
          if (!attrs.multipleImage) return {};
          return {
            "data-multiple-image": attrs.multipleImage
          };
        }
      },
      size: {
        default: null,
        renderDOM: ({ size }) => {
          if (!size || !size.width) return {};
          const style = `width: ${size.width}px; height: ${size.height}px; overflow: hidden;`;
          return { style };
        }
      },
      extras: {
        default: {},
        rendered: false
      },
      /// Formatting attrs for y-prosemirror support.
      bold: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-bold") === "true",
        renderDOM: (attrs) => {
          if (!attrs.bold) return {};
          return {
            "data-bold": "true",
            style: "font-weight: bold"
          };
        }
      },
      italic: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-italic") === "true",
        renderDOM: (attrs) => {
          if (!attrs.italic) return {};
          return {
            "data-italic": "true",
            style: "font-style: italic"
          };
        }
      },
      underline: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-underline") === "true",
        renderDOM: (attrs) => {
          if (!attrs.underline) return {};
          return {
            "data-underline": "true",
            style: "text-decoration: underline"
          };
        }
      },
      fontFamily: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-font-family") || elem.style.fontFamily || null,
        renderDOM: (attrs) => {
          if (!attrs.fontFamily) return {};
          return {
            "data-font-family": attrs.fontFamily,
            style: `font-family: ${attrs.fontFamily}`
          };
        }
      },
      fontSize: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-font-size") || elem.style.fontSize || null,
        renderDOM: (attrs) => {
          if (!attrs.fontSize) return {};
          let [value, unit] = parseSizeUnit(attrs.fontSize);
          if (Number.isNaN(value)) return {};
          unit = unit ? unit : "pt";
          let fontSize = `${value}${unit}`;
          return {
            "data-font-size": fontSize,
            style: `font-size: ${fontSize}`
          };
        }
      },
      textHighlight: {
        default: null,
        parseDOM: (element) => element.getAttribute("data-text-highlight"),
        renderDOM: (attrs) => {
          if (!attrs.textHighlight) return {};
          return {
            "data-text-highlight": attrs.textHighlight,
            // takes precedence over the fieldColor.
            style: `background-color: ${attrs.textHighlight} !important`
          };
        }
      },
      textColor: {
        default: null,
        parseDOM: (element) => element.getAttribute("data-text-color"),
        renderDOM: (attrs) => {
          if (!attrs.textColor) return {};
          return {
            "data-text-color": attrs.textColor,
            style: `color: ${attrs.textColor}`
          };
        }
      },
      /// Formatting attrs - end.
      generatorIndex: {
        rendered: false,
        default: null
      },
      hash: {
        rendered: false,
        default: null
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `span.${this.options.annotationClass}`,
        priority: 60
      }
    ];
  },
  renderDOM({ node, htmlAttributes }) {
    let { type, displayLabel, imageSrc, linkUrl } = node.attrs;
    let textRenderer = () => {
      return [
        "span",
        Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          "span",
          {
            class: `${this.options.annotationContentClass}`
          },
          displayLabel
        ]
      ];
    };
    let imageRenderer = () => {
      let contentRenderer = () => {
        if (!imageSrc) return displayLabel;
        return [
          "img",
          {
            src: imageSrc,
            alt: displayLabel
          }
        ];
      };
      return [
        "span",
        Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          "span",
          {
            class: `${this.options.annotationContentClass}`
          },
          contentRenderer()
        ]
      ];
    };
    let linkRenderer = () => {
      let contentRenderer = () => {
        if (!linkUrl) return displayLabel;
        return [
          "a",
          {
            href: linkUrl,
            target: "_blank"
          },
          linkUrl
        ];
      };
      return [
        "span",
        Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          "span",
          {
            class: `${this.options.annotationContentClass}`
          },
          contentRenderer()
        ]
      ];
    };
    let renderers = {
      text: () => textRenderer(),
      image: () => imageRenderer(),
      signature: () => imageRenderer(),
      checkbox: () => textRenderer(),
      html: () => textRenderer(),
      link: () => linkRenderer(),
      default: () => textRenderer()
    };
    let renderer = renderers[type] ?? renderers.default;
    return renderer();
  },
  addCommands() {
    const annotationTypes = this.options.types;
    return {
      /**
       * Add field annotation.
       * @param pos The position in the doc.
       * @param attrs The attributes.
       * @example
       * editor.commands.addFieldAnnotation(0, {
       *  displayLabel: 'Enter your info',
       *  fieldId: `123`,
       *  fieldType: 'TEXTINPUT',
       *  fieldColor: '#980043',
       * })
       */
      addFieldAnnotation: (pos, attrs = {}, editorFocus = false) => ({ editor, dispatch, state, tr }) => {
        if (dispatch) {
          let { schema } = editor;
          let newPos = tr.mapping.map(pos);
          let $pos = state.doc.resolve(newPos);
          let currentMarks = $pos.marks();
          currentMarks = currentMarks.length ? [...currentMarks] : null;
          let formatAttrs = getFormatAttrsFromMarks(currentMarks);
          let defaultDisplayLabel = attrs.defaultDisplayLabel ? attrs.defaultDisplayLabel : attrs.displayLabel || "";
          let node = schema.nodes[this.name].create(
            {
              ...attrs,
              ...formatAttrs,
              defaultDisplayLabel,
              hash: attrs.hash || generateDocxRandomId(4)
            },
            null,
            null
          );
          state.tr.insert(newPos, node).setSelection(Selection.near(tr.doc.resolve(newPos + node.nodeSize)));
          if (editorFocus) {
            this.editor.view.focus();
          }
        }
        return true;
      },
      addFieldAnnotationAtSelection: (attrs = {}, editorFocus = false) => ({ state, commands: commands2 }) => {
        const { from: from2 } = state.selection;
        return commands2.addFieldAnnotation(from2, attrs, editorFocus);
      },
      /**
       * Replace field annotation.
       * @param fieldsArray array of fields with attrs to add as annotation.
       * @example
       * editor.commands.replaceWithFieldAnnotation([
       *  from: 20,
       *  to: 45,
       *  attrs: {
       *    fieldType: 'TEXTINPUT'
       *    fieldColor: '#980043'
       *  }
       * ])
       */
      replaceWithFieldAnnotation: (fieldsArray) => ({ editor, dispatch, tr }) => {
        if (!dispatch) return true;
        fieldsArray.forEach((annotation) => {
          let { from: from2, to, attrs } = annotation;
          let { schema } = editor;
          let newPosFrom = tr.mapping.map(from2);
          let newPosTo = tr.mapping.map(to);
          let defaultDisplayLabel = attrs.defaultDisplayLabel ? attrs.defaultDisplayLabel : attrs.displayLabel || "";
          attrs.hash = generateDocxRandomId(4);
          let node = schema.nodes[this.name].create(
            {
              ...attrs,
              defaultDisplayLabel,
              hash: attrs.hash || generateDocxRandomId(4)
            },
            null,
            null
          );
          tr.replaceWith(newPosFrom, newPosTo, node);
        });
        return true;
      },
      /**
       * Replace annotations with a label (as text node) in selection.
       * @param options Additional options.
       * @example
       * editor.commands.replaceFieldAnnotationsWithLabelInSelection()
       */
      replaceFieldAnnotationsWithLabelInSelection: (options = {}) => ({ commands: commands2 }) => {
        return commands2.replaceFieldAnnotationsWithLabel(null, {
          ...options,
          isInSelection: true
        });
      },
      /**
       * Replace annotations with a label (as text node).
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param options.isInSelection Find in selection instead of field IDs.
       * @param options.addToHistory Add to history or not.
       * @param options.types Annotation types to replace.
       * @example
       * editor.commands.replaceFieldAnnotationsWithLabel(['1', '2'])
       */
      replaceFieldAnnotationsWithLabel: (fieldIdOrArray, { isInSelection = false, addToHistory = false, types = annotationTypes } = {}) => ({ dispatch, state, tr }) => {
        let { from: from2, to } = state.selection;
        let annotations = isInSelection ? findFieldAnnotationsBetween(from2, to, state.doc) : findFieldAnnotationsByFieldId(fieldIdOrArray, state);
        annotations = types.length ? annotations.filter(({ node }) => types.includes(node.attrs.type)) : annotations;
        if (!annotations.length) {
          return true;
        }
        if (!addToHistory) {
          tr.setMeta("addToHistory", false);
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            let { pos, node } = annotation;
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            let nodeEqual = node.attrs.fieldId === currentNode?.attrs?.fieldId;
            let $newPosFrom = tr.doc.resolve(newPosFrom);
            let currentMarks = $newPosFrom.marks();
            currentMarks = currentMarks.length ? [...currentMarks] : null;
            if (nodeEqual) {
              let label = node.attrs.displayLabel || " ";
              let textNode = state.schema.text(label, currentMarks);
              tr.replaceWith(newPosFrom, newPosTo, textNode);
            }
          });
        }
        return true;
      },
      /**
       * Resets all annotations to default values.
       * @example
       * editor.commands.resetFieldAnnotations()
       */
      resetFieldAnnotations: () => ({ dispatch, state, tr }) => {
        let annotations = getAllFieldAnnotations(state);
        if (!annotations.length) {
          return true;
        }
        tr.setMeta("fieldAnnotationUpdate", true);
        if (dispatch) {
          annotations.forEach(({ pos, node }) => {
            let newPos = tr.mapping.map(pos);
            let currentNode = tr.doc.nodeAt(newPos);
            let nodeEqual = node.attrs.fieldId === currentNode?.attrs?.fieldId;
            if (nodeEqual) {
              let displayLabel = node.attrs.defaultDisplayLabel || node.attrs.displayLabel || "";
              tr.setNodeMarkup(newPos, void 0, {
                ...node.attrs,
                // reset displayLabel to default.
                displayLabel,
                // reset attrs for specific types.
                imageSrc: null,
                rawHtml: null,
                linkUrl: null,
                hash: null
              });
            }
          });
        }
        return true;
      },
      /**
       * Update annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param attrs The attributes.
       * @example
       * editor.commands.updateFieldAnnotations('123', {
       *  displayLabel: 'Updated!',
       * })
       * @example
       * editor.commands.updateFieldAnnotations(['123', '456'], {
       *  displayLabel: 'Updated!',
       * })
       */
      updateFieldAnnotations: (fieldIdOrArray, attrs = {}) => ({ dispatch, state, commands: commands2 }) => {
        let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          return commands2.updateFieldAnnotationsAttributes(annotations, attrs);
        }
        return true;
      },
      /**
       * Update particular annotation's attributes.
       * @param annotation field annotation node to be updated.
       * @param attrs The attributes.
       *
       * Used for a case when multiple annotations for one input presented
       */
      updateFieldAnnotation: (annotation, attrs = {}) => ({ dispatch, commands: commands2 }) => {
        if (!annotation) {
          return true;
        }
        if (dispatch) {
          commands2.updateFieldAnnotationsAttributes([annotation], attrs);
          if (this.editor.options.pagination) {
            setTimeout(() => {
              const newTr = this.editor.view.state.tr;
              newTr.setMeta("forceUpdatePagination", true);
              this.editor.view.dispatch(newTr);
            }, 50);
          }
          return true;
        }
        return true;
      },
      /**
       * Update the attributes of annotations.
       * @param annotations The annotations array [{pos, node}].
       * @param attrs The attributes object.
       */
      updateFieldAnnotationsAttributes: (annotations, attrs = {}) => ({ dispatch, tr }) => {
        if (!dispatch) return true;
        tr.setMeta("fieldAnnotationUpdate", true);
        annotations.forEach((annotation) => {
          let { pos, node } = annotation;
          let newPos = tr.mapping.map(pos);
          let currentNode = tr.doc.nodeAt(newPos);
          let nodeEqual = node.attrs.fieldId === currentNode?.attrs?.fieldId;
          if (nodeEqual) {
            tr.setNodeMarkup(newPos, void 0, {
              ...node.attrs,
              ...attrs
            });
          }
        });
        return true;
      },
      /**
       * Delete annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @example
       * editor.commands.deleteFieldAnnotations('123')
       * @example
       * editor.commands.deleteFieldAnnotations(['123', '456'])
       */
      deleteFieldAnnotations: (fieldIdOrArray) => ({ dispatch, state, tr }) => {
        let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            let { pos, node } = annotation;
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            if (node.eq(currentNode)) {
              tr.delete(newPosFrom, newPosTo);
            }
          });
        }
        return true;
      },
      deleteFieldAnnotationsByNode: (annotations) => ({ dispatch, tr }) => {
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            let { pos, node } = annotation;
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            if (node.eq(currentNode)) {
              tr.delete(newPosFrom, newPosTo);
            }
          });
        }
        return true;
      },
      deleteFieldAnnotation: (annotation) => ({ dispatch, tr }) => {
        if (!annotation) {
          return true;
        }
        if (dispatch) {
          let { pos, node } = annotation;
          let newPosFrom = tr.mapping.map(pos);
          let newPosTo = tr.mapping.map(pos + node.nodeSize);
          let currentNode = tr.doc.nodeAt(newPosFrom);
          if (node.eq(currentNode)) {
            tr.delete(newPosFrom, newPosTo);
          }
        }
        return true;
      },
      /**
       * Delete a portion of annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param end index at which to end extraction
       * @example
       * editor.commands.sliceFieldAnnotations('123', 5) - will remove a portion of annotations array starting from index 6
       * @example
       * editor.commands.sliceFieldAnnotations(['123', '456'], 5)
       */
      sliceFieldAnnotations: (fieldIdOrArray, end2) => ({ dispatch, state, tr }) => {
        let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation, index2) => {
            if (index2 >= end2) {
              let { pos, node } = annotation;
              let newPosFrom = tr.mapping.map(pos);
              let newPosTo = tr.mapping.map(pos + node.nodeSize);
              let currentNode = tr.doc.nodeAt(newPosFrom);
              if (node.eq(currentNode)) {
                tr.delete(newPosFrom, newPosTo);
              }
            }
          });
        }
        return true;
      },
      /**
       * Set `hidden` for annotations matching predicate.
       * Other annotations become unhidden.
       * @param predicate The predicate function.
       * @param unsetFromOthers If should unset hidden from other annotations.
       * @example
       * editor.commands.setFieldAnnotationsHiddenByCondition((node) => {
       *   let ids = ['111', '222', '333'];
       *   return ids.includes(node.attrs.fieldId);
       * })
       */
      setFieldAnnotationsHiddenByCondition: (predicate = () => false, unsetFromOthers = false) => ({ dispatch, state, chain }) => {
        let annotations = getAllFieldAnnotations(state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          let otherAnnotations = [];
          let matchedAnnotations = annotations.filter((annotation) => {
            if (predicate(annotation.node)) return annotation;
            else otherAnnotations.push(annotation);
          });
          if (unsetFromOthers) {
            return chain().updateFieldAnnotationsAttributes(matchedAnnotations, { hidden: true }).updateFieldAnnotationsAttributes(otherAnnotations, { hidden: false }).run();
          } else {
            return chain().updateFieldAnnotationsAttributes(matchedAnnotations, { hidden: true }).run();
          }
        }
        return true;
      },
      /**
       * Unset `hidden` for all annotations.
       * @example
       * editor.commands.unsetFieldAnnotationsHidden()
       */
      unsetFieldAnnotationsHidden: () => ({ dispatch, state, commands: commands2 }) => {
        let annotations = getAllFieldAnnotations(state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          return commands2.updateFieldAnnotationsAttributes(annotations, { hidden: false });
        }
        return true;
      },
      /**
       * Set `visibility` for all annotations (without changing the layout).
       * @param visibility The visibility value (visible, hidden).
       * @example
       * editor.commands.setFieldAnnotationsVisibility('visible');
       * @example
       * editor.commands.setFieldAnnotationsVisibility('hidden');
       */
      setFieldAnnotationsVisibility: (visibility = "visible") => ({ dispatch, state, commands: commands2 }) => {
        let annotations = getAllFieldAnnotations(state);
        if (!annotations.length) {
          return true;
        }
        let containsVisibility = this.options.visibilityOptions.includes(visibility);
        if (!containsVisibility) {
          return false;
        }
        if (dispatch) {
          return commands2.updateFieldAnnotationsAttributes(annotations, {
            visibility
          });
        }
        return true;
      },
      /**
       * Set `highlighted` for annotations matching predicate.
       * @param predicate The predicate function.
       * @param highlighted The highlighted attribute.
       * @example
       * editor.commands.setFieldAnnotationsHighlighted((node) => {
       *   let ids = ['111', '222', '333'];
       *   return ids.includes(node.attrs.fieldId);
       * }, false)
       * @example Set for all annotations.
       * editor.commands.setFieldAnnotationsHighlighted(() => true, false)
       * editor.commands.setFieldAnnotationsHighlighted(() => true, true)
       */
      setFieldAnnotationsHighlighted: (predicate = () => false, highlighted = true) => ({ dispatch, state, commands: commands2 }) => {
        let annotations = getAllFieldAnnotations(state);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          let matchedAnnotations = annotations.filter((annotation) => {
            if (predicate(annotation.node)) return annotation;
          });
          return commands2.updateFieldAnnotationsAttributes(matchedAnnotations, {
            highlighted
          });
        }
        return true;
      },
      /// Formatting commands for y-prosemirror support.
      toggleFieldAnnotationsFormat: (name, setSelection = false) => ({ dispatch, tr, state, commands: commands2 }) => {
        let formats = this.options.toggleFormatNames;
        if (!formats.includes(name)) {
          return false;
        }
        let { from: from2, to, node } = state.selection;
        let annotations = findFieldAnnotationsBetween(from2, to, state.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              [name]: !annotation.node.attrs[name]
            });
          });
          if (setSelection && node?.type.name === this.name) {
            tr.setSelection(NodeSelection.create(tr.doc, from2));
          }
        }
        return true;
      },
      setFieldAnnotationsFontFamily: (fontFamily, setSelection = false) => ({ dispatch, tr, state, commands: commands2 }) => {
        let { from: from2, to, node } = state.selection;
        let annotations = findFieldAnnotationsBetween(from2, to, state.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              fontFamily
            });
          });
          if (setSelection && node?.type.name === this.name) {
            tr.setSelection(NodeSelection.create(tr.doc, from2));
          }
        }
        return true;
      },
      setFieldAnnotationsFontSize: (fontSize, setSelection = false) => ({ dispatch, tr, state, commands: commands2 }) => {
        let { from: from2, to, node } = state.selection;
        let annotations = findFieldAnnotationsBetween(from2, to, state.doc);
        if (!annotations.length) {
          return true;
        }
        let [value, unit] = parseSizeUnit(fontSize);
        let min2 = 8, max2 = 96, defaultUnit = "pt";
        if (Number.isNaN(value)) {
          return false;
        }
        value = minMax(value, min2, max2);
        unit = unit ? unit : defaultUnit;
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              fontSize: `${value}${unit}`
            });
          });
          if (setSelection && node?.type.name === this.name) {
            tr.setSelection(NodeSelection.create(tr.doc, from2));
          }
        }
        return true;
      },
      setFieldAnnotationsTextHighlight: (color, setSelection = false) => ({ dispatch, tr, state, commands: commands2 }) => {
        let { from: from2, to, node } = state.selection;
        let annotations = findFieldAnnotationsBetween(from2, to, state.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              textHighlight: color
            });
          });
          if (setSelection && node?.type.name === this.name) {
            tr.setSelection(NodeSelection.create(tr.doc, from2));
          }
        }
        return true;
      },
      setFieldAnnotationsTextColor: (color, setSelection = false) => ({ dispatch, tr, state, commands: commands2 }) => {
        let { from: from2, to, node } = state.selection;
        let annotations = findFieldAnnotationsBetween(from2, to, state.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              textColor: color
            });
          });
          if (setSelection && node?.type.name === this.name) {
            tr.setSelection(NodeSelection.create(tr.doc, from2));
          }
        }
        return true;
      },
      /// Formatting commands - end.
      // Clean up commands (after field deletion)
      ...commands
    };
  },
  addNodeView() {
    return (props) => {
      return new FieldAnnotationView({
        ...props,
        annotationClass: this.options.annotationClass,
        annotationContentClass: this.options.annotationContentClass,
        borderColor: this.options.borderColor
      });
    };
  },
  addPmPlugins() {
    return [
      FieldAnnotationPlugin({
        editor: this.editor,
        annotationClass: this.options.annotationClass,
        handleDropOutside: this.options.handleDropOutside
      })
    ];
  }
});
function getFormatAttrsFromMarks(marks) {
  if (!marks) {
    return {};
  }
  let formatAttrs = {
    bold: false,
    italic: false,
    underline: false,
    fontFamily: null,
    fontSize: null
  };
  if (marks && marks.length) {
    formatAttrs.bold = marks.some((mark) => mark.type.name === "bold");
    formatAttrs.italic = marks.some((mark) => mark.type.name === "italic");
    formatAttrs.underline = marks.some((mark) => mark.type.name === "underline");
    let textStyle = marks.find((mark) => mark.type.name === "textStyle");
    if (textStyle) {
      formatAttrs.fontFamily = textStyle.attrs.fontFamily ?? null;
      formatAttrs.fontSize = textStyle.attrs.fontSize ?? null;
    }
  }
  return formatAttrs;
}
const ImagePlaceholderPluginKey = new PluginKey("ImagePlaceholder");
const ImagePlaceholderPlugin = () => {
  return new Plugin({
    key: ImagePlaceholderPluginKey,
    state: {
      init() {
        return DecorationSet.empty;
      },
      apply(tr, set) {
        set = set.map(tr.mapping, tr.doc);
        let action = tr.getMeta(ImagePlaceholderPluginKey);
        if (action?.type === "add") {
          let widget = document.createElement("placeholder");
          let deco = Decoration.widget(action.pos, widget, {
            id: action.id
          });
          set = set.add(tr.doc, [deco]);
        } else if (action?.type === "remove") {
          set = set.remove(set.find(null, null, (spec) => spec.id == action.id));
        }
        return set;
      }
    },
    props: {
      decorations(state) {
        return this.getState(state);
      }
    }
  });
};
const findPlaceholder = (state, id) => {
  let decos = ImagePlaceholderPluginKey.getState(state);
  let found = decos?.find(null, null, (spec) => spec.id === id);
  return found?.length ? found[0].from : null;
};
const ImagePositionPluginKey = new PluginKey("ImagePosition");
const ImagePositionPlugin = ({ editor }) => {
  const { view } = editor;
  let shouldUpdate = false;
  return new Plugin({
    name: "ImagePositionPlugin",
    key: ImagePositionPluginKey,
    state: {
      init() {
        return DecorationSet.empty;
      },
      apply(tr, oldDecorationSet, oldState, newState) {
        if (!tr.docChanged) return oldDecorationSet;
        const decorations = getImagePositionDecorations(newState, view);
        return DecorationSet.create(newState.doc, decorations);
      }
    },
    view: () => {
      return {
        update: (view2, lastState) => {
          const pagination = PaginationPluginKey.getState(lastState);
          if (shouldUpdate) {
            shouldUpdate = false;
            const decorations = getImagePositionDecorations(lastState, view2);
            const updateTransaction = view2.state.tr.setMeta(ImagePositionPluginKey, { decorations });
            view2.dispatch(updateTransaction);
          }
          if (pagination?.isReadyToInit) {
            shouldUpdate = true;
          }
        }
      };
    },
    props: {
      decorations(state) {
        return this.getState(state);
      }
    }
  });
};
const getImagePositionDecorations = (state, view) => {
  let decorations = [];
  state.doc.descendants((node, pos) => {
    if (node.attrs.anchorData) {
      let style = "";
      let className = "";
      const { vRelativeFrom, alignH } = node.attrs.anchorData;
      const { size, padding, marginOffset } = node.attrs;
      const pageBreak = findPreviousDomNodeWithClass(view, pos, "pagination-break-wrapper");
      if (pageBreak) {
        switch (alignH) {
          case "left":
            style += "float: left; left: 0; margin-left: 0; ";
            break;
          case "right":
            style += "float: right; right: 0; margin-right: 0; ";
            break;
          case "center":
            style += "display: block; margin-left: auto; margin-right: auto; ";
            break;
        }
        const topPos = marginOffset.top !== void 0 ? marginOffset.top : pageBreak?.offsetTop + pageBreak?.offsetHeight;
        style += vRelativeFrom === "margin" ? `position: absolute; top: ${topPos}px; ` : "";
        if (vRelativeFrom === "margin") {
          const nextPos = view.posAtDOM(pageBreak, 1);
          if (nextPos < 0) {
            const $pos = view.state.doc.resolve(pos);
            decorations.push(
              Decoration.node(pos - 1, pos + $pos.parent.nodeSize - 1, {
                style: `height: ${size.height + parseInt(padding.top) + parseInt(padding.bottom)}px`
              })
            );
          }
          const imageBlock = document.createElement("div");
          imageBlock.className = "anchor-image-placeholder";
          imageBlock.style.float = alignH;
          imageBlock.style.width = size.width + parseInt(padding[alignH]) + "px";
          imageBlock.style.height = size.height + parseInt(padding.top) + parseInt(padding.bottom) + "px";
          decorations.push(Decoration.widget(nextPos, imageBlock, { key: "stable-key" }));
        }
      }
      decorations.push(Decoration.inline(pos, pos + node.nodeSize, { style, class: className }));
    }
  });
  return decorations;
};
const findPreviousDomNodeWithClass = (view, pos, className) => {
  let { node } = view.domAtPos(pos);
  if (node.nodeType === 3) {
    node = node.parentNode;
  }
  while (node) {
    if (node.classList && node.classList.contains(className)) {
      return node;
    }
    if (node.previousSibling) {
      node = node.previousSibling;
      while (node && node.lastChild) {
        node = node.lastChild;
      }
    } else {
      node = node.parentNode;
    }
  }
  return null;
};
const Image = Node$1.create({
  name: "image",
  group: "inline",
  inline: true,
  draggable: true,
  addOptions() {
    return {
      allowBase64: true,
      htmlAttributes: {
        style: "display: inline-block;",
        "aria-label": "Image node"
      }
    };
  },
  addStorage() {
    return {
      media: {}
    };
  },
  addAttributes() {
    return {
      src: {
        default: null,
        renderDOM: ({ src }) => {
          return {
            src: this.storage.media[src] ?? src
          };
        }
      },
      alt: {
        default: "Uploaded picture"
      },
      id: { rendered: false },
      title: {
        default: null
      },
      rId: {
        default: null,
        rendered: false
      },
      originalPadding: {
        default: null,
        rendered: false
      },
      originalAttributes: { rendered: false },
      wrapTopAndBottom: { rendered: false },
      anchorData: {
        default: null,
        rendered: false
      },
      isAnchor: { rendered: false },
      simplePos: { rendered: false },
      wrapText: { rendered: false },
      size: {
        default: {},
        renderDOM: ({ size }) => {
          let style = "";
          const { width, height } = size ?? {};
          if (width) style += `width: ${width}px;`;
          if (height) style += "height: auto;";
          return { style };
        }
      },
      padding: {
        default: {},
        renderDOM: ({ padding, marginOffset }) => {
          const { left: left2 = 0, top: top2 = 0, bottom: bottom2 = 0, right: right2 = 0 } = padding ?? {};
          let style = "";
          if (left2 && !marginOffset?.left) style += `margin-left: ${left2}px;`;
          if (top2 && !marginOffset?.top) style += `margin-top: ${top2}px;`;
          if (bottom2) style += `margin-bottom: ${bottom2}px;`;
          if (right2) style += `margin-right: ${right2}px;`;
          return { style };
        }
      },
      marginOffset: {
        default: {},
        renderDOM: ({ marginOffset, anchorData }) => {
          const relativeFromPageV = anchorData?.vRelativeFrom === "page";
          const maxMarginV = 500;
          const { left: left2 = 0, top: top2 = 0 } = marginOffset ?? {};
          let style = "";
          if (left2) style += `margin-left: ${left2}px;`;
          if (top2) {
            if (relativeFromPageV && top2 >= maxMarginV) style += `margin-top: ${maxMarginV}px;`;
            else style += `margin-top: ${top2}px;`;
          }
          return { style };
        }
      },
      style: {
        default: null,
        rendered: true,
        renderDOM: ({ style }) => {
          if (!style) return {};
          return { style };
        }
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["img", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      setImage: (options) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: options
        });
      }
    };
  },
  addPmPlugins() {
    return [ImagePlaceholderPlugin(), ImagePositionPlugin({ editor: this.editor })];
  }
});
const ACCEPT_IMAGE_TYPES = [".jpg", ".jpeg", ".png", "image/jpeg", "image/png"];
const getFileOpener = () => {
  let fileInput = document.createElement("input");
  fileInput.type = "file";
  let acceptTypes = ACCEPT_IMAGE_TYPES;
  fileInput.accept = acceptTypes.join(",");
  const openFile = () => {
    return new Promise((resolve, reject) => {
      fileInput.onchange = async () => {
        const files = fileInput.files;
        if (!files) return resolve(null);
        const file = files.item(0);
        if (!file) return resolve(null);
        return resolve({ file });
      };
      fileInput.oncancel = () => resolve(null);
      fileInput.onerror = reject;
      fileInput.click();
    });
  };
  return openFile;
};
const handleImageUpload = (file) => {
  return new Promise((resolve, reject) => {
    let reader = new FileReader();
    reader.onload = (event) => resolve(event.target.result);
    reader.onerror = reject;
    setTimeout(() => reader.readAsDataURL(file), 250);
  });
};
const processUploadedImage = (fileData, editor) => {
  return new Promise((resolve, reject) => {
    const img = new window.Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const { width: logicalWidth, height: logicalHeight } = getAllowedImageDimensions(img.width, img.height, editor);
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext("2d");
      if (ctx) {
        ctx.imageSmoothingEnabled = true;
        try {
          ctx.imageSmoothingQuality = "high";
        } catch {
        }
      }
      ctx.drawImage(img, 0, 0, img.width, img.height);
      const dpr = typeof window !== "undefined" && window.devicePixelRatio ? window.devicePixelRatio : 1;
      const targetPixelWidth = Math.round(logicalWidth * dpr);
      const targetPixelHeight = Math.round(logicalHeight * dpr);
      const finalTargetWidth = Math.min(targetPixelWidth, img.width);
      const finalTargetHeight = Math.min(targetPixelHeight, img.height);
      const resizeNeeded = finalTargetWidth !== img.width || finalTargetHeight !== img.height;
      if (resizeNeeded) {
        multiStepResize(canvas, finalTargetWidth, finalTargetHeight);
      }
      if (typeof fileData === "string") {
        const resizedBase64 = canvas.toDataURL();
        resolve(resizedBase64);
      } else {
        canvas.toBlob((blob) => {
          const updatedFile = new File([blob], fileData.name, {
            type: fileData.type,
            lastModified: Date.now()
          });
          resolve({ file: updatedFile, width: logicalWidth, height: logicalHeight });
        });
      }
    };
    img.onerror = (error) => reject(error);
    img.src = typeof fileData === "string" ? fileData : URL.createObjectURL(fileData);
  });
};
const getAllowedImageDimensions = (width, height, editor) => {
  const { width: maxWidth, height: maxHeight } = editor.getMaxContentSize();
  if (!maxWidth || !maxHeight) return { width, height };
  let adjustedWidth = width;
  let adjustedHeight = height;
  const aspectRatio = width / height;
  if (height > maxHeight) {
    adjustedHeight = maxHeight;
    adjustedWidth = Math.round(maxHeight * aspectRatio);
  }
  if (adjustedWidth > maxWidth) {
    adjustedWidth = maxWidth;
    adjustedHeight = Math.round(maxWidth / aspectRatio);
  }
  return { width: adjustedWidth, height: adjustedHeight };
};
function resample_high_quality(canvas, width, height, resize_canvas) {
  var width_source = canvas.width;
  var height_source = canvas.height;
  width = Math.round(width);
  height = Math.round(height);
  var ratio_w = width_source / width;
  var ratio_h = height_source / height;
  var ratio_w_half = Math.ceil(ratio_w / 2);
  var ratio_h_half = Math.ceil(ratio_h / 2);
  var ctx = canvas.getContext("2d");
  var img = ctx.getImageData(0, 0, width_source, height_source);
  var img2 = ctx.createImageData(width, height);
  var data = img.data;
  var data2 = img2.data;
  for (var j = 0; j < height; j++) {
    for (var i = 0; i < width; i++) {
      var x2 = (i + j * width) * 4;
      var weight = 0;
      var weights = 0;
      var weights_alpha = 0;
      var gx_r = 0;
      var gx_g = 0;
      var gx_b = 0;
      var gx_a = 0;
      var center_y = (j + 0.5) * ratio_h;
      var yy_start = Math.floor(j * ratio_h);
      var yy_stop = Math.ceil((j + 1) * ratio_h);
      for (var yy = yy_start; yy < yy_stop; yy++) {
        var dy = Math.abs(center_y - (yy + 0.5)) / ratio_h_half;
        var center_x = (i + 0.5) * ratio_w;
        var w0 = dy * dy;
        var xx_start = Math.floor(i * ratio_w);
        var xx_stop = Math.ceil((i + 1) * ratio_w);
        for (var xx = xx_start; xx < xx_stop; xx++) {
          var dx = Math.abs(center_x - (xx + 0.5)) / ratio_w_half;
          var w = Math.sqrt(w0 + dx * dx);
          if (w >= 1) {
            continue;
          }
          weight = 2 * w * w * w - 3 * w * w + 1;
          var pos_x = 4 * (xx + yy * width_source);
          gx_a += weight * data[pos_x + 3];
          weights_alpha += weight;
          if (data[pos_x + 3] < 255) weight = weight * data[pos_x + 3] / 250;
          gx_r += weight * data[pos_x];
          gx_g += weight * data[pos_x + 1];
          gx_b += weight * data[pos_x + 2];
          weights += weight;
        }
      }
      data2[x2] = gx_r / weights;
      data2[x2 + 1] = gx_g / weights;
      data2[x2 + 2] = gx_b / weights;
      data2[x2 + 3] = gx_a / weights_alpha;
    }
  }
  {
    canvas.width = width;
    canvas.height = height;
  }
  ctx.putImageData(img2, 0, 0);
}
function multiStepResize(canvas, targetWidth, targetHeight) {
  const originalWidth = canvas.width;
  const originalHeight = canvas.height;
  const scaleX = targetWidth / originalWidth;
  const scaleY = targetHeight / originalHeight;
  const scaleFactor = Math.min(scaleX, scaleY);
  if (scaleFactor < 0.5) {
    let currentWidth = originalWidth;
    let currentHeight = originalHeight;
    while (currentWidth > targetWidth * 2 || currentHeight > targetHeight * 2) {
      const nextWidth = Math.round(currentWidth / 2);
      const nextHeight = Math.round(currentHeight / 2);
      resample_high_quality(canvas, nextWidth, nextHeight);
      currentWidth = nextWidth;
      currentHeight = nextHeight;
    }
    if (currentWidth !== targetWidth || currentHeight !== targetHeight) {
      resample_high_quality(canvas, targetWidth, targetHeight);
    }
  } else {
    resample_high_quality(canvas, targetWidth, targetHeight);
  }
}
const startImageUpload = async ({ editor, view, file }) => {
  const imageUploadHandler = typeof editor.options.handleImageUpload === "function" ? editor.options.handleImageUpload : handleImageUpload;
  let fileSizeMb = Number((file.size / (1024 * 1024)).toFixed(4));
  if (fileSizeMb > 5) {
    window.alert("Image size must be less than 5MB");
    return;
  }
  let width;
  let height;
  try {
    const processedImageResult = await processUploadedImage(file, editor);
    width = processedImageResult.width;
    height = processedImageResult.height;
    file = processedImageResult.file;
  } catch (err) {
    console.warn("Error processing image:", err);
    return;
  }
  await uploadImage({
    editor,
    view,
    file,
    size: { width, height },
    uploadHandler: imageUploadHandler
  });
};
async function uploadImage({ editor, view, file, size, uploadHandler }) {
  let id = {};
  let { tr, schema } = view.state;
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  if (!selection.empty && !editor.options.isHeaderOrFooter) {
    tr.deleteSelection();
  }
  let imageMeta = {
    type: "add",
    pos: selection.from,
    id
  };
  tr.setMeta(ImagePlaceholderPluginKey, imageMeta);
  view.dispatch(tr);
  try {
    let url = await uploadHandler(file);
    let fileName = file.name.replace(" ", "_");
    let placeholderPos = findPlaceholder(view.state, id);
    if (placeholderPos == null) {
      return;
    }
    let removeMeta = { type: "remove", id };
    let mediaPath = `word/media/${fileName}`;
    let rId = null;
    if (editor.options.mode === "docx") {
      const [, path] = mediaPath.split("word/");
      const id2 = addImageRelationship({ editor, path });
      if (id2) rId = id2;
    }
    let imageNode = schema.nodes.image.create({
      src: mediaPath,
      size,
      rId
    });
    editor.storage.image.media = Object.assign(editor.storage.image.media, { [mediaPath]: url });
    if (editor.options.ydoc) {
      editor.commands.addImageToCollaboration({ mediaPath, fileData: url });
    }
    view.dispatch(
      view.state.tr.replaceWith(placeholderPos, placeholderPos, imageNode).setMeta(ImagePlaceholderPluginKey, removeMeta)
    );
  } catch {
    let removeMeta = { type: "remove", id };
    view.dispatch(tr.setMeta(ImagePlaceholderPluginKey, removeMeta));
  }
}
function addImageRelationship({ editor, path }) {
  const target = path;
  const type = "image";
  try {
    const id = insertNewRelationship(target, type, editor);
    return id;
  } catch {
    return null;
  }
}
const BookmarkStart = Node$1.create({
  name: "bookmarkStart",
  group: "inline",
  content: "inline*",
  inline: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} BookmarkOptions
       * @category Options
       * @property {Object} [htmlAttributes] - HTML attributes for the bookmark element
       */
      htmlAttributes: {
        style: "height: 0; width: 0;",
        "aria-label": "Bookmark start node",
        role: "link"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [name] - Bookmark name for cross-references and navigation
       */
      name: {
        default: null,
        renderDOM: ({ name }) => {
          if (name) return { name };
          return {};
        }
      },
      /**
       * @category Attribute
       * @param {string} [id] - Unique identifier for the bookmark
       */
      id: {
        default: null,
        renderDOM: ({ id }) => {
          if (id) return { id };
          return {};
        }
      }
    };
  },
  renderDOM({ htmlAttributes }) {
    return ["a", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      /**
       * Insert a bookmark at the current position
       * @category Command
       * @param {BookmarkConfig} config - Bookmark configuration
       * @returns {Function} Command function
       * @example
       * // Insert a named bookmark
       * insertBookmark({ name: 'chapter1' })
       *
       * // Insert with ID
       * insertBookmark({ name: 'introduction', id: 'intro-001' })
       * @note Bookmarks are invisible markers for navigation and cross-references
       */
      insertBookmark: (config) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: config
        });
      },
      /**
       * Navigate to a bookmark by name
       * @category Command
       * @param {string} name - Bookmark name to navigate to
       * @returns {Function} Command function
       * @example
       * goToBookmark('chapter1')
       * @note Scrolls the document to the bookmark position
       */
      goToBookmark: (name) => ({ editor, tr }) => {
        const { doc: doc2 } = tr;
        let targetPos = null;
        doc2.descendants((node, pos) => {
          if (node.type.name === "bookmarkStart" && node.attrs.name === name) {
            targetPos = pos;
            return false;
          }
        });
        if (targetPos !== null) {
          editor.commands.focus(targetPos);
          return true;
        }
        return false;
      }
    };
  }
});
const Mention = Node$1.create({
  name: "mention",
  group: "inline",
  inline: true,
  selectable: false,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-mention",
        "aria-label": "Mention node"
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `span[data-type="${this.name || this.email}"]`,
        getAttrs: (node) => ({
          name: node.getAttribute("name") || null,
          email: node.getAttribute("email") || null
        })
      }
    ];
  },
  renderDOM({ node, htmlAttributes }) {
    const { name, email } = node.attrs;
    return [
      "span",
      Attribute.mergeAttributes({ "data-type": this.name || this.email }, this.options.htmlAttributes, htmlAttributes),
      `@${name ? name : email}`
    ];
  },
  addAttributes() {
    return {
      name: { default: null },
      email: { default: null }
    };
  }
});
const PageNumber = Node$1.create({
  name: "page-number",
  group: "inline",
  inline: true,
  atom: true,
  draggable: false,
  selectable: false,
  defining: true,
  content: "",
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
        "data-id": "auto-page-number",
        "aria-label": "Page number node"
      }
    };
  },
  addAttributes() {
    return {
      marksAsAttrs: {
        default: null,
        rendered: false
      }
    };
  },
  addNodeView() {
    return ({ node, editor, getPos, decorations }) => {
      const htmlAttributes = this.options.htmlAttributes;
      return new AutoPageNumberNodeView(node, getPos, decorations, editor, htmlAttributes);
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-id="auto-page-number"' }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      addAutoPageNumber: () => ({ tr, dispatch, state, editor }) => {
        const { options } = editor;
        if (!options.isHeaderOrFooter) return false;
        const { schema } = state;
        const pageNumberType = schema?.nodes?.["page-number"];
        if (!pageNumberType) return false;
        const pageNumberNodeJSON = { type: "page-number" };
        const pageNumberNode = schema.nodeFromJSON(pageNumberNodeJSON);
        if (dispatch) {
          tr.replaceSelectionWith(pageNumberNode, false);
          tr.setMeta("forceUpdatePagination", true);
        }
        return true;
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-alt-p": () => this.editor.commands.addAutoPageNumber()
    };
  }
});
const TotalPageCount = Node$1.create({
  name: "total-page-number",
  group: "inline",
  inline: true,
  atom: true,
  draggable: false,
  selectable: false,
  content: "text*",
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
        "data-id": "auto-total-pages",
        "aria-label": "Total page count node",
        class: "sd-editor-auto-total-pages"
      }
    };
  },
  addAttributes() {
    return {
      marksAsAttrs: {
        default: null,
        rendered: false
      }
    };
  },
  addNodeView() {
    return ({ node, editor, getPos, decorations }) => {
      const htmlAttributes = this.options.htmlAttributes;
      return new AutoPageNumberNodeView(node, getPos, decorations, editor, htmlAttributes);
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-id="auto-total-pages"' }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      addTotalPageCount: () => ({ tr, dispatch, state, editor }) => {
        const { options } = editor;
        if (!options.isHeaderOrFooter) return false;
        const { schema } = state;
        const pageNumberType = schema.nodes?.["total-page-number"];
        if (!pageNumberType) return false;
        const currentPages = editor?.options?.parentEditor?.currentTotalPages || 1;
        const pageNumberNode = {
          type: "total-page-number",
          content: [{ type: "text", text: String(currentPages) }]
        };
        const pageNode = schema.nodeFromJSON(pageNumberNode);
        if (dispatch) {
          tr.replaceSelectionWith(pageNode, false);
        }
        return true;
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-alt-c": () => this.editor.commands.addTotalPageCount()
    };
  }
});
const getNodeAttributes = (nodeName, editor) => {
  switch (nodeName) {
    case "page-number":
      return {
        text: editor.options.currentPageNumber || "1",
        className: "sd-editor-auto-page-number",
        dataId: "auto-page-number",
        ariaLabel: "Page number node"
      };
    case "total-page-number":
      return {
        text: editor.options.parentEditor?.currentTotalPages || "1",
        className: "sd-editor-auto-total-pages",
        dataId: "auto-total-pages",
        ariaLabel: "Total page count node"
      };
    default:
      return {};
  }
};
class AutoPageNumberNodeView {
  constructor(node, getPos, decorations, editor, htmlAttributes = {}) {
    __privateAdd(this, _AutoPageNumberNodeView_instances);
    this.node = node;
    this.editor = editor;
    this.view = editor.view;
    this.getPos = getPos;
    this.editor = editor;
    this.dom = __privateMethod(this, _AutoPageNumberNodeView_instances, renderDom_fn).call(this, node, htmlAttributes);
  }
  update(node) {
    if (node.type !== this.node.type) return false;
    this.node = node;
    return true;
  }
}
_AutoPageNumberNodeView_instances = new WeakSet();
renderDom_fn = function(node, htmlAttributes) {
  const attrs = getNodeAttributes(this.node.type.name, this.editor);
  const content = document.createTextNode(String(attrs.text));
  const nodeContent = document.createElement("span");
  nodeContent.className = attrs.className;
  nodeContent.setAttribute("data-id", attrs.dataId);
  nodeContent.setAttribute("aria-label", attrs.ariaLabel);
  const currentPos = this.getPos();
  const { styles, marks } = getMarksFromNeighbors(currentPos, this.view);
  __privateMethod(this, _AutoPageNumberNodeView_instances, scheduleUpdateNodeStyle_fn).call(this, currentPos, marks);
  Object.assign(nodeContent.style, styles);
  nodeContent.appendChild(content);
  Object.entries(htmlAttributes).forEach(([key, value]) => {
    if (value) nodeContent.setAttribute(key, value);
  });
  return nodeContent;
};
scheduleUpdateNodeStyle_fn = function(pos, marks) {
  setTimeout(() => {
    const { state } = this.editor;
    const { dispatch } = this.view;
    const node = state.doc.nodeAt(pos);
    if (!node || node.isText) return;
    const currentMarks = node.attrs.marksAsAttrs || [];
    const newMarks = marks.map((m) => ({ type: m.type.name, attrs: m.attrs }));
    const isEqual = JSON.stringify(currentMarks) === JSON.stringify(newMarks);
    if (isEqual) return;
    const newAttrs = {
      ...node.attrs,
      marksAsAttrs: newMarks
    };
    const tr = state.tr.setNodeMarkup(pos, void 0, newAttrs);
    dispatch(tr);
  }, 0);
};
const getMarksFromNeighbors = (currentPos, view) => {
  const $pos = view.state.doc.resolve(currentPos);
  const styles = {};
  const marks = [];
  const before = $pos.nodeBefore;
  if (before) {
    Object.assign(styles, processMarks(before.marks));
    marks.push(...before.marks);
  }
  const after = $pos.nodeAfter;
  if (after) {
    Object.assign(styles, { ...styles, ...processMarks(after.marks) });
    marks.push(...after.marks);
  }
  return {
    styles,
    marks
  };
};
const processMarks = (marks) => {
  const styles = {};
  marks.forEach((mark) => {
    const { type, attrs } = mark;
    switch (type.name) {
      case "textStyle":
        if (attrs.fontFamily) styles["font-family"] = attrs.fontFamily;
        if (attrs.fontSize) styles["font-size"] = attrs.fontSize;
        if (attrs.color) styles["color"] = attrs.color;
        if (attrs.backgroundColor) styles["background-color"] = attrs.backgroundColor;
        break;
      case "bold":
        styles["font-weight"] = "bold";
        break;
      case "italic":
        styles["font-style"] = "italic";
        break;
      case "underline":
        styles["text-decoration"] = (styles["text-decoration"] || "") + " underline";
        break;
      case "strike":
        styles["text-decoration"] = (styles["text-decoration"] || "") + " line-through";
        break;
      default:
        if (attrs?.style) {
          Object.entries(attrs.style).forEach(([key, value]) => {
            styles[key] = value;
          });
        }
        break;
    }
  });
  return styles;
};
const ShapeContainer = Node$1.create({
  name: "shapeContainer",
  group: "block",
  content: "block+",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-shape-container",
        "aria-label": "Shape container node"
      }
    };
  },
  addAttributes() {
    return {
      fillcolor: {
        renderDOM: (attrs) => {
          if (!attrs.fillcolor) return {};
          return {
            style: `background-color: ${attrs.fillcolor}`
          };
        }
      },
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      style: {
        renderDOM: (attrs) => {
          if (!attrs.style) return {};
          return {
            style: attrs.style
          };
        }
      },
      wrapAttributes: {
        rendered: false
      },
      attributes: {
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return [
      "div",
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { "data-type": this.name }),
      0
    ];
  }
});
const ShapeTextbox = Node$1.create({
  name: "shapeTextbox",
  group: "block",
  content: "paragraph* block*",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-shape-textbox",
        "aria-label": "Shape textbox node"
      }
    };
  },
  addAttributes() {
    return {
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      attributes: {
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return [
      "div",
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { "data-type": this.name }),
      0
    ];
  }
});
const ContentBlock = Node$1.create({
  name: "contentBlock",
  group: "inline",
  content: "",
  isolating: true,
  atom: true,
  inline: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} ContentBlockOptions
       * @category Options
       * @property {Object} [htmlAttributes] - HTML attributes for the block element
       */
      htmlAttributes: {
        contenteditable: false
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {boolean} [horizontalRule=false] - Whether this block is a horizontal rule
       */
      horizontalRule: {
        default: false,
        renderDOM: ({ horizontalRule }) => {
          if (!horizontalRule) return {};
          return { "data-horizontal-rule": "true" };
        }
      },
      /**
       * @category Attribute
       * @param {ContentBlockSize} [size] - Size and position of the content block
       */
      size: {
        default: null,
        renderDOM: ({ size }) => {
          if (!size) return {};
          let style = "";
          if (size.top) style += `top: ${size.top}px; `;
          if (size.left) style += `left: ${size.left}px; `;
          if (size.width) style += `width: ${size.width.toString().endsWith("%") ? size.width : `${size.width}px`}; `;
          if (size.height)
            style += `height: ${size.height.toString().endsWith("%") ? size.height : `${size.height}px`}; `;
          return { style };
        }
      },
      /**
       * @category Attribute
       * @param {string} [background] - Background color for the block
       */
      background: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.background) return {};
          return {
            style: `background-color: ${attrs.background}`
          };
        }
      },
      /**
       * @private
       * @category Attribute
       * @param {Object} [drawingContent] - Internal drawing data
       */
      drawingContent: {
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {Object} [attributes] - Additional internal attributes
       */
      attributes: {
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return [
      "div",
      Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { "data-type": this.name }),
      0
    ];
  },
  addCommands() {
    return {
      /**
       * Insert a horizontal rule
       * @category Command
       * @returns {Function} Command function
       * @example
       * insertHorizontalRule()
       * @note Creates a visual separator between content sections
       */
      insertHorizontalRule: () => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: {
            horizontalRule: true,
            size: { width: "100%", height: 2 },
            background: "#e5e7eb"
          }
        });
      },
      /**
       * Insert a content block
       * @category Command
       * @param {ContentBlockConfig} config - Block configuration
       * @returns {Function} Command function
       * @example
       * // Insert a spacer block
       * insertContentBlock({ size: { height: 20 } })
       *
       * // Insert a colored divider
       * insertContentBlock({
       *   size: { width: '50%', height: 3 },
       *   background: '#3b82f6'
       * })
       * @note Used for spacing, dividers, and special inline content
       */
      insertContentBlock: (config) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: config
        });
      }
    };
  }
});
const StructuredContent = Node$1.create({
  name: "structuredContent",
  group: "inline",
  inline: true,
  content: "inline*",
  addOptions() {
    return {
      structuredContentClass: "sd-structured-content-tag",
      htmlAttributes: {
        "aria-label": "Structured content node"
      }
    };
  },
  parseDOM() {
    return [{ tag: `span.${this.options.structuredContentClass}` }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      sdtPr: {
        rendered: false
      }
    };
  }
});
const StructuredContentBlock = Node$1.create({
  name: "structuredContentBlock",
  group: "block",
  content: "block*",
  addOptions() {
    return {
      structuredContentClass: "sd-structured-content-tag",
      htmlAttributes: {
        "aria-label": "Structured content block node"
      }
    };
  },
  parseDOM() {
    return [{ tag: `div.${this.options.structuredContentClass}` }];
  },
  renderDOM({ htmlAttributes }) {
    return ["div", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      sdtPr: {
        rendered: false
      }
    };
  }
});
class DocumentSectionView {
  constructor(node, getPos, decorations, editor) {
    __privateAdd(this, _DocumentSectionView_instances);
    this.node = node;
    this.editor = editor;
    this.decorations = decorations;
    this.view = editor.view;
    this.getPos = getPos;
    __privateMethod(this, _DocumentSectionView_instances, init_fn3).call(this);
  }
}
_DocumentSectionView_instances = new WeakSet();
init_fn3 = function() {
  const { attrs } = this.node;
  const { id, title, description } = attrs;
  this.dom = document.createElement("div");
  this.dom.className = "sd-document-section-block";
  this.dom.setAttribute("data-id", id);
  this.dom.setAttribute("data-title", title);
  this.dom.setAttribute("data-description", description);
  this.dom.setAttribute("aria-label", "Document section");
  __privateMethod(this, _DocumentSectionView_instances, addToolTip_fn).call(this);
  this.contentDOM = document.createElement("div");
  this.contentDOM.className = "sd-document-section-block-content";
  this.contentDOM.setAttribute("contenteditable", "true");
  this.dom.appendChild(this.contentDOM);
};
addToolTip_fn = function() {
  const { title } = this.node.attrs;
  this.infoDiv = document.createElement("div");
  this.infoDiv.className = "sd-document-section-block-info";
  const textSpan = document.createElement("span");
  textSpan.textContent = title || "Document section";
  this.infoDiv.appendChild(textSpan);
  this.infoDiv.setAttribute("contenteditable", "false");
  this.dom.appendChild(this.infoDiv);
};
const getAllSections = (editor) => {
  if (!editor) return [];
  const type = editor.schema.nodes.documentSection;
  if (!type) return [];
  const sections = [];
  const { state } = editor;
  state.doc.descendants((node, pos) => {
    if (node.type.name === type.name) {
      sections.push({ node, pos });
    }
  });
  return sections;
};
const exportSectionsToHTML = (editor) => {
  const sections = getAllSections(editor);
  const processedSections = /* @__PURE__ */ new Set();
  const result = [];
  sections.forEach(({ node }) => {
    const { attrs } = node;
    const { id, title, description } = attrs;
    if (processedSections.has(id)) return;
    processedSections.add(id);
    const html = getHTMLFromNode(node, editor);
    result.push({
      id,
      title,
      description,
      html
    });
  });
  return result;
};
const getHTMLFromNode = (node, editor) => {
  const tempDocument = document.implementation.createHTMLDocument();
  const container = tempDocument.createElement("div");
  const fragment = DOMSerializer.fromSchema(editor.schema).serializeFragment(node.content);
  container.appendChild(fragment);
  let html = container.innerHTML;
  return html;
};
const exportSectionsToJSON = (editor) => {
  const sections = getAllSections(editor);
  const processedSections = /* @__PURE__ */ new Set();
  const result = [];
  sections.forEach(({ node }) => {
    const { attrs } = node;
    const { id, title, description } = attrs;
    if (processedSections.has(id)) return;
    processedSections.add(id);
    result.push({
      id,
      title,
      description,
      content: node.toJSON()
    });
  });
  return result;
};
const getLinkedSectionEditor = (id, options, editor) => {
  const sections = getAllSections(editor);
  const section = sections.find((s) => s.node.attrs.id === id);
  if (!section) return null;
  const child = editor.createChildEditor({
    ...options,
    onUpdate: ({ editor: childEditor, transaction }) => {
      const isFromtLinkedParent = transaction.getMeta("fromLinkedParent");
      if (isFromtLinkedParent) return;
      const updatedContent = childEditor.state.doc.content;
      const sectionNode = getAllSections(editor)?.find((s) => s.node.attrs.id === id);
      if (!sectionNode) return;
      const { pos, node } = sectionNode;
      const newNode = node.type.create(node.attrs, updatedContent, node.marks);
      const tr = editor.state.tr.replaceWith(pos, pos + node.nodeSize, newNode);
      tr.setMeta("fromLinkedChild", true);
      editor.view.dispatch(tr);
    }
  });
  editor.on("update", ({ transaction }) => {
    const isFromLinkedChild = transaction.getMeta("fromLinkedChild");
    if (isFromLinkedChild) return;
    const sectionNode = getAllSections(editor)?.find((s) => s.node.attrs.id === id);
    if (!sectionNode) return;
    const sectionContent = sectionNode.node.content;
    const json = {
      type: "doc",
      content: sectionContent.content.map((node) => node.toJSON())
    };
    const childTr = child.state.tr;
    childTr.setMeta("fromLinkedParent", true);
    childTr.replaceWith(0, child.state.doc.content.size, child.schema.nodeFromJSON(json));
    child.view.dispatch(childTr);
  });
  return child;
};
const SectionHelpers = {
  getAllSections,
  exportSectionsToHTML,
  exportSectionsToJSON,
  getLinkedSectionEditor
};
const DocumentSection = Node$1.create({
  name: "documentSection",
  group: "block",
  content: "block*",
  atom: true,
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-document-section-block",
        "aria-label": "Structured content block"
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: "div.sd-document-section-block",
        priority: 60
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["div", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {number} [id] - Unique section identifier
       */
      id: {},
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      /**
       * @category Attribute
       * @param {string} [title] - Section display label
       */
      title: {},
      /**
       * @category Attribute
       * @param {string} [description] - Section metadata
       */
      description: {},
      /**
       * @category Attribute
       * @param {string} [sectionType] - Business classification (e.g., 'legal', 'pricing')
       */
      sectionType: {},
      /**
       * @category Attribute
       * @param {boolean} [isLocked=false] - Lock state preventing edits
       */
      isLocked: { default: false }
    };
  },
  addNodeView() {
    return ({ node, editor, getPos, decorations }) => {
      return new DocumentSectionView(node, getPos, decorations, editor);
    };
  },
  addCommands() {
    return {
      /**
       * Create a lockable content section
       * @category Command
       * @param {SectionCreate} [options={}] - Section configuration
       * @returns {Function} Command - true if created, false if position invalid
       * @example
       * createDocumentSection({
       *   id: 'legal-1',
       *   title: 'Terms & Conditions',
       *   isLocked: true,
       *   html: '<p>Legal content...</p>'
       * })
       */
      createDocumentSection: (options = {}) => ({ tr, state, dispatch, editor }) => {
        const { selection } = state;
        let { from: from2, to } = selection;
        let content = selection.content().content;
        const { html: optionsHTML, json: optionsJSON } = options;
        if (optionsHTML) {
          const html = htmlHandler(optionsHTML, this.editor);
          const doc2 = DOMParser$1.fromSchema(this.editor.schema).parse(html);
          content = doc2.content;
        }
        if (optionsJSON) {
          content = this.editor.schema.nodeFromJSON(optionsJSON);
        }
        if (!content?.content?.length) {
          content = this.editor.schema.nodeFromJSON({ type: "paragraph", content: [] });
        }
        if (!options.id) {
          const allSections = SectionHelpers.getAllSections(editor);
          options.id = allSections.length + 1;
        }
        if (!options.title) {
          options.title = "Document section";
        }
        const node = this.type.createAndFill(options, content);
        if (!node) return false;
        const isAlreadyInSdtBlock = findParentNode((node2) => node2.type.name === "documentSection")(selection);
        if (isAlreadyInSdtBlock && isAlreadyInSdtBlock.node) {
          const insertPos2 = isAlreadyInSdtBlock.pos + isAlreadyInSdtBlock.node.nodeSize;
          from2 = insertPos2;
          to = insertPos2;
        }
        tr.replaceRangeWith(from2, to, node);
        const nodeEnd = from2 + node.nodeSize;
        let shouldInsertParagraph = true;
        let insertPos = nodeEnd;
        if (nodeEnd >= tr.doc.content.size) {
          insertPos = tr.doc.content.size;
          if (insertPos > 0) {
            const $endPos = tr.doc.resolve(insertPos);
            if ($endPos.nodeBefore && $endPos.nodeBefore.type.name === "paragraph") {
              shouldInsertParagraph = false;
            }
          }
        }
        if (shouldInsertParagraph) {
          const emptyParagraph = tr.doc.type.schema.nodes.paragraph.create();
          tr.insert(insertPos, emptyParagraph);
        }
        if (dispatch) {
          tr.setMeta("documentSection", { action: "create" });
          dispatch(tr);
          setTimeout(() => {
            try {
              const currentState = editor.state;
              const docSize = currentState.doc.content.size;
              let targetPos = from2 + node.nodeSize;
              if (shouldInsertParagraph) {
                targetPos += 1;
              }
              targetPos = Math.min(targetPos, docSize);
              if (targetPos < docSize && targetPos > 0) {
                const newSelection = Selection.near(currentState.doc.resolve(targetPos));
                const newTr = currentState.tr.setSelection(newSelection);
                editor.view.dispatch(newTr);
              }
            } catch (e) {
              console.warn("Could not set delayed selection:", e);
            }
          }, 0);
        }
        return true;
      },
      /**
       * Remove section wrapper at cursor, preserving its content
       * @category Command
       * @returns {Function} Command - true if removed, false if no section at position
       * @example
       * removeSectionAtSelection()
       * @note Content stays in document, only section wrapper is removed
       */
      removeSectionAtSelection: () => ({ tr, dispatch }) => {
        const sdtNode = findParentNode((node2) => node2.type.name === "documentSection")(tr.selection);
        if (!sdtNode) return false;
        const { node, pos } = sdtNode;
        const nodeStart = pos;
        const nodeEnd = nodeStart + node.nodeSize;
        const contentToPreserve = node.content;
        tr.delete(nodeStart, nodeEnd);
        if (contentToPreserve.size > 0) {
          tr.insert(nodeStart, contentToPreserve);
        }
        const newPos = Math.min(nodeStart, tr.doc.content.size);
        tr.setSelection(Selection.near(tr.doc.resolve(newPos)));
        if (dispatch) {
          tr.setMeta("documentSection", { action: "delete" });
          dispatch(tr);
        }
        return true;
      },
      /**
       * Delete section and all its content
       * @category Command
       * @param {number} id - Section to delete
       * @returns {Function} Command - true if deleted, false if ID doesn't exist
       * @example
       * removeSectionById(123)
       */
      removeSectionById: (id) => ({ tr, dispatch }) => {
        const sections = SectionHelpers.getAllSections(this.editor);
        const sectionToRemove = sections.find(({ node: node2 }) => node2.attrs.id === id);
        if (!sectionToRemove) return false;
        const { pos, node } = sectionToRemove;
        const nodeStart = pos;
        const nodeEnd = nodeStart + node.nodeSize;
        tr.delete(nodeStart, nodeEnd);
        if (dispatch) {
          tr.setMeta("documentSection", { action: "delete", id });
          dispatch(tr);
        }
        return true;
      },
      /**
       * Lock section against edits
       * @category Command
       * @param {number} id - Section to lock
       * @returns {Function} Command - true if locked, false if ID doesn't exist
       * @example
       * lockSectionById(123)
       */
      lockSectionById: (id) => ({ tr, dispatch }) => {
        const sections = SectionHelpers.getAllSections(this.editor);
        const sectionToLock = sections.find(({ node }) => node.attrs.id === id);
        if (!sectionToLock) return false;
        tr.setNodeMarkup(sectionToLock.pos, null, { ...sectionToLock.node.attrs, isLocked: true });
        if (dispatch) {
          tr.setMeta("documentSection", { action: "lock", id });
          dispatch(tr);
        }
        return true;
      },
      /**
       * Modify section attributes or content
       * @category Command
       * @param {SectionUpdate} options - Changes to apply
       * @returns {Function} Command - true if updated, false if ID doesn't exist
       * @example
       * // Toggle lock
       * updateSectionById({ id: 123, attrs: { isLocked: false } })
       *
       * // Replace content
       * updateSectionById({ id: 123, html: '<p>New content</p>' })
       *
       * // Both
       * updateSectionById({
       *   id: 123,
       *   html: '<p>Updated</p>',
       *   attrs: { title: 'New Title' }
       * })
       */
      updateSectionById: ({ id, html, json, attrs }) => ({ tr, dispatch, editor }) => {
        const sections = SectionHelpers.getAllSections(editor || this.editor);
        const sectionToUpdate = sections.find(({ node: node2 }) => node2.attrs.id === id);
        if (!sectionToUpdate) return false;
        const { pos, node } = sectionToUpdate;
        let newContent = null;
        if (html) {
          const htmlDoc = htmlHandler(html, editor || this.editor);
          const doc2 = DOMParser$1.fromSchema((editor || this.editor).schema).parse(htmlDoc);
          newContent = doc2.content;
        }
        if (json) {
          newContent = (editor || this.editor).schema.nodeFromJSON(json);
        }
        if (!newContent) {
          newContent = node.content;
        }
        const updatedNode = node.type.create({ ...node.attrs, ...attrs }, newContent, node.marks);
        tr.replaceWith(pos, pos + node.nodeSize, updatedNode);
        if (dispatch) {
          tr.setMeta("documentSection", { action: "update", id, attrs });
          dispatch(tr);
        }
        return true;
      }
    };
  },
  addHelpers() {
    return {
      ...SectionHelpers
    };
  }
});
const { findChildren } = helpers;
const SD_BLOCK_ID_ATTRIBUTE_NAME = "sdBlockId";
const BlockNodePluginKey = new PluginKey("blockNodePlugin");
const BlockNode = Extension.create({
  name: "blockNode",
  addCommands() {
    return {
      replaceBlockNodeById: (id, contentNode) => ({ dispatch, tr }) => {
        const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
        if (!blockNode || blockNode.length > 1) {
          return false;
        }
        if (dispatch) {
          let { pos, node } = blockNode[0];
          let newPosFrom = tr.mapping.map(pos);
          let newPosTo = tr.mapping.map(pos + node.nodeSize);
          let currentNode = tr.doc.nodeAt(newPosFrom);
          if (node.eq(currentNode)) {
            tr.replaceWith(newPosFrom, newPosTo, contentNode);
          }
        }
        return true;
      },
      deleteBlockNodeById: (id) => ({ dispatch, tr }) => {
        const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
        if (!blockNode || blockNode.length > 1) {
          return false;
        }
        if (dispatch) {
          let { pos, node } = blockNode[0];
          let newPosFrom = tr.mapping.map(pos);
          let newPosTo = tr.mapping.map(pos + node.nodeSize);
          let currentNode = tr.doc.nodeAt(newPosFrom);
          if (node.eq(currentNode)) {
            tr.delete(newPosFrom, newPosTo);
          }
        }
        return true;
      },
      updateBlockNodeAttributes: (id, attrs = {}) => ({ dispatch, tr }) => {
        const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
        if (!blockNode || blockNode.length > 1) {
          return false;
        }
        if (dispatch) {
          let { pos, node } = blockNode[0];
          let newPos = tr.mapping.map(pos);
          let currentNode = tr.doc.nodeAt(newPos);
          if (node.eq(currentNode)) {
            tr.setNodeMarkup(newPos, void 0, {
              ...node.attrs,
              ...attrs
            });
          }
          return true;
        }
      }
    };
  },
  addHelpers() {
    return {
      getBlockNodes: () => {
        return findChildren(this.editor.state.doc, (node) => nodeAllowsSdBlockIdAttr(node));
      },
      getBlockNodeById: (id) => {
        return findChildren(this.editor.state.doc, (node) => node.attrs.sdBlockId === id);
      },
      getBlockNodesByType: (type) => {
        return findChildren(this.editor.state.doc, (node) => node.type.name === type);
      },
      getBlockNodesInRange: (from2, to) => {
        let blockNodes = [];
        this.editor.state.doc.nodesBetween(from2, to, (node, pos) => {
          if (nodeAllowsSdBlockIdAttr(node)) {
            blockNodes.push({
              node,
              pos
            });
          }
        });
        return blockNodes;
      }
    };
  },
  addPmPlugins() {
    let hasInitialized = false;
    return [
      new Plugin({
        key: BlockNodePluginKey,
        appendTransaction: (transactions, _oldState, newState) => {
          if (hasInitialized && !transactions.some((tr2) => tr2.docChanged)) return null;
          if (hasInitialized && !checkForNewBlockNodesInTrs(transactions)) return null;
          let tr = null;
          let changed = false;
          newState.doc.descendants((node, pos) => {
            if (!nodeAllowsSdBlockIdAttr(node) || !nodeNeedsSdBlockId(node)) return null;
            tr = tr ?? newState.tr;
            tr.setNodeMarkup(
              pos,
              void 0,
              {
                ...node.attrs,
                sdBlockId: v4()
              },
              node.marks
            );
            changed = true;
          });
          if (changed && !hasInitialized) hasInitialized = true;
          return changed ? tr : null;
        }
      })
    ];
  }
});
const nodeAllowsSdBlockIdAttr = (node) => {
  return !!(node?.isBlock && node?.type?.spec?.attrs?.[SD_BLOCK_ID_ATTRIBUTE_NAME]);
};
const nodeNeedsSdBlockId = (node) => {
  const currentId = node?.attrs?.[SD_BLOCK_ID_ATTRIBUTE_NAME];
  return !currentId;
};
const checkForNewBlockNodesInTrs = (transactions) => {
  return transactions.some((tr) => {
    return tr.steps.some((step) => {
      const hasValidSdBlockNodes = step.slice?.content?.content?.some((node) => nodeAllowsSdBlockIdAttr(node));
      return step instanceof ReplaceStep && hasValidSdBlockNodes;
    });
  });
};
const TextStyle = Mark.create({
  name: "textStyle",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  parseDOM() {
    return [
      {
        tag: "span",
        getAttrs: (el) => {
          const hasStyles = el.hasAttribute("style");
          const isAnnotation = el.classList.contains(annotationClass) || el.classList.contains(annotationContentClass);
          if (!hasStyles || isAnnotation) return false;
          return {};
        }
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      styleId: {}
    };
  },
  addCommands() {
    return {
      /**
       * Remove empty text style marks
       * @category Command
       * @returns {Function} Command - Removes mark if no attributes present
       * @example
       * removeEmptyTextStyle()
       * @note Cleanup utility to prevent empty span elements
       */
      removeEmptyTextStyle: () => ({ state, commands: commands2 }) => {
        const attributes = Attribute.getMarkAttributes(state, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) return true;
        return commands2.unsetMark(this.name);
      }
    };
  }
});
const Bold = Mark.create({
  name: "bold",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [value] - Bold weight value ('0' renders as normal)
       */
      value: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.value) return {};
          if (attrs.value === "0") {
            return { style: "font-weight: normal" };
          }
          return {};
        }
      }
    };
  },
  parseDOM() {
    return [
      { tag: "strong" },
      { tag: "b", getAttrs: (node) => node.style.fontWeight != "normal" && null },
      { style: "font-weight=400", clearMark: (m) => m.type.name == "strong" },
      { style: "font-weight", getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["strong", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Apply bold formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * setBold()
       * @note '0' renders as normal weight
       */
      setBold: () => ({ commands: commands2 }) => commands2.setMark(this.name),
      /**
       * Remove bold formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetBold()
       */
      unsetBold: () => ({ commands: commands2 }) => commands2.unsetMark(this.name),
      /**
       * Toggle bold formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleBold()
       */
      toggleBold: () => ({ commands: commands2 }) => commands2.toggleMark(this.name)
    };
  },
  addShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  }
});
const Italic = Mark.create({
  name: "italic",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  parseDOM() {
    return [
      { tag: "i" },
      { tag: "em" },
      { style: "font-style=italic" },
      { style: "font-style=normal", clearMark: (m) => m.type.name == "em" }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["em", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Apply italic formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * setItalic()
       */
      setItalic: () => ({ commands: commands2 }) => commands2.setMark(this.name),
      /**
       * Remove italic formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetItalic()
       */
      unsetItalic: () => ({ commands: commands2 }) => commands2.unsetMark(this.name),
      /**
       * Toggle italic formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleItalic()
       */
      toggleItalic: () => ({ commands: commands2 }) => commands2.toggleMark(this.name)
    };
  },
  addShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  }
});
const Underline = Mark.create({
  name: "underline",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  parseDOM() {
    return [
      { tag: "u" },
      { style: "text-decoration=underline" },
      { style: "text-decoration=auto", clearMark: (m) => m.type.name == "u" }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["u", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {UnderlineConfig} [underlineType='single'] - Style of underline
       */
      underlineType: {
        default: "single"
      }
    };
  },
  addCommands() {
    return {
      /**
       * Apply underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * setUnderline()
       */
      setUnderline: () => ({ commands: commands2 }) => commands2.setMark(this.name),
      /**
       * Remove underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetUnderline()
       */
      unsetUnderline: () => ({ commands: commands2 }) => commands2.unsetMark(this.name),
      /**
       * Toggle underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleUnderline()
       */
      toggleUnderline: () => ({ commands: commands2 }) => commands2.toggleMark(this.name)
    };
  },
  addShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
const Highlight = Mark.create({
  name: "highlight",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [color] - Background color (CSS color value)
       */
      color: {
        default: null,
        parseDOM: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderDOM: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseDOM() {
    return [{ tag: "mark" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["mark", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Apply highlight with specified color
       * @category Command
       * @param {string} color - CSS color value
       * @returns {Function} Command
       * @example
       * setHighlight('#FFEB3B')
       * setHighlight('rgba(255, 235, 59, 0.5)')
       */
      setHighlight: (color) => ({ commands: commands2 }) => commands2.setMark(this.name, { color }),
      /**
       * Remove highlight formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetHighlight()
       */
      unsetHighlight: () => ({ commands: commands2 }) => commands2.unsetMark(this.name),
      /**
       * Toggle highlight formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHighlight()
       */
      toggleHighlight: () => ({ commands: commands2 }) => commands2.toggleMark(this.name)
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  }
});
const Strike = Mark.create({
  name: "strike",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  parseDOM() {
    return [
      { tag: "s" },
      { style: "text-decoration=line-through" },
      { style: "text-decoration=auto", clearMark: (m) => m.type.name == "s" }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["s", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Apply strikethrough formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * setStrike()
       */
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      /**
       * Remove strikethrough formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetStrike()
       */
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      },
      /**
       * Toggle strikethrough formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleStrike()
       */
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  }
});
const Link = Mark.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  inclusive: false,
  addOptions() {
    return {
      /**
       * Allowed URL protocols
       * @type {string[]}
       * @default ['http', 'https']
       */
      protocols: ["http", "https"],
      htmlAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      }
    };
  },
  parseDOM() {
    return [{ tag: "a" }];
  },
  renderDOM({ htmlAttributes }) {
    if (!isAllowedUri(htmlAttributes.href, this.options.protocols)) {
      return ["a", Attribute.mergeAttributes(this.options.htmlAttributes, { ...htmlAttributes, href: "" }), 0];
    }
    return ["a", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [href] - URL or anchor reference
       */
      href: {
        default: null,
        renderDOM: ({ href, name }) => {
          if (href && isAllowedUri(href, this.options.protocols)) return { href };
          else if (name) return { href: `#${name}` };
          return {};
        }
      },
      /**
       * @category Attribute
       * @param {string} [target='_blank'] - Link target window
       */
      target: { default: this.options.htmlAttributes.target },
      /**
       * @category Attribute
       * @param {string} [rel='noopener noreferrer nofollow'] - Relationship attributes
       */
      rel: { default: this.options.htmlAttributes.rel },
      /**
       * @private
       * @category Attribute
       * @param {string} [rId] - Word relationship ID for internal links
       */
      rId: { default: this.options.htmlAttributes.rId || null },
      /**
       * @category Attribute
       * @param {string} [text] - Display text for the link
       */
      text: { default: null },
      /**
       * @category Attribute
       * @param {string} [name] - Anchor name for internal references
       */
      name: { default: null }
    };
  },
  addCommands() {
    return {
      /**
       * Create or update a link
       * @category Command
       * @param {Object} options - Link configuration
       * @param {string} [options.href] - URL for the link
       * @param {string} [options.text] - Display text (uses selection if omitted)
       * @returns {Function} Command - Creates link with underline
       * @example
       * // Link selected text
       * setLink({ href: 'https://example.com' })
       *
       * // Link with custom text
       * setLink({
       *   href: 'https://example.com',
       *   text: 'Visit Example'
       * })
       * @note Automatically adds underline formatting and trims whitespace from link boundaries
       */
      setLink: ({ href, text } = {}) => ({ state, dispatch, editor }) => {
        const { selection } = state;
        const linkMarkType = editor.schema.marks.link;
        const underlineMarkType = editor.schema.marks.underline;
        let from2 = selection.from;
        let to = selection.to;
        if (selection.empty) {
          const range = getMarkRange(selection.$from, linkMarkType);
          if (range) {
            from2 = range.from;
            to = range.to;
          }
        } else {
          const fromLinkRange = getMarkRange(selection.$from, linkMarkType);
          const toLinkRange = getMarkRange(selection.$to, linkMarkType);
          if (fromLinkRange || toLinkRange) {
            const linkRange = fromLinkRange || toLinkRange;
            from2 = linkRange.from;
            to = linkRange.to;
          }
        }
        ({ from: from2, to } = trimRange(state.doc, from2, to));
        const currentText = state.doc.textBetween(from2, to);
        const computedText = text ?? currentText;
        const finalText = computedText && computedText.length > 0 ? computedText : href || "";
        let tr = state.tr;
        if (finalText && currentText !== finalText) {
          tr = tr.insertText(finalText, from2, to);
          to = from2 + finalText.length;
        }
        if (linkMarkType) tr = tr.removeMark(from2, to, linkMarkType);
        if (underlineMarkType) tr = tr.removeMark(from2, to, underlineMarkType);
        if (underlineMarkType) tr = tr.addMark(from2, to, underlineMarkType.create());
        let rId = null;
        if (editor.options.mode === "docx") {
          const id = addLinkRelationship({ editor, href });
          if (id) rId = id;
        }
        const newLinkMarkType = linkMarkType.create({ href, text: finalText, rId });
        tr = tr.addMark(from2, to, newLinkMarkType);
        dispatch(tr.scrollIntoView());
        return true;
      },
      /**
       * Remove link and associated formatting
       * @category Command
       * @returns {Function} Command - Removes link, underline, and color
       * @example
       * unsetLink()
       * @note Also removes underline and text color
       */
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark("underline", { extendEmptyMarkRange: true }).unsetColor().unsetMark("link", { extendEmptyMarkRange: true }).run();
      },
      /**
       * Toggle link on selection
       * @category Command
       * @param {Object} [options] - Link configuration
       * @param {string} [options.href] - URL for the link
       * @param {string} [options.text] - Display text
       * @returns {Function} Command - Creates link if href provided, removes otherwise
       * @example
       * // Add link
       * toggleLink({ href: 'https://example.com' })
       *
       * // Remove link
       * toggleLink()
       */
      toggleLink: ({ href, text } = {}) => ({ commands: commands2 }) => {
        if (!href) return commands2.unsetLink();
        return commands2.setLink({ href, text });
      }
    };
  }
});
const ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function isAllowedUri(uri, protocols) {
  const allowedProtocols = ["http", "https", "mailto"];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return !uri || uri.replace(ATTR_WHITESPACE, "").match(new RegExp(`^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`, "i"));
}
const trimRange = (doc2, from2, to) => {
  while (from2 < to && doc2.textBetween(from2, from2 + 1, "") === "") {
    from2 += 1;
  }
  while (to > from2 && doc2.textBetween(to - 1, to, "") === "") {
    to -= 1;
  }
  return { from: from2, to };
};
function addLinkRelationship({ editor, href }) {
  const target = href;
  const type = "hyperlink";
  try {
    const id = insertNewRelationship(target, type, editor);
    return id;
  } catch {
    return null;
  }
}
const trackInsertClass = "track-insert";
const TrackInsert = Mark.create({
  name: TrackInsertMarkName,
  group: "track",
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackInsertClass
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-id"),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            "data-id": attrs.id
          };
        }
      },
      author: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-author"),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            "data-author": attrs.author
          };
        }
      },
      authorEmail: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authoremail"),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            "data-authoremail": attrs.authorEmail
          };
        }
      },
      date: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-date"),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            "data-date": attrs.date
          };
        }
      },
      importedAuthor: {
        default: "",
        rendered: false
      }
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const trackDeleteClass = "track-delete";
const TrackDelete = Mark.create({
  name: TrackDeleteMarkName,
  group: "track",
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackDeleteClass
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-id"),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            "data-id": attrs.id
          };
        }
      },
      author: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-author"),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            "data-author": attrs.author
          };
        }
      },
      authorEmail: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authoremail"),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            "data-authoremail": attrs.authorEmail
          };
        }
      },
      date: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-date"),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            "data-date": attrs.date
          };
        }
      },
      importedAuthor: {
        default: "",
        rendered: false
      }
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const replaceAroundStep = () => {
};
const markWrapping = () => {
};
const parseFormatList = (str) => {
  if (!str) return [];
  let formatList;
  try {
    formatList = JSON.parse(str);
  } catch {
    return [];
  }
  if (!Array.isArray(formatList)) {
    return [];
  }
  return formatList.filter((format) => Object.hasOwn(format, "type") && Object.hasOwn(format, "attrs"));
};
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addMarkStep,
  documentHelpers,
  findTrackedMarkBetween,
  getTrackChanges,
  markDeletion,
  markInsertion,
  markWrapping,
  parseFormatList,
  removeMarkStep,
  replaceAroundStep,
  replaceStep,
  trackedTransaction
}, Symbol.toStringTag, { value: "Module" }));
const trackFormatClass = "track-format";
const TrackFormat = Mark.create({
  name: TrackFormatMarkName,
  group: "track",
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackFormatClass
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-id"),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            "data-id": attrs.id
          };
        }
      },
      author: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-author"),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            "data-author": attrs.author
          };
        }
      },
      authorEmail: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authoremail"),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            "data-authoremail": attrs.authorEmail
          };
        }
      },
      date: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-date"),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            "data-date": attrs.date
          };
        }
      },
      // {
      //   type: string, // the mark name
      //   attrs: object, // the mark attrs
      // }
      before: {
        default: [],
        parseDOM: (elem) => {
          return parseFormatList(elem.getAttribute("data-before"));
        },
        renderDOM: (attrs) => {
          if (!attrs.before) return {};
          return {
            "data-before": JSON.stringify(attrs.before)
          };
        }
      },
      // {
      //   type: string, // the mark name
      //   attrs: object, // the mark attrs
      // }
      after: {
        default: [],
        parseDOM: (elem) => {
          return parseFormatList(elem.getAttribute("data-after"));
        },
        renderDOM: (attrs) => {
          if (!attrs.after) return {};
          return {
            "data-after": JSON.stringify(attrs.after)
          };
        }
      },
      importedAuthor: {
        default: "",
        rendered: false
      }
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const TrackChanges = Extension.create({
  name: "trackChanges",
  addCommands() {
    return {
      acceptTrackedChangesBetween: (from2, to) => ({ state, dispatch }) => {
        let { tr, doc: doc2 } = state;
        tr.setMeta("acceptReject", true);
        const map2 = new Mapping();
        doc2.nodesBetween(from2, to, (node, pos) => {
          if (node.marks && node.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
            const deletionStep = new ReplaceStep(
              map2.map(Math.max(pos, from2)),
              map2.map(Math.min(pos + node.nodeSize, to)),
              Slice.empty
            );
            tr.step(deletionStep);
            map2.appendMap(deletionStep.getMap());
          } else if (node.marks && node.marks.find((mark) => mark.type.name === TrackInsertMarkName)) {
            const insertionMark = node.marks.find((mark) => mark.type.name === TrackInsertMarkName);
            tr.step(
              new RemoveMarkStep(
                map2.map(Math.max(pos, from2)),
                map2.map(Math.min(pos + node.nodeSize, to)),
                insertionMark
              )
            );
          } else if (node.marks && node.marks.find((mark) => mark.type.name === TrackFormatMarkName)) {
            const formatChangeMark = node.marks.find((mark) => mark.type.name === TrackFormatMarkName);
            tr.step(
              new RemoveMarkStep(
                map2.map(Math.max(pos, from2)),
                map2.map(Math.min(pos + node.nodeSize, to)),
                formatChangeMark
              )
            );
          }
        });
        if (tr.steps.length) {
          dispatch(tr);
        }
        return true;
      },
      rejectTrackedChangesBetween: (from2, to) => ({ state, dispatch }) => {
        const { tr, doc: doc2 } = state;
        tr.setMeta("acceptReject", true);
        const map2 = new Mapping();
        doc2.nodesBetween(from2, to, (node, pos) => {
          if (node.marks && node.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
            const deletionMark = node.marks.find((mark) => mark.type.name === TrackDeleteMarkName);
            tr.step(
              new RemoveMarkStep(
                map2.map(Math.max(pos, from2)),
                map2.map(Math.min(pos + node.nodeSize, to)),
                deletionMark
              )
            );
          } else if (node.marks && node.marks.find((mark) => mark.type.name === TrackInsertMarkName)) {
            const deletionStep = new ReplaceStep(
              map2.map(Math.max(pos, from2)),
              map2.map(Math.min(pos + node.nodeSize, to)),
              Slice.empty
            );
            tr.step(deletionStep);
            map2.appendMap(deletionStep.getMap());
          } else if (node.marks && node.marks.find((mark) => mark.type.name === TrackFormatMarkName)) {
            const formatChangeMark = node.marks.find((mark) => mark.type.name === TrackFormatMarkName);
            formatChangeMark.attrs.before.forEach((oldMark) => {
              tr.step(
                new AddMarkStep(
                  map2.map(Math.max(pos, from2)),
                  map2.map(Math.min(pos + node.nodeSize, to)),
                  state.schema.marks[oldMark.type].create(oldMark.attrs)
                )
              );
            });
            formatChangeMark.attrs.after.forEach((newMark) => {
              tr.step(
                new RemoveMarkStep(
                  map2.map(Math.max(pos, from2)),
                  map2.map(Math.min(pos + node.nodeSize, to)),
                  node.marks.find((mark) => mark.type.name === newMark.type)
                )
              );
            });
            tr.step(
              new RemoveMarkStep(
                map2.map(Math.max(pos, from2)),
                map2.map(Math.min(pos + node.nodeSize, to)),
                formatChangeMark
              )
            );
          }
        });
        if (tr.steps.length) {
          dispatch(tr);
        }
        return true;
      },
      acceptTrackedChange: ({ trackedChange }) => ({ commands: commands2 }) => {
        const { start: from2, end: to } = trackedChange;
        return commands2.acceptTrackedChangesBetween(from2, to);
      },
      acceptTrackedChangeBySelection: () => ({ state, commands: commands2 }) => {
        const { from: from2, to } = state.selection;
        return commands2.acceptTrackedChangesBetween(from2, to);
      },
      acceptTrackedChangeById: (id) => ({ state, tr, commands: commands2 }) => {
        const toResolve = getChangesByIdToResolve(state, id) || [];
        return toResolve.map(({ from: from2, to }) => {
          let mappedFrom = tr.mapping.map(from2);
          let mappedTo = tr.mapping.map(to);
          return commands2.acceptTrackedChangesBetween(mappedFrom, mappedTo);
        }).every((result) => result);
      },
      acceptAllTrackedChanges: () => ({ state, commands: commands2 }) => {
        const from2 = 0, to = state.doc.content.size;
        return commands2.acceptTrackedChangesBetween(from2, to);
      },
      rejectTrackedChangeById: (id) => ({ state, tr, commands: commands2 }) => {
        const toReject = getChangesByIdToResolve(state, id) || [];
        return toReject.map(({ from: from2, to }) => {
          let mappedFrom = tr.mapping.map(from2);
          let mappedTo = tr.mapping.map(to);
          return commands2.rejectTrackedChangesBetween(mappedFrom, mappedTo);
        }).every((result) => result);
      },
      rejectTrackedChange: ({ trackedChange }) => ({ commands: commands2 }) => {
        const { start: from2, end: to } = trackedChange;
        return commands2.rejectTrackedChangesBetween(from2, to);
      },
      rejectTrackedChangeOnSelection: () => ({ state, commands: commands2 }) => {
        const { from: from2, to } = state.selection;
        return commands2.rejectTrackedChangesBetween(from2, to);
      },
      rejectAllTrackedChanges: () => ({ state, commands: commands2 }) => {
        const from2 = 0, to = state.doc.content.size;
        return commands2.rejectTrackedChangesBetween(from2, to);
      },
      toggleTrackChanges: () => ({ state }) => {
        const trackChangeState = TrackChangesBasePluginKey.getState(state);
        if (trackChangeState === void 0) return false;
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "TRACK_CHANGES_ENABLE",
          value: !trackChangeState.isTrackChangesActive
        });
        return true;
      },
      enableTrackChanges: () => ({ state }) => {
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "TRACK_CHANGES_ENABLE",
          value: true
        });
        return true;
      },
      disableTrackChanges: () => ({ state }) => {
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "TRACK_CHANGES_ENABLE",
          value: false
        });
        return true;
      },
      toggleTrackChangesShowOriginal: () => ({ state }) => {
        const trackChangeState = TrackChangesBasePluginKey.getState(state);
        if (trackChangeState === void 0) return false;
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_ORIGINAL",
          value: !trackChangeState.onlyOriginalShown
        });
        return true;
      },
      enableTrackChangesShowOriginal: () => ({ state }) => {
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_ORIGINAL",
          value: true
        });
        return true;
      },
      disableTrackChangesShowOriginal: () => ({ state }) => {
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_ORIGINAL",
          value: false
        });
        return true;
      },
      toggleTrackChangesShowFinal: () => ({ state }) => {
        const trackChangeState = TrackChangesBasePluginKey.getState(state);
        if (trackChangeState === void 0) return false;
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_MODIFIED",
          value: !trackChangeState.onlyModifiedShown
        });
        return true;
      },
      enableTrackChangesShowFinal: () => ({ state }) => {
        state.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_MODIFIED",
          value: true
        });
        return true;
      }
    };
  },
  addPmPlugins() {
    return [TrackChangesBasePlugin()];
  }
});
const getChangesByIdToResolve = (state, id) => {
  const trackedChanges = getTrackChanges(state);
  const changeIndex = trackedChanges.findIndex(({ mark }) => mark.attrs.id === id);
  if (changeIndex === -1) return;
  const matchingChange = trackedChanges[changeIndex];
  const prev = trackedChanges[changeIndex - 1];
  const next = trackedChanges[changeIndex + 1];
  let linkedChange;
  if (prev && matchingChange.start === prev.end) {
    linkedChange = prev;
  } else if (next && matchingChange.end === next.start) {
    linkedChange = next;
  }
  return [matchingChange, linkedChange].filter(Boolean);
};
const TextTransform = Extension.create({
  name: "textTransform",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textTransform: {
            default: null,
            renderDOM: (attrs) => {
              if (!attrs.textCase) return {};
              return {
                style: `text-transform: ${attrs.textCase}`
              };
            }
          }
        }
      }
    ];
  }
});
const Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      placeholder: "Type something..."
    };
  },
  addPmPlugins() {
    const applyDecoration = (state) => {
      const plainText = state.doc.textBetween(0, state.doc.content.size, " ", " ");
      if (plainText !== "") return DecorationSet.empty;
      const { $from } = state.selection;
      const decoration = Decoration.node($from.before(), $from.after(), {
        "data-placeholder": this.options.placeholder,
        class: "sd-editor-placeholder"
      });
      return DecorationSet.create(state.doc, [decoration]);
    };
    const placeholderPlugin = new Plugin({
      key: new PluginKey("placeholder"),
      state: {
        init: (_, state) => {
          return applyDecoration(state);
        },
        apply: (tr, oldValue, oldState, newState) => {
          return applyDecoration(newState);
        }
      },
      props: {
        decorations(state) {
          return this.getState(state);
        }
      }
    });
    return [placeholderPlugin];
  }
});
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName$1(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow$1(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function isElement$2(node) {
  var OwnElement = getWindow$1(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement$1(node) {
  var OwnElement = getWindow$1(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot$1(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow$1(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element = state.elements[name];
    if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
      return;
    }
    Object.assign(element.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
        return;
      }
      Object.assign(element.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
var max$1 = Math.max;
var min$1 = Math.min;
var round$1 = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect$1(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect2 = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect2.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect2.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$2(element) ? getWindow$1(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect2.width / scaleX;
  var height = clientRect2.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect$1(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot$1(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$2(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function isTableElement$1(element) {
  return ["table", "td", "th"].indexOf(getNodeName$1(element)) >= 0;
}
function getDocumentElement$1(element) {
  return ((isElement$2(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode$1(element) {
  if (getNodeName$1(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot$1(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement$1(element)
  );
}
function getTrueOffsetParent$1(element) {
  if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock$1(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement$1(element)) {
    var elementCss = getComputedStyle$2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode$1(element);
  if (isShadowRoot$1(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName$1(currentNode)) < 0) {
    var css = getComputedStyle$2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent$1(element) {
  var window2 = getWindow$1(element);
  var offsetParent = getTrueOffsetParent$1(element);
  while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent$1(offsetParent);
  }
  if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock$1(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min2, value, max2) {
  return max$1(min2, min$1(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent$1(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    return;
  }
  state.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x * dpr) / dpr || 0,
    y: round$1(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent$1(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow$1(popper2)) {
      offsetParent = getDocumentElement$1(popper2);
      if (getComputedStyle$2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }, getWindow$1(popper2)) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement$1(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow$1(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node) {
  var win = getWindow$1(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX$1(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect$1(element, strategy) {
  var win = getWindow$1(element);
  var html = getDocumentElement$1(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX$1(element),
    y
  };
}
function getDocumentRect$1(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement$1(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX$1(element);
  var y = -winScroll.scrollTop;
  if (getComputedStyle$2(body || html).direction === "rtl") {
    x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName$1(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement$1(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode$1(node));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow$1(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode$1(target)))
  );
}
function rectToClientRect$1(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect$1(element, strategy) {
  var rect = getBoundingClientRect$1(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect$1(getViewportRect$1(element, strategy)) : isElement$2(clippingParent) ? getInnerBoundingClientRect$1(clippingParent, strategy) : rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode$1(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent$1(element) : element;
  if (!isElement$2(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$2(clippingParent) && contains(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body";
  });
}
function getClippingRect$1(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow$1(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect$1(isElement$2(element) ? element : element.contextElement || getDocumentElement$1(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect$1(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    placement
  });
  var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow$1(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement$1(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement$1(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement$1(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement$1(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow$1(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets$1(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped$1(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide$2(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow$1(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow$1(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets$1(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets$1(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped$1(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped$1(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$3 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide$2
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    placement: state.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow$1(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement$1(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent$1(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll$1(node) {
  if (node === getWindow$1(node) || !isHTMLElement$1(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement$1(offsetParent);
  var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName$1(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect$1(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX$1(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers2) {
  var map2 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map2.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map2.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$1(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement$2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update  it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent$1(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state.orderedModifiers.length; index2++) {
          if (state.reset === true) {
            state.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance
            }) || state;
          }
        }
      },
      // Async and optimistically optimized update  it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$1(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect3 = _ref.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({
            state,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$3];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function hasOwnProperty(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index2, defaultValue) {
  if (Array.isArray(value)) {
    var v = value[index2];
    return v == null ? Array.isArray(defaultValue) ? defaultValue[index2] : defaultValue : v;
  }
  return value;
}
function isType(value, type) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce(fn2, ms) {
  if (ms === 0) {
    return fn2;
  }
  var timeout2;
  return function(arg) {
    clearTimeout(timeout2);
    timeout2 = setTimeout(function() {
      fn2(arg);
    }, ms);
  };
}
function removeProperties(obj, keys2) {
  var clone = Object.assign({}, obj);
  keys2.forEach(function(key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index2) {
    return arr.indexOf(item) === index2;
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement$1(value) {
  return ["Element", "Fragment"].some(function(type) {
    return isType(value, type);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement$1(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
  return [
    getDevMessage(message),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var visitedMessages;
if (process$1.env.NODE_ENV !== "production") {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = /* @__PURE__ */ new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  if (process$1.env.NODE_ENV !== "production") {
    validateProps(partialProps, []);
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin) {
    var name = plugin.name, defaultValue = plugin.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function(plugin) {
        return plugin.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement$1(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent(content, props) {
  if (isElement$1(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node) {
      return node.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node) {
      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node) {
      return node.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent(content, instance.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content2, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow2);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box2.removeChild(arrow2);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount,
    destroy
  };
  if (!props.render) {
    if (process$1.env.NODE_ENV !== "production") {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance;
  }
  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins.map(function(plugin) {
    return plugin.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      var currentValue = node.getAttribute(attr);
      if (instance.state.isVisible) {
        node.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node.setAttribute(attr, nextValue);
        } else {
          node.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      if (instance.props.interactive) {
        node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false");
      } else {
        node.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc2 = getDocument();
    doc2.addEventListener("mousedown", onDocumentPress, true);
    doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc2 = getDocument();
    doc2.removeEventListener("mousedown", onDocumentPress, true);
    doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node) {
      node.addEventListener(eventType, handler, options);
      listeners.push({
        node,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on("touchstart", onTrigger2, {
        passive: true
      });
      on("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on("mouseleave", onMouseLeave);
          break;
        case "focus":
          on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance2 = popper3._tippy;
      var state2 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state2) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state2,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn2(_ref2) {
        var state2 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state2.placement);
            } else {
              if (state2.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state2.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset2
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount() {
    var appendTo = instance.props.appendTo;
    var parentNode2;
    var node = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
    if (process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node) {
        node.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent2(content) {
    instance.setProps({
      content
    });
  }
  function show() {
    if (process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount();
  }
  function hide2() {
    if (process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    if (process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount() {
    if (process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy() {
    if (process$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  if (process$1.env.NODE_ENV !== "production") {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  if (process$1.env.NODE_ENV !== "production") {
    var isSingleContentElement = isElement$1(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement$1(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
Object.assign({}, applyStyles$1, {
  effect: function effect2(_ref) {
    var state = _ref.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1 = ["onClick", "onMouseenter"];
const _hoisted_2 = { key: 0 };
const _hoisted_3 = { key: 0 };
const _hoisted_4 = { key: 1 };
const _hoisted_5 = { key: 1 };
const _sfc_main = {
  __name: "Mentions",
  props: {
    users: {
      type: Array,
      required: true
    },
    mention: {
      type: String,
      default: ""
    },
    inserMention: {
      type: Function,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const container = ref(null);
    const activeUserIndex = ref(null);
    const getFilteredUsers = computed(() => {
      const mention = props.mention.slice(1)?.toLowerCase();
      const filtered = props.users.filter((user) => {
        const isViewer = user.role === "viewer";
        const userMatch = user.name?.toLowerCase().startsWith(mention);
        const emailMatch = user.email?.toLowerCase().startsWith(mention);
        return !isViewer && (userMatch || emailMatch);
      }) || [];
      return filtered;
    });
    const handleClick2 = (user) => {
      props.inserMention(user);
    };
    const handleKeydown = (event) => {
      if (event.key === "ArrowDown") {
        activeUserIndex.value += 1;
        if (activeUserIndex.value === getFilteredUsers.value.length) {
          activeUserIndex.value = 0;
        }
      } else if (event.key === "ArrowUp") {
        activeUserIndex.value -= 1;
        if (activeUserIndex.value < 0) {
          activeUserIndex.value = getFilteredUsers.value.length - 1;
        }
      } else if (event.key === "Enter") {
        const user = getFilteredUsers.value[activeUserIndex.value];
        if (user) {
          props.inserMention(user);
        }
      }
    };
    const handleFocus = () => {
      activeUserIndex.value = 0;
    };
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "mentions-container",
        ref_key: "container",
        ref: container,
        onKeydown: withModifiers(handleKeydown, ["prevent"]),
        onFocus: withModifiers(handleFocus, ["stop", "prevent"]),
        tabindex: "0"
      }, [
        (openBlock(true), createElementBlock(Fragment$1, null, renderList(getFilteredUsers.value, (user, index2) => {
          return openBlock(), createElementBlock("div", {
            onClick: withModifiers(($event) => handleClick2(user), ["stop", "prevent"]),
            onMouseenter: ($event) => activeUserIndex.value = index2,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => activeUserIndex.value = null),
            key: user.email,
            class: normalizeClass(["user-row", { selected: activeUserIndex.value === index2 }])
          }, [
            user.name ? (openBlock(), createElementBlock("div", _hoisted_2, [
              user.name ? (openBlock(), createElementBlock("span", _hoisted_3, toDisplayString(user.name), 1)) : createCommentVNode("", true),
              user.name && user.email ? (openBlock(), createElementBlock("span", _hoisted_4, " (" + toDisplayString(user.email) + ")", 1)) : createCommentVNode("", true)
            ])) : (openBlock(), createElementBlock("div", _hoisted_5, [
              createElementVNode("span", null, toDisplayString(user.email), 1)
            ]))
          ], 42, _hoisted_1);
        }), 128))
      ], 544);
    };
  }
};
const Mentions = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-bcae18cf"]]);
const popoverPluginKey = new PluginKey("popoverPlugin");
const PopoverPlugin = Extension.create({
  name: "popoverPlugin",
  addPmPlugins() {
    const popover = new Plugin({
      key: popoverPluginKey,
      state: {
        init: () => {
          return {};
        },
        apply: (tr, value) => {
          let newValue = { ...value };
          if (tr.docChanged) {
            newValue.shouldUpdate = true;
          } else {
            newValue.shouldUpdate = false;
          }
          return newValue;
        }
      },
      view: (view) => {
        const popover2 = new Popover(view, this.editor);
        return {
          update: (view2, lastState) => {
            const pluginState = popoverPluginKey.getState(view2.state);
            if (!pluginState.shouldUpdate) return;
            popover2.update(view2, lastState);
          },
          destroy: () => {
            popover2.destroy();
          }
        };
      }
    });
    return [popover];
  }
});
class Popover {
  constructor(view, editor) {
    __publicField(this, "handleKeyDown", (event) => {
      const isArrow = event.key === "ArrowDown" || event.key === "ArrowUp";
      if (this.tippyInstance.state.isVisible && isArrow) {
        event.preventDefault();
        this.popover.firstChild.focus();
      }
    });
    this.editor = editor;
    this.view = view;
    this.popover = document.createElement("div");
    this.popover.className = "sd-editor-popover";
    document.body.appendChild(this.popover);
    this.tippyInstance = tippy(this.popover, {
      trigger: "manual",
      placement: "bottom-start",
      interactive: true,
      appendTo: document.body,
      arrow: false,
      onShow: (instance) => {
        instance.setProps({ getReferenceClientRect: () => this.popoverRect });
        this.bindKeyDownEvents();
      },
      onHide: () => {
        this.unbindKeyDownEvents();
      },
      theme: "sd-editor-popover"
    });
  }
  bindKeyDownEvents() {
    this.view.dom.addEventListener("keydown", this.handleKeyDown);
  }
  unbindKeyDownEvents() {
    this.view.dom.removeEventListener("keydown", this.handleKeyDown);
  }
  mountVueComponent(component, props = {}) {
    if (this.app) this.app.unmount();
    this.app = createApp(component, props);
    this.app.mount(this.popover);
    this.tippyInstance.setContent(this.popover);
  }
  update(view) {
    this.state = view.state;
    const showPopover = this.isShowMentions;
    let popoverContent = { component: null, props: null };
    if (this.isShowMentions) {
      const { from: from2 } = this.state.selection;
      const atMention = this.getMentionText(from2);
      popoverContent = {
        component: Mentions,
        props: {
          users: this.editor.users,
          mention: atMention,
          inserMention: (user) => {
            const { $from } = this.state.selection;
            const length2 = atMention.length;
            const attributes = { ...user };
            const mentionNode = this.editor.schema.nodes.mention.create(attributes);
            const tr = this.state.tr.replaceWith($from.pos - length2, $from.pos, mentionNode);
            this.editor.view.dispatch(tr);
            this.editor.view.focus();
          }
        }
      };
    }
    if (showPopover && popoverContent.component) {
      const { to } = this.state.selection;
      const { component, props } = popoverContent;
      this.mountVueComponent(component, props);
      this.showPopoverAtPosition(to);
    } else this.tippyInstance.hide();
  }
  showPopoverAtPosition(pos) {
    const end2 = this.view.coordsAtPos(pos);
    this.popoverRect = {
      width: 0,
      height: 0,
      top: end2.bottom,
      left: end2.left,
      bottom: end2.bottom,
      right: end2.left
    };
    this.tippyInstance.show();
  }
  getMentionText(from2) {
    const maxLookBehind = 20;
    const startPos = Math.max(0, from2 - maxLookBehind);
    const textBefore = this.state.doc.textBetween(startPos, from2, "\n", "\0");
    const atIndex = textBefore.lastIndexOf("@");
    if (atIndex !== -1) return textBefore.substring(atIndex);
    return "";
  }
  get isShowMentions() {
    const { from: from2 } = this.state.selection;
    if (from2 < 1) return false;
    const textBefore = this.getMentionText(from2);
    const mentionPattern = /(?:^|\s)@[\w]*$/;
    const match = textBefore.match(mentionPattern);
    return match && this.state.selection.empty;
  }
  destroy() {
    this.tippyInstance.destroy();
    this.popover.remove();
  }
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v) => ({
  x: v,
  y: v
});
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference: reference2,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
  const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
  const commonAlign = reference2[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference2.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case "right":
      coords = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference2.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference2.x,
        y: reference2.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference2, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference: reference2,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference: reference2,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference: reference2,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e) {
      return false;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
const containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit2 = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit2 && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit2 && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode2 = getParentNode(node);
  if (isLastTraversableNode(parentNode2)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode2) && isOverflowElement(parentNode2)) {
    return parentNode2;
  }
  return getNearestOverflowAncestor(parentNode2);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect2 = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect2.left + visualOffsets.x) / scale.x;
  let y = (clientRect2.top + visualOffsets.y) / scale.y;
  let width = clientRect2.width / scale.x;
  let height = clientRect2.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left2;
      y += top2;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
const SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc2 = html.ownerDocument;
    const body = doc2.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc2.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect2 = getBoundingClientRect(element, true, strategy === "fixed");
  const top2 = clientRect2.top + element.clientTop;
  const left2 = clientRect2.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left2 * scale.x;
  const y = top2 * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode2 = getParentNode(element);
  if (parentNode2 === stopNode || !isElement(parentNode2) || isLastTraversableNode(parentNode2)) {
    return false;
  }
  return getComputedStyle$1(parentNode2).position === "fixed" || hasFixedPositionAncestor(parentNode2, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult2 = cache.get(element);
  if (cachedResult2) {
    return cachedResult2;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a, b) {
  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left: left2,
      top: top2,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top2);
    const insetRight = floor(root.clientWidth - (left2 + width));
    const insetBottom = floor(root.clientHeight - (top2 + height));
    const insetLeft = floor(left2);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference2, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference2);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference2) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference2);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const hide = hide$1;
const computePosition = (reference2, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference2, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
const SEPARATOR_CLASS = "pagination-separator";
const SEPARATOR_FLOATING_CLASS = "pagination-separator-floating";
const isDebugging = false;
const cleanupFunctions = /* @__PURE__ */ new Set();
const Pagination = Extension.create({
  name: "pagination",
  priority: 500,
  addStorage() {
    return {
      height: 0,
      sectionData: null,
      headerFooterEditors: /* @__PURE__ */ new Map()
    };
  },
  addCommands() {
    return {
      insertPageBreak: () => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: "hardBreak"
        });
      },
      /**
       * Toggle pagination on/off
       * @returns {void}
       */
      togglePagination: () => ({ tr, state, dispatch, editor }) => {
        const isEnabled = PaginationPluginKey.getState(state)?.isEnabled;
        tr.setMeta(PaginationPluginKey, { isEnabled: !isEnabled });
        if (dispatch) {
          dispatch(tr);
          editor.initDefaultStyles(editor.element, !isEnabled);
          return true;
        }
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.insertPageBreak()
    };
  },
  /**
   * The pagination plugin is responsible for calculating page breaks, and redering them using decorations.
   */
  addPmPlugins() {
    const editor = this.editor;
    let isUpdating = false;
    let shouldUpdate = false;
    let hasInitialized = false;
    let shouldInitialize = false;
    const paginationPlugin = new Plugin({
      key: PaginationPluginKey,
      state: {
        isReadyToInit: false,
        init() {
          return {
            isReadyToInit: false,
            decorations: DecorationSet.empty,
            isDebugging,
            isEnabled: editor.options.pagination
          };
        },
        apply(tr, oldState, prevEditorState, newEditorState) {
          const meta = tr.getMeta(PaginationPluginKey);
          if (meta && "isEnabled" in meta) {
            const newEnabled = meta.isEnabled;
            if (newEnabled) shouldUpdate = true;
            return {
              ...oldState,
              decorations: newEnabled ? oldState.decorations : DecorationSet.empty,
              isEnabled: newEnabled
            };
          }
          if (meta && meta.isReadyToInit) {
            shouldUpdate = true;
            shouldInitialize = meta.isReadyToInit;
          }
          const syncMeta = tr.getMeta("y-sync$");
          const listSyncMeta = tr.getMeta("orderedListSync");
          if (syncMeta && syncMeta.isChangeOrigin || listSyncMeta) {
            return { ...oldState };
          }
          const imagePluginTransaction = tr.getMeta(ImagePlaceholderPluginKey);
          if (imagePluginTransaction) {
            if (imagePluginTransaction.type === "remove") {
              onImageLoad(editor);
            }
            return { ...oldState };
          }
          const isAnnotationUpdate = tr.getMeta("fieldAnnotationUpdate");
          if (isAnnotationUpdate) {
            return { ...oldState };
          }
          if (!shouldInitialize && !oldState.isReadyToInit) {
            return { ...oldState };
          }
          if (meta && meta.decorations) {
            shouldUpdate = true;
            return {
              ...oldState,
              decorations: meta.decorations.map(tr.mapping, tr.doc)
            };
          }
          const isForceUpdate = tr.getMeta("forceUpdatePagination");
          if (!isForceUpdate && prevEditorState.doc.eq(newEditorState.doc) && hasInitialized) {
            shouldUpdate = false;
            return { ...oldState };
          }
          shouldUpdate = true;
          if (isForceUpdate) shouldUpdate = true;
          return {
            ...oldState,
            decorations: meta?.decorations?.map(tr.mapping, tr.doc) || DecorationSet.empty,
            isReadyToInit: shouldInitialize
          };
        }
      },
      /* The view method is the most important part of the plugin */
      view: () => {
        let previousDecorations = DecorationSet.empty;
        return {
          update: (view) => {
            if (!PaginationPluginKey.getState(view.state)?.isEnabled) return;
            if (!shouldUpdate || isUpdating) return;
            isUpdating = true;
            hasInitialized = true;
            performUpdate(editor, view, previousDecorations);
            isUpdating = false;
            shouldUpdate = false;
          }
        };
      },
      props: {
        decorations(state) {
          const pluginState = PaginationPluginKey.getState(state);
          return pluginState.isEnabled ? pluginState.decorations : DecorationSet.empty;
        }
      }
    });
    return [paginationPlugin];
  },
  onDestroy() {
    cleanupFloatingSeparators();
    const { headerFooterEditors } = this.editor.storage.pagination;
    if (headerFooterEditors) {
      headerFooterEditors.clear();
    }
  }
});
const getHeaderFooterId = (currentPageNumber, sectionType, editor, node = null) => {
  const { alternateHeaders } = editor.converter.pageStyles;
  const sectionIds = editor.converter[sectionType];
  if (node && node.attrs?.paragraphProperties?.sectPr) {
    const sectPr = node.attrs?.paragraphProperties?.sectPr;
    if (currentPageNumber === 1) {
      if (sectionType === "headerIds") {
        const sectionData = sectPr?.elements?.find(
          (el) => el.name === "w:headerReference" && el.attributes?.["w:type"] === "first"
        );
        const newId = sectionData?.attributes?.["r:id"];
        return newId;
      } else if (sectionType === "footerIds") {
        const sectionData = sectPr?.elements?.find(
          (el) => el.name === "w:footerReference" && el.attributes?.["w:type"] === "first"
        );
        const newId = sectionData?.attributes?.["r:id"];
        return newId;
      }
    }
  }
  if (sectionIds?.titlePg && !sectionIds.first && currentPageNumber === 1) return null;
  const even = sectionIds.even;
  const odd = sectionIds.odd;
  const first2 = sectionIds.first;
  const defaultHeader = sectionIds.default;
  if (sectionIds?.titlePg && first2 && currentPageNumber === 1) return first2;
  let sectionId = sectionIds.default;
  if (currentPageNumber === 1) sectionId = defaultHeader;
  if (alternateHeaders) {
    if (currentPageNumber === 1) sectionId = first2;
    if (currentPageNumber % 2 === 0) sectionId = even || defaultHeader;
    else sectionId = odd || defaultHeader;
  }
  return sectionId;
};
const performUpdate = (editor, view, previousDecorations) => {
  const sectionData = editor.storage.pagination.sectionData;
  const newDecorations = calculatePageBreaks(view, editor, sectionData);
  const editorElement = editor.options.element;
  if (!previousDecorations.eq(newDecorations)) {
    const updateTransaction = view.state.tr.setMeta(PaginationPluginKey, { decorations: newDecorations });
    view.dispatch(updateTransaction);
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        cleanupFloatingSeparators();
        const separators = [...editorElement.querySelectorAll(`.${SEPARATOR_CLASS}--table`)];
        separators.forEach((separator) => {
          const { cleanup } = createFloatingSeparator(separator, editor);
          cleanupFunctions.add(cleanup);
        });
      });
    });
  }
  editor.emit("paginationUpdate");
};
const calculatePageBreaks = (view, editor, sectionData) => {
  if (!editor.converter) return DecorationSet.empty;
  const pageSize = editor.converter.pageStyles?.pageSize;
  if (!pageSize) return DecorationSet.empty;
  const { width, height } = pageSize;
  if (!width || !height) return DecorationSet.empty;
  const ignorePlugins = [CollaborationPluginKey, PaginationPluginKey];
  const { state } = view;
  const cleanState = EditorState.create({
    schema: state.schema,
    doc: state.doc,
    plugins: state.plugins.filter((plugin) => ignorePlugins.includes(plugin.key))
  });
  const tempContainer = editor.options.element.cloneNode();
  if (!tempContainer) return [];
  tempContainer.className = "temp-container super-editor";
  const HIDDEN_EDITOR_OFFSET_TOP = 0;
  const HIDDEN_EDITOR_OFFSET_LEFT = 0;
  tempContainer.style.left = HIDDEN_EDITOR_OFFSET_TOP + "px";
  tempContainer.style.top = HIDDEN_EDITOR_OFFSET_LEFT + "px";
  tempContainer.style.position = "fixed";
  tempContainer.style.visibility = "hidden";
  document.body.appendChild(tempContainer);
  const tempView = new EditorView(tempContainer, {
    state: cleanState,
    dispatchTransaction: () => {
    }
  });
  editor.initDefaultStyles(tempContainer);
  const decorations = generateInternalPageBreaks(cleanState.doc, tempView, editor, sectionData);
  tempView.destroy();
  document.body.removeChild(tempContainer);
  return DecorationSet.create(view.state.doc, decorations);
};
function generateInternalPageBreaks(doc2, view, editor, sectionData) {
  const decorations = [];
  const { pageSize, pageMargins } = editor.converter.pageStyles;
  const pageHeight = pageSize.height * 96;
  let currentPageNumber = 1;
  let pageHeightThreshold = pageHeight;
  let footer = null, header = null;
  const firstHeaderId = getHeaderFooterId(currentPageNumber, "headerIds", editor);
  const isFirstHeader = true;
  const firstHeader = createHeader(
    pageMargins,
    pageSize,
    sectionData,
    firstHeaderId,
    editor,
    currentPageNumber,
    isFirstHeader
  );
  const pageBreak = createPageBreak({ editor, header: firstHeader, isFirstHeader: true });
  decorations.push(Decoration.widget(0, pageBreak, { key: "stable-key" }));
  const lastFooterId = getHeaderFooterId(currentPageNumber, "footerIds", editor);
  const isLastFooter = true;
  const lastFooter = createFooter(
    pageMargins,
    pageSize,
    sectionData,
    lastFooterId,
    editor,
    currentPageNumber,
    isLastFooter
  );
  pageHeightThreshold -= firstHeader.headerHeight + lastFooter.footerHeight;
  let coords = view?.coordsAtPos(doc2.content.size);
  if (!coords) return [];
  doc2.descendants((node, pos) => {
    let currentNode = node;
    let currentPos = pos;
    coords = view?.coordsAtPos(currentPos);
    if (!coords) return;
    let isHardBreakNode = currentNode.type.name === "hardBreak";
    let isListItemNode = currentNode.type.name === "listItem";
    const endPos = currentPos + currentNode.nodeSize;
    const endCoords = view.coordsAtPos(endPos);
    let shouldAddPageBreak = currentNode.isBlock && isListItemNode ? endCoords && endCoords.bottom > pageHeightThreshold : coords.bottom > pageHeightThreshold;
    const paragraphSectPrBreak = currentNode.attrs?.pageBreakSource;
    if (paragraphSectPrBreak === "sectPr") {
      const nextNode = doc2.nodeAt(currentPos + currentNode.nodeSize);
      const nextNodeSectPr = nextNode?.attrs?.pageBreakSource === "sectPr";
      if (!nextNodeSectPr) isHardBreakNode = true;
      if (currentPageNumber === 1) {
        const headerId2 = getHeaderFooterId(currentPageNumber, "headerIds", editor, currentNode);
        decorations.pop();
        const isFirstHeader2 = true;
        const newFirstHeader = createHeader(
          pageMargins,
          pageSize,
          sectionData,
          headerId2,
          editor,
          currentPageNumber,
          isFirstHeader2
        );
        const pageBreak2 = createPageBreak({ editor, header: newFirstHeader, isFirstHeader: true });
        decorations.push(Decoration.widget(0, pageBreak2, { key: "stable-key" }));
      }
    }
    if (currentNode.type.name === "paragraph" && currentNode.attrs.styleId) {
      const linkedStyles = LinkedStylesPluginKey.getState(editor.state)?.styles;
      const style = linkedStyles?.find((style2) => style2.id === currentNode.attrs.styleId);
      if (style) {
        const { definition = {} } = style;
        const { pageBreakBefore, pageBreakAfter } = definition.attrs || {};
        if (pageBreakBefore || pageBreakAfter) shouldAddPageBreak = true;
      }
    }
    if (isHardBreakNode || shouldAddPageBreak) {
      const $currentPos = view.state.doc.resolve(currentPos);
      const table = findParentNodeClosestToPos($currentPos, (node2) => node2.type.name === "table");
      const tableRow = findParentNodeClosestToPos($currentPos, (node2) => node2.type.name === "tableRow");
      let isInTable2 = table || tableRow ? true : false;
      let {
        top: actualBreakTop,
        bottom: actualBreakBottom,
        pos: breakPos
      } = getActualBreakCoords(view, currentPos, pageHeightThreshold);
      const $breakPos = view.state.doc.resolve(breakPos);
      if ($breakPos.parent.type.name === "listItem") {
        breakPos = $breakPos.before($breakPos.depth);
      }
      const footerId2 = getHeaderFooterId(currentPageNumber, "footerIds", editor, currentNode);
      currentPageNumber++;
      const headerId2 = getHeaderFooterId(currentPageNumber, "headerIds", editor);
      header = createHeader(pageMargins, pageSize, sectionData, headerId2, editor, currentPageNumber - 1);
      footer = createFooter(pageMargins, pageSize, sectionData, footerId2, editor, currentPageNumber - 1);
      const bufferHeight2 = pageHeightThreshold - actualBreakBottom;
      const { node: spacingNode2 } = createFinalPagePadding(bufferHeight2);
      const pageSpacer2 = Decoration.widget(breakPos, spacingNode2, { key: "stable-key" });
      decorations.push(pageSpacer2);
      const pageBreak2 = createPageBreak({ editor, header, footer, isInTable: isInTable2 });
      decorations.push(Decoration.widget(breakPos, pageBreak2, { key: "stable-key" }));
      pageHeightThreshold = actualBreakBottom + (pageHeight - header.headerHeight - footer.footerHeight);
    }
  });
  let finalPos = doc2.content.size;
  const lastNodeCoords = view.coordsAtPos(finalPos);
  const headerId = getHeaderFooterId(currentPageNumber, "headerIds", editor);
  const footerId = getHeaderFooterId(currentPageNumber, "footerIds", editor);
  header = createHeader(pageMargins, pageSize, sectionData, headerId, editor, currentPageNumber);
  footer = createFooter(pageMargins, pageSize, sectionData, footerId, editor, currentPageNumber);
  const bufferHeight = pageHeightThreshold - lastNodeCoords.bottom;
  const { node: spacingNode } = createFinalPagePadding(bufferHeight);
  const pageSpacer = Decoration.widget(doc2.content.size, spacingNode, { key: "stable-key" });
  decorations.push(pageSpacer);
  const footerBreak = createPageBreak({ editor, footer, isLastFooter: true });
  decorations.push(Decoration.widget(doc2.content.size, footerBreak, { key: "stable-key" }));
  decorations.forEach((decoration) => {
    const sectionContainer = decoration.type.toDOM;
    const totalPageNumber = sectionContainer?.querySelector('span[data-id="auto-total-pages"]');
    if (totalPageNumber) {
      const fontSize = totalPageNumber.previousElementSibling?.style?.fontSize || totalPageNumber.nextElementSibling?.style?.fontSize;
      if (fontSize) totalPageNumber.style.fontSize = fontSize;
      totalPageNumber.innerText = currentPageNumber;
    }
  });
  editor.currentTotalPages = currentPageNumber;
  return decorations;
}
function createFinalPagePadding(bufferHeight) {
  const div2 = document.createElement("div");
  div2.className = "pagination-page-spacer";
  div2.style.userSelect = "none";
  div2.style.pointerEvents = "none";
  div2.style.height = bufferHeight + "px";
  return { nodeHeight: bufferHeight, node: div2 };
}
function createHeader(pageMargins, pageSize, sectionData, headerId, editor, currentPageNumber, isFirstHeader = false) {
  const headerDef = sectionData?.headers?.[headerId];
  const minHeaderHeight = pageMargins.top * 96;
  const headerMargin = pageMargins.header * 96;
  const hasHeaderOffset = headerDef?.height > minHeaderHeight - headerMargin;
  const headerOffset = hasHeaderOffset ? headerMargin : 0;
  const headerHeight = Math.max(headerDef?.height || 0, minHeaderHeight) + headerOffset;
  const availableHeight = headerHeight - headerMargin;
  let editorContainer = document.createElement("div");
  if (!headerId && !editor?.converter?.headerIds?.["default"]) {
    headerId = "rId" + generateDocxRandomId();
    editor.converter.headerIds["default"] = headerId;
  }
  if (!editor.converter.headers[headerId]) {
    editor.converter.headers[headerId] = {
      type: "doc",
      content: [{ type: "paragraph", content: [] }]
    };
  }
  const data = editor.converter.headers[headerId];
  const pageNumberIndex = currentPageNumber - 1;
  const editorKey = getHeaderFooterEditorKey({ pageNumber: pageNumberIndex, isHeader: true, isFirstHeader });
  let editorSection = null;
  const { headerFooterEditors } = editor.storage.pagination;
  if (headerFooterEditors.has(editorKey) && editor.converter.headerEditors[pageNumberIndex]) {
    const editorData = headerFooterEditors.get(editorKey);
    editorSection = editorData.editor;
    editorContainer = editorSection.element;
  } else {
    editorSection = createHeaderFooterEditor({
      editor,
      data,
      editorContainer,
      appendToBody: false,
      sectionId: headerId,
      type: "header",
      availableHeight,
      currentPageNumber
    });
    editor.converter.headerEditors.push({ id: headerId, editor: editorSection });
    headerFooterEditors.set(editorKey, { editor: editorSection });
    broadcastEditorEvents(editor, editorSection);
  }
  editorSection.setEditable(false, false);
  editorContainer.classList.add("pagination-section-header");
  editorContainer.style.paddingTop = headerMargin + "px";
  editorContainer.style.paddingLeft = pageMargins.left * 96 + "px";
  editorContainer.style.paddingRight = pageMargins.right * 96 + "px";
  editorContainer.style.height = headerHeight + "px";
  editorContainer.style.width = pageSize.width * 96 + "px";
  editorContainer.style.position = "static";
  editorContainer.addEventListener("dblclick", () => onHeaderFooterDblClick(editor, editorSection));
  return {
    section: editorContainer,
    headerHeight
  };
}
function createFooter(pageMargins, pageSize, sectionData, footerId, editor, currentPageNumber, isLastFooter = false) {
  const footerDef = sectionData?.footers?.[footerId];
  const minFooterHeight = pageMargins.bottom * 96;
  const footerPaddingFromEdge = pageMargins.footer * 96;
  const footerHeight = Math.max(footerDef?.height || 0, minFooterHeight - footerPaddingFromEdge);
  let editorContainer = document.createElement("div");
  if (!footerId && !editor.converter.footerIds["default"]) {
    footerId = "rId" + generateDocxRandomId();
    editor.converter.footerIds["default"] = footerId;
  }
  if (!editor.converter.footers[footerId]) {
    editor.converter.footers[footerId] = {
      type: "doc",
      content: [{ type: "paragraph", content: [] }]
    };
  }
  const data = editor.converter.footers[footerId];
  const pageNumberIndex = currentPageNumber - 1;
  const editorKey = getHeaderFooterEditorKey({ pageNumber: pageNumberIndex, isFooter: true, isLastFooter });
  let editorSection = null;
  const { headerFooterEditors } = editor.storage.pagination;
  if (headerFooterEditors.has(editorKey) && editor.converter.footerEditors[pageNumberIndex]) {
    const editorData = headerFooterEditors.get(editorKey);
    editorSection = editorData.editor;
    editorContainer = editorSection.element;
  } else {
    editorSection = createHeaderFooterEditor({
      editor,
      data,
      editorContainer,
      appendToBody: false,
      sectionId: footerId,
      type: "footer",
      availableHeight: footerHeight,
      currentPageNumber
    });
    editor.converter.footerEditors.push({ id: footerId, editor: editorSection });
    headerFooterEditors.set(editorKey, { editor: editorSection });
    broadcastEditorEvents(editor, editorSection);
  }
  editorSection.setEditable(false, false);
  editorContainer.classList.add("pagination-section-footer");
  editorContainer.style.height = footerHeight + "px";
  editorContainer.style.marginBottom = footerPaddingFromEdge + "px";
  editorContainer.style.paddingLeft = pageMargins.left * 96 + "px";
  editorContainer.style.paddingRight = pageMargins.right * 96 + "px";
  editorContainer.style.width = pageSize.width * 96 + "px";
  editorContainer.style.position = "static";
  editorContainer.addEventListener("dblclick", () => onHeaderFooterDblClick(editor, editorSection));
  return {
    section: editorContainer,
    footerHeight: footerHeight + footerPaddingFromEdge
  };
}
const getHeaderFooterEditorKey = ({ pageNumber, isHeader, isFooter, isFirstHeader = false, isLastFooter = false }) => {
  if (isFirstHeader) return `first-header-${pageNumber}`;
  if (isLastFooter) return `last-footer-${pageNumber}`;
  if (isHeader) return `header-${pageNumber}`;
  if (isFooter) return `footer-${pageNumber}`;
  return void 0;
};
const onHeaderFooterDblClick = (editor, currentFocusedSectionEditor) => {
  if (editor.options.documentMode !== "editing") return;
  editor.setEditable(false, false);
  toggleHeaderFooterEditMode({
    editor,
    focusedSectionEditor: currentFocusedSectionEditor,
    isEditMode: true,
    documentMode: editor.options.documentMode
  });
};
function createPageBreak({
  editor,
  header,
  footer,
  footerBottom = null,
  isFirstHeader,
  isLastFooter,
  isInTable: isInTable2 = false
}) {
  const { pageSize, pageMargins } = editor.converter.pageStyles;
  let sectionHeight = 0;
  const paginationDiv = document.createElement("div");
  paginationDiv.className = "pagination-break-wrapper";
  const innerDiv = document.createElement("div");
  innerDiv.className = "pagination-inner";
  innerDiv.style.width = pageSize.width * 96 - 1 + "px";
  if (isFirstHeader) innerDiv.style.borderRadius = "8px 8px 0 0";
  else if (isLastFooter) innerDiv.style.borderRadius = "0 0 8px 8px";
  paginationDiv.appendChild(innerDiv);
  if (footer) {
    innerDiv.appendChild(footer.section);
    sectionHeight += footer.footerHeight;
  }
  if (header && footer) {
    const separatorHeight = 20;
    sectionHeight += separatorHeight;
    const separator = document.createElement("div");
    separator.classList.add(SEPARATOR_CLASS);
    if (isInTable2) {
      separator.classList.add(`${SEPARATOR_CLASS}--table`);
    }
    innerDiv.appendChild(separator);
  }
  if (header) {
    innerDiv.appendChild(header.section);
    sectionHeight += header.headerHeight;
  }
  paginationDiv.style.height = sectionHeight + "px";
  paginationDiv.style.minHeight = sectionHeight + "px";
  paginationDiv.style.maxHeight = sectionHeight + "px";
  innerDiv.style.height = sectionHeight + "px";
  paginationDiv.style.width = "100px";
  paginationDiv.style.marginLeft = pageMargins.left * -96 + "px";
  if (footerBottom !== null) {
    paginationDiv.style.position = "absolute";
    paginationDiv.style.bottom = footerBottom + "px";
  }
  return paginationDiv;
}
function getActualBreakCoords(view, pos, calculatedThreshold) {
  let currentPos = pos - 1;
  const actualBreak = { top: 0, bottom: 0, pos: 0 };
  while (currentPos > 0) {
    const { top: top2, bottom: bottom2 } = view.coordsAtPos(currentPos);
    if (bottom2 < calculatedThreshold) {
      Object.assign(actualBreak, { top: top2, bottom: bottom2, pos: currentPos + 1 });
      break;
    }
    currentPos--;
  }
  return actualBreak;
}
const onImageLoad = (editor) => {
  requestAnimationFrame(() => {
    const newTr = editor.view.state.tr;
    newTr.setMeta("forceUpdatePagination", true);
    editor.view.dispatch(newTr);
  });
};
function createFloatingSeparator(separator, editor) {
  const floatingSeparator = document.createElement("div");
  floatingSeparator.classList.add(SEPARATOR_FLOATING_CLASS);
  floatingSeparator.dataset.floatingSeparator = "";
  const editorElement = editor.options.element;
  editorElement.append(floatingSeparator);
  const updatePosition2 = () => {
    computePosition(separator, floatingSeparator, {
      strategy: "absolute",
      placement: "top-start",
      middleware: [
        hide(),
        {
          name: "copy",
          fn: ({ elements }) => {
            const rect = elements.reference.getBoundingClientRect();
            const containerRect = editorElement.getBoundingClientRect();
            const scaleFactor = getScaleFactor(editorElement);
            const x = Math.round((rect.left - containerRect.left) / scaleFactor);
            const y = Math.round((rect.top - containerRect.top) / scaleFactor);
            const width = Math.round(rect.width / scaleFactor);
            const height = Math.round(rect.height / scaleFactor);
            return {
              x,
              y,
              data: { width, height }
            };
          }
        }
      ]
    }).then(({ x, y, middlewareData }) => {
      Object.assign(floatingSeparator.style, {
        top: `${y}px`,
        left: `${x}px`,
        width: `${middlewareData.copy.width}px`,
        height: `${middlewareData.copy.height}px`,
        visibility: middlewareData.hide?.referenceHidden ? "hidden" : "visible"
      });
    });
  };
  const cleanup = autoUpdate(separator, floatingSeparator, updatePosition2);
  const extendedCleanup = () => {
    floatingSeparator?.remove();
    cleanup();
  };
  return {
    cleanup: extendedCleanup,
    updatePosition: updatePosition2
  };
}
function cleanupFloatingSeparators() {
  cleanupFunctions.forEach((cleanup) => cleanup());
  cleanupFunctions.clear();
}
function getScaleFactor(element) {
  let scale = 1;
  let currentElement = element;
  while (currentElement && currentElement !== document.documentElement) {
    let zoomStyle = currentElement.style.zoom;
    if (zoomStyle) {
      let zoom = parseFloat(zoomStyle) || 1;
      scale *= zoom;
    }
    let transformStyle = currentElement.style.transform;
    if (transformStyle) {
      let scaleMatch = transformStyle.match(/scale\(([^)]+)\)/);
      if (scaleMatch) {
        let scaleValue = parseFloat(scaleMatch[1]) || 1;
        scale *= scaleValue;
      }
    }
    currentElement = currentElement.parentElement;
  }
  return scale;
}
class SearchQuery {
  /**
  Create a query object.
  */
  constructor(config) {
    this.search = config.search;
    this.caseSensitive = !!config.caseSensitive;
    this.literal = !!config.literal;
    this.regexp = !!config.regexp;
    this.replace = config.replace || "";
    this.valid = !!this.search && !(this.regexp && !validRegExp(this.search));
    this.wholeWord = !!config.wholeWord;
    this.filter = config.filter || null;
    this.impl = !this.valid ? nullQuery : this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
  Find the next occurrence of this query in the given range.
  */
  findNext(state, from2 = 0, to = state.doc.content.size) {
    for (; ; ) {
      if (from2 >= to)
        return null;
      let result = this.impl.findNext(state, from2, to);
      if (!result || this.checkResult(state, result))
        return result;
      from2 = result.from + 1;
    }
  }
  /**
  Find the previous occurrence of this query in the given range.
  Note that, if `to` is given, it should be _less_ than `from`.
  */
  findPrev(state, from2 = state.doc.content.size, to = 0) {
    for (; ; ) {
      if (from2 <= to)
        return null;
      let result = this.impl.findPrev(state, from2, to);
      if (!result || this.checkResult(state, result))
        return result;
      from2 = result.to - 1;
    }
  }
  /**
  @internal
  */
  checkResult(state, result) {
    return (!this.wholeWord || checkWordBoundary(state, result.from) && checkWordBoundary(state, result.to)) && (!this.filter || this.filter(state, result));
  }
  /**
  @internal
  */
  unquote(string) {
    return this.literal ? string : string.replace(/\\([nrt\\])/g, (_, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  /**
  Get the ranges that should be replaced for this result. This can
  return multiple ranges when `this.replace` contains
  `$1`/`$&`-style placeholders, in which case the preserved
  content is skipped by the replacements.
  
  Ranges are sorted by position, and `from`/`to` positions all
  refer to positions in `state.doc`. When applying these, you'll
  want to either apply them from back to front, or map these
  positions through your transaction's current mapping.
  */
  getReplacements(state, result) {
    let $from = state.doc.resolve(result.from);
    let marks = $from.marksAcross(state.doc.resolve(result.to));
    let ranges = [];
    let frag = Fragment.empty, pos = result.from, { match } = result;
    let groups = match ? getGroupIndices(match) : [[0, result.to - result.from]];
    let replParts = parseReplacement(this.unquote(this.replace)), groupSpan;
    for (let part of replParts) {
      if (typeof part == "string") {
        frag = frag.addToEnd(state.schema.text(part, marks));
      } else if (groupSpan = groups[part.group]) {
        let from2 = result.matchStart + groupSpan[0], to = result.matchStart + groupSpan[1];
        if (part.copy) {
          frag = frag.append(state.doc.slice(from2, to).content);
        } else {
          if (frag != Fragment.empty || from2 > pos) {
            ranges.push({ from: pos, to: from2, insert: new Slice(frag, 0, 0) });
            frag = Fragment.empty;
          }
          pos = to;
        }
      }
    }
    if (frag != Fragment.empty || pos < result.to)
      ranges.push({ from: pos, to: result.to, insert: new Slice(frag, 0, 0) });
    return ranges;
  }
}
const nullQuery = new class {
  findNext() {
    return null;
  }
  findPrev() {
    return null;
  }
}();
class StringQuery {
  constructor(query) {
    this.query = query;
    let string = query.unquote(query.search);
    if (!query.caseSensitive)
      string = string.toLowerCase();
    this.string = string;
  }
  findNext(state, from2, to) {
    return scanTextblocks(state.doc, from2, to, (node, start2) => {
      let off = Math.max(from2, start2);
      let content = textContent(node).slice(off - start2, Math.min(node.content.size, to - start2));
      let index2 = (this.query.caseSensitive ? content : content.toLowerCase()).indexOf(this.string);
      return index2 < 0 ? null : { from: off + index2, to: off + index2 + this.string.length, match: null, matchStart: start2 };
    });
  }
  findPrev(state, from2, to) {
    return scanTextblocks(state.doc, from2, to, (node, start2) => {
      let off = Math.max(start2, to);
      let content = textContent(node).slice(off - start2, Math.min(node.content.size, from2 - start2));
      if (!this.query.caseSensitive)
        content = content.toLowerCase();
      let index2 = content.lastIndexOf(this.string);
      return index2 < 0 ? null : { from: off + index2, to: off + index2 + this.string.length, match: null, matchStart: start2 };
    });
  }
}
const baseFlags = "g" + (/x/.unicode == null ? "" : "u") + (/x/.hasIndices == null ? "" : "d");
class RegExpQuery {
  constructor(query) {
    this.query = query;
    this.regexp = new RegExp(query.search, baseFlags + (query.caseSensitive ? "" : "i"));
  }
  findNext(state, from2, to) {
    return scanTextblocks(state.doc, from2, to, (node, start2) => {
      let content = textContent(node).slice(0, Math.min(node.content.size, to - start2));
      this.regexp.lastIndex = from2 - start2;
      let match = this.regexp.exec(content);
      return match ? { from: start2 + match.index, to: start2 + match.index + match[0].length, match, matchStart: start2 } : null;
    });
  }
  findPrev(state, from2, to) {
    return scanTextblocks(state.doc, from2, to, (node, start2) => {
      let content = textContent(node).slice(0, Math.min(node.content.size, from2 - start2));
      let match;
      for (let off = 0; ; ) {
        this.regexp.lastIndex = off;
        let next = this.regexp.exec(content);
        if (!next)
          break;
        match = next;
        off = next.index + 1;
      }
      return match ? { from: start2 + match.index, to: start2 + match.index + match[0].length, match, matchStart: start2 } : null;
    });
  }
}
function getGroupIndices(match) {
  if (match.indices)
    return match.indices;
  let result = [[0, match[0].length]];
  for (let i = 1, pos = 0; i < match.length; i++) {
    let found = match[i] ? match[0].indexOf(match[i], pos) : -1;
    result.push(found < 0 ? void 0 : [found, pos = found + match[i].length]);
  }
  return result;
}
function parseReplacement(text) {
  let result = [], highestSeen = -1;
  function add(text2) {
    let last = result.length - 1;
    if (last > -1 && typeof result[last] == "string")
      result[last] += text2;
    else
      result.push(text2);
  }
  while (text.length) {
    let m = /\$([$&\d+])/.exec(text);
    if (!m) {
      add(text);
      return result;
    }
    if (m.index > 0)
      add(text.slice(0, m.index + (m[1] == "$" ? 1 : 0)));
    if (m[1] != "$") {
      let n = m[1] == "&" ? 0 : +m[1];
      if (highestSeen >= n) {
        result.push({ group: n, copy: true });
      } else {
        highestSeen = n || 1e3;
        result.push({ group: n, copy: false });
      }
    }
    text = text.slice(m.index + m[0].length);
  }
  return result;
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a) {
    return false;
  }
}
const TextContentCache = /* @__PURE__ */ new WeakMap();
function textContent(node) {
  let cached = TextContentCache.get(node);
  if (cached)
    return cached;
  let content = "";
  for (let i = 0; i < node.childCount; i++) {
    let child = node.child(i);
    if (child.isText)
      content += child.text;
    else if (child.isLeaf)
      content += "";
    else
      content += " " + textContent(child) + " ";
  }
  TextContentCache.set(node, content);
  return content;
}
function scanTextblocks(node, from2, to, f, nodeStart = 0) {
  if (node.inlineContent) {
    return f(node, nodeStart);
  } else if (!node.isLeaf) {
    if (from2 > to) {
      for (let i = node.childCount - 1, pos = nodeStart + node.content.size; i >= 0 && pos > to; i--) {
        let child = node.child(i);
        pos -= child.nodeSize;
        if (pos < from2) {
          let result = scanTextblocks(child, from2, to, f, pos + 1);
          if (result != null)
            return result;
        }
      }
    } else {
      for (let i = 0, pos = nodeStart; i < node.childCount && pos < to; i++) {
        let child = node.child(i), start2 = pos;
        pos += child.nodeSize;
        if (pos > from2) {
          let result = scanTextblocks(child, from2, to, f, start2 + 1);
          if (result != null)
            return result;
        }
      }
    }
  }
  return null;
}
function checkWordBoundary(state, pos) {
  let $pos = state.doc.resolve(pos);
  let before = $pos.nodeBefore, after = $pos.nodeAfter;
  if (!before || !after || !before.isText || !after.isText)
    return true;
  return !/\p{L}$/u.test(before.text) || !/^\p{L}/u.test(after.text);
}
class SearchState {
  constructor(query, range, deco) {
    this.query = query;
    this.range = range;
    this.deco = deco;
  }
}
function buildMatchDeco(state, query, range) {
  if (!query.valid)
    return DecorationSet.empty;
  let deco = [];
  let sel = state.selection;
  for (let pos = range ? range.from : 0, end2 = range ? range.to : state.doc.content.size; ; ) {
    let next = query.findNext(state, pos, end2);
    if (!next)
      break;
    let cls = next.from == sel.from && next.to == sel.to ? "ProseMirror-active-search-match" : "ProseMirror-search-match";
    deco.push(Decoration.inline(next.from, next.to, { class: cls }));
    pos = next.to;
  }
  return DecorationSet.create(state.doc, deco);
}
const searchKey = new PluginKey("search");
function search(options = {}) {
  return new Plugin({
    key: searchKey,
    state: {
      init(_config, state) {
        let query = options.initialQuery || new SearchQuery({ search: "" });
        let range = options.initialRange || null;
        return new SearchState(query, range, buildMatchDeco(state, query, range));
      },
      apply(tr, search2, _oldState, state) {
        let set = tr.getMeta(searchKey);
        if (set)
          return new SearchState(set.query, set.range, buildMatchDeco(state, set.query, set.range));
        if (tr.docChanged || tr.selectionSet) {
          let range = search2.range;
          if (range) {
            let from2 = tr.mapping.map(range.from, 1);
            let to = tr.mapping.map(range.to, -1);
            range = from2 < to ? { from: from2, to } : null;
          }
          search2 = new SearchState(search2.query, range, buildMatchDeco(state, search2.query, range));
        }
        return search2;
      }
    },
    props: {
      decorations: (state) => searchKey.getState(state).deco
    }
  });
}
function getMatchHighlights(state) {
  let search2 = searchKey.getState(state);
  return search2 ? search2.deco : DecorationSet.empty;
}
function setSearchState(tr, query, range = null) {
  return tr.setMeta(searchKey, { query, range });
}
const Search = Extension.create({
  addStorage() {
    return {
      searchResults: []
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    const storage = this.storage;
    const searchHighlightWithIdPlugin = new Plugin({
      key: new PluginKey("customSearchHighlights"),
      props: {
        decorations(state) {
          if (!editor) return null;
          const matches = storage?.searchResults;
          if (!matches?.length) return null;
          const decorations = matches.map(
            (match) => Decoration.inline(match.from, match.to, {
              id: `search-match-${match.id}`
            })
          );
          return DecorationSet.create(state.doc, decorations);
        }
      }
    });
    return [search(), searchHighlightWithIdPlugin];
  },
  addCommands() {
    return {
      goToFirstMatch: () => ({ state, editor }) => {
        const highlights = getMatchHighlights(state);
        if (!highlights || !highlights.children?.length) return;
        const match = highlights.children.find((item) => item.local);
        const firstSearchItemPosition = highlights.children[0] + match.local[0].from + 1;
        editor.view.domAtPos(firstSearchItemPosition)?.node?.scrollIntoView(true);
      },
      search: (patternInput) => ({ state, dispatch }) => {
        let pattern;
        let caseSensitive = false;
        let regexp = false;
        const wholeWord = false;
        if (patternInput instanceof RegExp) {
          regexp = true;
          pattern = patternInput.source;
          caseSensitive = !patternInput.flags.includes("i");
        } else if (typeof patternInput === "string" && /^\/(.+)\/([gimsuy]*)$/.test(patternInput)) {
          const [, body, flags] = patternInput.match(/^\/(.+)\/([gimsuy]*)$/);
          regexp = true;
          pattern = body;
          caseSensitive = !flags.includes("i");
        } else {
          pattern = String(patternInput);
        }
        const query = new SearchQuery({
          search: pattern,
          caseSensitive,
          regexp,
          wholeWord
        });
        const tr = setSearchState(state.tr, query);
        dispatch(tr);
        const newState = state.apply(tr);
        const decoSet = getMatchHighlights(newState);
        const matches = decoSet ? decoSet.find() : [];
        const resultMatches = matches.map((d) => ({
          from: d.from,
          to: d.to,
          text: newState.doc.textBetween(d.from, d.to),
          id: v4()
        }));
        this.storage.searchResults = resultMatches;
        return resultMatches;
      },
      goToSearchResult: (match) => ({ state, dispatch, editor }) => {
        const { from: from2, to } = match;
        editor.view.focus();
        const tr = state.tr.setSelection(TextSelection.create(state.doc, from2, to)).scrollIntoView();
        dispatch(tr);
        const { node } = editor.view.domAtPos(from2);
        if (node?.scrollIntoView) {
          node.scrollIntoView({ block: "center", inline: "nearest" });
        }
        return true;
      }
    };
  }
});
const NodeResizerKey = new PluginKey("node-resizer");
const nodeResizer = (nodeNames = ["image"], editor) => {
  let resizeState = {
    dragging: false,
    startX: 0,
    startWidth: 0,
    handle: null,
    pos: null,
    resizableElement: null,
    aspectRatio: 1
  };
  let resizeContainer = null;
  let editorView = null;
  let globalClickHandler = null;
  let globalMousedownHandler = null;
  let scrollHandler = null;
  let currentWrapper = null;
  return new Plugin({
    key: NodeResizerKey,
    state: {
      init() {
        return DecorationSet.empty;
      },
      apply(tr, oldState, _, newState) {
        if (tr.getMeta(NodeResizerKey)) {
          return oldState;
        }
        if (typeof document === "undefined" || editor.options.isHeadless) return oldState;
        const { selection } = newState;
        const node = selection.node;
        if (!node || !nodeNames.includes(node.type.name)) {
          return DecorationSet.empty;
        }
        const decorations = [];
        if (nodeNames.includes(selection.node?.type.name)) {
          decorations.push(
            Decoration.node(selection.from, selection.to, {
              nodeName: "span",
              class: "sd-editor-resizable-wrapper",
              "data-pos": selection.from
            })
          );
        }
        return DecorationSet.create(newState.doc, decorations);
      }
    },
    props: {
      decorations(state) {
        return this.getState(state);
      }
    },
    view(view) {
      editorView = view;
      globalClickHandler = (event) => {
        if (!event.target.closest(".sd-editor-resizable-wrapper") && !event.target.closest(".sd-editor-resize-container")) {
          hideResizeHandles();
        }
      };
      document.addEventListener("click", globalClickHandler);
      globalMousedownHandler = (event) => {
        if (event.target.closest(".sd-editor-resize-handle")) {
          event.preventDefault();
          event.stopPropagation();
          startResize(editorView, event, event.target);
          return true;
        }
      };
      document.addEventListener("mousedown", globalMousedownHandler);
      scrollHandler = () => {
        if (currentWrapper && resizeContainer) {
          updateHandlePositions(currentWrapper.firstElementChild);
        }
      };
      window.addEventListener("scroll", scrollHandler, true);
      return {
        update(view2, prevState) {
          const { selection } = view2.state;
          const prevSelection = prevState.selection;
          if (selection.from !== prevSelection.from || selection.to !== prevSelection.to) {
            setTimeout(() => {
              const selectedResizableWrapper = document.querySelector(".sd-editor-resizable-wrapper");
              if (selectedResizableWrapper) {
                showResizeHandles(view2, selectedResizableWrapper);
              } else {
                hideResizeHandles();
              }
            }, 10);
          }
        },
        destroy() {
          hideResizeHandles();
          cleanupEventListeners();
          if (globalClickHandler) {
            document.removeEventListener("click", globalClickHandler);
            globalClickHandler = null;
          }
          if (globalMousedownHandler) {
            document.removeEventListener("mousedown", globalMousedownHandler);
            globalMousedownHandler = null;
          }
          if (scrollHandler) {
            window.removeEventListener("scroll", scrollHandler, true);
            scrollHandler = null;
          }
          editorView = null;
        }
      };
    }
  });
  function showResizeHandles(view, wrapper) {
    hideResizeHandles();
    const pos = Number.parseInt(wrapper.getAttribute("data-pos"), 10);
    const node = view.state.doc.nodeAt(pos);
    if (!nodeNames.includes(node?.type.name)) return;
    currentWrapper = wrapper;
    resizeContainer = document.createElement("div");
    resizeContainer.className = "sd-editor-resize-container";
    resizeContainer.style.position = "absolute";
    resizeContainer.style.pointerEvents = "none";
    resizeContainer.style.zIndex = "1000";
    const handles = ["nw", "ne", "sw", "se"];
    for (const handle of handles) {
      const handleEl = document.createElement("div");
      handleEl.className = `sd-editor-resize-handle sd-editor-resize-handle-${handle}`;
      handleEl.setAttribute("data-handle", handle);
      handleEl.setAttribute("data-pos", pos);
      handleEl.style.pointerEvents = "auto";
      resizeContainer.appendChild(handleEl);
    }
    document.body.appendChild(resizeContainer);
    updateHandlePositions(wrapper.firstElementChild);
  }
  function hideResizeHandles() {
    if (resizeContainer?.parentNode) {
      resizeContainer.parentNode.removeChild(resizeContainer);
      resizeContainer = null;
    }
    currentWrapper = null;
  }
  function updateHandlePositions(resizableElement) {
    if (!resizeContainer || !resizableElement) return;
    const rect = resizableElement.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    resizeContainer.style.left = `${rect.left + scrollLeft}px`;
    resizeContainer.style.top = `${rect.top + scrollTop}px`;
    resizeContainer.style.width = `${rect.width}px`;
    resizeContainer.style.height = `${rect.height}px`;
  }
  function startResize(view, event, handleElement) {
    if (!view.hasFocus()) return;
    const handle = handleElement.getAttribute("data-handle");
    const pos = Number.parseInt(handleElement.getAttribute("data-pos"), 10);
    if (view.state.selection.from !== pos || !nodeNames.includes(view.state.selection.node?.type.name)) return;
    const resizableElement = view.nodeDOM(pos);
    if (!resizableElement) return;
    const rect = resizableElement.getBoundingClientRect();
    resizeState = {
      dragging: true,
      startX: event.clientX,
      startY: event.clientY,
      startWidth: rect.width,
      startHeight: rect.height,
      handle,
      pos,
      resizableElement,
      aspectRatio: rect.width / rect.height
    };
    document.addEventListener("mousemove", handleMouseMove2);
    document.addEventListener("mouseup", handleMouseUp);
    document.body.style.cursor = getResizeCursor(handle);
    document.body.style.userSelect = "none";
  }
  function handleMouseMove2(event) {
    if (!resizeState.dragging) return;
    event.preventDefault();
    event.stopPropagation();
    let deltaX = event.clientX - resizeState.startX;
    if (resizeState.handle.includes("w")) deltaX = -deltaX;
    const newWidth = Math.max(20, resizeState.startWidth + deltaX);
    if (resizeState.resizableElement) {
      resizeState.resizableElement.style.width = `${newWidth}px`;
      resizeState.resizableElement.style.height = "auto";
      updateHandlePositions(resizeState.resizableElement);
    }
  }
  function handleMouseUp(event) {
    if (!resizeState.dragging) return;
    cleanupEventListeners();
    let deltaX = event.clientX - resizeState.startX;
    if (resizeState.handle.includes("w")) deltaX = -deltaX;
    const newWidth = Math.max(20, resizeState.startWidth + deltaX);
    const newHeight = newWidth / resizeState.aspectRatio;
    if (editorView && resizeState.pos < editorView.state.doc.content.size) {
      const tr = editorView.state.tr;
      const node = tr.doc.nodeAt(resizeState.pos);
      if (nodeNames.includes(node?.type.name)) {
        const attrs = {
          ...node.attrs,
          size: {
            ...node.attrs.size,
            width: Math.round(newWidth),
            height: Math.round(newHeight)
          }
        };
        tr.setNodeMarkup(resizeState.pos, null, attrs);
        tr.setMeta(NodeResizerKey, { action: "resize" });
        editorView.dispatch(tr);
      }
    }
    resizeState = {
      dragging: false,
      startX: 0,
      startY: 0,
      startWidth: 0,
      startHeight: 0,
      handle: null,
      pos: null,
      resizableElement: null,
      aspectRatio: 1
    };
  }
  function cleanupEventListeners() {
    document.removeEventListener("mousemove", handleMouseMove2);
    document.removeEventListener("mouseup", handleMouseUp);
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  }
  function getResizeCursor(handle) {
    switch (handle) {
      case "nw":
      case "se":
        return "nwse-resize";
      case "ne":
      case "sw":
        return "nesw-resize";
      default:
        return "default";
    }
  }
};
const NodeResizer = Extension.create({
  name: "nodeResizer",
  addPmPlugins() {
    const isHeadless = this.editor.options.isHeadless;
    const hasDocument = typeof document !== "undefined";
    if (isHeadless || !hasDocument) return [];
    return [nodeResizer(["image"], this.editor)];
  }
});
const getRichTextExtensions = () => {
  return [
    Bold,
    BulletList,
    Color,
    Document,
    FontFamily,
    FontSize,
    History,
    Heading,
    Italic,
    ListItem,
    LineHeight,
    Link,
    OrderedList,
    Paragraph,
    Strike,
    Text,
    TextAlign,
    TextIndent,
    TextStyle,
    Underline,
    Placeholder,
    PopoverPlugin,
    Mention,
    Highlight,
    FormatCommands,
    Table,
    TableRow,
    TableCell,
    TableHeader,
    FieldAnnotation,
    DropCursor,
    TrackInsert,
    TrackDelete,
    TrackFormat,
    AiPlugin,
    Image,
    NodeResizer,
    CustomSelection
  ];
};
const getStarterExtensions = () => {
  return [
    Bold,
    BlockNode,
    BulletList,
    Color,
    CommentRangeStart,
    CommentRangeEnd,
    CommentReference,
    Document,
    FontFamily,
    FontSize,
    History,
    Heading,
    Italic,
    ListItem,
    LineHeight,
    Link,
    OrderedList,
    Paragraph,
    LineBreak,
    HardBreak,
    RunItem,
    SlashMenu,
    Strike,
    TabNode,
    Text,
    TextAlign,
    TextIndent,
    TextStyle,
    Underline,
    FormatCommands,
    CommentsPlugin,
    Gapcursor,
    Table,
    TableRow,
    TableCell,
    TableHeader,
    FieldAnnotation,
    DropCursor,
    Image,
    BookmarkStart,
    Mention,
    Collaboration,
    CollaborationCursor,
    TrackChanges,
    TrackInsert,
    TrackDelete,
    TrackFormat,
    CommentsMark,
    Pagination,
    Highlight,
    LinkedStyles,
    AiPlugin,
    AiMark,
    AiAnimationMark,
    AiLoaderNode,
    PageNumber,
    TotalPageCount,
    ShapeContainer,
    ShapeTextbox,
    ContentBlock,
    Search,
    StructuredContent,
    StructuredContentBlock,
    DocumentSection,
    NodeResizer,
    CustomSelection,
    TextTransform
  ];
};
export {
  Attribute as A,
  CommentsPluginKey as C,
  Editor as E,
  Mark as M,
  Node$1 as N,
  Placeholder as P,
  SlashMenuPluginKey as S,
  TrackChangesBasePluginKey as T,
  _export_sfc as _,
  getQuickFormatList as a,
  generateLinkedStyleString as b,
  getFileOpener as c,
  undoDepth as d,
  getStarterExtensions as e,
  getRichTextExtensions as f,
  global as g,
  Extension as h,
  index$1 as i,
  index as j,
  AnnotatorHelpers as k,
  SectionHelpers as l,
  getAllowedImageDimensions as m,
  redoDepth as r,
  startImageUpload as s,
  useHighContrastMode as u,
  yUndoPluginKey as y
};
