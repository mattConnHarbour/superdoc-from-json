"use strict";
const vue = require("./vue-CenuKwdP.cjs");
const Y = require("yjs");
function _interopNamespaceDefault(e) {
  const n = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
  if (e) {
    for (const k in e) {
      if (k !== "default") {
        const d2 = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d2.get ? d2 : {
          enumerable: true,
          get: () => e[k]
        });
      }
    }
  }
  n.default = e;
  return Object.freeze(n);
}
const Y__namespace = /* @__PURE__ */ _interopNamespaceDefault(Y);
var __defProp$2 = Object.defineProperty;
var __typeError$2 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$2 = (obj, key, value) => __defNormalProp$2(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck$2 = (obj, member, msg2) => member.has(obj) || __typeError$2("Cannot " + msg2);
var __privateAdd$2 = (obj, member, value) => member.has(obj) ? __typeError$2("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod$2 = (obj, member, method) => (__accessCheck$2(obj, member, "access private method"), method);
var _a, _DocxExporter_instances, generate_xml_as_list_fn, replaceSpecialCharacters_fn, generateXml_fn, _SuperConverter_instances, exportNumberingFile_fn, prepareCommentsXmlFilesForExport_fn, exportProcessHeadersFooters_fn, exportProcessNewRelationships_fn, exportProcessMediaFiles_fn;
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof vue.global !== "undefined" ? vue.global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs$1(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$1 = 0, len = code$1.length; i$1 < len; ++i$1) {
  lookup[i$1] = code$1[i$1];
  revLookup[code$1.charCodeAt(i$1)] = i$1;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;
  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start2, end2) {
  var tmp;
  var output = [];
  for (var i = start2; i < end2; i += 3) {
    tmp = (uint8[i] << 16 & 16711680) + (uint8[i + 1] << 8 & 65280) + (uint8[i + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset2, isLE, mLen, nBytes) {
  var e, m2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d2 = isLE ? -1 : 1;
  var s = buffer2[offset2 + i];
  i += d2;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer2[offset2 + i], i += d2, nBits -= 8) {
  }
  m2 = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m2 = m2 * 256 + buffer2[offset2 + i], i += d2, nBits -= 8) {
  }
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m2 ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m2 = m2 + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
};
ieee754.write = function(buffer2, value, offset2, isLE, mLen, nBytes) {
  var e, m2, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d2 = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m2 = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e)) < 1) {
      e--;
      c2 *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e++;
      c2 /= 2;
    }
    if (e + eBias >= eMax) {
      m2 = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m2 = (value * c2 - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset2 + i] = m2 & 255, i += d2, m2 /= 256, mLen -= 8) {
  }
  e = e << mLen | m2;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset2 + i] = e & 255, i += d2, e /= 256, eLen -= 8) {
  }
  buffer2[offset2 + i - d2] |= s * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(exports2) {
  const base64 = base64Js;
  const ieee754$1 = ieee754;
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer3;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
  }
  function typedArraySupport() {
    try {
      const arr = new GlobalUint8Array(1);
      const proto = { foo: function() {
        return 42;
      } };
      Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length2) {
    if (length2 > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
    }
    const buf = new GlobalUint8Array(length2);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length2) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      }
      return allocUnsafe(arg);
    }
    return from2(arg, encodingOrOffset, length2);
  }
  Buffer3.poolSize = 8192;
  function from2(value, encodingOrOffset, length2) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (GlobalArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length2);
    }
    if (typeof value === "number") {
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length2);
    }
    const b2 = fromObject(value);
    if (b2) return b2;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
    }
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
    );
  }
  Buffer3.from = function(value, encodingOrOffset, length2) {
    return from2(value, encodingOrOffset, length2);
  };
  Object.setPrototypeOf(Buffer3.prototype, GlobalUint8Array.prototype);
  Object.setPrototypeOf(Buffer3, GlobalUint8Array);
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size2 < 0) {
      throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
    }
  }
  function alloc(size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
    }
    return createBuffer(size2);
  }
  Buffer3.alloc = function(size2, fill, encoding) {
    return alloc(size2, fill, encoding);
  };
  function allocUnsafe(size2) {
    assertSize(size2);
    return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
  }
  Buffer3.allocUnsafe = function(size2) {
    return allocUnsafe(size2);
  };
  Buffer3.allocUnsafeSlow = function(size2) {
    return allocUnsafe(size2);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length2 = byteLength2(string, encoding) | 0;
    let buf = createBuffer(length2);
    const actual = buf.write(string, encoding);
    if (actual !== length2) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length2);
    for (let i = 0; i < length2; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, GlobalUint8Array)) {
      const copy2 = new GlobalUint8Array(arrayView);
      return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length2) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length2 || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length2 === void 0) {
      buf = new GlobalUint8Array(array);
    } else if (length2 === void 0) {
      buf = new GlobalUint8Array(array, byteOffset);
    } else {
      buf = new GlobalUint8Array(array, byteOffset, length2);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length2) {
    if (length2 >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length2 | 0;
  }
  function SlowBuffer(length2) {
    if (+length2 != length2) {
      length2 = 0;
    }
    return Buffer3.alloc(+length2);
  }
  Buffer3.isBuffer = function isBuffer2(b2) {
    return b2 != null && b2._isBuffer === true && b2 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a, b2) {
    if (isInstance(a, GlobalUint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
    if (isInstance(b2, GlobalUint8Array)) b2 = Buffer3.from(b2, b2.offset, b2.byteLength);
    if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b2)) {
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    }
    if (a === b2) return 0;
    let x = a.length;
    let y2 = b2.length;
    for (let i = 0, len = Math.min(x, y2); i < len; ++i) {
      if (a[i] !== b2[i]) {
        x = a[i];
        y2 = b2[i];
        break;
      }
    }
    if (x < y2) return -1;
    if (y2 < x) return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length2) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i;
    if (length2 === void 0) {
      length2 = 0;
      for (i = 0; i < list.length; ++i) {
        length2 += list[i].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length2);
    let pos = 0;
    for (i = 0; i < list.length; ++i) {
      let buf = list[i];
      if (isInstance(buf, GlobalUint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          GlobalUint8Array.prototype.set.call(
            buffer2,
            buf,
            pos
          );
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
      );
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength2;
  function slowToString(encoding, start2, end2) {
    let loweredCase = false;
    if (start2 === void 0 || start2 < 0) {
      start2 = 0;
    }
    if (start2 > this.length) {
      return "";
    }
    if (end2 === void 0 || end2 > this.length) {
      end2 = this.length;
    }
    if (end2 <= 0) {
      return "";
    }
    end2 >>>= 0;
    start2 >>>= 0;
    if (end2 <= start2) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start2, end2);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start2, end2);
        case "ascii":
          return asciiSlice(this, start2, end2);
        case "latin1":
        case "binary":
          return latin1Slice(this, start2, end2);
        case "base64":
          return base64Slice(this, start2, end2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start2, end2);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b2, n, m2) {
    const i = b2[n];
    b2[n] = b2[m2];
    b2[m2] = i;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString2() {
    const length2 = this.length;
    if (length2 === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length2);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b2) {
    if (!Buffer3.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
    if (this === b2) return true;
    return Buffer3.compare(this, b2) === 0;
  };
  Buffer3.prototype.inspect = function inspect() {
    let str = "";
    const max2 = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max2) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start2, end2, thisStart, thisEnd) {
    if (isInstance(target, GlobalUint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
      );
    }
    if (start2 === void 0) {
      start2 = 0;
    }
    if (end2 === void 0) {
      end2 = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start2 >= end2) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start2 >= end2) {
      return 1;
    }
    start2 >>>= 0;
    end2 >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y2 = end2 - start2;
    const len = Math.min(x, y2);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start2, end2);
    for (let i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y2 = targetCopy[i];
        break;
      }
    }
    if (x < y2) return -1;
    if (y2 < x) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof GlobalUint8Array.prototype.indexOf === "function") {
        if (dir) {
          return GlobalUint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return GlobalUint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    let i;
    if (dir) {
      let foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        let found2 = true;
        for (let j2 = 0; j2 < valLength; j2++) {
          if (read2(arr, i + j2) !== read2(val, j2)) {
            found2 = false;
            break;
          }
        }
        if (found2) return i;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset2, length2) {
    offset2 = Number(offset2) || 0;
    const remaining = buf.length - offset2;
    if (!length2) {
      length2 = remaining;
    } else {
      length2 = Number(length2);
      if (length2 > remaining) {
        length2 = remaining;
      }
    }
    const strLen = string.length;
    if (length2 > strLen / 2) {
      length2 = strLen / 2;
    }
    let i;
    for (i = 0; i < length2; ++i) {
      const parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed)) return i;
      buf[offset2 + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset2, length2) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length2);
  }
  function asciiWrite(buf, string, offset2, length2) {
    return blitBuffer(asciiToBytes(string), buf, offset2, length2);
  }
  function base64Write(buf, string, offset2, length2) {
    return blitBuffer(base64ToBytes(string), buf, offset2, length2);
  }
  function ucs2Write(buf, string, offset2, length2) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length2);
  }
  Buffer3.prototype.write = function write2(string, offset2, length2, encoding) {
    if (offset2 === void 0) {
      encoding = "utf8";
      length2 = this.length;
      offset2 = 0;
    } else if (length2 === void 0 && typeof offset2 === "string") {
      encoding = offset2;
      length2 = this.length;
      offset2 = 0;
    } else if (isFinite(offset2)) {
      offset2 = offset2 >>> 0;
      if (isFinite(length2)) {
        length2 = length2 >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length2;
        length2 = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    const remaining = this.length - offset2;
    if (length2 === void 0 || length2 > remaining) length2 = remaining;
    if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset2, length2);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset2, length2);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset2, length2);
        case "base64":
          return base64Write(this, string, offset2, length2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset2, length2);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start2, end2) {
    if (start2 === 0 && end2 === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start2, end2));
    }
  }
  function utf8Slice(buf, start2, end2) {
    end2 = Math.min(buf.length, end2);
    const res = [];
    let i = start2;
    while (i < end2) {
      const firstByte = buf[i];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end2) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start2, end2) {
    let ret = "";
    end2 = Math.min(buf.length, end2);
    for (let i = start2; i < end2; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start2, end2) {
    let ret = "";
    end2 = Math.min(buf.length, end2);
    for (let i = start2; i < end2; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start2, end2) {
    const len = buf.length;
    if (!start2 || start2 < 0) start2 = 0;
    if (!end2 || end2 < 0 || end2 > len) end2 = len;
    let out = "";
    for (let i = start2; i < end2; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start2, end2) {
    const bytes = buf.slice(start2, end2);
    let res = "";
    for (let i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice2(start2, end2) {
    const len = this.length;
    start2 = ~~start2;
    end2 = end2 === void 0 ? len : ~~end2;
    if (start2 < 0) {
      start2 += len;
      if (start2 < 0) start2 = 0;
    } else if (start2 > len) {
      start2 = len;
    }
    if (end2 < 0) {
      end2 += len;
      if (end2 < 0) end2 = 0;
    } else if (end2 > len) {
      end2 = len;
    }
    if (end2 < start2) end2 = start2;
    const newBuf = this.subarray(start2, end2);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset2, ext, length2) {
    if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
    if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      checkOffset(offset2, byteLength3, this.length);
    }
    let val = this[offset2 + --byteLength3];
    let mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset2 + --byteLength3] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 1, this.length);
    return this[offset2];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    return this[offset2] | this[offset2 + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    return this[offset2] << 8 | this[offset2 + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first2 = this[offset2];
    const last = this[offset2 + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const lo = first2 + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
    const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first2 = this[offset2];
    const last = this[offset2 + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const hi = first2 * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let val = this[offset2];
    let mul = 1;
    let i = 0;
    while (++i < byteLength3 && (mul *= 256)) {
      val += this[offset2 + i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset2, byteLength3, noAssert) {
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) checkOffset(offset2, byteLength3, this.length);
    let i = byteLength3;
    let mul = 1;
    let val = this[offset2 + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset2 + --i] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 1, this.length);
    if (!(this[offset2] & 128)) return this[offset2];
    return (255 - this[offset2] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    const val = this[offset2] | this[offset2 + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 2, this.length);
    const val = this[offset2 + 1] | this[offset2] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first2 = this[offset2];
    const last = this[offset2 + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
    offset2 = offset2 >>> 0;
    validateNumber(offset2, "offset");
    const first2 = this[offset2];
    const last = this[offset2 + 7];
    if (first2 === void 0 || last === void 0) {
      boundsError(offset2, this.length - 8);
    }
    const val = (first2 << 24) + // Overflow
    this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 4, this.length);
    return ieee754$1.read(this, offset2, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
    offset2 = offset2 >>> 0;
    if (!noAssert) checkOffset(offset2, 8, this.length);
    return ieee754$1.read(this, offset2, false, 52, 8);
  };
  function checkInt(buf, value, offset2, ext, max2, min2) {
    if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
    if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      this[offset2 + i] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    byteLength3 = byteLength3 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset2, byteLength3, maxBytes, 0);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset2 + i] = value / mul & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 1, 255, 0);
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2 + 3] = value >>> 24;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 1] = value >>> 8;
    this[offset2] = value & 255;
    return offset2 + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  function wrtBigUInt64LE(buf, value, offset2, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    lo = lo >> 8;
    buf[offset2++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    hi = hi >> 8;
    buf[offset2++] = hi;
    return offset2;
  }
  function wrtBigUInt64BE(buf, value, offset2, min2, max2) {
    checkIntBI(value, min2, max2, buf, offset2, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset2 + 7] = lo;
    lo = lo >> 8;
    buf[offset2 + 6] = lo;
    lo = lo >> 8;
    buf[offset2 + 5] = lo;
    lo = lo >> 8;
    buf[offset2 + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset2 + 3] = hi;
    hi = hi >> 8;
    buf[offset2 + 2] = hi;
    hi = hi >> 8;
    buf[offset2 + 1] = hi;
    hi = hi >> 8;
    buf[offset2] = hi;
    return offset2 + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset2] = value & 255;
    while (++i < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength3, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset2, byteLength3, limit - 1, -limit);
    }
    let i = byteLength3 - 1;
    let mul = 1;
    let sub = 0;
    this[offset2 + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {
        sub = 1;
      }
      this[offset2 + i] = (value / mul >> 0) - sub & 255;
    }
    return offset2 + byteLength3;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset2] = value & 255;
    return offset2 + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    return offset2 + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
    this[offset2] = value >>> 8;
    this[offset2 + 1] = value & 255;
    return offset2 + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    this[offset2] = value & 255;
    this[offset2 + 1] = value >>> 8;
    this[offset2 + 2] = value >>> 16;
    this[offset2 + 3] = value >>> 24;
    return offset2 + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset2] = value >>> 24;
    this[offset2 + 1] = value >>> 16;
    this[offset2 + 2] = value >>> 8;
    this[offset2 + 3] = value & 255;
    return offset2 + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
    return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
    return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset2, ext, max2, min2) {
    if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
    if (offset2 < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 4);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
    return offset2 + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
    return writeFloat(this, value, offset2, false, noAssert);
  };
  function writeDouble(buf, value, offset2, littleEndian, noAssert) {
    value = +value;
    offset2 = offset2 >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset2, 8);
    }
    ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
    return offset2 + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
    return writeDouble(this, value, offset2, false, noAssert);
  };
  Buffer3.prototype.copy = function copy2(target, targetStart, start2, end2) {
    if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start2) start2 = 0;
    if (!end2 && end2 !== 0) end2 = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end2 > 0 && end2 < start2) end2 = start2;
    if (end2 === start2) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start2 < 0 || start2 >= this.length) throw new RangeError("Index out of range");
    if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
    if (end2 > this.length) end2 = this.length;
    if (target.length - targetStart < end2 - start2) {
      end2 = target.length - targetStart + start2;
    }
    const len = end2 - start2;
    if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start2, end2);
    } else {
      GlobalUint8Array.prototype.set.call(
        target,
        this.subarray(start2, end2),
        targetStart
      );
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start2, end2, encoding) {
    if (typeof val === "string") {
      if (typeof start2 === "string") {
        encoding = start2;
        start2 = 0;
        end2 = this.length;
      } else if (typeof end2 === "string") {
        encoding = end2;
        end2 = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code2 = val.charCodeAt(0);
        if (encoding === "utf8" && code2 < 128 || encoding === "latin1") {
          val = code2;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start2 < 0 || this.length < start2 || this.length < end2) {
      throw new RangeError("Out of range index");
    }
    if (end2 <= start2) {
      return this;
    }
    start2 = start2 >>> 0;
    end2 = end2 === void 0 ? this.length : end2 >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === "number") {
      for (i = start2; i < end2; ++i) {
        this[i] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end2 - start2; ++i) {
        this[i + start2] = bytes[i % len];
      }
    }
    return this;
  };
  const errors = {};
  function E2(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E2(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(name) {
      if (name) {
        return `${name} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    },
    RangeError
  );
  E2(
    "ERR_INVALID_ARG_TYPE",
    function(name, actual) {
      return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
    },
    TypeError
  );
  E2(
    "ERR_OUT_OF_RANGE",
    function(str, range2, input) {
      let msg2 = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg2 += ` It must be ${range2}. Received ${received}`;
      return msg2;
    },
    RangeError
  );
  function addNumericalSeparator(val) {
    let res = "";
    let i = val.length;
    const start2 = val[0] === "-" ? 1 : 0;
    for (; i >= start2 + 4; i -= 3) {
      res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
  }
  function checkBounds(buf, offset2, byteLength3) {
    validateNumber(offset2, "offset");
    if (buf[offset2] === void 0 || buf[offset2 + byteLength3] === void 0) {
      boundsError(offset2, buf.length - (byteLength3 + 1));
    }
  }
  function checkIntBI(value, min2, max2, buf, offset2, byteLength3) {
    if (value > max2 || value < min2) {
      const n = typeof min2 === "bigint" ? "n" : "";
      let range2;
      {
        if (min2 === 0 || min2 === BigInt(0)) {
          range2 = `>= 0${n} and < 2${n} ** ${(byteLength3 + 1) * 8}${n}`;
        } else {
          range2 = `>= -(2${n} ** ${(byteLength3 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength3 + 1) * 8 - 1}${n}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
    }
    checkBounds(buf, offset2, byteLength3);
  }
  function validateNumber(value, name) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
    }
  }
  function boundsError(value, length2, type2) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type2);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length2 < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(
      "offset",
      `>= ${0} and <= ${length2}`,
      value
    );
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length2 = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i = 0; i < length2; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length2) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c2, hi, lo;
    const byteArray = [];
    for (let i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c2 = str.charCodeAt(i);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset2, length2) {
    let i;
    for (i = 0; i < length2; ++i) {
      if (i + offset2 >= dst.length || i >= src.length) break;
      dst[i + offset2] = src[i];
    }
    return i;
  }
  function isInstance(obj, type2) {
    return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = (function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i = 0; i < 16; ++i) {
      const i16 = i * 16;
      for (let j2 = 0; j2 < 16; ++j2) {
        table[i16 + j2] = alphabet[i] + alphabet[j2];
      }
    }
    return table;
  })();
  function defineBigIntMethod(fn2) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
})(buffer);
const Buffer2 = buffer.Buffer;
var sax = {};
var events$1 = { exports: {} };
var hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents) return events$1.exports;
  hasRequiredEvents = 1;
  var R2 = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R2 && typeof R2.ownKeys === "function") {
    ReflectOwnKeys = R2.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
    return value !== value;
  };
  function EventEmitter3() {
    EventEmitter3.init.call(this);
  }
  events$1.exports = EventEmitter3;
  events$1.exports.once = once;
  EventEmitter3.EventEmitter = EventEmitter3;
  EventEmitter3.prototype._events = void 0;
  EventEmitter3.prototype._eventsCount = 0;
  EventEmitter3.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter3, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter3.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter3.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    }
    this._maxListeners = n;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter3.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter3.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter3.prototype.emit = function emit(type2) {
    var args = [];
    for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
    var doError = type2 === "error";
    var events2 = this._events;
    if (events2 !== void 0)
      doError = doError && events2.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err.context = er;
      throw err;
    }
    var handler = events2[type2];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        ReflectApply(listeners[i], this, args);
    }
    return true;
  };
  function _addListener(target, type2, listener, prepend2) {
    var m2;
    var events2;
    var existing;
    checkListener(listener);
    events2 = target._events;
    if (events2 === void 0) {
      events2 = target._events = /* @__PURE__ */ Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events2.newListener !== void 0) {
        target.emit(
          "newListener",
          type2,
          listener.listener ? listener.listener : listener
        );
        events2 = target._events;
      }
      existing = events2[type2];
    }
    if (existing === void 0) {
      existing = events2[type2] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events2[type2] = prepend2 ? [listener, existing] : [existing, listener];
      } else if (prepend2) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m2 = _getMaxListeners(target);
      if (m2 > 0 && existing.length > m2 && !existing.warned) {
        existing.warned = true;
        var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type2) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w2.name = "MaxListenersExceededWarning";
        w2.emitter = target;
        w2.type = type2;
        w2.count = existing.length;
        ProcessEmitWarning(w2);
      }
    }
    return target;
  }
  EventEmitter3.prototype.addListener = function addListener(type2, listener) {
    return _addListener(this, type2, listener, false);
  };
  EventEmitter3.prototype.on = EventEmitter3.prototype.addListener;
  EventEmitter3.prototype.prependListener = function prependListener(type2, listener) {
    return _addListener(this, type2, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type2, listener) {
    var state2 = { fired: false, wrapFn: void 0, target, type: type2, listener };
    var wrapped = onceWrapper.bind(state2);
    wrapped.listener = listener;
    state2.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter3.prototype.once = function once2(type2, listener) {
    checkListener(listener);
    this.on(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter3.prototype.prependOnceListener = function prependOnceListener(type2, listener) {
    checkListener(listener);
    this.prependListener(type2, _onceWrap(this, type2, listener));
    return this;
  };
  EventEmitter3.prototype.removeListener = function removeListener(type2, listener) {
    var list, events2, position, i, originalListener;
    checkListener(listener);
    events2 = this._events;
    if (events2 === void 0)
      return this;
    list = events2[type2];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = /* @__PURE__ */ Object.create(null);
      else {
        delete events2[type2];
        if (events2.removeListener)
          this.emit("removeListener", type2, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i = list.length - 1; i >= 0; i--) {
        if (list[i] === listener || list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne(list, position);
      }
      if (list.length === 1)
        events2[type2] = list[0];
      if (events2.removeListener !== void 0)
        this.emit("removeListener", type2, originalListener || listener);
    }
    return this;
  };
  EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
  EventEmitter3.prototype.removeAllListeners = function removeAllListeners(type2) {
    var listeners, events2, i;
    events2 = this._events;
    if (events2 === void 0)
      return this;
    if (events2.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      } else if (events2[type2] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else
          delete events2[type2];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys2 = Object.keys(events2);
      var key;
      for (i = 0; i < keys2.length; ++i) {
        key = keys2[i];
        if (key === "removeListener") continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = /* @__PURE__ */ Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events2[type2];
    if (typeof listeners === "function") {
      this.removeListener(type2, listeners);
    } else if (listeners !== void 0) {
      for (i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(type2, listeners[i]);
      }
    }
    return this;
  };
  function _listeners(target, type2, unwrap) {
    var events2 = target._events;
    if (events2 === void 0)
      return [];
    var evlistener = events2[type2];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter3.prototype.listeners = function listeners(type2) {
    return _listeners(this, type2, true);
  };
  EventEmitter3.prototype.rawListeners = function rawListeners(type2) {
    return _listeners(this, type2, false);
  };
  EventEmitter3.listenerCount = function(emitter, type2) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type2);
    } else {
      return listenerCount.call(emitter, type2);
    }
  };
  EventEmitter3.prototype.listenerCount = listenerCount;
  function listenerCount(type2) {
    var events2 = this._events;
    if (events2 !== void 0) {
      var evlistener = events2[type2];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter3.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr, n) {
    var copy2 = new Array(n);
    for (var i = 0; i < n; ++i)
      copy2[i] = arr[i];
    return copy2;
  }
  function spliceOne(list, index2) {
    for (; index2 + 1 < list.length; index2++)
      list[index2] = list[index2 + 1];
    list.pop();
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  function once(emitter, name) {
    return new Promise(function(resolve, reject) {
      function errorListener(err) {
        emitter.removeListener(name, resolver);
        reject(err);
      }
      function resolver() {
        if (typeof emitter.removeListener === "function") {
          emitter.removeListener("error", errorListener);
        }
        resolve([].slice.call(arguments));
      }
      eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
      if (name !== "error") {
        addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
      }
    });
  }
  function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === "function") {
      eventTargetAgnosticAddListener(emitter, "error", handler, flags);
    }
  }
  function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === "function") {
      if (flags.once) {
        emitter.once(name, listener);
      } else {
        emitter.on(name, listener);
      }
    } else if (typeof emitter.addEventListener === "function") {
      emitter.addEventListener(name, function wrapListener(arg) {
        if (flags.once) {
          emitter.removeEventListener(name, wrapListener);
        }
        listener(arg);
      });
    } else {
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
  }
  return events$1.exports;
}
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser$1 = { exports: {} };
var process$1 = browser$1.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout2 = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout2);
}
process$1.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item$1(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item$1(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item$1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process$1.title = "browser";
process$1.browser = true;
process$1.env = {};
process$1.argv = [];
process$1.version = "";
process$1.versions = {};
function noop() {
}
process$1.on = noop;
process$1.addListener = noop;
process$1.once = noop;
process$1.off = noop;
process$1.removeListener = noop;
process$1.removeAllListeners = noop;
process$1.emit = noop;
process$1.prependListener = noop;
process$1.prependOnceListener = noop;
process$1.listeners = function(name) {
  return [];
};
process$1.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process$1.cwd = function() {
  return "/";
};
process$1.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process$1.umask = function() {
  return 0;
};
var browserExports = browser$1.exports;
const process$1$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
var streamBrowser;
var hasRequiredStreamBrowser;
function requireStreamBrowser() {
  if (hasRequiredStreamBrowser) return streamBrowser;
  hasRequiredStreamBrowser = 1;
  streamBrowser = requireEvents().EventEmitter;
  return streamBrowser;
}
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports2) {
    Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
    var buffer2 = {};
    var base64Js2 = {};
    base64Js2.byteLength = byteLength2;
    base64Js2.toByteArray = toByteArray2;
    base64Js2.fromByteArray = fromByteArray2;
    var lookup2 = [];
    var revLookup2 = [];
    var Arr2 = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (var i = 0, len = code2.length; i < len; ++i) {
      lookup2[i] = code2[i];
      revLookup2[code2.charCodeAt(i)] = i;
    }
    revLookup2["-".charCodeAt(0)] = 62;
    revLookup2["_".charCodeAt(0)] = 63;
    function getLens2(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength2(b64) {
      var lens = getLens2(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength2(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray2(b64) {
      var tmp;
      var lens = getLens2(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr2(_byteLength2(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 18 | revLookup2[b64.charCodeAt(i2 + 1)] << 12 | revLookup2[b64.charCodeAt(i2 + 2)] << 6 | revLookup2[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 2 | revLookup2[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup2[b64.charCodeAt(i2)] << 10 | revLookup2[b64.charCodeAt(i2 + 1)] << 4 | revLookup2[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase642(num) {
      return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
    }
    function encodeChunk2(uint8, start2, end2) {
      var tmp;
      var output = [];
      for (var i2 = start2; i2 < end2; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase642(tmp));
      }
      return output.join("");
    }
    function fromByteArray2(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk2(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    var ieee7542 = {};
    /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
    ieee7542.read = function(buffer3, offset2, isLE, mLen, nBytes) {
      var e, m2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i2 = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s = buffer3[offset2 + i2];
      i2 += d2;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer3[offset2 + i2], i2 += d2, nBits -= 8) {
      }
      m2 = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m2 = m2 * 256 + buffer3[offset2 + i2], i2 += d2, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m2 ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m2 = m2 + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m2 * Math.pow(2, e - mLen);
    };
    ieee7542.write = function(buffer3, value, offset2, isLE, mLen, nBytes) {
      var e, m2, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i2 = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m2 = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e)) < 1) {
          e--;
          c2 *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e++;
          c2 /= 2;
        }
        if (e + eBias >= eMax) {
          m2 = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m2 = (value * c2 - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m2 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer3[offset2 + i2] = m2 & 255, i2 += d2, m2 /= 256, mLen -= 8) {
      }
      e = e << mLen | m2;
      eLen += mLen;
      for (; eLen > 0; buffer3[offset2 + i2] = e & 255, i2 += d2, e /= 256, eLen -= 8) {
      }
      buffer3[offset2 + i2 - d2] |= s * 128;
    };
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     */
    (function(exports22) {
      const base64 = base64Js2;
      const ieee754$1 = ieee7542;
      const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports22.Buffer = Buffer4;
      exports22.SlowBuffer = SlowBuffer;
      exports22.INSPECT_MAX_BYTES = 50;
      const K_MAX_LENGTH = 2147483647;
      exports22.kMaxLength = K_MAX_LENGTH;
      const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;
      Buffer4.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer4.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error(
          "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
        );
      }
      function typedArraySupport() {
        try {
          const arr = new GlobalUint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer4.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this)) return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer4.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer4.isBuffer(this)) return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length2) {
        if (length2 > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
        }
        const buf = new GlobalUint8Array(length2);
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function Buffer4(arg, encodingOrOffset, length2) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError(
              'The "string" argument must be of type string. Received type number'
            );
          }
          return allocUnsafe(arg);
        }
        return from2(arg, encodingOrOffset, length2);
      }
      Buffer4.poolSize = 8192;
      function from2(value, encodingOrOffset, length2) {
        if (typeof value === "string") {
          return fromString(value, encodingOrOffset);
        }
        if (GlobalArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError(
            "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
          );
        }
        if (isInstance(value, GlobalArrayBuffer) || value && isInstance(value.buffer, GlobalArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length2);
        }
        if (typeof GlobalSharedArrayBuffer !== "undefined" && (isInstance(value, GlobalSharedArrayBuffer) || value && isInstance(value.buffer, GlobalSharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length2);
        }
        if (typeof value === "number") {
          throw new TypeError(
            'The "value" argument must not be of type number. Received type number'
          );
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer4.from(valueOf, encodingOrOffset, length2);
        }
        const b2 = fromObject(value);
        if (b2) return b2;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer4.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
        }
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      Buffer4.from = function(value, encodingOrOffset, length2) {
        return from2(value, encodingOrOffset, length2);
      };
      Object.setPrototypeOf(Buffer4.prototype, GlobalUint8Array.prototype);
      Object.setPrototypeOf(Buffer4, GlobalUint8Array);
      function assertSize(size2) {
        if (typeof size2 !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size2 < 0) {
          throw new RangeError('The value "' + size2 + '" is invalid for option "size"');
        }
      }
      function alloc(size2, fill, encoding) {
        assertSize(size2);
        if (size2 <= 0) {
          return createBuffer(size2);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size2).fill(fill, encoding) : createBuffer(size2).fill(fill);
        }
        return createBuffer(size2);
      }
      Buffer4.alloc = function(size2, fill, encoding) {
        return alloc(size2, fill, encoding);
      };
      function allocUnsafe(size2) {
        assertSize(size2);
        return createBuffer(size2 < 0 ? 0 : checked(size2) | 0);
      }
      Buffer4.allocUnsafe = function(size2) {
        return allocUnsafe(size2);
      };
      Buffer4.allocUnsafeSlow = function(size2) {
        return allocUnsafe(size2);
      };
      function fromString(string, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer4.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length2 = byteLength3(string, encoding) | 0;
        let buf = createBuffer(length2);
        const actual = buf.write(string, encoding);
        if (actual !== length2) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length2);
        for (let i2 = 0; i2 < length2; i2 += 1) {
          buf[i2] = array[i2] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, GlobalUint8Array)) {
          const copy2 = new GlobalUint8Array(arrayView);
          return fromArrayBuffer(copy2.buffer, copy2.byteOffset, copy2.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length2) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length2 || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length2 === void 0) {
          buf = new GlobalUint8Array(array);
        } else if (length2 === void 0) {
          buf = new GlobalUint8Array(array, byteOffset);
        } else {
          buf = new GlobalUint8Array(array, byteOffset, length2);
        }
        Object.setPrototypeOf(buf, Buffer4.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer4.isBuffer(obj)) {
          const len2 = checked(obj.length) | 0;
          const buf = createBuffer(len2);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len2);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length2) {
        if (length2 >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length2 | 0;
      }
      function SlowBuffer(length2) {
        if (+length2 != length2) {
          length2 = 0;
        }
        return Buffer4.alloc(+length2);
      }
      Buffer4.isBuffer = function isBuffer2(b2) {
        return b2 != null && b2._isBuffer === true && b2 !== Buffer4.prototype;
      };
      Buffer4.compare = function compare(a, b2) {
        if (isInstance(a, GlobalUint8Array)) a = Buffer4.from(a, a.offset, a.byteLength);
        if (isInstance(b2, GlobalUint8Array)) b2 = Buffer4.from(b2, b2.offset, b2.byteLength);
        if (!Buffer4.isBuffer(a) || !Buffer4.isBuffer(b2)) {
          throw new TypeError(
            'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
          );
        }
        if (a === b2) return 0;
        let x = a.length;
        let y2 = b2.length;
        for (let i2 = 0, len2 = Math.min(x, y2); i2 < len2; ++i2) {
          if (a[i2] !== b2[i2]) {
            x = a[i2];
            y2 = b2[i2];
            break;
          }
        }
        if (x < y2) return -1;
        if (y2 < x) return 1;
        return 0;
      };
      Buffer4.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer4.concat = function concat(list, length2) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer4.alloc(0);
        }
        let i2;
        if (length2 === void 0) {
          length2 = 0;
          for (i2 = 0; i2 < list.length; ++i2) {
            length2 += list[i2].length;
          }
        }
        const buffer3 = Buffer4.allocUnsafe(length2);
        let pos = 0;
        for (i2 = 0; i2 < list.length; ++i2) {
          let buf = list[i2];
          if (isInstance(buf, GlobalUint8Array)) {
            if (pos + buf.length > buffer3.length) {
              if (!Buffer4.isBuffer(buf)) buf = Buffer4.from(buf);
              buf.copy(buffer3, pos);
            } else {
              GlobalUint8Array.prototype.set.call(
                buffer3,
                buf,
                pos
              );
            }
          } else if (!Buffer4.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer3, pos);
          }
          pos += buf.length;
        }
        return buffer3;
      };
      function byteLength3(string, encoding) {
        if (Buffer4.isBuffer(string)) {
          return string.length;
        }
        if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
          return string.byteLength;
        }
        if (typeof string !== "string") {
          throw new TypeError(
            'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
          );
        }
        const len2 = string.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len2 === 0) return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len2;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len2 * 2;
            case "hex":
              return len2 >>> 1;
            case "base64":
              return base64ToBytes(string).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.byteLength = byteLength3;
      function slowToString(encoding, start2, end2) {
        let loweredCase = false;
        if (start2 === void 0 || start2 < 0) {
          start2 = 0;
        }
        if (start2 > this.length) {
          return "";
        }
        if (end2 === void 0 || end2 > this.length) {
          end2 = this.length;
        }
        if (end2 <= 0) {
          return "";
        }
        end2 >>>= 0;
        start2 >>>= 0;
        if (end2 <= start2) {
          return "";
        }
        if (!encoding) encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start2, end2);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start2, end2);
            case "ascii":
              return asciiSlice(this, start2, end2);
            case "latin1":
            case "binary":
              return latin1Slice(this, start2, end2);
            case "base64":
              return base64Slice(this, start2, end2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start2, end2);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer4.prototype._isBuffer = true;
      function swap(b2, n, m2) {
        const i2 = b2[n];
        b2[n] = b2[m2];
        b2[m2] = i2;
      }
      Buffer4.prototype.swap16 = function swap16() {
        const len2 = this.length;
        if (len2 % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 2) {
          swap(this, i2, i2 + 1);
        }
        return this;
      };
      Buffer4.prototype.swap32 = function swap32() {
        const len2 = this.length;
        if (len2 % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 4) {
          swap(this, i2, i2 + 3);
          swap(this, i2 + 1, i2 + 2);
        }
        return this;
      };
      Buffer4.prototype.swap64 = function swap64() {
        const len2 = this.length;
        if (len2 % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i2 = 0; i2 < len2; i2 += 8) {
          swap(this, i2, i2 + 7);
          swap(this, i2 + 1, i2 + 6);
          swap(this, i2 + 2, i2 + 5);
          swap(this, i2 + 3, i2 + 4);
        }
        return this;
      };
      Buffer4.prototype.toString = function toString2() {
        const length2 = this.length;
        if (length2 === 0) return "";
        if (arguments.length === 0) return utf8Slice(this, 0, length2);
        return slowToString.apply(this, arguments);
      };
      Buffer4.prototype.toLocaleString = Buffer4.prototype.toString;
      Buffer4.prototype.equals = function equals(b2) {
        if (!Buffer4.isBuffer(b2)) throw new TypeError("Argument must be a Buffer");
        if (this === b2) return true;
        return Buffer4.compare(this, b2) === 0;
      };
      Buffer4.prototype.inspect = function inspect() {
        let str = "";
        const max2 = exports22.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max2).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max2) str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer4.prototype[customInspectSymbol] = Buffer4.prototype.inspect;
      }
      Buffer4.prototype.compare = function compare(target, start2, end2, thisStart, thisEnd) {
        if (isInstance(target, GlobalUint8Array)) {
          target = Buffer4.from(target, target.offset, target.byteLength);
        }
        if (!Buffer4.isBuffer(target)) {
          throw new TypeError(
            'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
          );
        }
        if (start2 === void 0) {
          start2 = 0;
        }
        if (end2 === void 0) {
          end2 = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start2 < 0 || end2 > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start2 >= end2) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start2 >= end2) {
          return 1;
        }
        start2 >>>= 0;
        end2 >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target) return 0;
        let x = thisEnd - thisStart;
        let y2 = end2 - start2;
        const len2 = Math.min(x, y2);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start2, end2);
        for (let i2 = 0; i2 < len2; ++i2) {
          if (thisCopy[i2] !== targetCopy[i2]) {
            x = thisCopy[i2];
            y2 = targetCopy[i2];
            break;
          }
        }
        if (x < y2) return -1;
        if (y2 < x) return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer3, val, byteOffset, encoding, dir) {
        if (buffer3.length === 0) return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer3.length - 1;
        }
        if (byteOffset < 0) byteOffset = buffer3.length + byteOffset;
        if (byteOffset >= buffer3.length) {
          if (dir) return -1;
          else byteOffset = buffer3.length - 1;
        } else if (byteOffset < 0) {
          if (dir) byteOffset = 0;
          else return -1;
        }
        if (typeof val === "string") {
          val = Buffer4.from(val, encoding);
        }
        if (Buffer4.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer3, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof GlobalUint8Array.prototype.indexOf === "function") {
            if (dir) {
              return GlobalUint8Array.prototype.indexOf.call(buffer3, val, byteOffset);
            } else {
              return GlobalUint8Array.prototype.lastIndexOf.call(buffer3, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer3, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read2(buf, i3) {
          if (indexSize === 1) {
            return buf[i3];
          } else {
            return buf.readUInt16BE(i3 * indexSize);
          }
        }
        let i2;
        if (dir) {
          let foundIndex = -1;
          for (i2 = byteOffset; i2 < arrLength; i2++) {
            if (read2(arr, i2) === read2(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
              if (foundIndex === -1) foundIndex = i2;
              if (i2 - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1) i2 -= i2 - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
          for (i2 = byteOffset; i2 >= 0; i2--) {
            let found2 = true;
            for (let j2 = 0; j2 < valLength; j2++) {
              if (read2(arr, i2 + j2) !== read2(val, j2)) {
                found2 = false;
                break;
              }
            }
            if (found2) return i2;
          }
        }
        return -1;
      }
      Buffer4.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer4.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer4.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string, offset2, length2) {
        offset2 = Number(offset2) || 0;
        const remaining = buf.length - offset2;
        if (!length2) {
          length2 = remaining;
        } else {
          length2 = Number(length2);
          if (length2 > remaining) {
            length2 = remaining;
          }
        }
        const strLen = string.length;
        if (length2 > strLen / 2) {
          length2 = strLen / 2;
        }
        let i2;
        for (i2 = 0; i2 < length2; ++i2) {
          const parsed = parseInt(string.substr(i2 * 2, 2), 16);
          if (numberIsNaN(parsed)) return i2;
          buf[offset2 + i2] = parsed;
        }
        return i2;
      }
      function utf8Write(buf, string, offset2, length2) {
        return blitBuffer(utf8ToBytes(string, buf.length - offset2), buf, offset2, length2);
      }
      function asciiWrite(buf, string, offset2, length2) {
        return blitBuffer(asciiToBytes(string), buf, offset2, length2);
      }
      function base64Write(buf, string, offset2, length2) {
        return blitBuffer(base64ToBytes(string), buf, offset2, length2);
      }
      function ucs2Write(buf, string, offset2, length2) {
        return blitBuffer(utf16leToBytes(string, buf.length - offset2), buf, offset2, length2);
      }
      Buffer4.prototype.write = function write2(string, offset2, length2, encoding) {
        if (offset2 === void 0) {
          encoding = "utf8";
          length2 = this.length;
          offset2 = 0;
        } else if (length2 === void 0 && typeof offset2 === "string") {
          encoding = offset2;
          length2 = this.length;
          offset2 = 0;
        } else if (isFinite(offset2)) {
          offset2 = offset2 >>> 0;
          if (isFinite(length2)) {
            length2 = length2 >>> 0;
            if (encoding === void 0) encoding = "utf8";
          } else {
            encoding = length2;
            length2 = void 0;
          }
        } else {
          throw new Error(
            "Buffer.write(string, encoding, offset[, length]) is no longer supported"
          );
        }
        const remaining = this.length - offset2;
        if (length2 === void 0 || length2 > remaining) length2 = remaining;
        if (string.length > 0 && (length2 < 0 || offset2 < 0) || offset2 > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding) encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string, offset2, length2);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string, offset2, length2);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string, offset2, length2);
            case "base64":
              return base64Write(this, string, offset2, length2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string, offset2, length2);
            default:
              if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer4.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start2, end2) {
        if (start2 === 0 && end2 === buf.length) {
          return base64.fromByteArray(buf);
        } else {
          return base64.fromByteArray(buf.slice(start2, end2));
        }
      }
      function utf8Slice(buf, start2, end2) {
        end2 = Math.min(buf.length, end2);
        const res = [];
        let i2 = start2;
        while (i2 < end2) {
          const firstByte = buf[i2];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i2 + bytesPerSequence <= end2) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i2 + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i2 + 1];
                thirdByte = buf[i2 + 2];
                fourthByte = buf[i2 + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i2 += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      const MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len2 = codePoints.length;
        if (len2 <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i2 = 0;
        while (i2 < len2) {
          res += String.fromCharCode.apply(
            String,
            codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
          );
        }
        return res;
      }
      function asciiSlice(buf, start2, end2) {
        let ret = "";
        end2 = Math.min(buf.length, end2);
        for (let i2 = start2; i2 < end2; ++i2) {
          ret += String.fromCharCode(buf[i2] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start2, end2) {
        let ret = "";
        end2 = Math.min(buf.length, end2);
        for (let i2 = start2; i2 < end2; ++i2) {
          ret += String.fromCharCode(buf[i2]);
        }
        return ret;
      }
      function hexSlice(buf, start2, end2) {
        const len2 = buf.length;
        if (!start2 || start2 < 0) start2 = 0;
        if (!end2 || end2 < 0 || end2 > len2) end2 = len2;
        let out = "";
        for (let i2 = start2; i2 < end2; ++i2) {
          out += hexSliceLookupTable[buf[i2]];
        }
        return out;
      }
      function utf16leSlice(buf, start2, end2) {
        const bytes = buf.slice(start2, end2);
        let res = "";
        for (let i2 = 0; i2 < bytes.length - 1; i2 += 2) {
          res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
        }
        return res;
      }
      Buffer4.prototype.slice = function slice2(start2, end2) {
        const len2 = this.length;
        start2 = ~~start2;
        end2 = end2 === void 0 ? len2 : ~~end2;
        if (start2 < 0) {
          start2 += len2;
          if (start2 < 0) start2 = 0;
        } else if (start2 > len2) {
          start2 = len2;
        }
        if (end2 < 0) {
          end2 += len2;
          if (end2 < 0) end2 = 0;
        } else if (end2 > len2) {
          end2 = len2;
        }
        if (end2 < start2) end2 = start2;
        const newBuf = this.subarray(start2, end2);
        Object.setPrototypeOf(newBuf, Buffer4.prototype);
        return newBuf;
      };
      function checkOffset(offset2, ext, length2) {
        if (offset2 % 1 !== 0 || offset2 < 0) throw new RangeError("offset is not uint");
        if (offset2 + ext > length2) throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer4.prototype.readUintLE = Buffer4.prototype.readUIntLE = function readUIntLE(offset2, byteLength4, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength4, this.length);
        let val = this[offset2];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength4 && (mul *= 256)) {
          val += this[offset2 + i2] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUintBE = Buffer4.prototype.readUIntBE = function readUIntBE(offset2, byteLength4, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          checkOffset(offset2, byteLength4, this.length);
        }
        let val = this[offset2 + --byteLength4];
        let mul = 1;
        while (byteLength4 > 0 && (mul *= 256)) {
          val += this[offset2 + --byteLength4] * mul;
        }
        return val;
      };
      Buffer4.prototype.readUint8 = Buffer4.prototype.readUInt8 = function readUInt8(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 1, this.length);
        return this[offset2];
      };
      Buffer4.prototype.readUint16LE = Buffer4.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        return this[offset2] | this[offset2 + 1] << 8;
      };
      Buffer4.prototype.readUint16BE = Buffer4.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        return this[offset2] << 8 | this[offset2 + 1];
      };
      Buffer4.prototype.readUint32LE = Buffer4.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;
      };
      Buffer4.prototype.readUint32BE = Buffer4.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);
      };
      Buffer4.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first2 = this[offset2];
        const last = this[offset2 + 7];
        if (first2 === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const lo = first2 + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;
        const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer4.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first2 = this[offset2];
        const last = this[offset2 + 7];
        if (first2 === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const hi = first2 * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
        const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer4.prototype.readIntLE = function readIntLE(offset2, byteLength4, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength4, this.length);
        let val = this[offset2];
        let mul = 1;
        let i2 = 0;
        while (++i2 < byteLength4 && (mul *= 256)) {
          val += this[offset2 + i2] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
        return val;
      };
      Buffer4.prototype.readIntBE = function readIntBE(offset2, byteLength4, noAssert) {
        offset2 = offset2 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) checkOffset(offset2, byteLength4, this.length);
        let i2 = byteLength4;
        let mul = 1;
        let val = this[offset2 + --i2];
        while (i2 > 0 && (mul *= 256)) {
          val += this[offset2 + --i2] * mul;
        }
        mul *= 128;
        if (val >= mul) val -= Math.pow(2, 8 * byteLength4);
        return val;
      };
      Buffer4.prototype.readInt8 = function readInt8(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 1, this.length);
        if (!(this[offset2] & 128)) return this[offset2];
        return (255 - this[offset2] + 1) * -1;
      };
      Buffer4.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        const val = this[offset2] | this[offset2 + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 2, this.length);
        const val = this[offset2 + 1] | this[offset2] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer4.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;
      };
      Buffer4.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];
      };
      Buffer4.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first2 = this[offset2];
        const last = this[offset2 + 7];
        if (first2 === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first2 + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);
      });
      Buffer4.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {
        offset2 = offset2 >>> 0;
        validateNumber(offset2, "offset");
        const first2 = this[offset2];
        const last = this[offset2 + 7];
        if (first2 === void 0 || last === void 0) {
          boundsError(offset2, this.length - 8);
        }
        const val = (first2 << 24) + // Overflow
        this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);
      });
      Buffer4.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return ieee754$1.read(this, offset2, true, 23, 4);
      };
      Buffer4.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 4, this.length);
        return ieee754$1.read(this, offset2, false, 23, 4);
      };
      Buffer4.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 8, this.length);
        return ieee754$1.read(this, offset2, true, 52, 8);
      };
      Buffer4.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {
        offset2 = offset2 >>> 0;
        if (!noAssert) checkOffset(offset2, 8, this.length);
        return ieee754$1.read(this, offset2, false, 52, 8);
      };
      function checkInt(buf, value, offset2, ext, max2, min2) {
        if (!Buffer4.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max2 || value < min2) throw new RangeError('"value" argument is out of bounds');
        if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
      }
      Buffer4.prototype.writeUintLE = Buffer4.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength4, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength4) - 1;
          checkInt(this, value, offset2, byteLength4, maxBytes, 0);
        }
        let mul = 1;
        let i2 = 0;
        this[offset2] = value & 255;
        while (++i2 < byteLength4 && (mul *= 256)) {
          this[offset2 + i2] = value / mul & 255;
        }
        return offset2 + byteLength4;
      };
      Buffer4.prototype.writeUintBE = Buffer4.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength4, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        byteLength4 = byteLength4 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength4) - 1;
          checkInt(this, value, offset2, byteLength4, maxBytes, 0);
        }
        let i2 = byteLength4 - 1;
        let mul = 1;
        this[offset2 + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          this[offset2 + i2] = value / mul & 255;
        }
        return offset2 + byteLength4;
      };
      Buffer4.prototype.writeUint8 = Buffer4.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 1, 255, 0);
        this[offset2] = value & 255;
        return offset2 + 1;
      };
      Buffer4.prototype.writeUint16LE = Buffer4.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        return offset2 + 2;
      };
      Buffer4.prototype.writeUint16BE = Buffer4.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 65535, 0);
        this[offset2] = value >>> 8;
        this[offset2 + 1] = value & 255;
        return offset2 + 2;
      };
      Buffer4.prototype.writeUint32LE = Buffer4.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
        this[offset2 + 3] = value >>> 24;
        this[offset2 + 2] = value >>> 16;
        this[offset2 + 1] = value >>> 8;
        this[offset2] = value & 255;
        return offset2 + 4;
      };
      Buffer4.prototype.writeUint32BE = Buffer4.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 4294967295, 0);
        this[offset2] = value >>> 24;
        this[offset2 + 1] = value >>> 16;
        this[offset2 + 2] = value >>> 8;
        this[offset2 + 3] = value & 255;
        return offset2 + 4;
      };
      function wrtBigUInt64LE(buf, value, offset2, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset2, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        lo = lo >> 8;
        buf[offset2++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        hi = hi >> 8;
        buf[offset2++] = hi;
        return offset2;
      }
      function wrtBigUInt64BE(buf, value, offset2, min2, max2) {
        checkIntBI(value, min2, max2, buf, offset2, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset2 + 7] = lo;
        lo = lo >> 8;
        buf[offset2 + 6] = lo;
        lo = lo >> 8;
        buf[offset2 + 5] = lo;
        lo = lo >> 8;
        buf[offset2 + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset2 + 3] = hi;
        hi = hi >> 8;
        buf[offset2 + 2] = hi;
        hi = hi >> 8;
        buf[offset2 + 1] = hi;
        hi = hi >> 8;
        buf[offset2] = hi;
        return offset2 + 8;
      }
      Buffer4.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {
        return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer4.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {
        return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer4.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength4, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength4 - 1);
          checkInt(this, value, offset2, byteLength4, limit - 1, -limit);
        }
        let i2 = 0;
        let mul = 1;
        let sub = 0;
        this[offset2] = value & 255;
        while (++i2 < byteLength4 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset2 + i2 - 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength4;
      };
      Buffer4.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength4, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength4 - 1);
          checkInt(this, value, offset2, byteLength4, limit - 1, -limit);
        }
        let i2 = byteLength4 - 1;
        let mul = 1;
        let sub = 0;
        this[offset2 + i2] = value & 255;
        while (--i2 >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset2 + i2 + 1] !== 0) {
            sub = 1;
          }
          this[offset2 + i2] = (value / mul >> 0) - sub & 255;
        }
        return offset2 + byteLength4;
      };
      Buffer4.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 1, 127, -128);
        if (value < 0) value = 255 + value + 1;
        this[offset2] = value & 255;
        return offset2 + 1;
      };
      Buffer4.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        return offset2 + 2;
      };
      Buffer4.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 2, 32767, -32768);
        this[offset2] = value >>> 8;
        this[offset2 + 1] = value & 255;
        return offset2 + 2;
      };
      Buffer4.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
        this[offset2] = value & 255;
        this[offset2 + 1] = value >>> 8;
        this[offset2 + 2] = value >>> 16;
        this[offset2 + 3] = value >>> 24;
        return offset2 + 4;
      };
      Buffer4.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) checkInt(this, value, offset2, 4, 2147483647, -2147483648);
        if (value < 0) value = 4294967295 + value + 1;
        this[offset2] = value >>> 24;
        this[offset2 + 1] = value >>> 16;
        this[offset2 + 2] = value >>> 8;
        this[offset2 + 3] = value & 255;
        return offset2 + 4;
      };
      Buffer4.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {
        return wrtBigUInt64LE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer4.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {
        return wrtBigUInt64BE(this, value, offset2, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset2, ext, max2, min2) {
        if (offset2 + ext > buf.length) throw new RangeError("Index out of range");
        if (offset2 < 0) throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset2, littleEndian, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset2, 4);
        }
        ieee754$1.write(buf, value, offset2, littleEndian, 23, 4);
        return offset2 + 4;
      }
      Buffer4.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {
        return writeFloat(this, value, offset2, true, noAssert);
      };
      Buffer4.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {
        return writeFloat(this, value, offset2, false, noAssert);
      };
      function writeDouble(buf, value, offset2, littleEndian, noAssert) {
        value = +value;
        offset2 = offset2 >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset2, 8);
        }
        ieee754$1.write(buf, value, offset2, littleEndian, 52, 8);
        return offset2 + 8;
      }
      Buffer4.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {
        return writeDouble(this, value, offset2, true, noAssert);
      };
      Buffer4.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {
        return writeDouble(this, value, offset2, false, noAssert);
      };
      Buffer4.prototype.copy = function copy2(target, targetStart, start2, end2) {
        if (!Buffer4.isBuffer(target)) throw new TypeError("argument should be a Buffer");
        if (!start2) start2 = 0;
        if (!end2 && end2 !== 0) end2 = this.length;
        if (targetStart >= target.length) targetStart = target.length;
        if (!targetStart) targetStart = 0;
        if (end2 > 0 && end2 < start2) end2 = start2;
        if (end2 === start2) return 0;
        if (target.length === 0 || this.length === 0) return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start2 < 0 || start2 >= this.length) throw new RangeError("Index out of range");
        if (end2 < 0) throw new RangeError("sourceEnd out of bounds");
        if (end2 > this.length) end2 = this.length;
        if (target.length - targetStart < end2 - start2) {
          end2 = target.length - targetStart + start2;
        }
        const len2 = end2 - start2;
        if (this === target && typeof GlobalUint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start2, end2);
        } else {
          GlobalUint8Array.prototype.set.call(
            target,
            this.subarray(start2, end2),
            targetStart
          );
        }
        return len2;
      };
      Buffer4.prototype.fill = function fill(val, start2, end2, encoding) {
        if (typeof val === "string") {
          if (typeof start2 === "string") {
            encoding = start2;
            start2 = 0;
            end2 = this.length;
          } else if (typeof end2 === "string") {
            encoding = end2;
            end2 = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer4.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code3 = val.charCodeAt(0);
            if (encoding === "utf8" && code3 < 128 || encoding === "latin1") {
              val = code3;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start2 < 0 || this.length < start2 || this.length < end2) {
          throw new RangeError("Out of range index");
        }
        if (end2 <= start2) {
          return this;
        }
        start2 = start2 >>> 0;
        end2 = end2 === void 0 ? this.length : end2 >>> 0;
        if (!val) val = 0;
        let i2;
        if (typeof val === "number") {
          for (i2 = start2; i2 < end2; ++i2) {
            this[i2] = val;
          }
        } else {
          const bytes = Buffer4.isBuffer(val) ? val : Buffer4.from(val, encoding);
          const len2 = bytes.length;
          if (len2 === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i2 = 0; i2 < end2 - start2; ++i2) {
            this[i2 + start2] = bytes[i2 % len2];
          }
        }
        return this;
      };
      const errors = {};
      function E2(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E2(
        "ERR_BUFFER_OUT_OF_BOUNDS",
        function(name) {
          if (name) {
            return `${name} is outside of buffer bounds`;
          }
          return "Attempt to access memory outside buffer bounds";
        },
        RangeError
      );
      E2(
        "ERR_INVALID_ARG_TYPE",
        function(name, actual) {
          return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
        },
        TypeError
      );
      E2(
        "ERR_OUT_OF_RANGE",
        function(str, range2, input) {
          let msg2 = `The value of "${str}" is out of range.`;
          let received = input;
          if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
            received = addNumericalSeparator(String(input));
          } else if (typeof input === "bigint") {
            received = String(input);
            if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
              received = addNumericalSeparator(received);
            }
            received += "n";
          }
          msg2 += ` It must be ${range2}. Received ${received}`;
          return msg2;
        },
        RangeError
      );
      function addNumericalSeparator(val) {
        let res = "";
        let i2 = val.length;
        const start2 = val[0] === "-" ? 1 : 0;
        for (; i2 >= start2 + 4; i2 -= 3) {
          res = `_${val.slice(i2 - 3, i2)}${res}`;
        }
        return `${val.slice(0, i2)}${res}`;
      }
      function checkBounds(buf, offset2, byteLength4) {
        validateNumber(offset2, "offset");
        if (buf[offset2] === void 0 || buf[offset2 + byteLength4] === void 0) {
          boundsError(offset2, buf.length - (byteLength4 + 1));
        }
      }
      function checkIntBI(value, min2, max2, buf, offset2, byteLength4) {
        if (value > max2 || value < min2) {
          const n = typeof min2 === "bigint" ? "n" : "";
          let range2;
          {
            if (min2 === 0 || min2 === BigInt(0)) {
              range2 = `>= 0${n} and < 2${n} ** ${(byteLength4 + 1) * 8}${n}`;
            } else {
              range2 = `>= -(2${n} ** ${(byteLength4 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength4 + 1) * 8 - 1}${n}`;
            }
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range2, value);
        }
        checkBounds(buf, offset2, byteLength4);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length2, type2) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type2);
          throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
        }
        if (length2 < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(
          "offset",
          `>= ${0} and <= ${length2}`,
          value
        );
      }
      const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2) return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string, units) {
        units = units || Infinity;
        let codePoint;
        const length2 = string.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i2 = 0; i2 < length2; ++i2) {
          codePoint = string.charCodeAt(i2);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              } else if (i2 + 1 === length2) {
                if ((units -= 3) > -1) bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0) break;
            bytes.push(
              codePoint >> 6 | 192,
              codePoint & 63 | 128
            );
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0) break;
            bytes.push(
              codePoint >> 12 | 224,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0) break;
            bytes.push(
              codePoint >> 18 | 240,
              codePoint >> 12 & 63 | 128,
              codePoint >> 6 & 63 | 128,
              codePoint & 63 | 128
            );
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          byteArray.push(str.charCodeAt(i2) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c2, hi, lo;
        const byteArray = [];
        for (let i2 = 0; i2 < str.length; ++i2) {
          if ((units -= 2) < 0) break;
          c2 = str.charCodeAt(i2);
          hi = c2 >> 8;
          lo = c2 % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base64.toByteArray(base64clean(str));
      }
      function blitBuffer(src, dst, offset2, length2) {
        let i2;
        for (i2 = 0; i2 < length2; ++i2) {
          if (i2 + offset2 >= dst.length || i2 >= src.length) break;
          dst[i2 + offset2] = src[i2];
        }
        return i2;
      }
      function isInstance(obj, type2) {
        return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      const hexSliceLookupTable = (function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i2 = 0; i2 < 16; ++i2) {
          const i16 = i2 * 16;
          for (let j2 = 0; j2 < 16; ++j2) {
            table[i16 + j2] = alphabet[i2] + alphabet[j2];
          }
        }
        return table;
      })();
      function defineBigIntMethod(fn2) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn2;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    })(buffer2);
    const Buffer3 = buffer2.Buffer;
    exports2.Blob = buffer2.Blob;
    exports2.BlobOptions = buffer2.BlobOptions;
    exports2.Buffer = buffer2.Buffer;
    exports2.File = buffer2.File;
    exports2.FileOptions = buffer2.FileOptions;
    exports2.INSPECT_MAX_BYTES = buffer2.INSPECT_MAX_BYTES;
    exports2.SlowBuffer = buffer2.SlowBuffer;
    exports2.TranscodeEncoding = buffer2.TranscodeEncoding;
    exports2.atob = buffer2.atob;
    exports2.btoa = buffer2.btoa;
    exports2.constants = buffer2.constants;
    exports2.default = Buffer3;
    exports2.isAscii = buffer2.isAscii;
    exports2.isUtf8 = buffer2.isUtf8;
    exports2.kMaxLength = buffer2.kMaxLength;
    exports2.kStringMaxLength = buffer2.kStringMaxLength;
    exports2.resolveObjectURL = buffer2.resolveObjectURL;
    exports2.transcode = buffer2.transcode;
  })(dist);
  return dist;
}
var util = {};
var types = {};
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _2 in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs$1;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs$1;
  hasRequiredAbs = 1;
  abs$1 = Math.abs;
  return abs$1;
}
var floor$2;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor$2;
  hasRequiredFloor = 1;
  floor$2 = Math.floor;
  return floor$2;
}
var max$3;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max$3;
  hasRequiredMax = 1;
  max$3 = Math.max;
  return max$3;
}
var min$3;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min$3;
  hasRequiredMin = 1;
  min$3 = Math.min;
  return min$3;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round$2;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round$2;
  hasRequiredRound = 1;
  round$2 = Math.round;
  return round$2;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b2) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j2 = 0; j2 < b2.length; j2 += 1) {
      arr[j2 + a.length] = b2[j2];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset2) {
    var arr = [];
    for (var i = offset2, j2 = 0; i < arrLike.length; i += 1, j2 += 1) {
      arr[j2] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers;
}
var get$1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get$1;
  hasRequiredGet = 1;
  var callBind2 = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get$1 = desc && typeof desc.get === "function" ? callBind2([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    (function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    })
  ) : false;
  return get$1;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O2) {
    return reflectGetProto(O2);
  } : originalGetProto ? function getProto2(O2) {
    if (!O2 || typeof O2 !== "object" && typeof O2 !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O2);
  } : getDunderProto ? function getProto2(O2) {
    return getDunderProto(O2);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call2 = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call2, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? (function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  })() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn2 = doEval2("%AsyncGeneratorFunction%");
      if (fn2) {
        value = fn2.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar2 = /\\(\\)?/g;
  var stringToPath2 = function stringToPath22(string) {
    var first2 = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first2 === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName2, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar2, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath2(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first2 = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first2 === '"' || first2 === "'" || first2 === "`" || (last === '"' || last === "'" || last === "`")) && first2 !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void undefined$1;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var callBindBasic = requireCallBindApplyHelpers();
  var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
  callBound = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = (
      /** @type {(this: unknown, ...args: unknown[]) => unknown} */
      GetIntrinsic(name, !!allowMissing)
    );
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBindBasic(
        /** @type {const} */
        [intrinsic]
      );
    }
    return intrinsic;
  };
  return callBound;
}
var isArguments$1;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments$1;
  hasRequiredIsArguments = 1;
  var hasToStringTag = requireShams()();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var $toString = callBound2("Object.prototype.toString");
  var isStandardArguments = function isArguments2(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments2(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = (function() {
    return isStandardArguments(arguments);
  })();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  isArguments$1 = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  return isArguments$1;
}
var isRegex;
var hasRequiredIsRegex;
function requireIsRegex() {
  if (hasRequiredIsRegex) return isRegex;
  hasRequiredIsRegex = 1;
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var hasToStringTag = requireShams()();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var fn2;
  if (hasToStringTag) {
    var $exec = callBound2("RegExp.prototype.exec");
    var isRegexMarker = {};
    var throwRegexMarker = function() {
      throw isRegexMarker;
    };
    var badStringifier = {
      toString: throwRegexMarker,
      valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === "symbol") {
      badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
    fn2 = function isRegex2(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      var descriptor = (
        /** @type {NonNullable<typeof gOPD>} */
        gOPD2(
          /** @type {{ lastIndex?: unknown }} */
          value,
          "lastIndex"
        )
      );
      var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
      if (!hasLastIndexDataProperty) {
        return false;
      }
      try {
        $exec(
          value,
          /** @type {string} */
          /** @type {unknown} */
          badStringifier
        );
      } catch (e) {
        return e === isRegexMarker;
      }
    };
  } else {
    var $toString = callBound2("Object.prototype.toString");
    var regexClass = "[object RegExp]";
    fn2 = function isRegex2(value) {
      if (!value || typeof value !== "object" && typeof value !== "function") {
        return false;
      }
      return $toString(value) === regexClass;
    };
  }
  isRegex = fn2;
  return isRegex;
}
var safeRegexTest;
var hasRequiredSafeRegexTest;
function requireSafeRegexTest() {
  if (hasRequiredSafeRegexTest) return safeRegexTest;
  hasRequiredSafeRegexTest = 1;
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var isRegex2 = requireIsRegex();
  var $exec = callBound2("RegExp.prototype.exec");
  var $TypeError = /* @__PURE__ */ requireType();
  safeRegexTest = function regexTester(regex) {
    if (!isRegex2(regex)) {
      throw new $TypeError("`regex` must be a RegExp");
    }
    return function test(s) {
      return $exec(regex, s) !== null;
    };
  };
  return safeRegexTest;
}
var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var safeRegexTest2 = /* @__PURE__ */ requireSafeRegexTest();
  var isFnRegex = safeRegexTest2(/^\s*(?:function)?\*/);
  var hasToStringTag = requireShams()();
  var getProto2 = requireGetProto();
  var toStr = callBound2("Object.prototype.toString");
  var fnToStr = callBound2("Function.prototype.toString");
  var getGeneratorFunc = function() {
    if (!hasToStringTag) {
      return false;
    }
    try {
      return Function("return function*() {}")();
    } catch (e) {
    }
  };
  var GeneratorFunction;
  isGeneratorFunction = function isGeneratorFunction2(fn2) {
    if (typeof fn2 !== "function") {
      return false;
    }
    if (isFnRegex(fnToStr(fn2))) {
      return true;
    }
    if (!hasToStringTag) {
      var str = toStr(fn2);
      return str === "[object GeneratorFunction]";
    }
    if (!getProto2) {
      return false;
    }
    if (typeof GeneratorFunction === "undefined") {
      var generatorFunc = getGeneratorFunc();
      GeneratorFunction = generatorFunc ? (
        /** @type {GeneratorFunctionConstructor} */
        getProto2(generatorFunc)
      ) : false;
    }
    return getProto2(fn2) === GeneratorFunction;
  };
  return isGeneratorFunction;
}
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  var fnToStr = Function.prototype.toString;
  var reflectApply2 = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
  var badArrayLike;
  var isCallableMarker;
  if (typeof reflectApply2 === "function" && typeof Object.defineProperty === "function") {
    try {
      badArrayLike = Object.defineProperty({}, "length", {
        get: function() {
          throw isCallableMarker;
        }
      });
      isCallableMarker = {};
      reflectApply2(function() {
        throw 42;
      }, null, badArrayLike);
    } catch (_2) {
      if (_2 !== isCallableMarker) {
        reflectApply2 = null;
      }
    }
  } else {
    reflectApply2 = null;
  }
  var constructorRegex = /^\s*class\b/;
  var isES6ClassFn = function isES6ClassFunction(value) {
    try {
      var fnStr = fnToStr.call(value);
      return constructorRegex.test(fnStr);
    } catch (e) {
      return false;
    }
  };
  var tryFunctionObject = function tryFunctionToStr(value) {
    try {
      if (isES6ClassFn(value)) {
        return false;
      }
      fnToStr.call(value);
      return true;
    } catch (e) {
      return false;
    }
  };
  var toStr = Object.prototype.toString;
  var objectClass = "[object Object]";
  var fnClass = "[object Function]";
  var genClass = "[object GeneratorFunction]";
  var ddaClass = "[object HTMLAllCollection]";
  var ddaClass2 = "[object HTML document.all class]";
  var ddaClass3 = "[object HTMLCollection]";
  var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
  var isIE68 = !(0 in [,]);
  var isDDA = function isDocumentDotAll() {
    return false;
  };
  if (typeof document === "object") {
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) {
      isDDA = function isDocumentDotAll(value) {
        if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
          try {
            var str = toStr.call(value);
            return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
          } catch (e) {
          }
        }
        return false;
      };
    }
  }
  isCallable = reflectApply2 ? function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    try {
      reflectApply2(value, null, badArrayLike);
    } catch (e) {
      if (e !== isCallableMarker) {
        return false;
      }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
  } : function isCallable2(value) {
    if (isDDA(value)) {
      return true;
    }
    if (!value) {
      return false;
    }
    if (typeof value !== "function" && typeof value !== "object") {
      return false;
    }
    if (hasToStringTag) {
      return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
      return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
      return false;
    }
    return tryFunctionObject(value);
  };
  return isCallable;
}
var forEach;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach) return forEach;
  hasRequiredForEach = 1;
  var isCallable2 = requireIsCallable();
  var toStr = Object.prototype.toString;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var forEachArray = function forEachArray2(array, iterator, receiver) {
    for (var i = 0, len = array.length; i < len; i++) {
      if (hasOwnProperty2.call(array, i)) {
        if (receiver == null) {
          iterator(array[i], i, array);
        } else {
          iterator.call(receiver, array[i], i, array);
        }
      }
    }
  };
  var forEachString = function forEachString2(string, iterator, receiver) {
    for (var i = 0, len = string.length; i < len; i++) {
      if (receiver == null) {
        iterator(string.charAt(i), i, string);
      } else {
        iterator.call(receiver, string.charAt(i), i, string);
      }
    }
  };
  var forEachObject = function forEachObject2(object, iterator, receiver) {
    for (var k in object) {
      if (hasOwnProperty2.call(object, k)) {
        if (receiver == null) {
          iterator(object[k], k, object);
        } else {
          iterator.call(receiver, object[k], k, object);
        }
      }
    }
  };
  function isArray2(x) {
    return toStr.call(x) === "[object Array]";
  }
  forEach = function forEach22(list, iterator, thisArg) {
    if (!isCallable2(iterator)) {
      throw new TypeError("iterator must be a function");
    }
    var receiver;
    if (arguments.length >= 3) {
      receiver = thisArg;
    }
    if (isArray2(list)) {
      forEachArray(list, iterator, receiver);
    } else if (typeof list === "string") {
      forEachString(list, iterator, receiver);
    } else {
      forEachObject(list, iterator, receiver);
    }
  };
  return forEach;
}
var possibleTypedArrayNames;
var hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  if (hasRequiredPossibleTypedArrayNames) return possibleTypedArrayNames;
  hasRequiredPossibleTypedArrayNames = 1;
  possibleTypedArrayNames = [
    "Float16Array",
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ];
  return possibleTypedArrayNames;
}
var availableTypedArrays;
var hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var possibleNames = /* @__PURE__ */ requirePossibleTypedArrayNames();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  availableTypedArrays = function availableTypedArrays2() {
    var out = [];
    for (var i = 0; i < possibleNames.length; i++) {
      if (typeof g[possibleNames[i]] === "function") {
        out[out.length] = possibleNames[i];
      }
    }
    return out;
  };
  return availableTypedArrays;
}
var callBind = { exports: {} };
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var gopd2 = /* @__PURE__ */ requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property2, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property2 !== "string" && typeof property2 !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd2 && gopd2(obj, property2);
    if ($defineProperty) {
      $defineProperty(obj, property2, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property2] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var define = /* @__PURE__ */ requireDefineDataProperty();
  var hasDescriptors = /* @__PURE__ */ requireHasPropertyDescriptors()();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var $TypeError = /* @__PURE__ */ requireType();
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn2, length2) {
    if (typeof fn2 !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length2 !== "number" || length2 < 0 || length2 > 4294967295 || $floor(length2) !== length2) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn2 && gOPD2) {
      var desc = gOPD2(fn2, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(
          /** @type {Parameters<define>[0]} */
          fn2,
          "length",
          length2,
          true,
          true
        );
      } else {
        define(
          /** @type {Parameters<define>[0]} */
          fn2,
          "length",
          length2
        );
      }
    }
    return fn2;
  };
  return setFunctionLength;
}
var applyBind;
var hasRequiredApplyBind;
function requireApplyBind() {
  if (hasRequiredApplyBind) return applyBind;
  hasRequiredApplyBind = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var actualApply2 = requireActualApply();
  applyBind = function applyBind2() {
    return actualApply2(bind2, $apply, arguments);
  };
  return applyBind;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind) return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module2) {
    var setFunctionLength2 = /* @__PURE__ */ requireSetFunctionLength();
    var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
    var callBindBasic = requireCallBindApplyHelpers();
    var applyBind2 = requireApplyBind();
    module2.exports = function callBind2(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength2(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind2 });
    } else {
      module2.exports.apply = applyBind2;
    }
  })(callBind);
  return callBind.exports;
}
var whichTypedArray;
var hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray) return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var forEach22 = requireForEach();
  var availableTypedArrays2 = /* @__PURE__ */ requireAvailableTypedArrays();
  var callBind2 = requireCallBind();
  var callBound2 = /* @__PURE__ */ requireCallBound();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var getProto2 = requireGetProto();
  var $toString = callBound2("Object.prototype.toString");
  var hasToStringTag = requireShams()();
  var g = typeof globalThis === "undefined" ? commonjsGlobal : globalThis;
  var typedArrays = availableTypedArrays2();
  var $slice = callBound2("String.prototype.slice");
  var $indexOf = callBound2("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for (var i = 0; i < array.length; i += 1) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  };
  var cache2 = { __proto__: null };
  if (hasToStringTag && gOPD2 && getProto2) {
    forEach22(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      if (Symbol.toStringTag in arr && getProto2) {
        var proto = getProto2(arr);
        var descriptor = gOPD2(proto, Symbol.toStringTag);
        if (!descriptor && proto) {
          var superProto = getProto2(proto);
          descriptor = gOPD2(superProto, Symbol.toStringTag);
        }
        cache2["$" + typedArray] = callBind2(descriptor.get);
      }
    });
  } else {
    forEach22(typedArrays, function(typedArray) {
      var arr = new g[typedArray]();
      var fn2 = arr.slice || arr.set;
      if (fn2) {
        cache2[
          /** @type {`$${import('.').TypedArrayName}`} */
          "$" + typedArray
        ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
        // @ts-expect-error TODO FIXME
        callBind2(fn2);
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var found2 = false;
    forEach22(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      cache2,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, typedArray) {
        if (!found2) {
          try {
            if ("$" + getter(value) === typedArray) {
              found2 = /** @type {import('.').TypedArrayName} */
              $slice(typedArray, 1);
            }
          } catch (e) {
          }
        }
      }
    );
    return found2;
  };
  var trySlices = function tryAllSlices(value) {
    var found2 = false;
    forEach22(
      /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
      cache2,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(getter, name) {
        if (!found2) {
          try {
            getter(value);
            found2 = /** @type {import('.').TypedArrayName} */
            $slice(name, 1);
          } catch (e) {
          }
        }
      }
    );
    return found2;
  };
  whichTypedArray = function whichTypedArray2(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag) {
      var tag = $slice($toString(value), 8, -1);
      if ($indexOf(typedArrays, tag) > -1) {
        return tag;
      }
      if (tag !== "Object") {
        return false;
      }
      return trySlices(value);
    }
    if (!gOPD2) {
      return null;
    }
    return tryTypedArrays(value);
  };
  return whichTypedArray;
}
var isTypedArray$1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray) return isTypedArray$1;
  hasRequiredIsTypedArray = 1;
  var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
  isTypedArray$1 = function isTypedArray2(value) {
    return !!whichTypedArray2(value);
  };
  return isTypedArray$1;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  (function(exports2) {
    var isArgumentsObject = /* @__PURE__ */ requireIsArguments();
    var isGeneratorFunction2 = requireIsGeneratorFunction();
    var whichTypedArray2 = /* @__PURE__ */ requireWhichTypedArray();
    var isTypedArray2 = /* @__PURE__ */ requireIsTypedArray();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    if (SymbolSupported) {
      var symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction2;
    exports2.isTypedArray = isTypedArray2;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports2.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray2(value) || isDataView(value);
    }
    exports2.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray2(value) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray2(value) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray2(value) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray2(value) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray2(value) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray2(value) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray2(value) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray2(value) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray2(value) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray2(value) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray2(value) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports2, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  })(types);
  return types;
}
var isBufferBrowser;
var hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  if (hasRequiredIsBufferBrowser) return isBufferBrowser;
  hasRequiredIsBufferBrowser = 1;
  isBufferBrowser = function isBuffer2(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
  };
  return isBufferBrowser;
}
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  (function(exports2) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys2 = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys2.length; i++) {
        descriptors[keys2[i]] = Object.getOwnPropertyDescriptor(obj, keys2[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%") return "%";
        if (i >= len) return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_2) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject2(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn2, msg2) {
      if (typeof process$1$1 !== "undefined" && process$1$1.noDeprecation === true) {
        return fn2;
      }
      if (typeof process$1$1 === "undefined") {
        return function() {
          return exports2.deprecate(fn2, msg2).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process$1$1.throwDeprecation) {
            throw new Error(msg2);
          } else if (process$1$1.traceDeprecation) {
            console.trace(msg2);
          } else {
            console.error(msg2);
          }
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process$1$1.env.NODE_DEBUG) {
      var debugEnv = process$1$1.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    exports2.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process$1$1.pid;
          debugs[set] = function() {
            var msg2 = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set, pid, msg2);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx2 = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx2.depth = arguments[2];
      if (arguments.length >= 4) ctx2.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx2.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx2, opts);
      }
      if (isUndefined(ctx2.showHidden)) ctx2.showHidden = false;
      if (isUndefined(ctx2.depth)) ctx2.depth = 2;
      if (isUndefined(ctx2.colors)) ctx2.colors = false;
      if (isUndefined(ctx2.customInspect)) ctx2.customInspect = true;
      if (ctx2.colors) ctx2.stylize = stylizeWithColor;
      return formatValue(ctx2, obj, ctx2.depth);
    }
    exports2.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style2 = inspect.styles[styleType];
      if (style2) {
        return "\x1B[" + inspect.colors[style2][0] + "m" + str + "\x1B[" + inspect.colors[style2][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash2 = {};
      array.forEach(function(val, idx) {
        hash2[val] = true;
      });
      return hash2;
    }
    function formatValue(ctx2, value, recurseTimes) {
      if (ctx2.customInspect && value && isFunction2(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx2);
        if (!isString(ret)) {
          ret = formatValue(ctx2, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx2, value);
      if (primitive) {
        return primitive;
      }
      var keys2 = Object.keys(value);
      var visibleKeys = arrayToHash(keys2);
      if (ctx2.showHidden) {
        keys2 = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys2.indexOf("message") >= 0 || keys2.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys2.length === 0) {
        if (isFunction2(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx2.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp2(value)) {
          return ctx2.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx2.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base2 = "", array = false, braces = ["{", "}"];
      if (isArray2(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction2(value)) {
        var n = value.name ? ": " + value.name : "";
        base2 = " [Function" + n + "]";
      }
      if (isRegExp2(value)) {
        base2 = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base2 = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base2 = " " + formatError(value);
      }
      if (keys2.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base2 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp2(value)) {
          return ctx2.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx2.stylize("[Object]", "special");
        }
      }
      ctx2.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx2, value, recurseTimes, visibleKeys, keys2);
      } else {
        output = keys2.map(function(key) {
          return formatProperty(ctx2, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx2.seen.pop();
      return reduceToSingleString(output, base2, braces);
    }
    function formatPrimitive(ctx2, value) {
      if (isUndefined(value))
        return ctx2.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx2.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx2.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx2.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx2.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx2, value, recurseTimes, visibleKeys, keys2) {
      var output = [];
      for (var i = 0, l3 = value.length; i < l3; ++i) {
        if (hasOwnProperty2(value, String(i))) {
          output.push(formatProperty(
            ctx2,
            value,
            recurseTimes,
            visibleKeys,
            String(i),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys2.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx2,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx2, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx2.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx2.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx2.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty2(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx2.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx2, desc.value, null);
          } else {
            str = formatValue(ctx2, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx2.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx2.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx2.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base2, braces) {
      var length2 = output.reduce(function(prev, cur) {
        if (cur.indexOf("\n") >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length2 > 60) {
        return braces[0] + (base2 === "" ? "" : base2 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base2 + " " + output.join(", ") + " " + braces[1];
    }
    exports2.types = requireTypes();
    function isArray2(ar) {
      return Array.isArray(ar);
    }
    exports2.isArray = isArray2;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol2(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol2;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp2(re2) {
      return isObject2(re2) && objectToString2(re2) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp2;
    exports2.types.isRegExp = isRegExp2;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d2) {
      return isObject2(d2) && objectToString2(d2) === "[object Date]";
    }
    exports2.isDate = isDate;
    exports2.types.isDate = isDate;
    function isError(e) {
      return isObject2(e) && (objectToString2(e) === "[object Error]" || e instanceof Error);
    }
    exports2.isError = isError;
    exports2.types.isNativeError = isError;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction2;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = requireIsBufferBrowser();
    function objectToString2(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d2 = /* @__PURE__ */ new Date();
      var time2 = [
        pad(d2.getHours()),
        pad(d2.getMinutes()),
        pad(d2.getSeconds())
      ].join(":");
      return [d2.getDate(), months[d2.getMonth()], time2].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = requireInherits_browser();
    exports2._extend = function(origin, add) {
      if (!add || !isObject2(add)) return origin;
      var keys2 = Object.keys(add);
      var i = keys2.length;
      while (i--) {
        origin[keys2[i]] = add[keys2[i]];
      }
      return origin;
    };
    function hasOwnProperty2(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn2 = original[kCustomPromisifiedSymbol];
        if (typeof fn2 !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
          value: fn2,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn2;
      }
      function fn2() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn2, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
        value: fn2,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn2,
        getOwnPropertyDescriptors(original)
      );
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process$1$1.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process$1$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports2.callbackify = callbackify;
  })(util);
  return util;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  var _require = requireDist(), Buffer3 = _require.Buffer;
  var _require2 = requireUtil(), inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset2) {
    Buffer3.prototype.copy.call(src, target, offset2);
  }
  buffer_list = /* @__PURE__ */ (function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v2) {
        var entry = {
          data: v2,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v2) {
        var entry = {
          data: v2,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift2() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0) return Buffer3.alloc(0);
        var ret = Buffer3.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first2() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c2 = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c2;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer3.allocUnsafe(n);
        var p = this.head;
        var c2 = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c2;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c2;
        }
        this.length -= c2;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  })();
  return buffer_list;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
  }
  destroy_1 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1;
}
var errorsBrowser = {};
var hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var codes = {};
  function createErrorType(code2, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ (function(_Base) {
      _inheritsLoose(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
      }
      return NodeError2;
    })(Base);
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code2;
    codes[code2] = NodeError;
  }
  function oneOf2(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i) {
        return String(i);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search2, pos) {
    return str.substr(0, search2.length) === search2;
  }
  function endsWith(str, search2, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search2.length, this_len) === search2;
  }
  function includes(str, search2, start2) {
    if (typeof start2 !== "number") {
      start2 = 0;
    }
    if (start2 + search2.length > str.length) {
      return false;
    } else {
      return str.indexOf(search2, start2) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg2;
    if (endsWith(name, " argument")) {
      msg2 = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf2(expected, "type"));
    } else {
      var type2 = includes(name, ".") ? "property" : "argument";
      msg2 = 'The "'.concat(name, '" ').concat(type2, " ").concat(determiner, " ").concat(oneOf2(expected, "type"));
    }
    msg2 += ". Received type ".concat(typeof actual);
    return msg2;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errorsBrowser.codes = codes;
  return errorsBrowser;
}
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
var browser;
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser;
  hasRequiredBrowser = 1;
  browser = deprecate;
  function deprecate(fn2, msg2) {
    if (config("noDeprecation")) {
      return fn2;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg2);
        } else if (config("traceDeprecation")) {
          console.trace(msg2);
        } else {
          console.warn(msg2);
        }
        warned = true;
      }
      return fn2.apply(this, arguments);
    }
    return deprecated;
  }
  function config(name) {
    try {
      if (!commonjsGlobal.localStorage) return false;
    } catch (_2) {
      return false;
    }
    var val = commonjsGlobal.localStorage[name];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
  }
  return browser;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireBrowser()
  };
  var Stream = requireStreamBrowser();
  var Buffer3 = requireDist().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  requireInherits_browser()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1$1.nextTick(cb, er);
  }
  function validChunk(stream, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer3.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer3.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream._writev(chunk, state2.onwrite);
    else stream._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream, state2, sync, er, cb) {
    --state2.pendingcb;
    if (sync) {
      process$1$1.nextTick(cb, er);
      process$1$1.nextTick(finishMaybe, stream, state2);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream, er) {
    var state2 = stream._writableState;
    var sync = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream, state2, sync, er, cb);
    else {
      var finished = needFinish(state2) || stream.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream, state2);
      }
      if (sync) {
        process$1$1.nextTick(afterWrite2, stream, state2, finished, cb);
      } else {
        afterWrite2(stream, state2, finished, cb);
      }
    }
  }
  function afterWrite2(stream, state2, finished, cb) {
    if (!finished) onwriteDrain(stream, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream, state2);
  }
  function onwriteDrain(stream, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l3 = state2.bufferedRequestCount;
      var buffer2 = new Array(l3);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state2, true, state2.length, buffer2, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream, state2) {
    stream._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state2.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state2);
    });
  }
  function prefinish(stream, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process$1$1.nextTick(callFinal, stream, state2);
      } else {
        state2.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state2, cb) {
    state2.ending = true;
    finishMaybe(stream, state2);
    if (cb) {
      if (state2.finished) process$1$1.nextTick(cb);
      else stream.once("finish", cb);
    }
    state2.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys3 = [];
    for (var key in obj) keys3.push(key);
    return keys3;
  };
  _stream_duplex = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  requireInherits_browser()(Duplex, Readable);
  {
    var keys2 = objectKeys(Writable.prototype);
    for (var v2 = 0; v2 < keys2.length; v2++) {
      var method = keys2[v2];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process$1$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex;
}
var string_decoder = {};
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module2, exports2) {
    var buffer2 = requireDist();
    var Buffer3 = buffer2.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length2) {
      return Buffer3(arg, encodingOrOffset, length2);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length2) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length2);
    };
    SafeBuffer.alloc = function(size2, fill, encoding) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size2);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size2);
    };
    SafeBuffer.allocUnsafeSlow = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size2);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer3 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer3.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer3.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer3.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r2;
    var i;
    if (this.lastNeed) {
      r2 = this.fillLast(buf);
      if (r2 === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r2 ? r2 + this.text(buf, i) : this.text(buf, i);
    return r2 || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j2 = buf.length - 1;
    if (j2 < i) return 0;
    var nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j2 < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j2 < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j2]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "�";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "�";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "�";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r2 = utf8CheckExtraBytes(this, buf);
    if (r2 !== void 0) return r2;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end2 = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end2);
    return buf.toString("utf8", i, end2);
  }
  function utf8End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r2 + "�";
    return r2;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r2 = buf.toString("utf16le", i);
      if (r2) {
        var c2 = r2.charCodeAt(r2.length - 1);
        if (c2 >= 55296 && c2 <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r2.slice(0, -1);
        }
      }
      return r2;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end2 = this.lastTotal - this.lastNeed;
      return r2 + this.lastChar.toString("utf16le", 0, end2);
    }
    return r2;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r2 = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r2 + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r2;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once(callback || noop2);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  endOfStream = eos;
  return endOfStream;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = requireEndOfStream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process$1$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var fromBrowser;
var hasRequiredFromBrowser;
function requireFromBrowser() {
  if (hasRequiredFromBrowser) return fromBrowser;
  hasRequiredFromBrowser = 1;
  fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return fromBrowser;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  _stream_readable = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  requireEvents().EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStreamBrowser();
  var Buffer3 = requireDist().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = requireUtil();
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = requireBuffer_list();
  var destroyImpl = requireDestroy();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrorsBrowser().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from2;
  requireInherits_browser()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn2) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn2);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn2);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn2);
    else emitter._events[event] = [fn2, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable)) return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer3.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream, state2, chunk, false);
            else maybeReadMore(stream, state2);
          } else {
            addChunk(stream, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state2) {
    debug("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state2 = stream._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process$1$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state2 = stream._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process$1$1.nextTick(maybeReadMore_, stream, state2);
    }
  }
  function maybeReadMore_(stream, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1$1.stdout && dest !== process$1$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process$1$1.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state2.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state2.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var index2 = indexOf(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn2) {
    var res = Stream.prototype.on.call(this, ev, fn2);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process$1$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn2) {
    var res = Stream.prototype.removeListener.call(this, ev, fn2);
    if (ev === "readable") {
      process$1$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process$1$1.nextTick(resume_, stream, state2);
    }
  }
  function resume_(stream, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream.read(0);
    }
    state2.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state2.flowing && !state2.reading) stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state2 = stream._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream.read() !== null) ;
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = /* @__PURE__ */ (function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        })(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      return this._readableState.flowing;
    },
    set: function set(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get22() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state2 = stream._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process$1$1.nextTick(endReadableNT, state2, stream);
    }
  }
  function endReadableNT(state2, stream) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state2.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from2 === void 0) {
        from2 = requireFromBrowser();
      }
      return from2(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l3 = xs.length; i < l3; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform2;
  var _require$codes = requireErrorsBrowser().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  requireInherits_browser()(Transform2, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform2(options) {
    if (!(this instanceof Transform2)) return new Transform2(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform2.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform2.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform2.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform2.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform2.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough;
  var Transform2 = require_stream_transform();
  requireInherits_browser()(PassThrough, Transform2);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform2.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrorsBrowser().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err) throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call2(fn2) {
    fn2();
  }
  function pipe(from2, to) {
    return from2.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop2;
    if (typeof streams[streams.length - 1] !== "function") return noop2;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error) error = err;
        if (err) destroys.forEach(call2);
        if (reading) return;
        destroys.forEach(call2);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
var streamBrowserify;
var hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify) return streamBrowserify;
  hasRequiredStreamBrowserify = 1;
  streamBrowserify = Stream;
  var EE = requireEvents().EventEmitter;
  var inherits = requireInherits_browser();
  inherits(Stream, EE);
  Stream.Readable = require_stream_readable();
  Stream.Writable = require_stream_writable();
  Stream.Duplex = require_stream_duplex();
  Stream.Transform = require_stream_transform();
  Stream.PassThrough = require_stream_passthrough();
  Stream.finished = requireEndOfStream();
  Stream.pipeline = requirePipeline();
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return streamBrowserify;
}
var hasRequiredSax;
function requireSax() {
  if (hasRequiredSax) return sax;
  hasRequiredSax = 1;
  (function(exports2) {
    (function(sax2) {
      sax2.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax2.SAXParser = SAXParser;
      sax2.SAXStream = SAXStream;
      sax2.createStream = createStream;
      sax2.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax2.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax2.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S2.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax2.XML_ENTITIES) : Object.create(sax2.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        if (parser.opt.unquotedAttributeValues === void 0) {
          parser.opt.unquotedAttributeValues = !strict;
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F2() {
          }
          F2.prototype = o;
          var newf = new F2();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax2.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l3 = buffers.length; i < l3; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m2 = sax2.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m2 + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l3 = buffers.length; i < l3; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end2(this);
        },
        write: write2,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var Stream;
      try {
        Stream = requireStreamBrowserify().Stream;
      } catch (ex) {
        Stream = function() {
        };
      }
      if (!Stream) Stream = function() {
      };
      var streamWraps = sax2.EVENTS.filter(function(ev) {
        return ev !== "error" && ev !== "end";
      });
      function createStream(strict, opt) {
        return new SAXStream(strict, opt);
      }
      function SAXStream(strict, opt) {
        if (!(this instanceof SAXStream)) {
          return new SAXStream(strict, opt);
        }
        Stream.apply(this);
        this._parser = new SAXParser(strict, opt);
        this.writable = true;
        this.readable = true;
        var me = this;
        this._parser.onend = function() {
          me.emit("end");
        };
        this._parser.onerror = function(er) {
          me.emit("error", er);
          me._parser.error = null;
        };
        this._decoder = null;
        streamWraps.forEach(function(ev) {
          Object.defineProperty(me, "on" + ev, {
            get: function() {
              return me._parser["on" + ev];
            },
            set: function(h2) {
              if (!h2) {
                me.removeAllListeners(ev);
                me._parser["on" + ev] = h2;
                return h2;
              }
              me.on(ev, h2);
            },
            enumerable: true,
            configurable: false
          });
        });
      }
      SAXStream.prototype = Object.create(Stream.prototype, {
        constructor: {
          value: SAXStream
        }
      });
      SAXStream.prototype.write = function(data) {
        if (typeof Buffer2 === "function" && typeof Buffer2.isBuffer === "function" && Buffer2.isBuffer(data)) {
          if (!this._decoder) {
            var SD = requireString_decoder().StringDecoder;
            this._decoder = new SD("utf8");
          }
          data = this._decoder.write(data);
        }
        this._parser.write(data.toString());
        this.emit("data", data);
        return true;
      };
      SAXStream.prototype.end = function(chunk) {
        if (chunk && chunk.length) {
          this.write(chunk);
        }
        this._parser.end();
        return true;
      };
      SAXStream.prototype.on = function(ev, handler) {
        var me = this;
        if (!me._parser["on" + ev] && streamWraps.indexOf(ev) !== -1) {
          me._parser["on" + ev] = function() {
            var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments);
            args.splice(0, 0, ev);
            me.emit.apply(me, args);
          };
        }
        return Stream.prototype.on.call(me, ev, handler);
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c2) {
        return c2 === " " || c2 === "\n" || c2 === "\r" || c2 === "	";
      }
      function isQuote(c2) {
        return c2 === '"' || c2 === "'";
      }
      function isAttribEnd(c2) {
        return c2 === ">" || isWhitespace(c2);
      }
      function isMatch(regex, c2) {
        return regex.test(c2);
      }
      function notMatch(regex, c2) {
        return !isMatch(regex, c2);
      }
      var S2 = 0;
      sax2.STATE = {
        BEGIN: S2++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S2++,
        // leading whitespace
        TEXT: S2++,
        // general stuff
        TEXT_ENTITY: S2++,
        // &amp and such.
        OPEN_WAKA: S2++,
        // <
        SGML_DECL: S2++,
        // <!BLARG
        SGML_DECL_QUOTED: S2++,
        // <!BLARG foo "bar
        DOCTYPE: S2++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S2++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S2++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S2++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S2++,
        // <!-
        COMMENT: S2++,
        // <!--
        COMMENT_ENDING: S2++,
        // <!-- blah -
        COMMENT_ENDED: S2++,
        // <!-- blah --
        CDATA: S2++,
        // <![CDATA[ something
        CDATA_ENDING: S2++,
        // ]
        CDATA_ENDING_2: S2++,
        // ]]
        PROC_INST: S2++,
        // <?hi
        PROC_INST_BODY: S2++,
        // <?hi there
        PROC_INST_ENDING: S2++,
        // <?hi "there" ?
        OPEN_TAG: S2++,
        // <strong
        OPEN_TAG_SLASH: S2++,
        // <strong /
        ATTRIB: S2++,
        // <a
        ATTRIB_NAME: S2++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S2++,
        // <a foo _
        ATTRIB_VALUE: S2++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S2++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S2++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S2++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S2++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S2++,
        // <foo bar=&quot
        CLOSE_TAG: S2++,
        // </a
        CLOSE_TAG_SAW_WHITE: S2++,
        // </a   >
        SCRIPT: S2++,
        // <script> ...
        SCRIPT_ENDING: S2++
        // <script> ... <
      };
      sax2.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax2.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax2.ENTITIES).forEach(function(key) {
        var e = sax2.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax2.ENTITIES[key] = s2;
      });
      for (var s in sax2.STATE) {
        sax2.STATE[sax2.STATE[s]] = s;
      }
      S2 = sax2.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, er) {
        closeText(parser);
        if (parser.trackPosition) {
          er += "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        }
        er = new Error(er);
        parser.error = er;
        emit(parser, "onerror", er);
        return parser;
      }
      function end2(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S2.BEGIN && parser.state !== S2.BEGIN_WHITESPACE && parser.state !== S2.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix2 = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix2 = "xmlns";
          local = "";
        }
        return { prefix: prefix2, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix2 = qn.prefix;
          var local = qn.local;
          if (prefix2 === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l3 = parser.attribList.length; i < l3; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix2 = qualName.prefix;
            var local = qualName.local;
            var uri2 = prefix2 === "" ? "" : tag.ns[prefix2] || "";
            var a = {
              name,
              value,
              prefix: prefix2,
              local,
              uri: uri2
            };
            if (prefix2 && prefix2 !== "xmlns" && !uri2) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix2));
              a.uri = prefix2;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S2.SCRIPT;
          } else {
            parser.state = S2.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S2.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S2.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close2 = parser.tags[t];
          if (close2.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S2.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S2.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c2) {
        if (c2 === "<") {
          parser.state = S2.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c2)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c2;
          parser.state = S2.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write2(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end2(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c2 = "";
        while (true) {
          c2 = charAt(chunk, i++);
          parser.c = c2;
          if (!c2) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c2 === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S2.BEGIN:
              parser.state = S2.BEGIN_WHITESPACE;
              if (c2 === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c2);
              continue;
            case S2.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c2);
              continue;
            case S2.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c2 && c2 !== "<" && c2 !== "&") {
                  c2 = charAt(chunk, i++);
                  if (c2 && parser.trackPosition) {
                    parser.position++;
                    if (c2 === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c2 === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c2) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c2 === "&") {
                  parser.state = S2.TEXT_ENTITY;
                } else {
                  parser.textNode += c2;
                }
              }
              continue;
            case S2.SCRIPT:
              if (c2 === "<") {
                parser.state = S2.SCRIPT_ENDING;
              } else {
                parser.script += c2;
              }
              continue;
            case S2.SCRIPT_ENDING:
              if (c2 === "/") {
                parser.state = S2.CLOSE_TAG;
              } else {
                parser.script += "<" + c2;
                parser.state = S2.SCRIPT;
              }
              continue;
            case S2.OPEN_WAKA:
              if (c2 === "!") {
                parser.state = S2.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c2)) ;
              else if (isMatch(nameStart, c2)) {
                parser.state = S2.OPEN_TAG;
                parser.tagName = c2;
              } else if (c2 === "/") {
                parser.state = S2.CLOSE_TAG;
                parser.tagName = "";
              } else if (c2 === "?") {
                parser.state = S2.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c2 = new Array(pad).join(" ") + c2;
                }
                parser.textNode += "<" + c2;
                parser.state = S2.TEXT;
              }
              continue;
            case S2.SGML_DECL:
              if (parser.sgmlDecl + c2 === "--") {
                parser.state = S2.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
                continue;
              }
              if (parser.doctype && parser.doctype !== true && parser.sgmlDecl) {
                parser.state = S2.DOCTYPE_DTD;
                parser.doctype += "<!" + parser.sgmlDecl + c2;
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c2).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S2.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if ((parser.sgmlDecl + c2).toUpperCase() === DOCTYPE) {
                parser.state = S2.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c2 === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S2.TEXT;
              } else if (isQuote(c2)) {
                parser.state = S2.SGML_DECL_QUOTED;
                parser.sgmlDecl += c2;
              } else {
                parser.sgmlDecl += c2;
              }
              continue;
            case S2.SGML_DECL_QUOTED:
              if (c2 === parser.q) {
                parser.state = S2.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c2;
              continue;
            case S2.DOCTYPE:
              if (c2 === ">") {
                parser.state = S2.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c2;
                if (c2 === "[") {
                  parser.state = S2.DOCTYPE_DTD;
                } else if (isQuote(c2)) {
                  parser.state = S2.DOCTYPE_QUOTED;
                  parser.q = c2;
                }
              }
              continue;
            case S2.DOCTYPE_QUOTED:
              parser.doctype += c2;
              if (c2 === parser.q) {
                parser.q = "";
                parser.state = S2.DOCTYPE;
              }
              continue;
            case S2.DOCTYPE_DTD:
              if (c2 === "]") {
                parser.doctype += c2;
                parser.state = S2.DOCTYPE;
              } else if (c2 === "<") {
                parser.state = S2.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else if (isQuote(c2)) {
                parser.doctype += c2;
                parser.state = S2.DOCTYPE_DTD_QUOTED;
                parser.q = c2;
              } else {
                parser.doctype += c2;
              }
              continue;
            case S2.DOCTYPE_DTD_QUOTED:
              parser.doctype += c2;
              if (c2 === parser.q) {
                parser.state = S2.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S2.COMMENT:
              if (c2 === "-") {
                parser.state = S2.COMMENT_ENDING;
              } else {
                parser.comment += c2;
              }
              continue;
            case S2.COMMENT_ENDING:
              if (c2 === "-") {
                parser.state = S2.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c2;
                parser.state = S2.COMMENT;
              }
              continue;
            case S2.COMMENT_ENDED:
              if (c2 !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c2;
                parser.state = S2.COMMENT;
              } else if (parser.doctype && parser.doctype !== true) {
                parser.state = S2.DOCTYPE_DTD;
              } else {
                parser.state = S2.TEXT;
              }
              continue;
            case S2.CDATA:
              if (c2 === "]") {
                parser.state = S2.CDATA_ENDING;
              } else {
                parser.cdata += c2;
              }
              continue;
            case S2.CDATA_ENDING:
              if (c2 === "]") {
                parser.state = S2.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c2;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.CDATA_ENDING_2:
              if (c2 === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S2.TEXT;
              } else if (c2 === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c2;
                parser.state = S2.CDATA;
              }
              continue;
            case S2.PROC_INST:
              if (c2 === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else if (isWhitespace(c2)) {
                parser.state = S2.PROC_INST_BODY;
              } else {
                parser.procInstName += c2;
              }
              continue;
            case S2.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c2)) {
                continue;
              } else if (c2 === "?") {
                parser.state = S2.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c2;
              }
              continue;
            case S2.PROC_INST_ENDING:
              if (c2 === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S2.TEXT;
              } else {
                parser.procInstBody += "?" + c2;
                parser.state = S2.PROC_INST_BODY;
              }
              continue;
            case S2.OPEN_TAG:
              if (isMatch(nameBody, c2)) {
                parser.tagName += c2;
              } else {
                newTag(parser);
                if (c2 === ">") {
                  openTag(parser);
                } else if (c2 === "/") {
                  parser.state = S2.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c2)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.OPEN_TAG_SLASH:
              if (c2 === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.ATTRIB:
              if (isWhitespace(c2)) {
                continue;
              } else if (c2 === ">") {
                openTag(parser);
              } else if (c2 === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c2)) {
                parser.attribName = c2;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME:
              if (c2 === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (c2 === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c2)) {
                parser.state = S2.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c2)) {
                parser.attribName += c2;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_NAME_SAW_WHITE:
              if (c2 === "=") {
                parser.state = S2.ATTRIB_VALUE;
              } else if (isWhitespace(c2)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c2 === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c2)) {
                  parser.attribName = c2;
                  parser.state = S2.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S2.ATTRIB;
                }
              }
              continue;
            case S2.ATTRIB_VALUE:
              if (isWhitespace(c2)) {
                continue;
              } else if (isQuote(c2)) {
                parser.q = c2;
                parser.state = S2.ATTRIB_VALUE_QUOTED;
              } else {
                if (!parser.opt.unquotedAttributeValues) {
                  error(parser, "Unquoted attribute value");
                }
                parser.state = S2.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c2;
              }
              continue;
            case S2.ATTRIB_VALUE_QUOTED:
              if (c2 !== parser.q) {
                if (c2 === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c2;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S2.ATTRIB_VALUE_CLOSED;
              continue;
            case S2.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c2)) {
                parser.state = S2.ATTRIB;
              } else if (c2 === ">") {
                openTag(parser);
              } else if (c2 === "/") {
                parser.state = S2.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c2)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c2;
                parser.attribValue = "";
                parser.state = S2.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S2.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c2)) {
                if (c2 === "&") {
                  parser.state = S2.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c2;
                }
                continue;
              }
              attrib(parser);
              if (c2 === ">") {
                openTag(parser);
              } else {
                parser.state = S2.ATTRIB;
              }
              continue;
            case S2.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c2)) {
                  continue;
                } else if (notMatch(nameStart, c2)) {
                  if (parser.script) {
                    parser.script += "</" + c2;
                    parser.state = S2.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c2;
                }
              } else if (c2 === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c2)) {
                parser.tagName += c2;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S2.SCRIPT;
              } else {
                if (!isWhitespace(c2)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S2.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S2.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c2)) {
                continue;
              }
              if (c2 === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S2.TEXT_ENTITY:
            case S2.ATTRIB_VALUE_ENTITY_Q:
            case S2.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer2;
              switch (parser.state) {
                case S2.TEXT_ENTITY:
                  returnState = S2.TEXT;
                  buffer2 = "textNode";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S2.ATTRIB_VALUE_QUOTED;
                  buffer2 = "attribValue";
                  break;
                case S2.ATTRIB_VALUE_ENTITY_U:
                  returnState = S2.ATTRIB_VALUE_UNQUOTED;
                  buffer2 = "attribValue";
                  break;
              }
              if (c2 === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.opt.unparsedEntities && !Object.values(sax2.XML_ENTITIES).includes(parsedEntity)) {
                  parser.entity = "";
                  parser.state = returnState;
                  parser.write(parsedEntity);
                } else {
                  parser[buffer2] += parsedEntity;
                  parser.entity = "";
                  parser.state = returnState;
                }
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c2)) {
                parser.entity += c2;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer2] += "&" + parser.entity + c2;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default: {
              throw new Error(parser, "Unknown state: " + parser.state);
            }
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
      /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
      if (!String.fromCodePoint) {
        (function() {
          var stringFromCharCode = String.fromCharCode;
          var floor2 = Math.floor;
          var fromCodePoint = function() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index2 = -1;
            var length2 = arguments.length;
            if (!length2) {
              return "";
            }
            var result = "";
            while (++index2 < length2) {
              var codePoint = Number(arguments[index2]);
              if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
              codePoint < 0 || // not a valid Unicode code point
              codePoint > 1114111 || // not a valid Unicode code point
              floor2(codePoint) !== codePoint) {
                throw RangeError("Invalid code point: " + codePoint);
              }
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index2 + 1 === length2 || codeUnits.length > MAX_SIZE) {
                result += stringFromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          };
          if (Object.defineProperty) {
            Object.defineProperty(String, "fromCodePoint", {
              value: fromCodePoint,
              configurable: true,
              writable: true
            });
          } else {
            String.fromCodePoint = fromCodePoint;
          }
        })();
      }
    })(exports2);
  })(sax);
  return sax;
}
var arrayHelper;
var hasRequiredArrayHelper;
function requireArrayHelper() {
  if (hasRequiredArrayHelper) return arrayHelper;
  hasRequiredArrayHelper = 1;
  arrayHelper = {
    isArray: function(value) {
      if (Array.isArray) {
        return Array.isArray(value);
      }
      return Object.prototype.toString.call(value) === "[object Array]";
    }
  };
  return arrayHelper;
}
var optionsHelper;
var hasRequiredOptionsHelper;
function requireOptionsHelper() {
  if (hasRequiredOptionsHelper) return optionsHelper;
  hasRequiredOptionsHelper = 1;
  var isArray2 = requireArrayHelper().isArray;
  optionsHelper = {
    copyOptions: function(options) {
      var key, copy2 = {};
      for (key in options) {
        if (options.hasOwnProperty(key)) {
          copy2[key] = options[key];
        }
      }
      return copy2;
    },
    ensureFlagExists: function(item, options) {
      if (!(item in options) || typeof options[item] !== "boolean") {
        options[item] = false;
      }
    },
    ensureSpacesExists: function(options) {
      if (!("spaces" in options) || typeof options.spaces !== "number" && typeof options.spaces !== "string") {
        options.spaces = 0;
      }
    },
    ensureAlwaysArrayExists: function(options) {
      if (!("alwaysArray" in options) || typeof options.alwaysArray !== "boolean" && !isArray2(options.alwaysArray)) {
        options.alwaysArray = false;
      }
    },
    ensureKeyExists: function(key, options) {
      if (!(key + "Key" in options) || typeof options[key + "Key"] !== "string") {
        options[key + "Key"] = options.compact ? "_" + key : key;
      }
    },
    checkFnExists: function(key, options) {
      return key + "Fn" in options;
    }
  };
  return optionsHelper;
}
var xml2js;
var hasRequiredXml2js;
function requireXml2js() {
  if (hasRequiredXml2js) return xml2js;
  hasRequiredXml2js = 1;
  var sax2 = requireSax();
  var helper = requireOptionsHelper();
  var isArray2 = requireArrayHelper().isArray;
  var options;
  var currentElement;
  function validateOptions(userOptions) {
    options = helper.copyOptions(userOptions);
    helper.ensureFlagExists("ignoreDeclaration", options);
    helper.ensureFlagExists("ignoreInstruction", options);
    helper.ensureFlagExists("ignoreAttributes", options);
    helper.ensureFlagExists("ignoreText", options);
    helper.ensureFlagExists("ignoreComment", options);
    helper.ensureFlagExists("ignoreCdata", options);
    helper.ensureFlagExists("ignoreDoctype", options);
    helper.ensureFlagExists("compact", options);
    helper.ensureFlagExists("alwaysChildren", options);
    helper.ensureFlagExists("addParent", options);
    helper.ensureFlagExists("trim", options);
    helper.ensureFlagExists("nativeType", options);
    helper.ensureFlagExists("nativeTypeAttributes", options);
    helper.ensureFlagExists("sanitize", options);
    helper.ensureFlagExists("instructionHasAttributes", options);
    helper.ensureFlagExists("captureSpacesBetweenElements", options);
    helper.ensureAlwaysArrayExists(options);
    helper.ensureKeyExists("declaration", options);
    helper.ensureKeyExists("instruction", options);
    helper.ensureKeyExists("attributes", options);
    helper.ensureKeyExists("text", options);
    helper.ensureKeyExists("comment", options);
    helper.ensureKeyExists("cdata", options);
    helper.ensureKeyExists("doctype", options);
    helper.ensureKeyExists("type", options);
    helper.ensureKeyExists("name", options);
    helper.ensureKeyExists("elements", options);
    helper.ensureKeyExists("parent", options);
    helper.checkFnExists("doctype", options);
    helper.checkFnExists("instruction", options);
    helper.checkFnExists("cdata", options);
    helper.checkFnExists("comment", options);
    helper.checkFnExists("text", options);
    helper.checkFnExists("instructionName", options);
    helper.checkFnExists("elementName", options);
    helper.checkFnExists("attributeName", options);
    helper.checkFnExists("attributeValue", options);
    helper.checkFnExists("attributes", options);
    return options;
  }
  function nativeType(value) {
    var nValue = Number(value);
    if (!isNaN(nValue)) {
      return nValue;
    }
    var bValue = value.toLowerCase();
    if (bValue === "true") {
      return true;
    } else if (bValue === "false") {
      return false;
    }
    return value;
  }
  function addField(type2, value) {
    var key;
    if (options.compact) {
      if (!currentElement[options[type2 + "Key"]] && (isArray2(options.alwaysArray) ? options.alwaysArray.indexOf(options[type2 + "Key"]) !== -1 : options.alwaysArray)) {
        currentElement[options[type2 + "Key"]] = [];
      }
      if (currentElement[options[type2 + "Key"]] && !isArray2(currentElement[options[type2 + "Key"]])) {
        currentElement[options[type2 + "Key"]] = [currentElement[options[type2 + "Key"]]];
      }
      if (type2 + "Fn" in options && typeof value === "string") {
        value = options[type2 + "Fn"](value, currentElement);
      }
      if (type2 === "instruction" && ("instructionFn" in options || "instructionNameFn" in options)) {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            if ("instructionFn" in options) {
              value[key] = options.instructionFn(value[key], key, currentElement);
            } else {
              var temp = value[key];
              delete value[key];
              value[options.instructionNameFn(key, temp, currentElement)] = temp;
            }
          }
        }
      }
      if (isArray2(currentElement[options[type2 + "Key"]])) {
        currentElement[options[type2 + "Key"]].push(value);
      } else {
        currentElement[options[type2 + "Key"]] = value;
      }
    } else {
      if (!currentElement[options.elementsKey]) {
        currentElement[options.elementsKey] = [];
      }
      var element = {};
      element[options.typeKey] = type2;
      if (type2 === "instruction") {
        for (key in value) {
          if (value.hasOwnProperty(key)) {
            break;
          }
        }
        element[options.nameKey] = "instructionNameFn" in options ? options.instructionNameFn(key, value, currentElement) : key;
        if (options.instructionHasAttributes) {
          element[options.attributesKey] = value[key][options.attributesKey];
          if ("instructionFn" in options) {
            element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
          }
        } else {
          if ("instructionFn" in options) {
            value[key] = options.instructionFn(value[key], key, currentElement);
          }
          element[options.instructionKey] = value[key];
        }
      } else {
        if (type2 + "Fn" in options) {
          value = options[type2 + "Fn"](value, currentElement);
        }
        element[options[type2 + "Key"]] = value;
      }
      if (options.addParent) {
        element[options.parentKey] = currentElement;
      }
      currentElement[options.elementsKey].push(element);
    }
  }
  function manipulateAttributes(attributes) {
    if ("attributesFn" in options && attributes) {
      attributes = options.attributesFn(attributes, currentElement);
    }
    if ((options.trim || "attributeValueFn" in options || "attributeNameFn" in options || options.nativeTypeAttributes) && attributes) {
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          if (options.trim) attributes[key] = attributes[key].trim();
          if (options.nativeTypeAttributes) {
            attributes[key] = nativeType(attributes[key]);
          }
          if ("attributeValueFn" in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
          if ("attributeNameFn" in options) {
            var temp = attributes[key];
            delete attributes[key];
            attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
          }
        }
      }
    }
    return attributes;
  }
  function onInstruction(instruction) {
    var attributes = {};
    if (instruction.body && (instruction.name.toLowerCase() === "xml" || options.instructionHasAttributes)) {
      var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
      var match;
      while ((match = attrsRegExp.exec(instruction.body)) !== null) {
        attributes[match[1]] = match[2] || match[3] || match[4];
      }
      attributes = manipulateAttributes(attributes);
    }
    if (instruction.name.toLowerCase() === "xml") {
      if (options.ignoreDeclaration) {
        return;
      }
      currentElement[options.declarationKey] = {};
      if (Object.keys(attributes).length) {
        currentElement[options.declarationKey][options.attributesKey] = attributes;
      }
      if (options.addParent) {
        currentElement[options.declarationKey][options.parentKey] = currentElement;
      }
    } else {
      if (options.ignoreInstruction) {
        return;
      }
      if (options.trim) {
        instruction.body = instruction.body.trim();
      }
      var value = {};
      if (options.instructionHasAttributes && Object.keys(attributes).length) {
        value[instruction.name] = {};
        value[instruction.name][options.attributesKey] = attributes;
      } else {
        value[instruction.name] = instruction.body;
      }
      addField("instruction", value);
    }
  }
  function onStartElement(name, attributes) {
    var element;
    if (typeof name === "object") {
      attributes = name.attributes;
      name = name.name;
    }
    attributes = manipulateAttributes(attributes);
    if ("elementNameFn" in options) {
      name = options.elementNameFn(name, currentElement);
    }
    if (options.compact) {
      element = {};
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = {};
        var key;
        for (key in attributes) {
          if (attributes.hasOwnProperty(key)) {
            element[options.attributesKey][key] = attributes[key];
          }
        }
      }
      if (!(name in currentElement) && (isArray2(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)) {
        currentElement[name] = [];
      }
      if (currentElement[name] && !isArray2(currentElement[name])) {
        currentElement[name] = [currentElement[name]];
      }
      if (isArray2(currentElement[name])) {
        currentElement[name].push(element);
      } else {
        currentElement[name] = element;
      }
    } else {
      if (!currentElement[options.elementsKey]) {
        currentElement[options.elementsKey] = [];
      }
      element = {};
      element[options.typeKey] = "element";
      element[options.nameKey] = name;
      if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
        element[options.attributesKey] = attributes;
      }
      if (options.alwaysChildren) {
        element[options.elementsKey] = [];
      }
      currentElement[options.elementsKey].push(element);
    }
    element[options.parentKey] = currentElement;
    currentElement = element;
  }
  function onText(text) {
    if (options.ignoreText) {
      return;
    }
    if (!text.trim() && !options.captureSpacesBetweenElements) {
      return;
    }
    if (options.trim) {
      text = text.trim();
    }
    if (options.nativeType) {
      text = nativeType(text);
    }
    if (options.sanitize) {
      text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    addField("text", text);
  }
  function onComment(comment) {
    if (options.ignoreComment) {
      return;
    }
    if (options.trim) {
      comment = comment.trim();
    }
    addField("comment", comment);
  }
  function onEndElement(name) {
    var parentElement = currentElement[options.parentKey];
    if (!options.addParent) {
      delete currentElement[options.parentKey];
    }
    currentElement = parentElement;
  }
  function onCdata(cdata) {
    if (options.ignoreCdata) {
      return;
    }
    if (options.trim) {
      cdata = cdata.trim();
    }
    addField("cdata", cdata);
  }
  function onDoctype(doctype) {
    if (options.ignoreDoctype) {
      return;
    }
    doctype = doctype.replace(/^ /, "");
    if (options.trim) {
      doctype = doctype.trim();
    }
    addField("doctype", doctype);
  }
  function onError(error) {
    error.note = error;
  }
  xml2js = function(xml, userOptions) {
    var parser = sax2.parser(true, {});
    var result = {};
    currentElement = result;
    options = validateOptions(userOptions);
    {
      parser.opt = { strictEntities: true };
      parser.onopentag = onStartElement;
      parser.ontext = onText;
      parser.oncomment = onComment;
      parser.onclosetag = onEndElement;
      parser.onerror = onError;
      parser.oncdata = onCdata;
      parser.ondoctype = onDoctype;
      parser.onprocessinginstruction = onInstruction;
    }
    {
      parser.write(xml).close();
    }
    if (result[options.elementsKey]) {
      var temp = result[options.elementsKey];
      delete result[options.elementsKey];
      result[options.elementsKey] = temp;
      delete result.text;
    }
    return result;
  };
  return xml2js;
}
var xml2json;
var hasRequiredXml2json;
function requireXml2json() {
  if (hasRequiredXml2json) return xml2json;
  hasRequiredXml2json = 1;
  var helper = requireOptionsHelper();
  var xml2js2 = requireXml2js();
  function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureSpacesExists(options);
    return options;
  }
  xml2json = function(xml, userOptions) {
    var options, js, json, parentKey;
    options = validateOptions(userOptions);
    js = xml2js2(xml, options);
    parentKey = "compact" in options && options.compact ? "_parent" : "parent";
    if ("addParent" in options && options.addParent) {
      json = JSON.stringify(js, function(k, v2) {
        return k === parentKey ? "_" : v2;
      }, options.spaces);
    } else {
      json = JSON.stringify(js, null, options.spaces);
    }
    return json.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
  };
  return xml2json;
}
var js2xml;
var hasRequiredJs2xml;
function requireJs2xml() {
  if (hasRequiredJs2xml) return js2xml;
  hasRequiredJs2xml = 1;
  var helper = requireOptionsHelper();
  var isArray2 = requireArrayHelper().isArray;
  var currentElement, currentElementName;
  function validateOptions(userOptions) {
    var options = helper.copyOptions(userOptions);
    helper.ensureFlagExists("ignoreDeclaration", options);
    helper.ensureFlagExists("ignoreInstruction", options);
    helper.ensureFlagExists("ignoreAttributes", options);
    helper.ensureFlagExists("ignoreText", options);
    helper.ensureFlagExists("ignoreComment", options);
    helper.ensureFlagExists("ignoreCdata", options);
    helper.ensureFlagExists("ignoreDoctype", options);
    helper.ensureFlagExists("compact", options);
    helper.ensureFlagExists("indentText", options);
    helper.ensureFlagExists("indentCdata", options);
    helper.ensureFlagExists("indentAttributes", options);
    helper.ensureFlagExists("indentInstruction", options);
    helper.ensureFlagExists("fullTagEmptyElement", options);
    helper.ensureFlagExists("noQuotesForNativeAttributes", options);
    helper.ensureSpacesExists(options);
    if (typeof options.spaces === "number") {
      options.spaces = Array(options.spaces + 1).join(" ");
    }
    helper.ensureKeyExists("declaration", options);
    helper.ensureKeyExists("instruction", options);
    helper.ensureKeyExists("attributes", options);
    helper.ensureKeyExists("text", options);
    helper.ensureKeyExists("comment", options);
    helper.ensureKeyExists("cdata", options);
    helper.ensureKeyExists("doctype", options);
    helper.ensureKeyExists("type", options);
    helper.ensureKeyExists("name", options);
    helper.ensureKeyExists("elements", options);
    helper.checkFnExists("doctype", options);
    helper.checkFnExists("instruction", options);
    helper.checkFnExists("cdata", options);
    helper.checkFnExists("comment", options);
    helper.checkFnExists("text", options);
    helper.checkFnExists("instructionName", options);
    helper.checkFnExists("elementName", options);
    helper.checkFnExists("attributeName", options);
    helper.checkFnExists("attributeValue", options);
    helper.checkFnExists("attributes", options);
    helper.checkFnExists("fullTagEmptyElement", options);
    return options;
  }
  function writeIndentation(options, depth, firstLine) {
    return (!firstLine && options.spaces ? "\n" : "") + Array(depth + 1).join(options.spaces);
  }
  function writeAttributes(attributes, options, depth) {
    if (options.ignoreAttributes) {
      return "";
    }
    if ("attributesFn" in options) {
      attributes = options.attributesFn(attributes, currentElementName, currentElement);
    }
    var key, attr, attrName, quote, result = [];
    for (key in attributes) {
      if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== void 0) {
        quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== "string" ? "" : '"';
        attr = "" + attributes[key];
        attr = attr.replace(/"/g, "&quot;");
        attrName = "attributeNameFn" in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
        result.push(options.spaces && options.indentAttributes ? writeIndentation(options, depth + 1, false) : " ");
        result.push(attrName + "=" + quote + ("attributeValueFn" in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
      }
    }
    if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
      result.push(writeIndentation(options, depth, false));
    }
    return result.join("");
  }
  function writeDeclaration(declaration, options, depth) {
    currentElement = declaration;
    currentElementName = "xml";
    return options.ignoreDeclaration ? "" : "<?xml" + writeAttributes(declaration[options.attributesKey], options, depth) + "?>";
  }
  function writeInstruction(instruction, options, depth) {
    if (options.ignoreInstruction) {
      return "";
    }
    var key;
    for (key in instruction) {
      if (instruction.hasOwnProperty(key)) {
        break;
      }
    }
    var instructionName = "instructionNameFn" in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
    if (typeof instruction[key] === "object") {
      currentElement = instruction;
      currentElementName = instructionName;
      return "<?" + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + "?>";
    } else {
      var instructionValue = instruction[key] ? instruction[key] : "";
      if ("instructionFn" in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
      return "<?" + instructionName + (instructionValue ? " " + instructionValue : "") + "?>";
    }
  }
  function writeComment(comment, options) {
    return options.ignoreComment ? "" : "<!--" + ("commentFn" in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + "-->";
  }
  function writeCdata(cdata, options) {
    return options.ignoreCdata ? "" : "<![CDATA[" + ("cdataFn" in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace("]]>", "]]]]><![CDATA[>")) + "]]>";
  }
  function writeDoctype(doctype, options) {
    return options.ignoreDoctype ? "" : "<!DOCTYPE " + ("doctypeFn" in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + ">";
  }
  function writeText(text, options) {
    if (options.ignoreText) return "";
    text = "" + text;
    text = text.replace(/&amp;/g, "&");
    text = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return "textFn" in options ? options.textFn(text, currentElementName, currentElement) : text;
  }
  function hasContent(element, options) {
    var i;
    if (element.elements && element.elements.length) {
      for (i = 0; i < element.elements.length; ++i) {
        switch (element.elements[i][options.typeKey]) {
          case "text":
            if (options.indentText) {
              return true;
            }
            break;
          // skip to next key
          case "cdata":
            if (options.indentCdata) {
              return true;
            }
            break;
          // skip to next key
          case "instruction":
            if (options.indentInstruction) {
              return true;
            }
            break;
          // skip to next key
          case "doctype":
          case "comment":
          case "element":
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElement(element, options, depth) {
    currentElement = element;
    currentElementName = element.name;
    var xml = [], elementName = "elementNameFn" in options ? options.elementNameFn(element.name, element) : element.name;
    xml.push("<" + elementName);
    if (element[options.attributesKey]) {
      xml.push(writeAttributes(element[options.attributesKey], options, depth));
    }
    var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
    if (!withClosingTag) {
      if ("fullTagEmptyElementFn" in options) {
        withClosingTag = options.fullTagEmptyElementFn(element.name, element);
      } else {
        withClosingTag = options.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml.push(">");
      if (element[options.elementsKey] && element[options.elementsKey].length) {
        xml.push(writeElements(element[options.elementsKey], options, depth + 1));
        currentElement = element;
        currentElementName = element.name;
      }
      xml.push(options.spaces && hasContent(element, options) ? "\n" + Array(depth + 1).join(options.spaces) : "");
      xml.push("</" + elementName + ">");
    } else {
      xml.push("/>");
    }
    return xml.join("");
  }
  function writeElements(elements, options, depth, firstLine) {
    return elements.reduce(function(xml, element) {
      var indent = writeIndentation(options, depth, firstLine && !xml);
      switch (element.type) {
        case "element":
          return xml + indent + writeElement(element, options, depth);
        case "comment":
          return xml + indent + writeComment(element[options.commentKey], options);
        case "doctype":
          return xml + indent + writeDoctype(element[options.doctypeKey], options);
        case "cdata":
          return xml + (options.indentCdata ? indent : "") + writeCdata(element[options.cdataKey], options);
        case "text":
          return xml + (options.indentText ? indent : "") + writeText(element[options.textKey], options);
        case "instruction":
          var instruction = {};
          instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
          return xml + (options.indentInstruction ? indent : "") + writeInstruction(instruction, options, depth);
      }
    }, "");
  }
  function hasContentCompact(element, options, anyContent) {
    var key;
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        switch (key) {
          case options.parentKey:
          case options.attributesKey:
            break;
          // skip to next key
          case options.textKey:
            if (options.indentText || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.cdataKey:
            if (options.indentCdata || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.instructionKey:
            if (options.indentInstruction || anyContent) {
              return true;
            }
            break;
          // skip to next key
          case options.doctypeKey:
          case options.commentKey:
            return true;
          default:
            return true;
        }
      }
    }
    return false;
  }
  function writeElementCompact(element, name, options, depth, indent) {
    currentElement = element;
    currentElementName = name;
    var elementName = "elementNameFn" in options ? options.elementNameFn(name, element) : name;
    if (typeof element === "undefined" || element === null || element === "") {
      return "fullTagEmptyElementFn" in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? "<" + elementName + "></" + elementName + ">" : "<" + elementName + "/>";
    }
    var xml = [];
    if (name) {
      xml.push("<" + elementName);
      if (typeof element !== "object") {
        xml.push(">" + writeText(element, options) + "</" + elementName + ">");
        return xml.join("");
      }
      if (element[options.attributesKey]) {
        xml.push(writeAttributes(element[options.attributesKey], options, depth));
      }
      var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]["xml:space"] === "preserve";
      if (!withClosingTag) {
        if ("fullTagEmptyElementFn" in options) {
          withClosingTag = options.fullTagEmptyElementFn(name, element);
        } else {
          withClosingTag = options.fullTagEmptyElement;
        }
      }
      if (withClosingTag) {
        xml.push(">");
      } else {
        xml.push("/>");
        return xml.join("");
      }
    }
    xml.push(writeElementsCompact(element, options, depth + 1, false));
    currentElement = element;
    currentElementName = name;
    if (name) {
      xml.push((indent ? writeIndentation(options, depth, false) : "") + "</" + elementName + ">");
    }
    return xml.join("");
  }
  function writeElementsCompact(element, options, depth, firstLine) {
    var i, key, nodes, xml = [];
    for (key in element) {
      if (element.hasOwnProperty(key)) {
        nodes = isArray2(element[key]) ? element[key] : [element[key]];
        for (i = 0; i < nodes.length; ++i) {
          switch (key) {
            case options.declarationKey:
              xml.push(writeDeclaration(nodes[i], options, depth));
              break;
            case options.instructionKey:
              xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : "") + writeInstruction(nodes[i], options, depth));
              break;
            case options.attributesKey:
            case options.parentKey:
              break;
            // skip
            case options.textKey:
              xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : "") + writeText(nodes[i], options));
              break;
            case options.cdataKey:
              xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : "") + writeCdata(nodes[i], options));
              break;
            case options.doctypeKey:
              xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options));
              break;
            case options.commentKey:
              xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options));
              break;
            default:
              xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
          }
          firstLine = firstLine && !xml.length;
        }
      }
    }
    return xml.join("");
  }
  js2xml = function(js, options) {
    options = validateOptions(options);
    var xml = [];
    currentElement = js;
    currentElementName = "_root_";
    if (options.compact) {
      xml.push(writeElementsCompact(js, options, 0, true));
    } else {
      if (js[options.declarationKey]) {
        xml.push(writeDeclaration(js[options.declarationKey], options, 0));
      }
      if (js[options.elementsKey] && js[options.elementsKey].length) {
        xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
      }
    }
    return xml.join("");
  };
  return js2xml;
}
var json2xml;
var hasRequiredJson2xml;
function requireJson2xml() {
  if (hasRequiredJson2xml) return json2xml;
  hasRequiredJson2xml = 1;
  var js2xml2 = requireJs2xml();
  json2xml = function(json, options) {
    if (json instanceof Buffer2) {
      json = json.toString();
    }
    var js = null;
    if (typeof json === "string") {
      try {
        js = JSON.parse(json);
      } catch (e) {
        throw new Error("The JSON structure is invalid");
      }
    } else {
      js = json;
    }
    return js2xml2(js, options);
  };
  return json2xml;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  var xml2js2 = requireXml2js();
  var xml2json2 = requireXml2json();
  var js2xml2 = requireJs2xml();
  var json2xml2 = requireJson2xml();
  lib = {
    xml2js: xml2js2,
    xml2json: xml2json2,
    js2xml: js2xml2,
    json2xml: json2xml2
  };
  return lib;
}
var libExports = requireLib();
const xmljs = /* @__PURE__ */ getDefaultExportFromCjs$1(libExports);
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
var byteToHex = [];
for (var i$2 = 0; i$2 < 256; ++i$2) {
  byteToHex.push((i$2 + 256).toString(16).substr(1));
}
function stringify(arr) {
  var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset2) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return stringify(rnds);
}
var he$3 = { exports: {} };
/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
var he$2 = he$3.exports;
var hasRequiredHe;
function requireHe() {
  if (hasRequiredHe) return he$3.exports;
  hasRequiredHe = 1;
  (function(module2, exports2) {
    (function(root2) {
      var freeExports2 = exports2;
      var freeModule2 = module2 && module2.exports == freeExports2 && module2;
      var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal;
      if (freeGlobal2.global === freeGlobal2 || freeGlobal2.window === freeGlobal2) {
        root2 = freeGlobal2;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var regexAsciiWhitelist = /[\x01-\x7F]/g;
      var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;
      var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
      var encodeMap = { "­": "shy", "‌": "zwnj", "‍": "zwj", "‎": "lrm", "⁣": "ic", "⁢": "it", "⁡": "af", "‏": "rlm", "​": "ZeroWidthSpace", "⁠": "NoBreak", "̑": "DownBreve", "⃛": "tdot", "⃜": "DotDot", "	": "Tab", "\n": "NewLine", " ": "puncsp", " ": "MediumSpace", " ": "thinsp", " ": "hairsp", " ": "emsp13", " ": "ensp", " ": "emsp14", " ": "emsp", " ": "numsp", " ": "nbsp", "  ": "ThickSpace", "‾": "oline", "_": "lowbar", "‐": "dash", "–": "ndash", "—": "mdash", "―": "horbar", ",": "comma", ";": "semi", "⁏": "bsemi", ":": "colon", "⩴": "Colone", "!": "excl", "¡": "iexcl", "?": "quest", "¿": "iquest", ".": "period", "‥": "nldr", "…": "mldr", "·": "middot", "'": "apos", "‘": "lsquo", "’": "rsquo", "‚": "sbquo", "‹": "lsaquo", "›": "rsaquo", '"': "quot", "“": "ldquo", "”": "rdquo", "„": "bdquo", "«": "laquo", "»": "raquo", "(": "lpar", ")": "rpar", "[": "lsqb", "]": "rsqb", "{": "lcub", "}": "rcub", "⌈": "lceil", "⌉": "rceil", "⌊": "lfloor", "⌋": "rfloor", "⦅": "lopar", "⦆": "ropar", "⦋": "lbrke", "⦌": "rbrke", "⦍": "lbrkslu", "⦎": "rbrksld", "⦏": "lbrksld", "⦐": "rbrkslu", "⦑": "langd", "⦒": "rangd", "⦓": "lparlt", "⦔": "rpargt", "⦕": "gtlPar", "⦖": "ltrPar", "⟦": "lobrk", "⟧": "robrk", "⟨": "lang", "⟩": "rang", "⟪": "Lang", "⟫": "Rang", "⟬": "loang", "⟭": "roang", "❲": "lbbrk", "❳": "rbbrk", "‖": "Vert", "§": "sect", "¶": "para", "@": "commat", "*": "ast", "/": "sol", "undefined": null, "&": "amp", "#": "num", "%": "percnt", "‰": "permil", "‱": "pertenk", "†": "dagger", "‡": "Dagger", "•": "bull", "⁃": "hybull", "′": "prime", "″": "Prime", "‴": "tprime", "⁗": "qprime", "‵": "bprime", "⁁": "caret", "`": "grave", "´": "acute", "˜": "tilde", "^": "Hat", "¯": "macr", "˘": "breve", "˙": "dot", "¨": "die", "˚": "ring", "˝": "dblac", "¸": "cedil", "˛": "ogon", "ˆ": "circ", "ˇ": "caron", "°": "deg", "©": "copy", "®": "reg", "℗": "copysr", "℘": "wp", "℞": "rx", "℧": "mho", "℩": "iiota", "←": "larr", "↚": "nlarr", "→": "rarr", "↛": "nrarr", "↑": "uarr", "↓": "darr", "↔": "harr", "↮": "nharr", "↕": "varr", "↖": "nwarr", "↗": "nearr", "↘": "searr", "↙": "swarr", "↝": "rarrw", "↝̸": "nrarrw", "↞": "Larr", "↟": "Uarr", "↠": "Rarr", "↡": "Darr", "↢": "larrtl", "↣": "rarrtl", "↤": "mapstoleft", "↥": "mapstoup", "↦": "map", "↧": "mapstodown", "↩": "larrhk", "↪": "rarrhk", "↫": "larrlp", "↬": "rarrlp", "↭": "harrw", "↰": "lsh", "↱": "rsh", "↲": "ldsh", "↳": "rdsh", "↵": "crarr", "↶": "cularr", "↷": "curarr", "↺": "olarr", "↻": "orarr", "↼": "lharu", "↽": "lhard", "↾": "uharr", "↿": "uharl", "⇀": "rharu", "⇁": "rhard", "⇂": "dharr", "⇃": "dharl", "⇄": "rlarr", "⇅": "udarr", "⇆": "lrarr", "⇇": "llarr", "⇈": "uuarr", "⇉": "rrarr", "⇊": "ddarr", "⇋": "lrhar", "⇌": "rlhar", "⇐": "lArr", "⇍": "nlArr", "⇑": "uArr", "⇒": "rArr", "⇏": "nrArr", "⇓": "dArr", "⇔": "iff", "⇎": "nhArr", "⇕": "vArr", "⇖": "nwArr", "⇗": "neArr", "⇘": "seArr", "⇙": "swArr", "⇚": "lAarr", "⇛": "rAarr", "⇝": "zigrarr", "⇤": "larrb", "⇥": "rarrb", "⇵": "duarr", "⇽": "loarr", "⇾": "roarr", "⇿": "hoarr", "∀": "forall", "∁": "comp", "∂": "part", "∂̸": "npart", "∃": "exist", "∄": "nexist", "∅": "empty", "∇": "Del", "∈": "in", "∉": "notin", "∋": "ni", "∌": "notni", "϶": "bepsi", "∏": "prod", "∐": "coprod", "∑": "sum", "+": "plus", "±": "pm", "÷": "div", "×": "times", "<": "lt", "≮": "nlt", "<⃒": "nvlt", "=": "equals", "≠": "ne", "=⃥": "bne", "⩵": "Equal", ">": "gt", "≯": "ngt", ">⃒": "nvgt", "¬": "not", "|": "vert", "¦": "brvbar", "−": "minus", "∓": "mp", "∔": "plusdo", "⁄": "frasl", "∖": "setmn", "∗": "lowast", "∘": "compfn", "√": "Sqrt", "∝": "prop", "∞": "infin", "∟": "angrt", "∠": "ang", "∠⃒": "nang", "∡": "angmsd", "∢": "angsph", "∣": "mid", "∤": "nmid", "∥": "par", "∦": "npar", "∧": "and", "∨": "or", "∩": "cap", "∩︀": "caps", "∪": "cup", "∪︀": "cups", "∫": "int", "∬": "Int", "∭": "tint", "⨌": "qint", "∮": "oint", "∯": "Conint", "∰": "Cconint", "∱": "cwint", "∲": "cwconint", "∳": "awconint", "∴": "there4", "∵": "becaus", "∶": "ratio", "∷": "Colon", "∸": "minusd", "∺": "mDDot", "∻": "homtht", "∼": "sim", "≁": "nsim", "∼⃒": "nvsim", "∽": "bsim", "∽̱": "race", "∾": "ac", "∾̳": "acE", "∿": "acd", "≀": "wr", "≂": "esim", "≂̸": "nesim", "≃": "sime", "≄": "nsime", "≅": "cong", "≇": "ncong", "≆": "simne", "≈": "ap", "≉": "nap", "≊": "ape", "≋": "apid", "≋̸": "napid", "≌": "bcong", "≍": "CupCap", "≭": "NotCupCap", "≍⃒": "nvap", "≎": "bump", "≎̸": "nbump", "≏": "bumpe", "≏̸": "nbumpe", "≐": "doteq", "≐̸": "nedot", "≑": "eDot", "≒": "efDot", "≓": "erDot", "≔": "colone", "≕": "ecolon", "≖": "ecir", "≗": "cire", "≙": "wedgeq", "≚": "veeeq", "≜": "trie", "≟": "equest", "≡": "equiv", "≢": "nequiv", "≡⃥": "bnequiv", "≤": "le", "≰": "nle", "≤⃒": "nvle", "≥": "ge", "≱": "nge", "≥⃒": "nvge", "≦": "lE", "≦̸": "nlE", "≧": "gE", "≧̸": "ngE", "≨︀": "lvnE", "≨": "lnE", "≩": "gnE", "≩︀": "gvnE", "≪": "ll", "≪̸": "nLtv", "≪⃒": "nLt", "≫": "gg", "≫̸": "nGtv", "≫⃒": "nGt", "≬": "twixt", "≲": "lsim", "≴": "nlsim", "≳": "gsim", "≵": "ngsim", "≶": "lg", "≸": "ntlg", "≷": "gl", "≹": "ntgl", "≺": "pr", "⊀": "npr", "≻": "sc", "⊁": "nsc", "≼": "prcue", "⋠": "nprcue", "≽": "sccue", "⋡": "nsccue", "≾": "prsim", "≿": "scsim", "≿̸": "NotSucceedsTilde", "⊂": "sub", "⊄": "nsub", "⊂⃒": "vnsub", "⊃": "sup", "⊅": "nsup", "⊃⃒": "vnsup", "⊆": "sube", "⊈": "nsube", "⊇": "supe", "⊉": "nsupe", "⊊︀": "vsubne", "⊊": "subne", "⊋︀": "vsupne", "⊋": "supne", "⊍": "cupdot", "⊎": "uplus", "⊏": "sqsub", "⊏̸": "NotSquareSubset", "⊐": "sqsup", "⊐̸": "NotSquareSuperset", "⊑": "sqsube", "⋢": "nsqsube", "⊒": "sqsupe", "⋣": "nsqsupe", "⊓": "sqcap", "⊓︀": "sqcaps", "⊔": "sqcup", "⊔︀": "sqcups", "⊕": "oplus", "⊖": "ominus", "⊗": "otimes", "⊘": "osol", "⊙": "odot", "⊚": "ocir", "⊛": "oast", "⊝": "odash", "⊞": "plusb", "⊟": "minusb", "⊠": "timesb", "⊡": "sdotb", "⊢": "vdash", "⊬": "nvdash", "⊣": "dashv", "⊤": "top", "⊥": "bot", "⊧": "models", "⊨": "vDash", "⊭": "nvDash", "⊩": "Vdash", "⊮": "nVdash", "⊪": "Vvdash", "⊫": "VDash", "⊯": "nVDash", "⊰": "prurel", "⊲": "vltri", "⋪": "nltri", "⊳": "vrtri", "⋫": "nrtri", "⊴": "ltrie", "⋬": "nltrie", "⊴⃒": "nvltrie", "⊵": "rtrie", "⋭": "nrtrie", "⊵⃒": "nvrtrie", "⊶": "origof", "⊷": "imof", "⊸": "mumap", "⊹": "hercon", "⊺": "intcal", "⊻": "veebar", "⊽": "barvee", "⊾": "angrtvb", "⊿": "lrtri", "⋀": "Wedge", "⋁": "Vee", "⋂": "xcap", "⋃": "xcup", "⋄": "diam", "⋅": "sdot", "⋆": "Star", "⋇": "divonx", "⋈": "bowtie", "⋉": "ltimes", "⋊": "rtimes", "⋋": "lthree", "⋌": "rthree", "⋍": "bsime", "⋎": "cuvee", "⋏": "cuwed", "⋐": "Sub", "⋑": "Sup", "⋒": "Cap", "⋓": "Cup", "⋔": "fork", "⋕": "epar", "⋖": "ltdot", "⋗": "gtdot", "⋘": "Ll", "⋘̸": "nLl", "⋙": "Gg", "⋙̸": "nGg", "⋚︀": "lesg", "⋚": "leg", "⋛": "gel", "⋛︀": "gesl", "⋞": "cuepr", "⋟": "cuesc", "⋦": "lnsim", "⋧": "gnsim", "⋨": "prnsim", "⋩": "scnsim", "⋮": "vellip", "⋯": "ctdot", "⋰": "utdot", "⋱": "dtdot", "⋲": "disin", "⋳": "isinsv", "⋴": "isins", "⋵": "isindot", "⋵̸": "notindot", "⋶": "notinvc", "⋷": "notinvb", "⋹": "isinE", "⋹̸": "notinE", "⋺": "nisd", "⋻": "xnis", "⋼": "nis", "⋽": "notnivc", "⋾": "notnivb", "⌅": "barwed", "⌆": "Barwed", "⌌": "drcrop", "⌍": "dlcrop", "⌎": "urcrop", "⌏": "ulcrop", "⌐": "bnot", "⌒": "profline", "⌓": "profsurf", "⌕": "telrec", "⌖": "target", "⌜": "ulcorn", "⌝": "urcorn", "⌞": "dlcorn", "⌟": "drcorn", "⌢": "frown", "⌣": "smile", "⌭": "cylcty", "⌮": "profalar", "⌶": "topbot", "⌽": "ovbar", "⌿": "solbar", "⍼": "angzarr", "⎰": "lmoust", "⎱": "rmoust", "⎴": "tbrk", "⎵": "bbrk", "⎶": "bbrktbrk", "⏜": "OverParenthesis", "⏝": "UnderParenthesis", "⏞": "OverBrace", "⏟": "UnderBrace", "⏢": "trpezium", "⏧": "elinters", "␣": "blank", "─": "boxh", "│": "boxv", "┌": "boxdr", "┐": "boxdl", "└": "boxur", "┘": "boxul", "├": "boxvr", "┤": "boxvl", "┬": "boxhd", "┴": "boxhu", "┼": "boxvh", "═": "boxH", "║": "boxV", "╒": "boxdR", "╓": "boxDr", "╔": "boxDR", "╕": "boxdL", "╖": "boxDl", "╗": "boxDL", "╘": "boxuR", "╙": "boxUr", "╚": "boxUR", "╛": "boxuL", "╜": "boxUl", "╝": "boxUL", "╞": "boxvR", "╟": "boxVr", "╠": "boxVR", "╡": "boxvL", "╢": "boxVl", "╣": "boxVL", "╤": "boxHd", "╥": "boxhD", "╦": "boxHD", "╧": "boxHu", "╨": "boxhU", "╩": "boxHU", "╪": "boxvH", "╫": "boxVh", "╬": "boxVH", "▀": "uhblk", "▄": "lhblk", "█": "block", "░": "blk14", "▒": "blk12", "▓": "blk34", "□": "squ", "▪": "squf", "▫": "EmptyVerySmallSquare", "▭": "rect", "▮": "marker", "▱": "fltns", "△": "xutri", "▴": "utrif", "▵": "utri", "▸": "rtrif", "▹": "rtri", "▽": "xdtri", "▾": "dtrif", "▿": "dtri", "◂": "ltrif", "◃": "ltri", "◊": "loz", "○": "cir", "◬": "tridot", "◯": "xcirc", "◸": "ultri", "◹": "urtri", "◺": "lltri", "◻": "EmptySmallSquare", "◼": "FilledSmallSquare", "★": "starf", "☆": "star", "☎": "phone", "♀": "female", "♂": "male", "♠": "spades", "♣": "clubs", "♥": "hearts", "♦": "diams", "♪": "sung", "✓": "check", "✗": "cross", "✠": "malt", "✶": "sext", "❘": "VerticalSeparator", "⟈": "bsolhsub", "⟉": "suphsol", "⟵": "xlarr", "⟶": "xrarr", "⟷": "xharr", "⟸": "xlArr", "⟹": "xrArr", "⟺": "xhArr", "⟼": "xmap", "⟿": "dzigrarr", "⤂": "nvlArr", "⤃": "nvrArr", "⤄": "nvHarr", "⤅": "Map", "⤌": "lbarr", "⤍": "rbarr", "⤎": "lBarr", "⤏": "rBarr", "⤐": "RBarr", "⤑": "DDotrahd", "⤒": "UpArrowBar", "⤓": "DownArrowBar", "⤖": "Rarrtl", "⤙": "latail", "⤚": "ratail", "⤛": "lAtail", "⤜": "rAtail", "⤝": "larrfs", "⤞": "rarrfs", "⤟": "larrbfs", "⤠": "rarrbfs", "⤣": "nwarhk", "⤤": "nearhk", "⤥": "searhk", "⤦": "swarhk", "⤧": "nwnear", "⤨": "toea", "⤩": "tosa", "⤪": "swnwar", "⤳": "rarrc", "⤳̸": "nrarrc", "⤵": "cudarrr", "⤶": "ldca", "⤷": "rdca", "⤸": "cudarrl", "⤹": "larrpl", "⤼": "curarrm", "⤽": "cularrp", "⥅": "rarrpl", "⥈": "harrcir", "⥉": "Uarrocir", "⥊": "lurdshar", "⥋": "ldrushar", "⥎": "LeftRightVector", "⥏": "RightUpDownVector", "⥐": "DownLeftRightVector", "⥑": "LeftUpDownVector", "⥒": "LeftVectorBar", "⥓": "RightVectorBar", "⥔": "RightUpVectorBar", "⥕": "RightDownVectorBar", "⥖": "DownLeftVectorBar", "⥗": "DownRightVectorBar", "⥘": "LeftUpVectorBar", "⥙": "LeftDownVectorBar", "⥚": "LeftTeeVector", "⥛": "RightTeeVector", "⥜": "RightUpTeeVector", "⥝": "RightDownTeeVector", "⥞": "DownLeftTeeVector", "⥟": "DownRightTeeVector", "⥠": "LeftUpTeeVector", "⥡": "LeftDownTeeVector", "⥢": "lHar", "⥣": "uHar", "⥤": "rHar", "⥥": "dHar", "⥦": "luruhar", "⥧": "ldrdhar", "⥨": "ruluhar", "⥩": "rdldhar", "⥪": "lharul", "⥫": "llhard", "⥬": "rharul", "⥭": "lrhard", "⥮": "udhar", "⥯": "duhar", "⥰": "RoundImplies", "⥱": "erarr", "⥲": "simrarr", "⥳": "larrsim", "⥴": "rarrsim", "⥵": "rarrap", "⥶": "ltlarr", "⥸": "gtrarr", "⥹": "subrarr", "⥻": "suplarr", "⥼": "lfisht", "⥽": "rfisht", "⥾": "ufisht", "⥿": "dfisht", "⦚": "vzigzag", "⦜": "vangrt", "⦝": "angrtvbd", "⦤": "ange", "⦥": "range", "⦦": "dwangle", "⦧": "uwangle", "⦨": "angmsdaa", "⦩": "angmsdab", "⦪": "angmsdac", "⦫": "angmsdad", "⦬": "angmsdae", "⦭": "angmsdaf", "⦮": "angmsdag", "⦯": "angmsdah", "⦰": "bemptyv", "⦱": "demptyv", "⦲": "cemptyv", "⦳": "raemptyv", "⦴": "laemptyv", "⦵": "ohbar", "⦶": "omid", "⦷": "opar", "⦹": "operp", "⦻": "olcross", "⦼": "odsold", "⦾": "olcir", "⦿": "ofcir", "⧀": "olt", "⧁": "ogt", "⧂": "cirscir", "⧃": "cirE", "⧄": "solb", "⧅": "bsolb", "⧉": "boxbox", "⧍": "trisb", "⧎": "rtriltri", "⧏": "LeftTriangleBar", "⧏̸": "NotLeftTriangleBar", "⧐": "RightTriangleBar", "⧐̸": "NotRightTriangleBar", "⧜": "iinfin", "⧝": "infintie", "⧞": "nvinfin", "⧣": "eparsl", "⧤": "smeparsl", "⧥": "eqvparsl", "⧫": "lozf", "⧴": "RuleDelayed", "⧶": "dsol", "⨀": "xodot", "⨁": "xoplus", "⨂": "xotime", "⨄": "xuplus", "⨆": "xsqcup", "⨍": "fpartint", "⨐": "cirfnint", "⨑": "awint", "⨒": "rppolint", "⨓": "scpolint", "⨔": "npolint", "⨕": "pointint", "⨖": "quatint", "⨗": "intlarhk", "⨢": "pluscir", "⨣": "plusacir", "⨤": "simplus", "⨥": "plusdu", "⨦": "plussim", "⨧": "plustwo", "⨩": "mcomma", "⨪": "minusdu", "⨭": "loplus", "⨮": "roplus", "⨯": "Cross", "⨰": "timesd", "⨱": "timesbar", "⨳": "smashp", "⨴": "lotimes", "⨵": "rotimes", "⨶": "otimesas", "⨷": "Otimes", "⨸": "odiv", "⨹": "triplus", "⨺": "triminus", "⨻": "tritime", "⨼": "iprod", "⨿": "amalg", "⩀": "capdot", "⩂": "ncup", "⩃": "ncap", "⩄": "capand", "⩅": "cupor", "⩆": "cupcap", "⩇": "capcup", "⩈": "cupbrcap", "⩉": "capbrcup", "⩊": "cupcup", "⩋": "capcap", "⩌": "ccups", "⩍": "ccaps", "⩐": "ccupssm", "⩓": "And", "⩔": "Or", "⩕": "andand", "⩖": "oror", "⩗": "orslope", "⩘": "andslope", "⩚": "andv", "⩛": "orv", "⩜": "andd", "⩝": "ord", "⩟": "wedbar", "⩦": "sdote", "⩪": "simdot", "⩭": "congdot", "⩭̸": "ncongdot", "⩮": "easter", "⩯": "apacir", "⩰": "apE", "⩰̸": "napE", "⩱": "eplus", "⩲": "pluse", "⩳": "Esim", "⩷": "eDDot", "⩸": "equivDD", "⩹": "ltcir", "⩺": "gtcir", "⩻": "ltquest", "⩼": "gtquest", "⩽": "les", "⩽̸": "nles", "⩾": "ges", "⩾̸": "nges", "⩿": "lesdot", "⪀": "gesdot", "⪁": "lesdoto", "⪂": "gesdoto", "⪃": "lesdotor", "⪄": "gesdotol", "⪅": "lap", "⪆": "gap", "⪇": "lne", "⪈": "gne", "⪉": "lnap", "⪊": "gnap", "⪋": "lEg", "⪌": "gEl", "⪍": "lsime", "⪎": "gsime", "⪏": "lsimg", "⪐": "gsiml", "⪑": "lgE", "⪒": "glE", "⪓": "lesges", "⪔": "gesles", "⪕": "els", "⪖": "egs", "⪗": "elsdot", "⪘": "egsdot", "⪙": "el", "⪚": "eg", "⪝": "siml", "⪞": "simg", "⪟": "simlE", "⪠": "simgE", "⪡": "LessLess", "⪡̸": "NotNestedLessLess", "⪢": "GreaterGreater", "⪢̸": "NotNestedGreaterGreater", "⪤": "glj", "⪥": "gla", "⪦": "ltcc", "⪧": "gtcc", "⪨": "lescc", "⪩": "gescc", "⪪": "smt", "⪫": "lat", "⪬": "smte", "⪬︀": "smtes", "⪭": "late", "⪭︀": "lates", "⪮": "bumpE", "⪯": "pre", "⪯̸": "npre", "⪰": "sce", "⪰̸": "nsce", "⪳": "prE", "⪴": "scE", "⪵": "prnE", "⪶": "scnE", "⪷": "prap", "⪸": "scap", "⪹": "prnap", "⪺": "scnap", "⪻": "Pr", "⪼": "Sc", "⪽": "subdot", "⪾": "supdot", "⪿": "subplus", "⫀": "supplus", "⫁": "submult", "⫂": "supmult", "⫃": "subedot", "⫄": "supedot", "⫅": "subE", "⫅̸": "nsubE", "⫆": "supE", "⫆̸": "nsupE", "⫇": "subsim", "⫈": "supsim", "⫋︀": "vsubnE", "⫋": "subnE", "⫌︀": "vsupnE", "⫌": "supnE", "⫏": "csub", "⫐": "csup", "⫑": "csube", "⫒": "csupe", "⫓": "subsup", "⫔": "supsub", "⫕": "subsub", "⫖": "supsup", "⫗": "suphsub", "⫘": "supdsub", "⫙": "forkv", "⫚": "topfork", "⫛": "mlcp", "⫤": "Dashv", "⫦": "Vdashl", "⫧": "Barv", "⫨": "vBar", "⫩": "vBarv", "⫫": "Vbar", "⫬": "Not", "⫭": "bNot", "⫮": "rnmid", "⫯": "cirmid", "⫰": "midcir", "⫱": "topcir", "⫲": "nhpar", "⫳": "parsim", "⫽": "parsl", "⫽⃥": "nparsl", "♭": "flat", "♮": "natur", "♯": "sharp", "¤": "curren", "¢": "cent", "$": "dollar", "£": "pound", "¥": "yen", "€": "euro", "¹": "sup1", "½": "half", "⅓": "frac13", "¼": "frac14", "⅕": "frac15", "⅙": "frac16", "⅛": "frac18", "²": "sup2", "⅔": "frac23", "⅖": "frac25", "³": "sup3", "¾": "frac34", "⅗": "frac35", "⅜": "frac38", "⅘": "frac45", "⅚": "frac56", "⅝": "frac58", "⅞": "frac78", "𝒶": "ascr", "𝕒": "aopf", "𝔞": "afr", "𝔸": "Aopf", "𝔄": "Afr", "𝒜": "Ascr", "ª": "ordf", "á": "aacute", "Á": "Aacute", "à": "agrave", "À": "Agrave", "ă": "abreve", "Ă": "Abreve", "â": "acirc", "Â": "Acirc", "å": "aring", "Å": "angst", "ä": "auml", "Ä": "Auml", "ã": "atilde", "Ã": "Atilde", "ą": "aogon", "Ą": "Aogon", "ā": "amacr", "Ā": "Amacr", "æ": "aelig", "Æ": "AElig", "𝒷": "bscr", "𝕓": "bopf", "𝔟": "bfr", "𝔹": "Bopf", "ℬ": "Bscr", "𝔅": "Bfr", "𝔠": "cfr", "𝒸": "cscr", "𝕔": "copf", "ℭ": "Cfr", "𝒞": "Cscr", "ℂ": "Copf", "ć": "cacute", "Ć": "Cacute", "ĉ": "ccirc", "Ĉ": "Ccirc", "č": "ccaron", "Č": "Ccaron", "ċ": "cdot", "Ċ": "Cdot", "ç": "ccedil", "Ç": "Ccedil", "℅": "incare", "𝔡": "dfr", "ⅆ": "dd", "𝕕": "dopf", "𝒹": "dscr", "𝒟": "Dscr", "𝔇": "Dfr", "ⅅ": "DD", "𝔻": "Dopf", "ď": "dcaron", "Ď": "Dcaron", "đ": "dstrok", "Đ": "Dstrok", "ð": "eth", "Ð": "ETH", "ⅇ": "ee", "ℯ": "escr", "𝔢": "efr", "𝕖": "eopf", "ℰ": "Escr", "𝔈": "Efr", "𝔼": "Eopf", "é": "eacute", "É": "Eacute", "è": "egrave", "È": "Egrave", "ê": "ecirc", "Ê": "Ecirc", "ě": "ecaron", "Ě": "Ecaron", "ë": "euml", "Ë": "Euml", "ė": "edot", "Ė": "Edot", "ę": "eogon", "Ę": "Eogon", "ē": "emacr", "Ē": "Emacr", "𝔣": "ffr", "𝕗": "fopf", "𝒻": "fscr", "𝔉": "Ffr", "𝔽": "Fopf", "ℱ": "Fscr", "ﬀ": "fflig", "ﬃ": "ffilig", "ﬄ": "ffllig", "ﬁ": "filig", "fj": "fjlig", "ﬂ": "fllig", "ƒ": "fnof", "ℊ": "gscr", "𝕘": "gopf", "𝔤": "gfr", "𝒢": "Gscr", "𝔾": "Gopf", "𝔊": "Gfr", "ǵ": "gacute", "ğ": "gbreve", "Ğ": "Gbreve", "ĝ": "gcirc", "Ĝ": "Gcirc", "ġ": "gdot", "Ġ": "Gdot", "Ģ": "Gcedil", "𝔥": "hfr", "ℎ": "planckh", "𝒽": "hscr", "𝕙": "hopf", "ℋ": "Hscr", "ℌ": "Hfr", "ℍ": "Hopf", "ĥ": "hcirc", "Ĥ": "Hcirc", "ℏ": "hbar", "ħ": "hstrok", "Ħ": "Hstrok", "𝕚": "iopf", "𝔦": "ifr", "𝒾": "iscr", "ⅈ": "ii", "𝕀": "Iopf", "ℐ": "Iscr", "ℑ": "Im", "í": "iacute", "Í": "Iacute", "ì": "igrave", "Ì": "Igrave", "î": "icirc", "Î": "Icirc", "ï": "iuml", "Ï": "Iuml", "ĩ": "itilde", "Ĩ": "Itilde", "İ": "Idot", "į": "iogon", "Į": "Iogon", "ī": "imacr", "Ī": "Imacr", "ĳ": "ijlig", "Ĳ": "IJlig", "ı": "imath", "𝒿": "jscr", "𝕛": "jopf", "𝔧": "jfr", "𝒥": "Jscr", "𝔍": "Jfr", "𝕁": "Jopf", "ĵ": "jcirc", "Ĵ": "Jcirc", "ȷ": "jmath", "𝕜": "kopf", "𝓀": "kscr", "𝔨": "kfr", "𝒦": "Kscr", "𝕂": "Kopf", "𝔎": "Kfr", "ķ": "kcedil", "Ķ": "Kcedil", "𝔩": "lfr", "𝓁": "lscr", "ℓ": "ell", "𝕝": "lopf", "ℒ": "Lscr", "𝔏": "Lfr", "𝕃": "Lopf", "ĺ": "lacute", "Ĺ": "Lacute", "ľ": "lcaron", "Ľ": "Lcaron", "ļ": "lcedil", "Ļ": "Lcedil", "ł": "lstrok", "Ł": "Lstrok", "ŀ": "lmidot", "Ŀ": "Lmidot", "𝔪": "mfr", "𝕞": "mopf", "𝓂": "mscr", "𝔐": "Mfr", "𝕄": "Mopf", "ℳ": "Mscr", "𝔫": "nfr", "𝕟": "nopf", "𝓃": "nscr", "ℕ": "Nopf", "𝒩": "Nscr", "𝔑": "Nfr", "ń": "nacute", "Ń": "Nacute", "ň": "ncaron", "Ň": "Ncaron", "ñ": "ntilde", "Ñ": "Ntilde", "ņ": "ncedil", "Ņ": "Ncedil", "№": "numero", "ŋ": "eng", "Ŋ": "ENG", "𝕠": "oopf", "𝔬": "ofr", "ℴ": "oscr", "𝒪": "Oscr", "𝔒": "Ofr", "𝕆": "Oopf", "º": "ordm", "ó": "oacute", "Ó": "Oacute", "ò": "ograve", "Ò": "Ograve", "ô": "ocirc", "Ô": "Ocirc", "ö": "ouml", "Ö": "Ouml", "ő": "odblac", "Ő": "Odblac", "õ": "otilde", "Õ": "Otilde", "ø": "oslash", "Ø": "Oslash", "ō": "omacr", "Ō": "Omacr", "œ": "oelig", "Œ": "OElig", "𝔭": "pfr", "𝓅": "pscr", "𝕡": "popf", "ℙ": "Popf", "𝔓": "Pfr", "𝒫": "Pscr", "𝕢": "qopf", "𝔮": "qfr", "𝓆": "qscr", "𝒬": "Qscr", "𝔔": "Qfr", "ℚ": "Qopf", "ĸ": "kgreen", "𝔯": "rfr", "𝕣": "ropf", "𝓇": "rscr", "ℛ": "Rscr", "ℜ": "Re", "ℝ": "Ropf", "ŕ": "racute", "Ŕ": "Racute", "ř": "rcaron", "Ř": "Rcaron", "ŗ": "rcedil", "Ŗ": "Rcedil", "𝕤": "sopf", "𝓈": "sscr", "𝔰": "sfr", "𝕊": "Sopf", "𝔖": "Sfr", "𝒮": "Sscr", "Ⓢ": "oS", "ś": "sacute", "Ś": "Sacute", "ŝ": "scirc", "Ŝ": "Scirc", "š": "scaron", "Š": "Scaron", "ş": "scedil", "Ş": "Scedil", "ß": "szlig", "𝔱": "tfr", "𝓉": "tscr", "𝕥": "topf", "𝒯": "Tscr", "𝔗": "Tfr", "𝕋": "Topf", "ť": "tcaron", "Ť": "Tcaron", "ţ": "tcedil", "Ţ": "Tcedil", "™": "trade", "ŧ": "tstrok", "Ŧ": "Tstrok", "𝓊": "uscr", "𝕦": "uopf", "𝔲": "ufr", "𝕌": "Uopf", "𝔘": "Ufr", "𝒰": "Uscr", "ú": "uacute", "Ú": "Uacute", "ù": "ugrave", "Ù": "Ugrave", "ŭ": "ubreve", "Ŭ": "Ubreve", "û": "ucirc", "Û": "Ucirc", "ů": "uring", "Ů": "Uring", "ü": "uuml", "Ü": "Uuml", "ű": "udblac", "Ű": "Udblac", "ũ": "utilde", "Ũ": "Utilde", "ų": "uogon", "Ų": "Uogon", "ū": "umacr", "Ū": "Umacr", "𝔳": "vfr", "𝕧": "vopf", "𝓋": "vscr", "𝔙": "Vfr", "𝕍": "Vopf", "𝒱": "Vscr", "𝕨": "wopf", "𝓌": "wscr", "𝔴": "wfr", "𝒲": "Wscr", "𝕎": "Wopf", "𝔚": "Wfr", "ŵ": "wcirc", "Ŵ": "Wcirc", "𝔵": "xfr", "𝓍": "xscr", "𝕩": "xopf", "𝕏": "Xopf", "𝔛": "Xfr", "𝒳": "Xscr", "𝔶": "yfr", "𝓎": "yscr", "𝕪": "yopf", "𝒴": "Yscr", "𝔜": "Yfr", "𝕐": "Yopf", "ý": "yacute", "Ý": "Yacute", "ŷ": "ycirc", "Ŷ": "Ycirc", "ÿ": "yuml", "Ÿ": "Yuml", "𝓏": "zscr", "𝔷": "zfr", "𝕫": "zopf", "ℨ": "Zfr", "ℤ": "Zopf", "𝒵": "Zscr", "ź": "zacute", "Ź": "Zacute", "ž": "zcaron", "Ž": "Zcaron", "ż": "zdot", "Ż": "Zdot", "Ƶ": "imped", "þ": "thorn", "Þ": "THORN", "ŉ": "napos", "α": "alpha", "Α": "Alpha", "β": "beta", "Β": "Beta", "γ": "gamma", "Γ": "Gamma", "δ": "delta", "Δ": "Delta", "ε": "epsi", "ϵ": "epsiv", "Ε": "Epsilon", "ϝ": "gammad", "Ϝ": "Gammad", "ζ": "zeta", "Ζ": "Zeta", "η": "eta", "Η": "Eta", "θ": "theta", "ϑ": "thetav", "Θ": "Theta", "ι": "iota", "Ι": "Iota", "κ": "kappa", "ϰ": "kappav", "Κ": "Kappa", "λ": "lambda", "Λ": "Lambda", "μ": "mu", "µ": "micro", "Μ": "Mu", "ν": "nu", "Ν": "Nu", "ξ": "xi", "Ξ": "Xi", "ο": "omicron", "Ο": "Omicron", "π": "pi", "ϖ": "piv", "Π": "Pi", "ρ": "rho", "ϱ": "rhov", "Ρ": "Rho", "σ": "sigma", "Σ": "Sigma", "ς": "sigmaf", "τ": "tau", "Τ": "Tau", "υ": "upsi", "Υ": "Upsilon", "ϒ": "Upsi", "φ": "phi", "ϕ": "phiv", "Φ": "Phi", "χ": "chi", "Χ": "Chi", "ψ": "psi", "Ψ": "Psi", "ω": "omega", "Ω": "ohm", "а": "acy", "А": "Acy", "б": "bcy", "Б": "Bcy", "в": "vcy", "В": "Vcy", "г": "gcy", "Г": "Gcy", "ѓ": "gjcy", "Ѓ": "GJcy", "д": "dcy", "Д": "Dcy", "ђ": "djcy", "Ђ": "DJcy", "е": "iecy", "Е": "IEcy", "ё": "iocy", "Ё": "IOcy", "є": "jukcy", "Є": "Jukcy", "ж": "zhcy", "Ж": "ZHcy", "з": "zcy", "З": "Zcy", "ѕ": "dscy", "Ѕ": "DScy", "и": "icy", "И": "Icy", "і": "iukcy", "І": "Iukcy", "ї": "yicy", "Ї": "YIcy", "й": "jcy", "Й": "Jcy", "ј": "jsercy", "Ј": "Jsercy", "к": "kcy", "К": "Kcy", "ќ": "kjcy", "Ќ": "KJcy", "л": "lcy", "Л": "Lcy", "љ": "ljcy", "Љ": "LJcy", "м": "mcy", "М": "Mcy", "н": "ncy", "Н": "Ncy", "њ": "njcy", "Њ": "NJcy", "о": "ocy", "О": "Ocy", "п": "pcy", "П": "Pcy", "р": "rcy", "Р": "Rcy", "с": "scy", "С": "Scy", "т": "tcy", "Т": "Tcy", "ћ": "tshcy", "Ћ": "TSHcy", "у": "ucy", "У": "Ucy", "ў": "ubrcy", "Ў": "Ubrcy", "ф": "fcy", "Ф": "Fcy", "х": "khcy", "Х": "KHcy", "ц": "tscy", "Ц": "TScy", "ч": "chcy", "Ч": "CHcy", "џ": "dzcy", "Џ": "DZcy", "ш": "shcy", "Ш": "SHcy", "щ": "shchcy", "Щ": "SHCHcy", "ъ": "hardcy", "Ъ": "HARDcy", "ы": "ycy", "Ы": "Ycy", "ь": "softcy", "Ь": "SOFTcy", "э": "ecy", "Э": "Ecy", "ю": "yucy", "Ю": "YUcy", "я": "yacy", "Я": "YAcy", "ℵ": "aleph", "ℶ": "beth", "ℷ": "gimel", "ℸ": "daleth" };
      var regexEscape = /["&'<>`]/g;
      var escapeMap = {
        '"': "&quot;",
        "&": "&amp;",
        "'": "&#x27;",
        "<": "&lt;",
        // See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
        // following is not strictly necessary unless it’s part of a tag or an
        // unquoted attribute value. We’re only escaping it to support those
        // situations, and for XML support.
        ">": "&gt;",
        // In Internet Explorer ≤ 8, the backtick character can be used
        // to break out of (un)quoted attribute values or HTML comments.
        // See http://html5sec.org/#102, http://html5sec.org/#108, and
        // http://html5sec.org/#133.
        "`": "&#x60;"
      };
      var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
      var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
      var decodeMap = { "aacute": "á", "Aacute": "Á", "abreve": "ă", "Abreve": "Ă", "ac": "∾", "acd": "∿", "acE": "∾̳", "acirc": "â", "Acirc": "Â", "acute": "´", "acy": "а", "Acy": "А", "aelig": "æ", "AElig": "Æ", "af": "⁡", "afr": "𝔞", "Afr": "𝔄", "agrave": "à", "Agrave": "À", "alefsym": "ℵ", "aleph": "ℵ", "alpha": "α", "Alpha": "Α", "amacr": "ā", "Amacr": "Ā", "amalg": "⨿", "amp": "&", "AMP": "&", "and": "∧", "And": "⩓", "andand": "⩕", "andd": "⩜", "andslope": "⩘", "andv": "⩚", "ang": "∠", "ange": "⦤", "angle": "∠", "angmsd": "∡", "angmsdaa": "⦨", "angmsdab": "⦩", "angmsdac": "⦪", "angmsdad": "⦫", "angmsdae": "⦬", "angmsdaf": "⦭", "angmsdag": "⦮", "angmsdah": "⦯", "angrt": "∟", "angrtvb": "⊾", "angrtvbd": "⦝", "angsph": "∢", "angst": "Å", "angzarr": "⍼", "aogon": "ą", "Aogon": "Ą", "aopf": "𝕒", "Aopf": "𝔸", "ap": "≈", "apacir": "⩯", "ape": "≊", "apE": "⩰", "apid": "≋", "apos": "'", "ApplyFunction": "⁡", "approx": "≈", "approxeq": "≊", "aring": "å", "Aring": "Å", "ascr": "𝒶", "Ascr": "𝒜", "Assign": "≔", "ast": "*", "asymp": "≈", "asympeq": "≍", "atilde": "ã", "Atilde": "Ã", "auml": "ä", "Auml": "Ä", "awconint": "∳", "awint": "⨑", "backcong": "≌", "backepsilon": "϶", "backprime": "‵", "backsim": "∽", "backsimeq": "⋍", "Backslash": "∖", "Barv": "⫧", "barvee": "⊽", "barwed": "⌅", "Barwed": "⌆", "barwedge": "⌅", "bbrk": "⎵", "bbrktbrk": "⎶", "bcong": "≌", "bcy": "б", "Bcy": "Б", "bdquo": "„", "becaus": "∵", "because": "∵", "Because": "∵", "bemptyv": "⦰", "bepsi": "϶", "bernou": "ℬ", "Bernoullis": "ℬ", "beta": "β", "Beta": "Β", "beth": "ℶ", "between": "≬", "bfr": "𝔟", "Bfr": "𝔅", "bigcap": "⋂", "bigcirc": "◯", "bigcup": "⋃", "bigodot": "⨀", "bigoplus": "⨁", "bigotimes": "⨂", "bigsqcup": "⨆", "bigstar": "★", "bigtriangledown": "▽", "bigtriangleup": "△", "biguplus": "⨄", "bigvee": "⋁", "bigwedge": "⋀", "bkarow": "⤍", "blacklozenge": "⧫", "blacksquare": "▪", "blacktriangle": "▴", "blacktriangledown": "▾", "blacktriangleleft": "◂", "blacktriangleright": "▸", "blank": "␣", "blk12": "▒", "blk14": "░", "blk34": "▓", "block": "█", "bne": "=⃥", "bnequiv": "≡⃥", "bnot": "⌐", "bNot": "⫭", "bopf": "𝕓", "Bopf": "𝔹", "bot": "⊥", "bottom": "⊥", "bowtie": "⋈", "boxbox": "⧉", "boxdl": "┐", "boxdL": "╕", "boxDl": "╖", "boxDL": "╗", "boxdr": "┌", "boxdR": "╒", "boxDr": "╓", "boxDR": "╔", "boxh": "─", "boxH": "═", "boxhd": "┬", "boxhD": "╥", "boxHd": "╤", "boxHD": "╦", "boxhu": "┴", "boxhU": "╨", "boxHu": "╧", "boxHU": "╩", "boxminus": "⊟", "boxplus": "⊞", "boxtimes": "⊠", "boxul": "┘", "boxuL": "╛", "boxUl": "╜", "boxUL": "╝", "boxur": "└", "boxuR": "╘", "boxUr": "╙", "boxUR": "╚", "boxv": "│", "boxV": "║", "boxvh": "┼", "boxvH": "╪", "boxVh": "╫", "boxVH": "╬", "boxvl": "┤", "boxvL": "╡", "boxVl": "╢", "boxVL": "╣", "boxvr": "├", "boxvR": "╞", "boxVr": "╟", "boxVR": "╠", "bprime": "‵", "breve": "˘", "Breve": "˘", "brvbar": "¦", "bscr": "𝒷", "Bscr": "ℬ", "bsemi": "⁏", "bsim": "∽", "bsime": "⋍", "bsol": "\\", "bsolb": "⧅", "bsolhsub": "⟈", "bull": "•", "bullet": "•", "bump": "≎", "bumpe": "≏", "bumpE": "⪮", "bumpeq": "≏", "Bumpeq": "≎", "cacute": "ć", "Cacute": "Ć", "cap": "∩", "Cap": "⋒", "capand": "⩄", "capbrcup": "⩉", "capcap": "⩋", "capcup": "⩇", "capdot": "⩀", "CapitalDifferentialD": "ⅅ", "caps": "∩︀", "caret": "⁁", "caron": "ˇ", "Cayleys": "ℭ", "ccaps": "⩍", "ccaron": "č", "Ccaron": "Č", "ccedil": "ç", "Ccedil": "Ç", "ccirc": "ĉ", "Ccirc": "Ĉ", "Cconint": "∰", "ccups": "⩌", "ccupssm": "⩐", "cdot": "ċ", "Cdot": "Ċ", "cedil": "¸", "Cedilla": "¸", "cemptyv": "⦲", "cent": "¢", "centerdot": "·", "CenterDot": "·", "cfr": "𝔠", "Cfr": "ℭ", "chcy": "ч", "CHcy": "Ч", "check": "✓", "checkmark": "✓", "chi": "χ", "Chi": "Χ", "cir": "○", "circ": "ˆ", "circeq": "≗", "circlearrowleft": "↺", "circlearrowright": "↻", "circledast": "⊛", "circledcirc": "⊚", "circleddash": "⊝", "CircleDot": "⊙", "circledR": "®", "circledS": "Ⓢ", "CircleMinus": "⊖", "CirclePlus": "⊕", "CircleTimes": "⊗", "cire": "≗", "cirE": "⧃", "cirfnint": "⨐", "cirmid": "⫯", "cirscir": "⧂", "ClockwiseContourIntegral": "∲", "CloseCurlyDoubleQuote": "”", "CloseCurlyQuote": "’", "clubs": "♣", "clubsuit": "♣", "colon": ":", "Colon": "∷", "colone": "≔", "Colone": "⩴", "coloneq": "≔", "comma": ",", "commat": "@", "comp": "∁", "compfn": "∘", "complement": "∁", "complexes": "ℂ", "cong": "≅", "congdot": "⩭", "Congruent": "≡", "conint": "∮", "Conint": "∯", "ContourIntegral": "∮", "copf": "𝕔", "Copf": "ℂ", "coprod": "∐", "Coproduct": "∐", "copy": "©", "COPY": "©", "copysr": "℗", "CounterClockwiseContourIntegral": "∳", "crarr": "↵", "cross": "✗", "Cross": "⨯", "cscr": "𝒸", "Cscr": "𝒞", "csub": "⫏", "csube": "⫑", "csup": "⫐", "csupe": "⫒", "ctdot": "⋯", "cudarrl": "⤸", "cudarrr": "⤵", "cuepr": "⋞", "cuesc": "⋟", "cularr": "↶", "cularrp": "⤽", "cup": "∪", "Cup": "⋓", "cupbrcap": "⩈", "cupcap": "⩆", "CupCap": "≍", "cupcup": "⩊", "cupdot": "⊍", "cupor": "⩅", "cups": "∪︀", "curarr": "↷", "curarrm": "⤼", "curlyeqprec": "⋞", "curlyeqsucc": "⋟", "curlyvee": "⋎", "curlywedge": "⋏", "curren": "¤", "curvearrowleft": "↶", "curvearrowright": "↷", "cuvee": "⋎", "cuwed": "⋏", "cwconint": "∲", "cwint": "∱", "cylcty": "⌭", "dagger": "†", "Dagger": "‡", "daleth": "ℸ", "darr": "↓", "dArr": "⇓", "Darr": "↡", "dash": "‐", "dashv": "⊣", "Dashv": "⫤", "dbkarow": "⤏", "dblac": "˝", "dcaron": "ď", "Dcaron": "Ď", "dcy": "д", "Dcy": "Д", "dd": "ⅆ", "DD": "ⅅ", "ddagger": "‡", "ddarr": "⇊", "DDotrahd": "⤑", "ddotseq": "⩷", "deg": "°", "Del": "∇", "delta": "δ", "Delta": "Δ", "demptyv": "⦱", "dfisht": "⥿", "dfr": "𝔡", "Dfr": "𝔇", "dHar": "⥥", "dharl": "⇃", "dharr": "⇂", "DiacriticalAcute": "´", "DiacriticalDot": "˙", "DiacriticalDoubleAcute": "˝", "DiacriticalGrave": "`", "DiacriticalTilde": "˜", "diam": "⋄", "diamond": "⋄", "Diamond": "⋄", "diamondsuit": "♦", "diams": "♦", "die": "¨", "DifferentialD": "ⅆ", "digamma": "ϝ", "disin": "⋲", "div": "÷", "divide": "÷", "divideontimes": "⋇", "divonx": "⋇", "djcy": "ђ", "DJcy": "Ђ", "dlcorn": "⌞", "dlcrop": "⌍", "dollar": "$", "dopf": "𝕕", "Dopf": "𝔻", "dot": "˙", "Dot": "¨", "DotDot": "⃜", "doteq": "≐", "doteqdot": "≑", "DotEqual": "≐", "dotminus": "∸", "dotplus": "∔", "dotsquare": "⊡", "doublebarwedge": "⌆", "DoubleContourIntegral": "∯", "DoubleDot": "¨", "DoubleDownArrow": "⇓", "DoubleLeftArrow": "⇐", "DoubleLeftRightArrow": "⇔", "DoubleLeftTee": "⫤", "DoubleLongLeftArrow": "⟸", "DoubleLongLeftRightArrow": "⟺", "DoubleLongRightArrow": "⟹", "DoubleRightArrow": "⇒", "DoubleRightTee": "⊨", "DoubleUpArrow": "⇑", "DoubleUpDownArrow": "⇕", "DoubleVerticalBar": "∥", "downarrow": "↓", "Downarrow": "⇓", "DownArrow": "↓", "DownArrowBar": "⤓", "DownArrowUpArrow": "⇵", "DownBreve": "̑", "downdownarrows": "⇊", "downharpoonleft": "⇃", "downharpoonright": "⇂", "DownLeftRightVector": "⥐", "DownLeftTeeVector": "⥞", "DownLeftVector": "↽", "DownLeftVectorBar": "⥖", "DownRightTeeVector": "⥟", "DownRightVector": "⇁", "DownRightVectorBar": "⥗", "DownTee": "⊤", "DownTeeArrow": "↧", "drbkarow": "⤐", "drcorn": "⌟", "drcrop": "⌌", "dscr": "𝒹", "Dscr": "𝒟", "dscy": "ѕ", "DScy": "Ѕ", "dsol": "⧶", "dstrok": "đ", "Dstrok": "Đ", "dtdot": "⋱", "dtri": "▿", "dtrif": "▾", "duarr": "⇵", "duhar": "⥯", "dwangle": "⦦", "dzcy": "џ", "DZcy": "Џ", "dzigrarr": "⟿", "eacute": "é", "Eacute": "É", "easter": "⩮", "ecaron": "ě", "Ecaron": "Ě", "ecir": "≖", "ecirc": "ê", "Ecirc": "Ê", "ecolon": "≕", "ecy": "э", "Ecy": "Э", "eDDot": "⩷", "edot": "ė", "eDot": "≑", "Edot": "Ė", "ee": "ⅇ", "efDot": "≒", "efr": "𝔢", "Efr": "𝔈", "eg": "⪚", "egrave": "è", "Egrave": "È", "egs": "⪖", "egsdot": "⪘", "el": "⪙", "Element": "∈", "elinters": "⏧", "ell": "ℓ", "els": "⪕", "elsdot": "⪗", "emacr": "ē", "Emacr": "Ē", "empty": "∅", "emptyset": "∅", "EmptySmallSquare": "◻", "emptyv": "∅", "EmptyVerySmallSquare": "▫", "emsp": " ", "emsp13": " ", "emsp14": " ", "eng": "ŋ", "ENG": "Ŋ", "ensp": " ", "eogon": "ę", "Eogon": "Ę", "eopf": "𝕖", "Eopf": "𝔼", "epar": "⋕", "eparsl": "⧣", "eplus": "⩱", "epsi": "ε", "epsilon": "ε", "Epsilon": "Ε", "epsiv": "ϵ", "eqcirc": "≖", "eqcolon": "≕", "eqsim": "≂", "eqslantgtr": "⪖", "eqslantless": "⪕", "Equal": "⩵", "equals": "=", "EqualTilde": "≂", "equest": "≟", "Equilibrium": "⇌", "equiv": "≡", "equivDD": "⩸", "eqvparsl": "⧥", "erarr": "⥱", "erDot": "≓", "escr": "ℯ", "Escr": "ℰ", "esdot": "≐", "esim": "≂", "Esim": "⩳", "eta": "η", "Eta": "Η", "eth": "ð", "ETH": "Ð", "euml": "ë", "Euml": "Ë", "euro": "€", "excl": "!", "exist": "∃", "Exists": "∃", "expectation": "ℰ", "exponentiale": "ⅇ", "ExponentialE": "ⅇ", "fallingdotseq": "≒", "fcy": "ф", "Fcy": "Ф", "female": "♀", "ffilig": "ﬃ", "fflig": "ﬀ", "ffllig": "ﬄ", "ffr": "𝔣", "Ffr": "𝔉", "filig": "ﬁ", "FilledSmallSquare": "◼", "FilledVerySmallSquare": "▪", "fjlig": "fj", "flat": "♭", "fllig": "ﬂ", "fltns": "▱", "fnof": "ƒ", "fopf": "𝕗", "Fopf": "𝔽", "forall": "∀", "ForAll": "∀", "fork": "⋔", "forkv": "⫙", "Fouriertrf": "ℱ", "fpartint": "⨍", "frac12": "½", "frac13": "⅓", "frac14": "¼", "frac15": "⅕", "frac16": "⅙", "frac18": "⅛", "frac23": "⅔", "frac25": "⅖", "frac34": "¾", "frac35": "⅗", "frac38": "⅜", "frac45": "⅘", "frac56": "⅚", "frac58": "⅝", "frac78": "⅞", "frasl": "⁄", "frown": "⌢", "fscr": "𝒻", "Fscr": "ℱ", "gacute": "ǵ", "gamma": "γ", "Gamma": "Γ", "gammad": "ϝ", "Gammad": "Ϝ", "gap": "⪆", "gbreve": "ğ", "Gbreve": "Ğ", "Gcedil": "Ģ", "gcirc": "ĝ", "Gcirc": "Ĝ", "gcy": "г", "Gcy": "Г", "gdot": "ġ", "Gdot": "Ġ", "ge": "≥", "gE": "≧", "gel": "⋛", "gEl": "⪌", "geq": "≥", "geqq": "≧", "geqslant": "⩾", "ges": "⩾", "gescc": "⪩", "gesdot": "⪀", "gesdoto": "⪂", "gesdotol": "⪄", "gesl": "⋛︀", "gesles": "⪔", "gfr": "𝔤", "Gfr": "𝔊", "gg": "≫", "Gg": "⋙", "ggg": "⋙", "gimel": "ℷ", "gjcy": "ѓ", "GJcy": "Ѓ", "gl": "≷", "gla": "⪥", "glE": "⪒", "glj": "⪤", "gnap": "⪊", "gnapprox": "⪊", "gne": "⪈", "gnE": "≩", "gneq": "⪈", "gneqq": "≩", "gnsim": "⋧", "gopf": "𝕘", "Gopf": "𝔾", "grave": "`", "GreaterEqual": "≥", "GreaterEqualLess": "⋛", "GreaterFullEqual": "≧", "GreaterGreater": "⪢", "GreaterLess": "≷", "GreaterSlantEqual": "⩾", "GreaterTilde": "≳", "gscr": "ℊ", "Gscr": "𝒢", "gsim": "≳", "gsime": "⪎", "gsiml": "⪐", "gt": ">", "Gt": "≫", "GT": ">", "gtcc": "⪧", "gtcir": "⩺", "gtdot": "⋗", "gtlPar": "⦕", "gtquest": "⩼", "gtrapprox": "⪆", "gtrarr": "⥸", "gtrdot": "⋗", "gtreqless": "⋛", "gtreqqless": "⪌", "gtrless": "≷", "gtrsim": "≳", "gvertneqq": "≩︀", "gvnE": "≩︀", "Hacek": "ˇ", "hairsp": " ", "half": "½", "hamilt": "ℋ", "hardcy": "ъ", "HARDcy": "Ъ", "harr": "↔", "hArr": "⇔", "harrcir": "⥈", "harrw": "↭", "Hat": "^", "hbar": "ℏ", "hcirc": "ĥ", "Hcirc": "Ĥ", "hearts": "♥", "heartsuit": "♥", "hellip": "…", "hercon": "⊹", "hfr": "𝔥", "Hfr": "ℌ", "HilbertSpace": "ℋ", "hksearow": "⤥", "hkswarow": "⤦", "hoarr": "⇿", "homtht": "∻", "hookleftarrow": "↩", "hookrightarrow": "↪", "hopf": "𝕙", "Hopf": "ℍ", "horbar": "―", "HorizontalLine": "─", "hscr": "𝒽", "Hscr": "ℋ", "hslash": "ℏ", "hstrok": "ħ", "Hstrok": "Ħ", "HumpDownHump": "≎", "HumpEqual": "≏", "hybull": "⁃", "hyphen": "‐", "iacute": "í", "Iacute": "Í", "ic": "⁣", "icirc": "î", "Icirc": "Î", "icy": "и", "Icy": "И", "Idot": "İ", "iecy": "е", "IEcy": "Е", "iexcl": "¡", "iff": "⇔", "ifr": "𝔦", "Ifr": "ℑ", "igrave": "ì", "Igrave": "Ì", "ii": "ⅈ", "iiiint": "⨌", "iiint": "∭", "iinfin": "⧜", "iiota": "℩", "ijlig": "ĳ", "IJlig": "Ĳ", "Im": "ℑ", "imacr": "ī", "Imacr": "Ī", "image": "ℑ", "ImaginaryI": "ⅈ", "imagline": "ℐ", "imagpart": "ℑ", "imath": "ı", "imof": "⊷", "imped": "Ƶ", "Implies": "⇒", "in": "∈", "incare": "℅", "infin": "∞", "infintie": "⧝", "inodot": "ı", "int": "∫", "Int": "∬", "intcal": "⊺", "integers": "ℤ", "Integral": "∫", "intercal": "⊺", "Intersection": "⋂", "intlarhk": "⨗", "intprod": "⨼", "InvisibleComma": "⁣", "InvisibleTimes": "⁢", "iocy": "ё", "IOcy": "Ё", "iogon": "į", "Iogon": "Į", "iopf": "𝕚", "Iopf": "𝕀", "iota": "ι", "Iota": "Ι", "iprod": "⨼", "iquest": "¿", "iscr": "𝒾", "Iscr": "ℐ", "isin": "∈", "isindot": "⋵", "isinE": "⋹", "isins": "⋴", "isinsv": "⋳", "isinv": "∈", "it": "⁢", "itilde": "ĩ", "Itilde": "Ĩ", "iukcy": "і", "Iukcy": "І", "iuml": "ï", "Iuml": "Ï", "jcirc": "ĵ", "Jcirc": "Ĵ", "jcy": "й", "Jcy": "Й", "jfr": "𝔧", "Jfr": "𝔍", "jmath": "ȷ", "jopf": "𝕛", "Jopf": "𝕁", "jscr": "𝒿", "Jscr": "𝒥", "jsercy": "ј", "Jsercy": "Ј", "jukcy": "є", "Jukcy": "Є", "kappa": "κ", "Kappa": "Κ", "kappav": "ϰ", "kcedil": "ķ", "Kcedil": "Ķ", "kcy": "к", "Kcy": "К", "kfr": "𝔨", "Kfr": "𝔎", "kgreen": "ĸ", "khcy": "х", "KHcy": "Х", "kjcy": "ќ", "KJcy": "Ќ", "kopf": "𝕜", "Kopf": "𝕂", "kscr": "𝓀", "Kscr": "𝒦", "lAarr": "⇚", "lacute": "ĺ", "Lacute": "Ĺ", "laemptyv": "⦴", "lagran": "ℒ", "lambda": "λ", "Lambda": "Λ", "lang": "⟨", "Lang": "⟪", "langd": "⦑", "langle": "⟨", "lap": "⪅", "Laplacetrf": "ℒ", "laquo": "«", "larr": "←", "lArr": "⇐", "Larr": "↞", "larrb": "⇤", "larrbfs": "⤟", "larrfs": "⤝", "larrhk": "↩", "larrlp": "↫", "larrpl": "⤹", "larrsim": "⥳", "larrtl": "↢", "lat": "⪫", "latail": "⤙", "lAtail": "⤛", "late": "⪭", "lates": "⪭︀", "lbarr": "⤌", "lBarr": "⤎", "lbbrk": "❲", "lbrace": "{", "lbrack": "[", "lbrke": "⦋", "lbrksld": "⦏", "lbrkslu": "⦍", "lcaron": "ľ", "Lcaron": "Ľ", "lcedil": "ļ", "Lcedil": "Ļ", "lceil": "⌈", "lcub": "{", "lcy": "л", "Lcy": "Л", "ldca": "⤶", "ldquo": "“", "ldquor": "„", "ldrdhar": "⥧", "ldrushar": "⥋", "ldsh": "↲", "le": "≤", "lE": "≦", "LeftAngleBracket": "⟨", "leftarrow": "←", "Leftarrow": "⇐", "LeftArrow": "←", "LeftArrowBar": "⇤", "LeftArrowRightArrow": "⇆", "leftarrowtail": "↢", "LeftCeiling": "⌈", "LeftDoubleBracket": "⟦", "LeftDownTeeVector": "⥡", "LeftDownVector": "⇃", "LeftDownVectorBar": "⥙", "LeftFloor": "⌊", "leftharpoondown": "↽", "leftharpoonup": "↼", "leftleftarrows": "⇇", "leftrightarrow": "↔", "Leftrightarrow": "⇔", "LeftRightArrow": "↔", "leftrightarrows": "⇆", "leftrightharpoons": "⇋", "leftrightsquigarrow": "↭", "LeftRightVector": "⥎", "LeftTee": "⊣", "LeftTeeArrow": "↤", "LeftTeeVector": "⥚", "leftthreetimes": "⋋", "LeftTriangle": "⊲", "LeftTriangleBar": "⧏", "LeftTriangleEqual": "⊴", "LeftUpDownVector": "⥑", "LeftUpTeeVector": "⥠", "LeftUpVector": "↿", "LeftUpVectorBar": "⥘", "LeftVector": "↼", "LeftVectorBar": "⥒", "leg": "⋚", "lEg": "⪋", "leq": "≤", "leqq": "≦", "leqslant": "⩽", "les": "⩽", "lescc": "⪨", "lesdot": "⩿", "lesdoto": "⪁", "lesdotor": "⪃", "lesg": "⋚︀", "lesges": "⪓", "lessapprox": "⪅", "lessdot": "⋖", "lesseqgtr": "⋚", "lesseqqgtr": "⪋", "LessEqualGreater": "⋚", "LessFullEqual": "≦", "LessGreater": "≶", "lessgtr": "≶", "LessLess": "⪡", "lesssim": "≲", "LessSlantEqual": "⩽", "LessTilde": "≲", "lfisht": "⥼", "lfloor": "⌊", "lfr": "𝔩", "Lfr": "𝔏", "lg": "≶", "lgE": "⪑", "lHar": "⥢", "lhard": "↽", "lharu": "↼", "lharul": "⥪", "lhblk": "▄", "ljcy": "љ", "LJcy": "Љ", "ll": "≪", "Ll": "⋘", "llarr": "⇇", "llcorner": "⌞", "Lleftarrow": "⇚", "llhard": "⥫", "lltri": "◺", "lmidot": "ŀ", "Lmidot": "Ŀ", "lmoust": "⎰", "lmoustache": "⎰", "lnap": "⪉", "lnapprox": "⪉", "lne": "⪇", "lnE": "≨", "lneq": "⪇", "lneqq": "≨", "lnsim": "⋦", "loang": "⟬", "loarr": "⇽", "lobrk": "⟦", "longleftarrow": "⟵", "Longleftarrow": "⟸", "LongLeftArrow": "⟵", "longleftrightarrow": "⟷", "Longleftrightarrow": "⟺", "LongLeftRightArrow": "⟷", "longmapsto": "⟼", "longrightarrow": "⟶", "Longrightarrow": "⟹", "LongRightArrow": "⟶", "looparrowleft": "↫", "looparrowright": "↬", "lopar": "⦅", "lopf": "𝕝", "Lopf": "𝕃", "loplus": "⨭", "lotimes": "⨴", "lowast": "∗", "lowbar": "_", "LowerLeftArrow": "↙", "LowerRightArrow": "↘", "loz": "◊", "lozenge": "◊", "lozf": "⧫", "lpar": "(", "lparlt": "⦓", "lrarr": "⇆", "lrcorner": "⌟", "lrhar": "⇋", "lrhard": "⥭", "lrm": "‎", "lrtri": "⊿", "lsaquo": "‹", "lscr": "𝓁", "Lscr": "ℒ", "lsh": "↰", "Lsh": "↰", "lsim": "≲", "lsime": "⪍", "lsimg": "⪏", "lsqb": "[", "lsquo": "‘", "lsquor": "‚", "lstrok": "ł", "Lstrok": "Ł", "lt": "<", "Lt": "≪", "LT": "<", "ltcc": "⪦", "ltcir": "⩹", "ltdot": "⋖", "lthree": "⋋", "ltimes": "⋉", "ltlarr": "⥶", "ltquest": "⩻", "ltri": "◃", "ltrie": "⊴", "ltrif": "◂", "ltrPar": "⦖", "lurdshar": "⥊", "luruhar": "⥦", "lvertneqq": "≨︀", "lvnE": "≨︀", "macr": "¯", "male": "♂", "malt": "✠", "maltese": "✠", "map": "↦", "Map": "⤅", "mapsto": "↦", "mapstodown": "↧", "mapstoleft": "↤", "mapstoup": "↥", "marker": "▮", "mcomma": "⨩", "mcy": "м", "Mcy": "М", "mdash": "—", "mDDot": "∺", "measuredangle": "∡", "MediumSpace": " ", "Mellintrf": "ℳ", "mfr": "𝔪", "Mfr": "𝔐", "mho": "℧", "micro": "µ", "mid": "∣", "midast": "*", "midcir": "⫰", "middot": "·", "minus": "−", "minusb": "⊟", "minusd": "∸", "minusdu": "⨪", "MinusPlus": "∓", "mlcp": "⫛", "mldr": "…", "mnplus": "∓", "models": "⊧", "mopf": "𝕞", "Mopf": "𝕄", "mp": "∓", "mscr": "𝓂", "Mscr": "ℳ", "mstpos": "∾", "mu": "μ", "Mu": "Μ", "multimap": "⊸", "mumap": "⊸", "nabla": "∇", "nacute": "ń", "Nacute": "Ń", "nang": "∠⃒", "nap": "≉", "napE": "⩰̸", "napid": "≋̸", "napos": "ŉ", "napprox": "≉", "natur": "♮", "natural": "♮", "naturals": "ℕ", "nbsp": " ", "nbump": "≎̸", "nbumpe": "≏̸", "ncap": "⩃", "ncaron": "ň", "Ncaron": "Ň", "ncedil": "ņ", "Ncedil": "Ņ", "ncong": "≇", "ncongdot": "⩭̸", "ncup": "⩂", "ncy": "н", "Ncy": "Н", "ndash": "–", "ne": "≠", "nearhk": "⤤", "nearr": "↗", "neArr": "⇗", "nearrow": "↗", "nedot": "≐̸", "NegativeMediumSpace": "​", "NegativeThickSpace": "​", "NegativeThinSpace": "​", "NegativeVeryThinSpace": "​", "nequiv": "≢", "nesear": "⤨", "nesim": "≂̸", "NestedGreaterGreater": "≫", "NestedLessLess": "≪", "NewLine": "\n", "nexist": "∄", "nexists": "∄", "nfr": "𝔫", "Nfr": "𝔑", "nge": "≱", "ngE": "≧̸", "ngeq": "≱", "ngeqq": "≧̸", "ngeqslant": "⩾̸", "nges": "⩾̸", "nGg": "⋙̸", "ngsim": "≵", "ngt": "≯", "nGt": "≫⃒", "ngtr": "≯", "nGtv": "≫̸", "nharr": "↮", "nhArr": "⇎", "nhpar": "⫲", "ni": "∋", "nis": "⋼", "nisd": "⋺", "niv": "∋", "njcy": "њ", "NJcy": "Њ", "nlarr": "↚", "nlArr": "⇍", "nldr": "‥", "nle": "≰", "nlE": "≦̸", "nleftarrow": "↚", "nLeftarrow": "⇍", "nleftrightarrow": "↮", "nLeftrightarrow": "⇎", "nleq": "≰", "nleqq": "≦̸", "nleqslant": "⩽̸", "nles": "⩽̸", "nless": "≮", "nLl": "⋘̸", "nlsim": "≴", "nlt": "≮", "nLt": "≪⃒", "nltri": "⋪", "nltrie": "⋬", "nLtv": "≪̸", "nmid": "∤", "NoBreak": "⁠", "NonBreakingSpace": " ", "nopf": "𝕟", "Nopf": "ℕ", "not": "¬", "Not": "⫬", "NotCongruent": "≢", "NotCupCap": "≭", "NotDoubleVerticalBar": "∦", "NotElement": "∉", "NotEqual": "≠", "NotEqualTilde": "≂̸", "NotExists": "∄", "NotGreater": "≯", "NotGreaterEqual": "≱", "NotGreaterFullEqual": "≧̸", "NotGreaterGreater": "≫̸", "NotGreaterLess": "≹", "NotGreaterSlantEqual": "⩾̸", "NotGreaterTilde": "≵", "NotHumpDownHump": "≎̸", "NotHumpEqual": "≏̸", "notin": "∉", "notindot": "⋵̸", "notinE": "⋹̸", "notinva": "∉", "notinvb": "⋷", "notinvc": "⋶", "NotLeftTriangle": "⋪", "NotLeftTriangleBar": "⧏̸", "NotLeftTriangleEqual": "⋬", "NotLess": "≮", "NotLessEqual": "≰", "NotLessGreater": "≸", "NotLessLess": "≪̸", "NotLessSlantEqual": "⩽̸", "NotLessTilde": "≴", "NotNestedGreaterGreater": "⪢̸", "NotNestedLessLess": "⪡̸", "notni": "∌", "notniva": "∌", "notnivb": "⋾", "notnivc": "⋽", "NotPrecedes": "⊀", "NotPrecedesEqual": "⪯̸", "NotPrecedesSlantEqual": "⋠", "NotReverseElement": "∌", "NotRightTriangle": "⋫", "NotRightTriangleBar": "⧐̸", "NotRightTriangleEqual": "⋭", "NotSquareSubset": "⊏̸", "NotSquareSubsetEqual": "⋢", "NotSquareSuperset": "⊐̸", "NotSquareSupersetEqual": "⋣", "NotSubset": "⊂⃒", "NotSubsetEqual": "⊈", "NotSucceeds": "⊁", "NotSucceedsEqual": "⪰̸", "NotSucceedsSlantEqual": "⋡", "NotSucceedsTilde": "≿̸", "NotSuperset": "⊃⃒", "NotSupersetEqual": "⊉", "NotTilde": "≁", "NotTildeEqual": "≄", "NotTildeFullEqual": "≇", "NotTildeTilde": "≉", "NotVerticalBar": "∤", "npar": "∦", "nparallel": "∦", "nparsl": "⫽⃥", "npart": "∂̸", "npolint": "⨔", "npr": "⊀", "nprcue": "⋠", "npre": "⪯̸", "nprec": "⊀", "npreceq": "⪯̸", "nrarr": "↛", "nrArr": "⇏", "nrarrc": "⤳̸", "nrarrw": "↝̸", "nrightarrow": "↛", "nRightarrow": "⇏", "nrtri": "⋫", "nrtrie": "⋭", "nsc": "⊁", "nsccue": "⋡", "nsce": "⪰̸", "nscr": "𝓃", "Nscr": "𝒩", "nshortmid": "∤", "nshortparallel": "∦", "nsim": "≁", "nsime": "≄", "nsimeq": "≄", "nsmid": "∤", "nspar": "∦", "nsqsube": "⋢", "nsqsupe": "⋣", "nsub": "⊄", "nsube": "⊈", "nsubE": "⫅̸", "nsubset": "⊂⃒", "nsubseteq": "⊈", "nsubseteqq": "⫅̸", "nsucc": "⊁", "nsucceq": "⪰̸", "nsup": "⊅", "nsupe": "⊉", "nsupE": "⫆̸", "nsupset": "⊃⃒", "nsupseteq": "⊉", "nsupseteqq": "⫆̸", "ntgl": "≹", "ntilde": "ñ", "Ntilde": "Ñ", "ntlg": "≸", "ntriangleleft": "⋪", "ntrianglelefteq": "⋬", "ntriangleright": "⋫", "ntrianglerighteq": "⋭", "nu": "ν", "Nu": "Ν", "num": "#", "numero": "№", "numsp": " ", "nvap": "≍⃒", "nvdash": "⊬", "nvDash": "⊭", "nVdash": "⊮", "nVDash": "⊯", "nvge": "≥⃒", "nvgt": ">⃒", "nvHarr": "⤄", "nvinfin": "⧞", "nvlArr": "⤂", "nvle": "≤⃒", "nvlt": "<⃒", "nvltrie": "⊴⃒", "nvrArr": "⤃", "nvrtrie": "⊵⃒", "nvsim": "∼⃒", "nwarhk": "⤣", "nwarr": "↖", "nwArr": "⇖", "nwarrow": "↖", "nwnear": "⤧", "oacute": "ó", "Oacute": "Ó", "oast": "⊛", "ocir": "⊚", "ocirc": "ô", "Ocirc": "Ô", "ocy": "о", "Ocy": "О", "odash": "⊝", "odblac": "ő", "Odblac": "Ő", "odiv": "⨸", "odot": "⊙", "odsold": "⦼", "oelig": "œ", "OElig": "Œ", "ofcir": "⦿", "ofr": "𝔬", "Ofr": "𝔒", "ogon": "˛", "ograve": "ò", "Ograve": "Ò", "ogt": "⧁", "ohbar": "⦵", "ohm": "Ω", "oint": "∮", "olarr": "↺", "olcir": "⦾", "olcross": "⦻", "oline": "‾", "olt": "⧀", "omacr": "ō", "Omacr": "Ō", "omega": "ω", "Omega": "Ω", "omicron": "ο", "Omicron": "Ο", "omid": "⦶", "ominus": "⊖", "oopf": "𝕠", "Oopf": "𝕆", "opar": "⦷", "OpenCurlyDoubleQuote": "“", "OpenCurlyQuote": "‘", "operp": "⦹", "oplus": "⊕", "or": "∨", "Or": "⩔", "orarr": "↻", "ord": "⩝", "order": "ℴ", "orderof": "ℴ", "ordf": "ª", "ordm": "º", "origof": "⊶", "oror": "⩖", "orslope": "⩗", "orv": "⩛", "oS": "Ⓢ", "oscr": "ℴ", "Oscr": "𝒪", "oslash": "ø", "Oslash": "Ø", "osol": "⊘", "otilde": "õ", "Otilde": "Õ", "otimes": "⊗", "Otimes": "⨷", "otimesas": "⨶", "ouml": "ö", "Ouml": "Ö", "ovbar": "⌽", "OverBar": "‾", "OverBrace": "⏞", "OverBracket": "⎴", "OverParenthesis": "⏜", "par": "∥", "para": "¶", "parallel": "∥", "parsim": "⫳", "parsl": "⫽", "part": "∂", "PartialD": "∂", "pcy": "п", "Pcy": "П", "percnt": "%", "period": ".", "permil": "‰", "perp": "⊥", "pertenk": "‱", "pfr": "𝔭", "Pfr": "𝔓", "phi": "φ", "Phi": "Φ", "phiv": "ϕ", "phmmat": "ℳ", "phone": "☎", "pi": "π", "Pi": "Π", "pitchfork": "⋔", "piv": "ϖ", "planck": "ℏ", "planckh": "ℎ", "plankv": "ℏ", "plus": "+", "plusacir": "⨣", "plusb": "⊞", "pluscir": "⨢", "plusdo": "∔", "plusdu": "⨥", "pluse": "⩲", "PlusMinus": "±", "plusmn": "±", "plussim": "⨦", "plustwo": "⨧", "pm": "±", "Poincareplane": "ℌ", "pointint": "⨕", "popf": "𝕡", "Popf": "ℙ", "pound": "£", "pr": "≺", "Pr": "⪻", "prap": "⪷", "prcue": "≼", "pre": "⪯", "prE": "⪳", "prec": "≺", "precapprox": "⪷", "preccurlyeq": "≼", "Precedes": "≺", "PrecedesEqual": "⪯", "PrecedesSlantEqual": "≼", "PrecedesTilde": "≾", "preceq": "⪯", "precnapprox": "⪹", "precneqq": "⪵", "precnsim": "⋨", "precsim": "≾", "prime": "′", "Prime": "″", "primes": "ℙ", "prnap": "⪹", "prnE": "⪵", "prnsim": "⋨", "prod": "∏", "Product": "∏", "profalar": "⌮", "profline": "⌒", "profsurf": "⌓", "prop": "∝", "Proportion": "∷", "Proportional": "∝", "propto": "∝", "prsim": "≾", "prurel": "⊰", "pscr": "𝓅", "Pscr": "𝒫", "psi": "ψ", "Psi": "Ψ", "puncsp": " ", "qfr": "𝔮", "Qfr": "𝔔", "qint": "⨌", "qopf": "𝕢", "Qopf": "ℚ", "qprime": "⁗", "qscr": "𝓆", "Qscr": "𝒬", "quaternions": "ℍ", "quatint": "⨖", "quest": "?", "questeq": "≟", "quot": '"', "QUOT": '"', "rAarr": "⇛", "race": "∽̱", "racute": "ŕ", "Racute": "Ŕ", "radic": "√", "raemptyv": "⦳", "rang": "⟩", "Rang": "⟫", "rangd": "⦒", "range": "⦥", "rangle": "⟩", "raquo": "»", "rarr": "→", "rArr": "⇒", "Rarr": "↠", "rarrap": "⥵", "rarrb": "⇥", "rarrbfs": "⤠", "rarrc": "⤳", "rarrfs": "⤞", "rarrhk": "↪", "rarrlp": "↬", "rarrpl": "⥅", "rarrsim": "⥴", "rarrtl": "↣", "Rarrtl": "⤖", "rarrw": "↝", "ratail": "⤚", "rAtail": "⤜", "ratio": "∶", "rationals": "ℚ", "rbarr": "⤍", "rBarr": "⤏", "RBarr": "⤐", "rbbrk": "❳", "rbrace": "}", "rbrack": "]", "rbrke": "⦌", "rbrksld": "⦎", "rbrkslu": "⦐", "rcaron": "ř", "Rcaron": "Ř", "rcedil": "ŗ", "Rcedil": "Ŗ", "rceil": "⌉", "rcub": "}", "rcy": "р", "Rcy": "Р", "rdca": "⤷", "rdldhar": "⥩", "rdquo": "”", "rdquor": "”", "rdsh": "↳", "Re": "ℜ", "real": "ℜ", "realine": "ℛ", "realpart": "ℜ", "reals": "ℝ", "rect": "▭", "reg": "®", "REG": "®", "ReverseElement": "∋", "ReverseEquilibrium": "⇋", "ReverseUpEquilibrium": "⥯", "rfisht": "⥽", "rfloor": "⌋", "rfr": "𝔯", "Rfr": "ℜ", "rHar": "⥤", "rhard": "⇁", "rharu": "⇀", "rharul": "⥬", "rho": "ρ", "Rho": "Ρ", "rhov": "ϱ", "RightAngleBracket": "⟩", "rightarrow": "→", "Rightarrow": "⇒", "RightArrow": "→", "RightArrowBar": "⇥", "RightArrowLeftArrow": "⇄", "rightarrowtail": "↣", "RightCeiling": "⌉", "RightDoubleBracket": "⟧", "RightDownTeeVector": "⥝", "RightDownVector": "⇂", "RightDownVectorBar": "⥕", "RightFloor": "⌋", "rightharpoondown": "⇁", "rightharpoonup": "⇀", "rightleftarrows": "⇄", "rightleftharpoons": "⇌", "rightrightarrows": "⇉", "rightsquigarrow": "↝", "RightTee": "⊢", "RightTeeArrow": "↦", "RightTeeVector": "⥛", "rightthreetimes": "⋌", "RightTriangle": "⊳", "RightTriangleBar": "⧐", "RightTriangleEqual": "⊵", "RightUpDownVector": "⥏", "RightUpTeeVector": "⥜", "RightUpVector": "↾", "RightUpVectorBar": "⥔", "RightVector": "⇀", "RightVectorBar": "⥓", "ring": "˚", "risingdotseq": "≓", "rlarr": "⇄", "rlhar": "⇌", "rlm": "‏", "rmoust": "⎱", "rmoustache": "⎱", "rnmid": "⫮", "roang": "⟭", "roarr": "⇾", "robrk": "⟧", "ropar": "⦆", "ropf": "𝕣", "Ropf": "ℝ", "roplus": "⨮", "rotimes": "⨵", "RoundImplies": "⥰", "rpar": ")", "rpargt": "⦔", "rppolint": "⨒", "rrarr": "⇉", "Rrightarrow": "⇛", "rsaquo": "›", "rscr": "𝓇", "Rscr": "ℛ", "rsh": "↱", "Rsh": "↱", "rsqb": "]", "rsquo": "’", "rsquor": "’", "rthree": "⋌", "rtimes": "⋊", "rtri": "▹", "rtrie": "⊵", "rtrif": "▸", "rtriltri": "⧎", "RuleDelayed": "⧴", "ruluhar": "⥨", "rx": "℞", "sacute": "ś", "Sacute": "Ś", "sbquo": "‚", "sc": "≻", "Sc": "⪼", "scap": "⪸", "scaron": "š", "Scaron": "Š", "sccue": "≽", "sce": "⪰", "scE": "⪴", "scedil": "ş", "Scedil": "Ş", "scirc": "ŝ", "Scirc": "Ŝ", "scnap": "⪺", "scnE": "⪶", "scnsim": "⋩", "scpolint": "⨓", "scsim": "≿", "scy": "с", "Scy": "С", "sdot": "⋅", "sdotb": "⊡", "sdote": "⩦", "searhk": "⤥", "searr": "↘", "seArr": "⇘", "searrow": "↘", "sect": "§", "semi": ";", "seswar": "⤩", "setminus": "∖", "setmn": "∖", "sext": "✶", "sfr": "𝔰", "Sfr": "𝔖", "sfrown": "⌢", "sharp": "♯", "shchcy": "щ", "SHCHcy": "Щ", "shcy": "ш", "SHcy": "Ш", "ShortDownArrow": "↓", "ShortLeftArrow": "←", "shortmid": "∣", "shortparallel": "∥", "ShortRightArrow": "→", "ShortUpArrow": "↑", "shy": "­", "sigma": "σ", "Sigma": "Σ", "sigmaf": "ς", "sigmav": "ς", "sim": "∼", "simdot": "⩪", "sime": "≃", "simeq": "≃", "simg": "⪞", "simgE": "⪠", "siml": "⪝", "simlE": "⪟", "simne": "≆", "simplus": "⨤", "simrarr": "⥲", "slarr": "←", "SmallCircle": "∘", "smallsetminus": "∖", "smashp": "⨳", "smeparsl": "⧤", "smid": "∣", "smile": "⌣", "smt": "⪪", "smte": "⪬", "smtes": "⪬︀", "softcy": "ь", "SOFTcy": "Ь", "sol": "/", "solb": "⧄", "solbar": "⌿", "sopf": "𝕤", "Sopf": "𝕊", "spades": "♠", "spadesuit": "♠", "spar": "∥", "sqcap": "⊓", "sqcaps": "⊓︀", "sqcup": "⊔", "sqcups": "⊔︀", "Sqrt": "√", "sqsub": "⊏", "sqsube": "⊑", "sqsubset": "⊏", "sqsubseteq": "⊑", "sqsup": "⊐", "sqsupe": "⊒", "sqsupset": "⊐", "sqsupseteq": "⊒", "squ": "□", "square": "□", "Square": "□", "SquareIntersection": "⊓", "SquareSubset": "⊏", "SquareSubsetEqual": "⊑", "SquareSuperset": "⊐", "SquareSupersetEqual": "⊒", "SquareUnion": "⊔", "squarf": "▪", "squf": "▪", "srarr": "→", "sscr": "𝓈", "Sscr": "𝒮", "ssetmn": "∖", "ssmile": "⌣", "sstarf": "⋆", "star": "☆", "Star": "⋆", "starf": "★", "straightepsilon": "ϵ", "straightphi": "ϕ", "strns": "¯", "sub": "⊂", "Sub": "⋐", "subdot": "⪽", "sube": "⊆", "subE": "⫅", "subedot": "⫃", "submult": "⫁", "subne": "⊊", "subnE": "⫋", "subplus": "⪿", "subrarr": "⥹", "subset": "⊂", "Subset": "⋐", "subseteq": "⊆", "subseteqq": "⫅", "SubsetEqual": "⊆", "subsetneq": "⊊", "subsetneqq": "⫋", "subsim": "⫇", "subsub": "⫕", "subsup": "⫓", "succ": "≻", "succapprox": "⪸", "succcurlyeq": "≽", "Succeeds": "≻", "SucceedsEqual": "⪰", "SucceedsSlantEqual": "≽", "SucceedsTilde": "≿", "succeq": "⪰", "succnapprox": "⪺", "succneqq": "⪶", "succnsim": "⋩", "succsim": "≿", "SuchThat": "∋", "sum": "∑", "Sum": "∑", "sung": "♪", "sup": "⊃", "Sup": "⋑", "sup1": "¹", "sup2": "²", "sup3": "³", "supdot": "⪾", "supdsub": "⫘", "supe": "⊇", "supE": "⫆", "supedot": "⫄", "Superset": "⊃", "SupersetEqual": "⊇", "suphsol": "⟉", "suphsub": "⫗", "suplarr": "⥻", "supmult": "⫂", "supne": "⊋", "supnE": "⫌", "supplus": "⫀", "supset": "⊃", "Supset": "⋑", "supseteq": "⊇", "supseteqq": "⫆", "supsetneq": "⊋", "supsetneqq": "⫌", "supsim": "⫈", "supsub": "⫔", "supsup": "⫖", "swarhk": "⤦", "swarr": "↙", "swArr": "⇙", "swarrow": "↙", "swnwar": "⤪", "szlig": "ß", "Tab": "	", "target": "⌖", "tau": "τ", "Tau": "Τ", "tbrk": "⎴", "tcaron": "ť", "Tcaron": "Ť", "tcedil": "ţ", "Tcedil": "Ţ", "tcy": "т", "Tcy": "Т", "tdot": "⃛", "telrec": "⌕", "tfr": "𝔱", "Tfr": "𝔗", "there4": "∴", "therefore": "∴", "Therefore": "∴", "theta": "θ", "Theta": "Θ", "thetasym": "ϑ", "thetav": "ϑ", "thickapprox": "≈", "thicksim": "∼", "ThickSpace": "  ", "thinsp": " ", "ThinSpace": " ", "thkap": "≈", "thksim": "∼", "thorn": "þ", "THORN": "Þ", "tilde": "˜", "Tilde": "∼", "TildeEqual": "≃", "TildeFullEqual": "≅", "TildeTilde": "≈", "times": "×", "timesb": "⊠", "timesbar": "⨱", "timesd": "⨰", "tint": "∭", "toea": "⤨", "top": "⊤", "topbot": "⌶", "topcir": "⫱", "topf": "𝕥", "Topf": "𝕋", "topfork": "⫚", "tosa": "⤩", "tprime": "‴", "trade": "™", "TRADE": "™", "triangle": "▵", "triangledown": "▿", "triangleleft": "◃", "trianglelefteq": "⊴", "triangleq": "≜", "triangleright": "▹", "trianglerighteq": "⊵", "tridot": "◬", "trie": "≜", "triminus": "⨺", "TripleDot": "⃛", "triplus": "⨹", "trisb": "⧍", "tritime": "⨻", "trpezium": "⏢", "tscr": "𝓉", "Tscr": "𝒯", "tscy": "ц", "TScy": "Ц", "tshcy": "ћ", "TSHcy": "Ћ", "tstrok": "ŧ", "Tstrok": "Ŧ", "twixt": "≬", "twoheadleftarrow": "↞", "twoheadrightarrow": "↠", "uacute": "ú", "Uacute": "Ú", "uarr": "↑", "uArr": "⇑", "Uarr": "↟", "Uarrocir": "⥉", "ubrcy": "ў", "Ubrcy": "Ў", "ubreve": "ŭ", "Ubreve": "Ŭ", "ucirc": "û", "Ucirc": "Û", "ucy": "у", "Ucy": "У", "udarr": "⇅", "udblac": "ű", "Udblac": "Ű", "udhar": "⥮", "ufisht": "⥾", "ufr": "𝔲", "Ufr": "𝔘", "ugrave": "ù", "Ugrave": "Ù", "uHar": "⥣", "uharl": "↿", "uharr": "↾", "uhblk": "▀", "ulcorn": "⌜", "ulcorner": "⌜", "ulcrop": "⌏", "ultri": "◸", "umacr": "ū", "Umacr": "Ū", "uml": "¨", "UnderBar": "_", "UnderBrace": "⏟", "UnderBracket": "⎵", "UnderParenthesis": "⏝", "Union": "⋃", "UnionPlus": "⊎", "uogon": "ų", "Uogon": "Ų", "uopf": "𝕦", "Uopf": "𝕌", "uparrow": "↑", "Uparrow": "⇑", "UpArrow": "↑", "UpArrowBar": "⤒", "UpArrowDownArrow": "⇅", "updownarrow": "↕", "Updownarrow": "⇕", "UpDownArrow": "↕", "UpEquilibrium": "⥮", "upharpoonleft": "↿", "upharpoonright": "↾", "uplus": "⊎", "UpperLeftArrow": "↖", "UpperRightArrow": "↗", "upsi": "υ", "Upsi": "ϒ", "upsih": "ϒ", "upsilon": "υ", "Upsilon": "Υ", "UpTee": "⊥", "UpTeeArrow": "↥", "upuparrows": "⇈", "urcorn": "⌝", "urcorner": "⌝", "urcrop": "⌎", "uring": "ů", "Uring": "Ů", "urtri": "◹", "uscr": "𝓊", "Uscr": "𝒰", "utdot": "⋰", "utilde": "ũ", "Utilde": "Ũ", "utri": "▵", "utrif": "▴", "uuarr": "⇈", "uuml": "ü", "Uuml": "Ü", "uwangle": "⦧", "vangrt": "⦜", "varepsilon": "ϵ", "varkappa": "ϰ", "varnothing": "∅", "varphi": "ϕ", "varpi": "ϖ", "varpropto": "∝", "varr": "↕", "vArr": "⇕", "varrho": "ϱ", "varsigma": "ς", "varsubsetneq": "⊊︀", "varsubsetneqq": "⫋︀", "varsupsetneq": "⊋︀", "varsupsetneqq": "⫌︀", "vartheta": "ϑ", "vartriangleleft": "⊲", "vartriangleright": "⊳", "vBar": "⫨", "Vbar": "⫫", "vBarv": "⫩", "vcy": "в", "Vcy": "В", "vdash": "⊢", "vDash": "⊨", "Vdash": "⊩", "VDash": "⊫", "Vdashl": "⫦", "vee": "∨", "Vee": "⋁", "veebar": "⊻", "veeeq": "≚", "vellip": "⋮", "verbar": "|", "Verbar": "‖", "vert": "|", "Vert": "‖", "VerticalBar": "∣", "VerticalLine": "|", "VerticalSeparator": "❘", "VerticalTilde": "≀", "VeryThinSpace": " ", "vfr": "𝔳", "Vfr": "𝔙", "vltri": "⊲", "vnsub": "⊂⃒", "vnsup": "⊃⃒", "vopf": "𝕧", "Vopf": "𝕍", "vprop": "∝", "vrtri": "⊳", "vscr": "𝓋", "Vscr": "𝒱", "vsubne": "⊊︀", "vsubnE": "⫋︀", "vsupne": "⊋︀", "vsupnE": "⫌︀", "Vvdash": "⊪", "vzigzag": "⦚", "wcirc": "ŵ", "Wcirc": "Ŵ", "wedbar": "⩟", "wedge": "∧", "Wedge": "⋀", "wedgeq": "≙", "weierp": "℘", "wfr": "𝔴", "Wfr": "𝔚", "wopf": "𝕨", "Wopf": "𝕎", "wp": "℘", "wr": "≀", "wreath": "≀", "wscr": "𝓌", "Wscr": "𝒲", "xcap": "⋂", "xcirc": "◯", "xcup": "⋃", "xdtri": "▽", "xfr": "𝔵", "Xfr": "𝔛", "xharr": "⟷", "xhArr": "⟺", "xi": "ξ", "Xi": "Ξ", "xlarr": "⟵", "xlArr": "⟸", "xmap": "⟼", "xnis": "⋻", "xodot": "⨀", "xopf": "𝕩", "Xopf": "𝕏", "xoplus": "⨁", "xotime": "⨂", "xrarr": "⟶", "xrArr": "⟹", "xscr": "𝓍", "Xscr": "𝒳", "xsqcup": "⨆", "xuplus": "⨄", "xutri": "△", "xvee": "⋁", "xwedge": "⋀", "yacute": "ý", "Yacute": "Ý", "yacy": "я", "YAcy": "Я", "ycirc": "ŷ", "Ycirc": "Ŷ", "ycy": "ы", "Ycy": "Ы", "yen": "¥", "yfr": "𝔶", "Yfr": "𝔜", "yicy": "ї", "YIcy": "Ї", "yopf": "𝕪", "Yopf": "𝕐", "yscr": "𝓎", "Yscr": "𝒴", "yucy": "ю", "YUcy": "Ю", "yuml": "ÿ", "Yuml": "Ÿ", "zacute": "ź", "Zacute": "Ź", "zcaron": "ž", "Zcaron": "Ž", "zcy": "з", "Zcy": "З", "zdot": "ż", "Zdot": "Ż", "zeetrf": "ℨ", "ZeroWidthSpace": "​", "zeta": "ζ", "Zeta": "Ζ", "zfr": "𝔷", "Zfr": "ℨ", "zhcy": "ж", "ZHcy": "Ж", "zigrarr": "⇝", "zopf": "𝕫", "Zopf": "ℤ", "zscr": "𝓏", "Zscr": "𝒵", "zwj": "‍", "zwnj": "‌" };
      var decodeMapLegacy = { "aacute": "á", "Aacute": "Á", "acirc": "â", "Acirc": "Â", "acute": "´", "aelig": "æ", "AElig": "Æ", "agrave": "à", "Agrave": "À", "amp": "&", "AMP": "&", "aring": "å", "Aring": "Å", "atilde": "ã", "Atilde": "Ã", "auml": "ä", "Auml": "Ä", "brvbar": "¦", "ccedil": "ç", "Ccedil": "Ç", "cedil": "¸", "cent": "¢", "copy": "©", "COPY": "©", "curren": "¤", "deg": "°", "divide": "÷", "eacute": "é", "Eacute": "É", "ecirc": "ê", "Ecirc": "Ê", "egrave": "è", "Egrave": "È", "eth": "ð", "ETH": "Ð", "euml": "ë", "Euml": "Ë", "frac12": "½", "frac14": "¼", "frac34": "¾", "gt": ">", "GT": ">", "iacute": "í", "Iacute": "Í", "icirc": "î", "Icirc": "Î", "iexcl": "¡", "igrave": "ì", "Igrave": "Ì", "iquest": "¿", "iuml": "ï", "Iuml": "Ï", "laquo": "«", "lt": "<", "LT": "<", "macr": "¯", "micro": "µ", "middot": "·", "nbsp": " ", "not": "¬", "ntilde": "ñ", "Ntilde": "Ñ", "oacute": "ó", "Oacute": "Ó", "ocirc": "ô", "Ocirc": "Ô", "ograve": "ò", "Ograve": "Ò", "ordf": "ª", "ordm": "º", "oslash": "ø", "Oslash": "Ø", "otilde": "õ", "Otilde": "Õ", "ouml": "ö", "Ouml": "Ö", "para": "¶", "plusmn": "±", "pound": "£", "quot": '"', "QUOT": '"', "raquo": "»", "reg": "®", "REG": "®", "sect": "§", "shy": "­", "sup1": "¹", "sup2": "²", "sup3": "³", "szlig": "ß", "thorn": "þ", "THORN": "Þ", "times": "×", "uacute": "ú", "Uacute": "Ú", "ucirc": "û", "Ucirc": "Û", "ugrave": "ù", "Ugrave": "Ù", "uml": "¨", "uuml": "ü", "Uuml": "Ü", "yacute": "ý", "Yacute": "Ý", "yen": "¥", "yuml": "ÿ" };
      var decodeMapNumeric = { "0": "�", "128": "€", "130": "‚", "131": "ƒ", "132": "„", "133": "…", "134": "†", "135": "‡", "136": "ˆ", "137": "‰", "138": "Š", "139": "‹", "140": "Œ", "142": "Ž", "145": "‘", "146": "’", "147": "“", "148": "”", "149": "•", "150": "–", "151": "—", "152": "˜", "153": "™", "154": "š", "155": "›", "156": "œ", "158": "ž", "159": "Ÿ" };
      var invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111];
      var stringFromCharCode = String.fromCharCode;
      var object = {};
      var hasOwnProperty2 = object.hasOwnProperty;
      var has = function(object2, propertyName) {
        return hasOwnProperty2.call(object2, propertyName);
      };
      var contains2 = function(array, value) {
        var index2 = -1;
        var length2 = array.length;
        while (++index2 < length2) {
          if (array[index2] == value) {
            return true;
          }
        }
        return false;
      };
      var merge2 = function(options, defaults) {
        if (!options) {
          return defaults;
        }
        var result = {};
        var key2;
        for (key2 in defaults) {
          result[key2] = has(options, key2) ? options[key2] : defaults[key2];
        }
        return result;
      };
      var codePointToSymbol = function(codePoint, strict) {
        var output = "";
        if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
          if (strict) {
            parseError("character reference outside the permissible Unicode range");
          }
          return "�";
        }
        if (has(decodeMapNumeric, codePoint)) {
          if (strict) {
            parseError("disallowed character reference");
          }
          return decodeMapNumeric[codePoint];
        }
        if (strict && contains2(invalidReferenceCodePoints, codePoint)) {
          parseError("disallowed character reference");
        }
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += stringFromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += stringFromCharCode(codePoint);
        return output;
      };
      var hexEscape = function(codePoint) {
        return "&#x" + codePoint.toString(16).toUpperCase() + ";";
      };
      var decEscape = function(codePoint) {
        return "&#" + codePoint + ";";
      };
      var parseError = function(message) {
        throw Error("Parse error: " + message);
      };
      var encode2 = function(string, options) {
        options = merge2(options, encode2.options);
        var strict = options.strict;
        if (strict && regexInvalidRawCodePoint.test(string)) {
          parseError("forbidden code point");
        }
        var encodeEverything = options.encodeEverything;
        var useNamedReferences = options.useNamedReferences;
        var allowUnsafeSymbols = options.allowUnsafeSymbols;
        var escapeCodePoint = options.decimal ? decEscape : hexEscape;
        var escapeBmpSymbol = function(symbol) {
          return escapeCodePoint(symbol.charCodeAt(0));
        };
        if (encodeEverything) {
          string = string.replace(regexAsciiWhitelist, function(symbol) {
            if (useNamedReferences && has(encodeMap, symbol)) {
              return "&" + encodeMap[symbol] + ";";
            }
            return escapeBmpSymbol(symbol);
          });
          if (useNamedReferences) {
            string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;");
          }
          if (useNamedReferences) {
            string = string.replace(regexEncodeNonAscii, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
        } else if (useNamedReferences) {
          if (!allowUnsafeSymbols) {
            string = string.replace(regexEscape, function(string2) {
              return "&" + encodeMap[string2] + ";";
            });
          }
          string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;");
          string = string.replace(regexEncodeNonAscii, function(string2) {
            return "&" + encodeMap[string2] + ";";
          });
        } else if (!allowUnsafeSymbols) {
          string = string.replace(regexEscape, escapeBmpSymbol);
        }
        return string.replace(regexAstralSymbols, function($0) {
          var high = $0.charCodeAt(0);
          var low = $0.charCodeAt(1);
          var codePoint = (high - 55296) * 1024 + low - 56320 + 65536;
          return escapeCodePoint(codePoint);
        }).replace(regexBmpWhitelist, escapeBmpSymbol);
      };
      encode2.options = {
        "allowUnsafeSymbols": false,
        "encodeEverything": false,
        "strict": false,
        "useNamedReferences": false,
        "decimal": false
      };
      var decode = function(html, options) {
        options = merge2(options, decode.options);
        var strict = options.strict;
        if (strict && regexInvalidEntity.test(html)) {
          parseError("malformed character reference");
        }
        return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
          var codePoint;
          var semicolon;
          var decDigits;
          var hexDigits;
          var reference2;
          var next;
          if ($1) {
            reference2 = $1;
            return decodeMap[reference2];
          }
          if ($2) {
            reference2 = $2;
            next = $3;
            if (next && options.isAttributeValue) {
              if (strict && next == "=") {
                parseError("`&` did not start a character reference");
              }
              return $0;
            } else {
              if (strict) {
                parseError(
                  "named character reference was not terminated by a semicolon"
                );
              }
              return decodeMapLegacy[reference2] + (next || "");
            }
          }
          if ($4) {
            decDigits = $4;
            semicolon = $5;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(decDigits, 10);
            return codePointToSymbol(codePoint, strict);
          }
          if ($6) {
            hexDigits = $6;
            semicolon = $7;
            if (strict && !semicolon) {
              parseError("character reference was not terminated by a semicolon");
            }
            codePoint = parseInt(hexDigits, 16);
            return codePointToSymbol(codePoint, strict);
          }
          if (strict) {
            parseError(
              "named character reference was not terminated by a semicolon"
            );
          }
          return $0;
        });
      };
      decode.options = {
        "isAttributeValue": false,
        "strict": false
      };
      var escape = function(string) {
        return string.replace(regexEscape, function($0) {
          return escapeMap[$0];
        });
      };
      var he2 = {
        "version": "1.2.0",
        "encode": encode2,
        "decode": decode,
        "escape": escape,
        "unescape": decode
      };
      if (freeExports2 && !freeExports2.nodeType) {
        if (freeModule2) {
          freeModule2.exports = he2;
        } else {
          for (var key in he2) {
            has(he2, key) && (freeExports2[key] = he2[key]);
          }
        }
      } else {
        root2.he = he2;
      }
    })(he$2);
  })(he$3, he$3.exports);
  return he$3.exports;
}
var heExports = requireHe();
const he$1 = /* @__PURE__ */ getDefaultExportFromCjs$1(heExports);
function OrderedMap(content) {
  this.content = content;
}
OrderedMap.prototype = {
  constructor: OrderedMap,
  find: function(key) {
    for (var i = 0; i < this.content.length; i += 2)
      if (this.content[i] === key) return i;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(key) {
    var found2 = this.find(key);
    return found2 == -1 ? void 0 : this.content[found2 + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(key, value, newKey) {
    var self2 = newKey && newKey != key ? this.remove(newKey) : this;
    var found2 = self2.find(key), content = self2.content.slice();
    if (found2 == -1) {
      content.push(newKey || key, value);
    } else {
      content[found2 + 1] = value;
      if (newKey) content[found2] = newKey;
    }
    return new OrderedMap(content);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(key) {
    var found2 = this.find(key);
    if (found2 == -1) return this;
    var content = this.content.slice();
    content.splice(found2, 2);
    return new OrderedMap(content);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(key, value) {
    return new OrderedMap([key, value].concat(this.remove(key).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(key, value) {
    var content = this.remove(key).content.slice();
    content.push(key, value);
    return new OrderedMap(content);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(place, key, value) {
    var without = this.remove(key), content = without.content.slice();
    var found2 = without.find(place);
    content.splice(found2 == -1 ? content.length : found2, 0, key, value);
    return new OrderedMap(content);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(f) {
    for (var i = 0; i < this.content.length; i += 2)
      f(this.content[i], this.content[i + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(map3) {
    map3 = OrderedMap.from(map3);
    if (!map3.size) return this;
    return new OrderedMap(map3.content.concat(this.subtract(map3).content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(map3) {
    map3 = OrderedMap.from(map3);
    if (!map3.size) return this;
    return new OrderedMap(this.subtract(map3).content.concat(map3.content));
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(map3) {
    var result = this;
    map3 = OrderedMap.from(map3);
    for (var i = 0; i < map3.content.length; i += 2)
      result = result.remove(map3.content[i]);
    return result;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var result = {};
    this.forEach(function(key, value) {
      result[key] = value;
    });
    return result;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
OrderedMap.from = function(value) {
  if (value instanceof OrderedMap) return value;
  var content = [];
  if (value) for (var prop in value) content.push(prop, value[prop]);
  return new OrderedMap(content);
};
function findDiffStart(a, b2, pos) {
  for (let i = 0; ; i++) {
    if (i == a.childCount || i == b2.childCount)
      return a.childCount == b2.childCount ? null : pos;
    let childA = a.child(i), childB = b2.child(i);
    if (childA == childB) {
      pos += childA.nodeSize;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return pos;
    if (childA.isText && childA.text != childB.text) {
      for (let j2 = 0; childA.text[j2] == childB.text[j2]; j2++)
        pos++;
      return pos;
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffStart(childA.content, childB.content, pos + 1);
      if (inner != null)
        return inner;
    }
    pos += childA.nodeSize;
  }
}
function findDiffEnd(a, b2, posA, posB) {
  for (let iA = a.childCount, iB = b2.childCount; ; ) {
    if (iA == 0 || iB == 0)
      return iA == iB ? null : { a: posA, b: posB };
    let childA = a.child(--iA), childB = b2.child(--iB), size2 = childA.nodeSize;
    if (childA == childB) {
      posA -= size2;
      posB -= size2;
      continue;
    }
    if (!childA.sameMarkup(childB))
      return { a: posA, b: posB };
    if (childA.isText && childA.text != childB.text) {
      let same = 0, minSize = Math.min(childA.text.length, childB.text.length);
      while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {
        same++;
        posA--;
        posB--;
      }
      return { a: posA, b: posB };
    }
    if (childA.content.size || childB.content.size) {
      let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);
      if (inner)
        return inner;
    }
    posA -= size2;
    posB -= size2;
  }
}
class Fragment {
  /**
  @internal
  */
  constructor(content, size2) {
    this.content = content;
    this.size = size2 || 0;
    if (size2 == null)
      for (let i = 0; i < content.length; i++)
        this.size += content[i].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(from2, to, f, nodeStart = 0, parent) {
    for (let i = 0, pos = 0; pos < to; i++) {
      let child = this.content[i], end2 = pos + child.nodeSize;
      if (end2 > from2 && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {
        let start2 = pos + 1;
        child.nodesBetween(Math.max(0, from2 - start2), Math.min(child.content.size, to - start2), f, nodeStart + start2);
      }
      pos = end2;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(f) {
    this.nodesBetween(0, this.size, f);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(from2, to, blockSeparator, leafText) {
    let text = "", first2 = true;
    this.nodesBetween(from2, to, (node2, pos) => {
      let nodeText = node2.isText ? node2.text.slice(Math.max(from2, pos) - pos, to - pos) : !node2.isLeaf ? "" : leafText ? typeof leafText === "function" ? leafText(node2) : leafText : node2.type.spec.leafText ? node2.type.spec.leafText(node2) : "";
      if (node2.isBlock && (node2.isLeaf && nodeText || node2.isTextblock) && blockSeparator) {
        if (first2)
          first2 = false;
        else
          text += blockSeparator;
      }
      text += nodeText;
    }, 0);
    return text;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(other) {
    if (!other.size)
      return this;
    if (!this.size)
      return other;
    let last = this.lastChild, first2 = other.firstChild, content = this.content.slice(), i = 0;
    if (last.isText && last.sameMarkup(first2)) {
      content[content.length - 1] = last.withText(last.text + first2.text);
      i = 1;
    }
    for (; i < other.content.length; i++)
      content.push(other.content[i]);
    return new Fragment(content, this.size + other.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(from2, to = this.size) {
    if (from2 == 0 && to == this.size)
      return this;
    let result = [], size2 = 0;
    if (to > from2)
      for (let i = 0, pos = 0; pos < to; i++) {
        let child = this.content[i], end2 = pos + child.nodeSize;
        if (end2 > from2) {
          if (pos < from2 || end2 > to) {
            if (child.isText)
              child = child.cut(Math.max(0, from2 - pos), Math.min(child.text.length, to - pos));
            else
              child = child.cut(Math.max(0, from2 - pos - 1), Math.min(child.content.size, to - pos - 1));
          }
          result.push(child);
          size2 += child.nodeSize;
        }
        pos = end2;
      }
    return new Fragment(result, size2);
  }
  /**
  @internal
  */
  cutByIndex(from2, to) {
    if (from2 == to)
      return Fragment.empty;
    if (from2 == 0 && to == this.content.length)
      return this;
    return new Fragment(this.content.slice(from2, to));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(index2, node2) {
    let current = this.content[index2];
    if (current == node2)
      return this;
    let copy2 = this.content.slice();
    let size2 = this.size + node2.nodeSize - current.nodeSize;
    copy2[index2] = node2;
    return new Fragment(copy2, size2);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(node2) {
    return new Fragment([node2].concat(this.content), this.size + node2.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(node2) {
    return new Fragment(this.content.concat(node2), this.size + node2.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(other) {
    if (this.content.length != other.content.length)
      return false;
    for (let i = 0; i < this.content.length; i++)
      if (!this.content[i].eq(other.content[i]))
        return false;
    return true;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(index2) {
    let found2 = this.content[index2];
    if (!found2)
      throw new RangeError("Index " + index2 + " out of range for " + this);
    return found2;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content[index2] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    for (let i = 0, p = 0; i < this.content.length; i++) {
      let child = this.content[i];
      f(child, p, i);
      p += child.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(other, pos = 0) {
    return findDiffStart(this, other, pos);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(other, pos = this.size, otherPos = other.size) {
    return findDiffEnd(this, other, pos, otherPos);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. @internal
  */
  findIndex(pos) {
    if (pos == 0)
      return retIndex(0, pos);
    if (pos == this.size)
      return retIndex(this.content.length, pos);
    if (pos > this.size || pos < 0)
      throw new RangeError(`Position ${pos} outside of fragment (${this})`);
    for (let i = 0, curPos = 0; ; i++) {
      let cur = this.child(i), end2 = curPos + cur.nodeSize;
      if (end2 >= pos) {
        if (end2 == pos)
          return retIndex(i + 1, end2);
        return retIndex(i, curPos);
      }
      curPos = end2;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((n) => n.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(schema, value) {
    if (!value)
      return Fragment.empty;
    if (!Array.isArray(value))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new Fragment(value.map(schema.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(array) {
    if (!array.length)
      return Fragment.empty;
    let joined, size2 = 0;
    for (let i = 0; i < array.length; i++) {
      let node2 = array[i];
      size2 += node2.nodeSize;
      if (i && node2.isText && array[i - 1].sameMarkup(node2)) {
        if (!joined)
          joined = array.slice(0, i);
        joined[joined.length - 1] = node2.withText(joined[joined.length - 1].text + node2.text);
      } else if (joined) {
        joined.push(node2);
      }
    }
    return new Fragment(joined || array, size2);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(nodes) {
    if (!nodes)
      return Fragment.empty;
    if (nodes instanceof Fragment)
      return nodes;
    if (Array.isArray(nodes))
      return this.fromArray(nodes);
    if (nodes.attrs)
      return new Fragment([nodes], nodes.nodeSize);
    throw new RangeError("Can not convert " + nodes + " to a Fragment" + (nodes.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
Fragment.empty = new Fragment([], 0);
const found = { index: 0, offset: 0 };
function retIndex(index2, offset2) {
  found.index = index2;
  found.offset = offset2;
  return found;
}
function compareDeep(a, b2) {
  if (a === b2)
    return true;
  if (!(a && typeof a == "object") || !(b2 && typeof b2 == "object"))
    return false;
  let array = Array.isArray(a);
  if (Array.isArray(b2) != array)
    return false;
  if (array) {
    if (a.length != b2.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!compareDeep(a[i], b2[i]))
        return false;
  } else {
    for (let p in a)
      if (!(p in b2) || !compareDeep(a[p], b2[p]))
        return false;
    for (let p in b2)
      if (!(p in a))
        return false;
  }
  return true;
}
let Mark$1 = class Mark {
  /**
  @internal
  */
  constructor(type2, attrs) {
    this.type = type2;
    this.attrs = attrs;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(set) {
    let copy2, placed = false;
    for (let i = 0; i < set.length; i++) {
      let other = set[i];
      if (this.eq(other))
        return set;
      if (this.type.excludes(other.type)) {
        if (!copy2)
          copy2 = set.slice(0, i);
      } else if (other.type.excludes(this.type)) {
        return set;
      } else {
        if (!placed && other.type.rank > this.type.rank) {
          if (!copy2)
            copy2 = set.slice(0, i);
          copy2.push(this);
          placed = true;
        }
        if (copy2)
          copy2.push(other);
      }
    }
    if (!copy2)
      copy2 = set.slice();
    if (!placed)
      copy2.push(this);
    return copy2;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return set.slice(0, i).concat(set.slice(i + 1));
    return set;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (this.eq(set[i]))
        return true;
    return false;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(other) {
    return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    return obj;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let type2 = schema.marks[json.type];
    if (!type2)
      throw new RangeError(`There is no mark type ${json.type} in this schema`);
    let mark = type2.create(json.attrs);
    type2.checkAttrs(mark.attrs);
    return mark;
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(a, b2) {
    if (a == b2)
      return true;
    if (a.length != b2.length)
      return false;
    for (let i = 0; i < a.length; i++)
      if (!a[i].eq(b2[i]))
        return false;
    return true;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(marks) {
    if (!marks || Array.isArray(marks) && marks.length == 0)
      return Mark.none;
    if (marks instanceof Mark)
      return [marks];
    let copy2 = marks.slice();
    copy2.sort((a, b2) => a.type.rank - b2.type.rank);
    return copy2;
  }
};
Mark$1.none = [];
class ReplaceError extends Error {
}
class Slice {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(content, openStart, openEnd) {
    this.content = content;
    this.openStart = openStart;
    this.openEnd = openEnd;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(pos, fragment) {
    let content = insertInto(this.content, pos + this.openStart, fragment);
    return content && new Slice(content, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(from2, to) {
    return new Slice(removeRange(this.content, from2 + this.openStart, to + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(other) {
    return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let json = { content: this.content.toJSON() };
    if (this.openStart > 0)
      json.openStart = this.openStart;
    if (this.openEnd > 0)
      json.openEnd = this.openEnd;
    return json;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      return Slice.empty;
    let openStart = json.openStart || 0, openEnd = json.openEnd || 0;
    if (typeof openStart != "number" || typeof openEnd != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(fragment, openIsolating = true) {
    let openStart = 0, openEnd = 0;
    for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)
      openStart++;
    for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)
      openEnd++;
    return new Slice(fragment, openStart, openEnd);
  }
}
Slice.empty = new Slice(Fragment.empty, 0, 0);
function removeRange(content, from2, to) {
  let { index: index2, offset: offset2 } = content.findIndex(from2), child = content.maybeChild(index2);
  let { index: indexTo, offset: offsetTo } = content.findIndex(to);
  if (offset2 == from2 || child.isText) {
    if (offsetTo != to && !content.child(indexTo).isText)
      throw new RangeError("Removing non-flat range");
    return content.cut(0, from2).append(content.cut(to));
  }
  if (index2 != indexTo)
    throw new RangeError("Removing non-flat range");
  return content.replaceChild(index2, child.copy(removeRange(child.content, from2 - offset2 - 1, to - offset2 - 1)));
}
function insertInto(content, dist2, insert, parent) {
  let { index: index2, offset: offset2 } = content.findIndex(dist2), child = content.maybeChild(index2);
  if (offset2 == dist2 || child.isText) {
    if (parent && !parent.canReplace(index2, index2, insert))
      return null;
    return content.cut(0, dist2).append(insert).append(content.cut(dist2));
  }
  let inner = insertInto(child.content, dist2 - offset2 - 1, insert, child);
  return inner && content.replaceChild(index2, child.copy(inner));
}
function replace($from, $to, slice2) {
  if (slice2.openStart > $from.depth)
    throw new ReplaceError("Inserted content deeper than insertion position");
  if ($from.depth - slice2.openStart != $to.depth - slice2.openEnd)
    throw new ReplaceError("Inconsistent open depths");
  return replaceOuter($from, $to, slice2, 0);
}
function replaceOuter($from, $to, slice2, depth) {
  let index2 = $from.index(depth), node2 = $from.node(depth);
  if (index2 == $to.index(depth) && depth < $from.depth - slice2.openStart) {
    let inner = replaceOuter($from, $to, slice2, depth + 1);
    return node2.copy(node2.content.replaceChild(index2, inner));
  } else if (!slice2.content.size) {
    return close(node2, replaceTwoWay($from, $to, depth));
  } else if (!slice2.openStart && !slice2.openEnd && $from.depth == depth && $to.depth == depth) {
    let parent = $from.parent, content = parent.content;
    return close(parent, content.cut(0, $from.parentOffset).append(slice2.content).append(content.cut($to.parentOffset)));
  } else {
    let { start: start2, end: end2 } = prepareSliceForReplace(slice2, $from);
    return close(node2, replaceThreeWay($from, start2, end2, $to, depth));
  }
}
function checkJoin(main2, sub) {
  if (!sub.type.compatibleContent(main2.type))
    throw new ReplaceError("Cannot join " + sub.type.name + " onto " + main2.type.name);
}
function joinable$1($before, $after, depth) {
  let node2 = $before.node(depth);
  checkJoin(node2, $after.node(depth));
  return node2;
}
function addNode(child, target) {
  let last = target.length - 1;
  if (last >= 0 && child.isText && child.sameMarkup(target[last]))
    target[last] = child.withText(target[last].text + child.text);
  else
    target.push(child);
}
function addRange($start, $end, depth, target) {
  let node2 = ($end || $start).node(depth);
  let startIndex = 0, endIndex = $end ? $end.index(depth) : node2.childCount;
  if ($start) {
    startIndex = $start.index(depth);
    if ($start.depth > depth) {
      startIndex++;
    } else if ($start.textOffset) {
      addNode($start.nodeAfter, target);
      startIndex++;
    }
  }
  for (let i = startIndex; i < endIndex; i++)
    addNode(node2.child(i), target);
  if ($end && $end.depth == depth && $end.textOffset)
    addNode($end.nodeBefore, target);
}
function close(node2, content) {
  node2.type.checkContent(content);
  return node2.copy(content);
}
function replaceThreeWay($from, $start, $end, $to, depth) {
  let openStart = $from.depth > depth && joinable$1($from, $start, depth + 1);
  let openEnd = $to.depth > depth && joinable$1($end, $to, depth + 1);
  let content = [];
  addRange(null, $from, depth, content);
  if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {
    checkJoin(openStart, openEnd);
    addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);
  } else {
    if (openStart)
      addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);
    addRange($start, $end, depth, content);
    if (openEnd)
      addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function replaceTwoWay($from, $to, depth) {
  let content = [];
  addRange(null, $from, depth, content);
  if ($from.depth > depth) {
    let type2 = joinable$1($from, $to, depth + 1);
    addNode(close(type2, replaceTwoWay($from, $to, depth + 1)), content);
  }
  addRange($to, null, depth, content);
  return new Fragment(content);
}
function prepareSliceForReplace(slice2, $along) {
  let extra = $along.depth - slice2.openStart, parent = $along.node(extra);
  let node2 = parent.copy(slice2.content);
  for (let i = extra - 1; i >= 0; i--)
    node2 = $along.node(i).copy(Fragment.from(node2));
  return {
    start: node2.resolveNoCache(slice2.openStart + extra),
    end: node2.resolveNoCache(node2.content.size - slice2.openEnd - extra)
  };
}
class ResolvedPos {
  /**
  @internal
  */
  constructor(pos, path, parentOffset) {
    this.pos = pos;
    this.path = path;
    this.parentOffset = parentOffset;
    this.depth = path.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(val) {
    if (val == null)
      return this.depth;
    if (val < 0)
      return this.depth + val;
    return val;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(depth) {
    return this.path[this.resolveDepth(depth) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(depth) {
    return this.path[this.resolveDepth(depth) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(depth) {
    depth = this.resolveDepth(depth);
    return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(depth) {
    depth = this.resolveDepth(depth);
    return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(depth) {
    depth = this.resolveDepth(depth);
    return this.start(depth) + this.node(depth).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position before the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(depth) {
    depth = this.resolveDepth(depth);
    if (!depth)
      throw new RangeError("There is no position after the top-level node");
    return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let parent = this.parent, index2 = this.index(this.depth);
    if (index2 == parent.childCount)
      return null;
    let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index2);
    return dOff ? parent.child(index2).cut(dOff) : child;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let index2 = this.index(this.depth);
    let dOff = this.pos - this.path[this.path.length - 1];
    if (dOff)
      return this.parent.child(index2).cut(0, dOff);
    return index2 == 0 ? null : this.parent.child(index2 - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(index2, depth) {
    depth = this.resolveDepth(depth);
    let node2 = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;
    for (let i = 0; i < index2; i++)
      pos += node2.child(i).nodeSize;
    return pos;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let parent = this.parent, index2 = this.index();
    if (parent.content.size == 0)
      return Mark$1.none;
    if (this.textOffset)
      return parent.child(index2).marks;
    let main2 = parent.maybeChild(index2 - 1), other = parent.maybeChild(index2);
    if (!main2) {
      let tmp = main2;
      main2 = other;
      other = tmp;
    }
    let marks = main2.marks;
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross($end) {
    let after = this.parent.maybeChild(this.index());
    if (!after || !after.isInline)
      return null;
    let marks = after.marks, next = $end.parent.maybeChild($end.index());
    for (var i = 0; i < marks.length; i++)
      if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))
        marks = marks[i--].removeFromSet(marks);
    return marks;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(pos) {
    for (let depth = this.depth; depth > 0; depth--)
      if (this.start(depth) <= pos && this.end(depth) >= pos)
        return depth;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(other = this, pred) {
    if (other.pos < this.pos)
      return other.blockRange(this);
    for (let d2 = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d2 >= 0; d2--)
      if (other.pos <= this.end(d2) && (!pred || pred(this.node(d2))))
        return new NodeRange(this, other, d2);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(other) {
    return this.pos - this.parentOffset == other.pos - other.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(other) {
    return other.pos > this.pos ? other : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(other) {
    return other.pos < this.pos ? other : this;
  }
  /**
  @internal
  */
  toString() {
    let str = "";
    for (let i = 1; i <= this.depth; i++)
      str += (str ? "/" : "") + this.node(i).type.name + "_" + this.index(i - 1);
    return str + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(doc2, pos) {
    if (!(pos >= 0 && pos <= doc2.content.size))
      throw new RangeError("Position " + pos + " out of range");
    let path = [];
    let start2 = 0, parentOffset = pos;
    for (let node2 = doc2; ; ) {
      let { index: index2, offset: offset2 } = node2.content.findIndex(parentOffset);
      let rem = parentOffset - offset2;
      path.push(node2, index2, start2 + offset2);
      if (!rem)
        break;
      node2 = node2.child(index2);
      if (node2.isText)
        break;
      parentOffset = rem - 1;
      start2 += offset2 + 1;
    }
    return new ResolvedPos(pos, path, parentOffset);
  }
  /**
  @internal
  */
  static resolveCached(doc2, pos) {
    let cache2 = resolveCache.get(doc2);
    if (cache2) {
      for (let i = 0; i < cache2.elts.length; i++) {
        let elt = cache2.elts[i];
        if (elt.pos == pos)
          return elt;
      }
    } else {
      resolveCache.set(doc2, cache2 = new ResolveCache());
    }
    let result = cache2.elts[cache2.i] = ResolvedPos.resolve(doc2, pos);
    cache2.i = (cache2.i + 1) % resolveCacheSize;
    return result;
  }
}
class ResolveCache {
  constructor() {
    this.elts = [];
    this.i = 0;
  }
}
const resolveCacheSize = 12, resolveCache = /* @__PURE__ */ new WeakMap();
class NodeRange {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor($from, $to, depth) {
    this.$from = $from;
    this.$to = $to;
    this.depth = depth;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const emptyAttrs = /* @__PURE__ */ Object.create(null);
let Node$1$1 = class Node2 {
  /**
  @internal
  */
  constructor(type2, attrs, content, marks = Mark$1.none) {
    this.type = type2;
    this.attrs = attrs;
    this.marks = marks;
    this.content = content || Fragment.empty;
  }
  /**
  The array of this node's child nodes.
  */
  get children() {
    return this.content.content;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(index2) {
    return this.content.child(index2);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(index2) {
    return this.content.maybeChild(index2);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(f) {
    this.content.forEach(f);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(from2, to, f, startPos = 0) {
    this.content.nodesBetween(from2, to, f, startPos, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(f) {
    this.nodesBetween(0, this.content.size, f);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.
  */
  textBetween(from2, to, blockSeparator, leafText) {
    return this.content.textBetween(from2, to, blockSeparator, leafText);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(other) {
    return this == other || this.sameMarkup(other) && this.content.eq(other.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(other) {
    return this.hasMarkup(other.type, other.attrs, other.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(type2, attrs, marks) {
    return this.type == type2 && compareDeep(this.attrs, attrs || type2.defaultAttrs || emptyAttrs) && Mark$1.sameSet(this.marks, marks || Mark$1.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(content = null) {
    if (content == this.content)
      return this;
    return new Node2(this.type, this.attrs, content, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(marks) {
    return marks == this.marks ? this : new Node2(this.type, this.attrs, this.content, marks);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(from2, to = this.content.size) {
    if (from2 == 0 && to == this.content.size)
      return this;
    return this.copy(this.content.cut(from2, to));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(from2, to = this.content.size, includeParents = false) {
    if (from2 == to)
      return Slice.empty;
    let $from = this.resolve(from2), $to = this.resolve(to);
    let depth = includeParents ? 0 : $from.sharedDepth(to);
    let start2 = $from.start(depth), node2 = $from.node(depth);
    let content = node2.content.cut($from.pos - start2, $to.pos - start2);
    return new Slice(content, $from.depth - depth, $to.depth - depth);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(from2, to, slice2) {
    return replace(this.resolve(from2), this.resolve(to), slice2);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(pos) {
    for (let node2 = this; ; ) {
      let { index: index2, offset: offset2 } = node2.content.findIndex(pos);
      node2 = node2.maybeChild(index2);
      if (!node2)
        return null;
      if (offset2 == pos || node2.isText)
        return node2;
      pos -= offset2 + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(pos) {
    let { index: index2, offset: offset2 } = this.content.findIndex(pos);
    return { node: this.content.maybeChild(index2), index: index2, offset: offset2 };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(pos) {
    if (pos == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: index2, offset: offset2 } = this.content.findIndex(pos);
    if (offset2 < pos)
      return { node: this.content.child(index2), index: index2, offset: offset2 };
    let node2 = this.content.child(index2 - 1);
    return { node: node2, index: index2 - 1, offset: offset2 - node2.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(pos) {
    return ResolvedPos.resolveCached(this, pos);
  }
  /**
  @internal
  */
  resolveNoCache(pos) {
    return ResolvedPos.resolve(this, pos);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(from2, to, type2) {
    let found2 = false;
    if (to > from2)
      this.nodesBetween(from2, to, (node2) => {
        if (type2.isInSet(node2.marks))
          found2 = true;
        return !found2;
      });
    return found2;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let name = this.type.name;
    if (this.content.size)
      name += "(" + this.content.toStringInner() + ")";
    return wrapMarks(this.marks, name);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(index2) {
    let match = this.type.contentMatch.matchFragment(this.content, 0, index2);
    if (!match)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return match;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(from2, to, replacement = Fragment.empty, start2 = 0, end2 = replacement.childCount) {
    let one = this.contentMatchAt(from2).matchFragment(replacement, start2, end2);
    let two = one && one.matchFragment(this.content, to);
    if (!two || !two.validEnd)
      return false;
    for (let i = start2; i < end2; i++)
      if (!this.type.allowsMarks(replacement.child(i).marks))
        return false;
    return true;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(from2, to, type2, marks) {
    if (marks && !this.type.allowsMarks(marks))
      return false;
    let start2 = this.contentMatchAt(from2).matchType(type2);
    let end2 = start2 && start2.matchFragment(this.content, to);
    return end2 ? end2.validEnd : false;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(other) {
    if (other.content.size)
      return this.canReplace(this.childCount, this.childCount, other.content);
    else
      return this.type.compatibleContent(other.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise an exception when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    this.type.checkAttrs(this.attrs);
    let copy2 = Mark$1.none;
    for (let i = 0; i < this.marks.length; i++) {
      let mark = this.marks[i];
      mark.type.checkAttrs(mark.attrs);
      copy2 = mark.addToSet(copy2);
    }
    if (!Mark$1.sameSet(copy2, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m2) => m2.type.name)}`);
    this.content.forEach((node2) => node2.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let obj = { type: this.type.name };
    for (let _2 in this.attrs) {
      obj.attrs = this.attrs;
      break;
    }
    if (this.content.size)
      obj.content = this.content.toJSON();
    if (this.marks.length)
      obj.marks = this.marks.map((n) => n.toJSON());
    return obj;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(schema, json) {
    if (!json)
      throw new RangeError("Invalid input for Node.fromJSON");
    let marks = void 0;
    if (json.marks) {
      if (!Array.isArray(json.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      marks = json.marks.map(schema.markFromJSON);
    }
    if (json.type == "text") {
      if (typeof json.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return schema.text(json.text, marks);
    }
    let content = Fragment.fromJSON(schema, json.content);
    let node2 = schema.nodeType(json.type).create(json.attrs, content, marks);
    node2.type.checkAttrs(node2.attrs);
    return node2;
  }
};
Node$1$1.prototype.text = void 0;
class TextNode extends Node$1$1 {
  /**
  @internal
  */
  constructor(type2, attrs, content, marks) {
    super(type2, attrs, null, marks);
    if (!content)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = content;
  }
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    return wrapMarks(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(from2, to) {
    return this.text.slice(from2, to);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(marks) {
    return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);
  }
  withText(text) {
    if (text == this.text)
      return this;
    return new TextNode(this.type, this.attrs, text, this.marks);
  }
  cut(from2 = 0, to = this.text.length) {
    if (from2 == 0 && to == this.text.length)
      return this;
    return this.withText(this.text.slice(from2, to));
  }
  eq(other) {
    return this.sameMarkup(other) && this.text == other.text;
  }
  toJSON() {
    let base2 = super.toJSON();
    base2.text = this.text;
    return base2;
  }
}
function wrapMarks(marks, str) {
  for (let i = marks.length - 1; i >= 0; i--)
    str = marks[i].type.name + "(" + str + ")";
  return str;
}
class ContentMatch {
  /**
  @internal
  */
  constructor(validEnd) {
    this.validEnd = validEnd;
    this.next = [];
    this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(string, nodeTypes) {
    let stream = new TokenStream(string, nodeTypes);
    if (stream.next == null)
      return ContentMatch.empty;
    let expr = parseExpr(stream);
    if (stream.next)
      stream.err("Unexpected trailing text");
    let match = dfa(nfa(expr));
    checkForDeadEnds(match, stream);
    return match;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(type2) {
    for (let i = 0; i < this.next.length; i++)
      if (this.next[i].type == type2)
        return this.next[i].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(frag, start2 = 0, end2 = frag.childCount) {
    let cur = this;
    for (let i = start2; cur && i < end2; i++)
      cur = cur.matchType(frag.child(i).type);
    return cur;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let i = 0; i < this.next.length; i++) {
      let { type: type2 } = this.next[i];
      if (!(type2.isText || type2.hasRequiredAttrs()))
        return type2;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(other) {
    for (let i = 0; i < this.next.length; i++)
      for (let j2 = 0; j2 < other.next.length; j2++)
        if (this.next[i].type == other.next[j2].type)
          return true;
    return false;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(after, toEnd = false, startIndex = 0) {
    let seen = [this];
    function search2(match, types2) {
      let finished = match.matchFragment(after, startIndex);
      if (finished && (!toEnd || finished.validEnd))
        return Fragment.from(types2.map((tp) => tp.createAndFill()));
      for (let i = 0; i < match.next.length; i++) {
        let { type: type2, next } = match.next[i];
        if (!(type2.isText || type2.hasRequiredAttrs()) && seen.indexOf(next) == -1) {
          seen.push(next);
          let found2 = search2(next, types2.concat(type2));
          if (found2)
            return found2;
        }
      }
      return null;
    }
    return search2(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(target) {
    for (let i = 0; i < this.wrapCache.length; i += 2)
      if (this.wrapCache[i] == target)
        return this.wrapCache[i + 1];
    let computed = this.computeWrapping(target);
    this.wrapCache.push(target, computed);
    return computed;
  }
  /**
  @internal
  */
  computeWrapping(target) {
    let seen = /* @__PURE__ */ Object.create(null), active = [{ match: this, type: null, via: null }];
    while (active.length) {
      let current = active.shift(), match = current.match;
      if (match.matchType(target)) {
        let result = [];
        for (let obj = current; obj.type; obj = obj.via)
          result.push(obj.type);
        return result.reverse();
      }
      for (let i = 0; i < match.next.length; i++) {
        let { type: type2, next } = match.next[i];
        if (!type2.isLeaf && !type2.hasRequiredAttrs() && !(type2.name in seen) && (!current.type || next.validEnd)) {
          active.push({ match: type2.contentMatch, type: type2, via: current });
          seen[type2.name] = true;
        }
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(n) {
    if (n >= this.next.length)
      throw new RangeError(`There's no ${n}th edge in this content match`);
    return this.next[n];
  }
  /**
  @internal
  */
  toString() {
    let seen = [];
    function scan(m2) {
      seen.push(m2);
      for (let i = 0; i < m2.next.length; i++)
        if (seen.indexOf(m2.next[i].next) == -1)
          scan(m2.next[i].next);
    }
    scan(this);
    return seen.map((m2, i) => {
      let out = i + (m2.validEnd ? "*" : " ") + " ";
      for (let i2 = 0; i2 < m2.next.length; i2++)
        out += (i2 ? ", " : "") + m2.next[i2].type.name + "->" + seen.indexOf(m2.next[i2].next);
      return out;
    }).join("\n");
  }
}
ContentMatch.empty = new ContentMatch(true);
class TokenStream {
  constructor(string, nodeTypes) {
    this.string = string;
    this.nodeTypes = nodeTypes;
    this.inline = null;
    this.pos = 0;
    this.tokens = string.split(/\s*(?=\b|\W|$)/);
    if (this.tokens[this.tokens.length - 1] == "")
      this.tokens.pop();
    if (this.tokens[0] == "")
      this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(tok) {
    return this.next == tok && (this.pos++ || true);
  }
  err(str) {
    throw new SyntaxError(str + " (in content expression '" + this.string + "')");
  }
}
function parseExpr(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSeq(stream));
  } while (stream.eat("|"));
  return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
}
function parseExprSeq(stream) {
  let exprs = [];
  do {
    exprs.push(parseExprSubscript(stream));
  } while (stream.next && stream.next != ")" && stream.next != "|");
  return exprs.length == 1 ? exprs[0] : { type: "seq", exprs };
}
function parseExprSubscript(stream) {
  let expr = parseExprAtom(stream);
  for (; ; ) {
    if (stream.eat("+"))
      expr = { type: "plus", expr };
    else if (stream.eat("*"))
      expr = { type: "star", expr };
    else if (stream.eat("?"))
      expr = { type: "opt", expr };
    else if (stream.eat("{"))
      expr = parseExprRange(stream, expr);
    else
      break;
  }
  return expr;
}
function parseNum(stream) {
  if (/\D/.test(stream.next))
    stream.err("Expected number, got '" + stream.next + "'");
  let result = Number(stream.next);
  stream.pos++;
  return result;
}
function parseExprRange(stream, expr) {
  let min2 = parseNum(stream), max2 = min2;
  if (stream.eat(",")) {
    if (stream.next != "}")
      max2 = parseNum(stream);
    else
      max2 = -1;
  }
  if (!stream.eat("}"))
    stream.err("Unclosed braced range");
  return { type: "range", min: min2, max: max2, expr };
}
function resolveName(stream, name) {
  let types2 = stream.nodeTypes, type2 = types2[name];
  if (type2)
    return [type2];
  let result = [];
  for (let typeName in types2) {
    let type3 = types2[typeName];
    if (type3.isInGroup(name))
      result.push(type3);
  }
  if (result.length == 0)
    stream.err("No node type or group '" + name + "' found");
  return result;
}
function parseExprAtom(stream) {
  if (stream.eat("(")) {
    let expr = parseExpr(stream);
    if (!stream.eat(")"))
      stream.err("Missing closing paren");
    return expr;
  } else if (!/\W/.test(stream.next)) {
    let exprs = resolveName(stream, stream.next).map((type2) => {
      if (stream.inline == null)
        stream.inline = type2.isInline;
      else if (stream.inline != type2.isInline)
        stream.err("Mixing inline and block content");
      return { type: "name", value: type2 };
    });
    stream.pos++;
    return exprs.length == 1 ? exprs[0] : { type: "choice", exprs };
  } else {
    stream.err("Unexpected token '" + stream.next + "'");
  }
}
function nfa(expr) {
  let nfa2 = [[]];
  connect(compile(expr, 0), node2());
  return nfa2;
  function node2() {
    return nfa2.push([]) - 1;
  }
  function edge(from2, to, term) {
    let edge2 = { term, to };
    nfa2[from2].push(edge2);
    return edge2;
  }
  function connect(edges, to) {
    edges.forEach((edge2) => edge2.to = to);
  }
  function compile(expr2, from2) {
    if (expr2.type == "choice") {
      return expr2.exprs.reduce((out, expr3) => out.concat(compile(expr3, from2)), []);
    } else if (expr2.type == "seq") {
      for (let i = 0; ; i++) {
        let next = compile(expr2.exprs[i], from2);
        if (i == expr2.exprs.length - 1)
          return next;
        connect(next, from2 = node2());
      }
    } else if (expr2.type == "star") {
      let loop = node2();
      edge(from2, loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "plus") {
      let loop = node2();
      connect(compile(expr2.expr, from2), loop);
      connect(compile(expr2.expr, loop), loop);
      return [edge(loop)];
    } else if (expr2.type == "opt") {
      return [edge(from2)].concat(compile(expr2.expr, from2));
    } else if (expr2.type == "range") {
      let cur = from2;
      for (let i = 0; i < expr2.min; i++) {
        let next = node2();
        connect(compile(expr2.expr, cur), next);
        cur = next;
      }
      if (expr2.max == -1) {
        connect(compile(expr2.expr, cur), cur);
      } else {
        for (let i = expr2.min; i < expr2.max; i++) {
          let next = node2();
          edge(cur, next);
          connect(compile(expr2.expr, cur), next);
          cur = next;
        }
      }
      return [edge(cur)];
    } else if (expr2.type == "name") {
      return [edge(from2, void 0, expr2.value)];
    } else {
      throw new Error("Unknown expr type");
    }
  }
}
function cmp(a, b2) {
  return b2 - a;
}
function nullFrom(nfa2, node2) {
  let result = [];
  scan(node2);
  return result.sort(cmp);
  function scan(node3) {
    let edges = nfa2[node3];
    if (edges.length == 1 && !edges[0].term)
      return scan(edges[0].to);
    result.push(node3);
    for (let i = 0; i < edges.length; i++) {
      let { term, to } = edges[i];
      if (!term && result.indexOf(to) == -1)
        scan(to);
    }
  }
}
function dfa(nfa2) {
  let labeled = /* @__PURE__ */ Object.create(null);
  return explore(nullFrom(nfa2, 0));
  function explore(states) {
    let out = [];
    states.forEach((node2) => {
      nfa2[node2].forEach(({ term, to }) => {
        if (!term)
          return;
        let set;
        for (let i = 0; i < out.length; i++)
          if (out[i][0] == term)
            set = out[i][1];
        nullFrom(nfa2, to).forEach((node3) => {
          if (!set)
            out.push([term, set = []]);
          if (set.indexOf(node3) == -1)
            set.push(node3);
        });
      });
    });
    let state2 = labeled[states.join(",")] = new ContentMatch(states.indexOf(nfa2.length - 1) > -1);
    for (let i = 0; i < out.length; i++) {
      let states2 = out[i][1].sort(cmp);
      state2.next.push({ type: out[i][0], next: labeled[states2.join(",")] || explore(states2) });
    }
    return state2;
  }
}
function checkForDeadEnds(match, stream) {
  for (let i = 0, work = [match]; i < work.length; i++) {
    let state2 = work[i], dead = !state2.validEnd, nodes = [];
    for (let j2 = 0; j2 < state2.next.length; j2++) {
      let { type: type2, next } = state2.next[j2];
      nodes.push(type2.name);
      if (dead && !(type2.isText || type2.hasRequiredAttrs()))
        dead = false;
      if (work.indexOf(next) == -1)
        work.push(next);
    }
    if (dead)
      stream.err("Only non-generatable nodes (" + nodes.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function defaultAttrs(attrs) {
  let defaults = /* @__PURE__ */ Object.create(null);
  for (let attrName in attrs) {
    let attr = attrs[attrName];
    if (!attr.hasDefault)
      return null;
    defaults[attrName] = attr.default;
  }
  return defaults;
}
function computeAttrs(attrs, value) {
  let built = /* @__PURE__ */ Object.create(null);
  for (let name in attrs) {
    let given = value && value[name];
    if (given === void 0) {
      let attr = attrs[name];
      if (attr.hasDefault)
        given = attr.default;
      else
        throw new RangeError("No value supplied for attribute " + name);
    }
    built[name] = given;
  }
  return built;
}
function checkAttrs(attrs, values, type2, name) {
  for (let name2 in values)
    if (!(name2 in attrs))
      throw new RangeError(`Unsupported attribute ${name2} for ${type2} of type ${name2}`);
  for (let name2 in attrs) {
    let attr = attrs[name2];
    if (attr.validate)
      attr.validate(values[name2]);
  }
}
function initAttrs(typeName, attrs) {
  let result = /* @__PURE__ */ Object.create(null);
  if (attrs)
    for (let name in attrs)
      result[name] = new Attribute$1(typeName, name, attrs[name]);
  return result;
}
let NodeType$1 = class NodeType {
  /**
  @internal
  */
  constructor(name, schema, spec) {
    this.name = name;
    this.schema = schema;
    this.spec = spec;
    this.markSet = null;
    this.groups = spec.group ? spec.group.split(" ") : [];
    this.attrs = initAttrs(name, spec.attrs);
    this.defaultAttrs = defaultAttrs(this.attrs);
    this.contentMatch = null;
    this.inlineContent = null;
    this.isBlock = !(spec.inline || name == "text");
    this.isText = name == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == ContentMatch.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  Return true when this node type is part of the given
  [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).
  */
  isInGroup(group) {
    return this.groups.indexOf(group) > -1;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let n in this.attrs)
      if (this.attrs[n].isRequired)
        return true;
    return false;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(other) {
    return this == other || this.contentMatch.compatible(other.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(attrs) {
    if (!attrs && this.defaultAttrs)
      return this.defaultAttrs;
    else
      return computeAttrs(this.attrs, attrs);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(attrs = null, content, marks) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Node$1$1(this, this.computeAttrs(attrs), Fragment.from(content), Mark$1.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(attrs = null, content, marks) {
    content = Fragment.from(content);
    this.checkContent(content);
    return new Node$1$1(this, this.computeAttrs(attrs), content, Mark$1.setFrom(marks));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(attrs = null, content, marks) {
    attrs = this.computeAttrs(attrs);
    content = Fragment.from(content);
    if (content.size) {
      let before = this.contentMatch.fillBefore(content);
      if (!before)
        return null;
      content = before.append(content);
    }
    let matched = this.contentMatch.matchFragment(content);
    let after = matched && matched.fillBefore(Fragment.empty, true);
    if (!after)
      return null;
    return new Node$1$1(this, attrs, content.append(after), Mark$1.setFrom(marks));
  }
  /**
  Returns true if the given fragment is valid content for this node
  type.
  */
  validContent(content) {
    let result = this.contentMatch.matchFragment(content);
    if (!result || !result.validEnd)
      return false;
    for (let i = 0; i < content.childCount; i++)
      if (!this.allowsMarks(content.child(i).marks))
        return false;
    return true;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(content) {
    if (!this.validContent(content))
      throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "node", this.name);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(markType) {
    return this.markSet == null || this.markSet.indexOf(markType) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(marks) {
    if (this.markSet == null)
      return true;
    for (let i = 0; i < marks.length; i++)
      if (!this.allowsMarkType(marks[i].type))
        return false;
    return true;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(marks) {
    if (this.markSet == null)
      return marks;
    let copy2;
    for (let i = 0; i < marks.length; i++) {
      if (!this.allowsMarkType(marks[i].type)) {
        if (!copy2)
          copy2 = marks.slice(0, i);
      } else if (copy2) {
        copy2.push(marks[i]);
      }
    }
    return !copy2 ? marks : copy2.length ? copy2 : Mark$1.none;
  }
  /**
  @internal
  */
  static compile(nodes, schema) {
    let result = /* @__PURE__ */ Object.create(null);
    nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));
    let topType = schema.spec.topNode || "doc";
    if (!result[topType])
      throw new RangeError("Schema is missing its top node type ('" + topType + "')");
    if (!result.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let _2 in result.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return result;
  }
};
function validateType(typeName, attrName, type2) {
  let types2 = type2.split("|");
  return (value) => {
    let name = value === null ? "null" : typeof value;
    if (types2.indexOf(name) < 0)
      throw new RangeError(`Expected value of type ${types2} for attribute ${attrName} on type ${typeName}, got ${name}`);
  };
}
let Attribute$1 = class Attribute {
  constructor(typeName, attrName, options) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(options, "default");
    this.default = options.default;
    this.validate = typeof options.validate == "string" ? validateType(typeName, attrName, options.validate) : options.validate;
  }
  get isRequired() {
    return !this.hasDefault;
  }
};
class MarkType {
  /**
  @internal
  */
  constructor(name, rank, schema, spec) {
    this.name = name;
    this.rank = rank;
    this.schema = schema;
    this.spec = spec;
    this.attrs = initAttrs(name, spec.attrs);
    this.excluded = null;
    let defaults = defaultAttrs(this.attrs);
    this.instance = defaults ? new Mark$1(this, defaults) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(attrs = null) {
    if (!attrs && this.instance)
      return this.instance;
    return new Mark$1(this, computeAttrs(this.attrs, attrs));
  }
  /**
  @internal
  */
  static compile(marks, schema) {
    let result = /* @__PURE__ */ Object.create(null), rank = 0;
    marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));
    return result;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(set) {
    for (var i = 0; i < set.length; i++)
      if (set[i].type == this) {
        set = set.slice(0, i).concat(set.slice(i + 1));
        i--;
      }
    return set;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(set) {
    for (let i = 0; i < set.length; i++)
      if (set[i].type == this)
        return set[i];
  }
  /**
  @internal
  */
  checkAttrs(attrs) {
    checkAttrs(this.attrs, attrs, "mark", this.name);
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(other) {
    return this.excluded.indexOf(other) > -1;
  }
}
let Schema$1 = class Schema {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(spec) {
    this.linebreakReplacement = null;
    this.cached = /* @__PURE__ */ Object.create(null);
    let instanceSpec = this.spec = {};
    for (let prop in spec)
      instanceSpec[prop] = spec[prop];
    instanceSpec.nodes = OrderedMap.from(spec.nodes), instanceSpec.marks = OrderedMap.from(spec.marks || {}), this.nodes = NodeType$1.compile(this.spec.nodes, this);
    this.marks = MarkType.compile(this.spec.marks, this);
    let contentExprCache = /* @__PURE__ */ Object.create(null);
    for (let prop in this.nodes) {
      if (prop in this.marks)
        throw new RangeError(prop + " can not be both a node and a mark");
      let type2 = this.nodes[prop], contentExpr = type2.spec.content || "", markExpr = type2.spec.marks;
      type2.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));
      type2.inlineContent = type2.contentMatch.inlineContent;
      if (type2.spec.linebreakReplacement) {
        if (this.linebreakReplacement)
          throw new RangeError("Multiple linebreak nodes defined");
        if (!type2.isInline || !type2.isLeaf)
          throw new RangeError("Linebreak replacement nodes must be inline leaf nodes");
        this.linebreakReplacement = type2;
      }
      type2.markSet = markExpr == "_" ? null : markExpr ? gatherMarks(this, markExpr.split(" ")) : markExpr == "" || !type2.inlineContent ? [] : null;
    }
    for (let prop in this.marks) {
      let type2 = this.marks[prop], excl = type2.spec.excludes;
      type2.excluded = excl == null ? [type2] : excl == "" ? [] : gatherMarks(this, excl.split(" "));
    }
    this.nodeFromJSON = (json) => Node$1$1.fromJSON(this, json);
    this.markFromJSON = (json) => Mark$1.fromJSON(this, json);
    this.topNodeType = this.nodes[this.spec.topNode || "doc"];
    this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(type2, attrs = null, content, marks) {
    if (typeof type2 == "string")
      type2 = this.nodeType(type2);
    else if (!(type2 instanceof NodeType$1))
      throw new RangeError("Invalid node type: " + type2);
    else if (type2.schema != this)
      throw new RangeError("Node type from different schema used (" + type2.name + ")");
    return type2.createChecked(attrs, content, marks);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(text, marks) {
    let type2 = this.nodes.text;
    return new TextNode(type2, type2.defaultAttrs, text, Mark$1.setFrom(marks));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(type2, attrs) {
    if (typeof type2 == "string")
      type2 = this.marks[type2];
    return type2.create(attrs);
  }
  /**
  @internal
  */
  nodeType(name) {
    let found2 = this.nodes[name];
    if (!found2)
      throw new RangeError("Unknown node type: " + name);
    return found2;
  }
};
function gatherMarks(schema, marks) {
  let found2 = [];
  for (let i = 0; i < marks.length; i++) {
    let name = marks[i], mark = schema.marks[name], ok = mark;
    if (mark) {
      found2.push(mark);
    } else {
      for (let prop in schema.marks) {
        let mark2 = schema.marks[prop];
        if (name == "_" || mark2.spec.group && mark2.spec.group.split(" ").indexOf(name) > -1)
          found2.push(ok = mark2);
      }
    }
    if (!ok)
      throw new SyntaxError("Unknown mark type: '" + marks[i] + "'");
  }
  return found2;
}
function isTagRule(rule) {
  return rule.tag != null;
}
function isStyleRule(rule) {
  return rule.style != null;
}
let DOMParser$1 = class DOMParser2 {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(schema, rules) {
    this.schema = schema;
    this.rules = rules;
    this.tags = [];
    this.styles = [];
    let matchedStyles = this.matchedStyles = [];
    rules.forEach((rule) => {
      if (isTagRule(rule)) {
        this.tags.push(rule);
      } else if (isStyleRule(rule)) {
        let prop = /[^=]*/.exec(rule.style)[0];
        if (matchedStyles.indexOf(prop) < 0)
          matchedStyles.push(prop);
        this.styles.push(rule);
      }
    });
    this.normalizeLists = !this.tags.some((r2) => {
      if (!/^(ul|ol)\b/.test(r2.tag) || !r2.node)
        return false;
      let node2 = schema.nodes[r2.node];
      return node2.contentMatch.matchType(node2);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(dom, options = {}) {
    let context = new ParseContext(this, options, false);
    context.addAll(dom, Mark$1.none, options.from, options.to);
    return context.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(dom, options = {}) {
    let context = new ParseContext(this, options, true);
    context.addAll(dom, Mark$1.none, options.from, options.to);
    return Slice.maxOpen(context.finish());
  }
  /**
  @internal
  */
  matchTag(dom, context, after) {
    for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {
      let rule = this.tags[i];
      if (matches(dom, rule.tag) && (rule.namespace === void 0 || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {
        if (rule.getAttrs) {
          let result = rule.getAttrs(dom);
          if (result === false)
            continue;
          rule.attrs = result || void 0;
        }
        return rule;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(prop, value, context, after) {
    for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {
      let rule = this.styles[i], style2 = rule.style;
      if (style2.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      style2.length > prop.length && (style2.charCodeAt(prop.length) != 61 || style2.slice(prop.length + 1) != value))
        continue;
      if (rule.getAttrs) {
        let result = rule.getAttrs(value);
        if (result === false)
          continue;
        rule.attrs = result || void 0;
      }
      return rule;
    }
  }
  /**
  @internal
  */
  static schemaRules(schema) {
    let result = [];
    function insert(rule) {
      let priority = rule.priority == null ? 50 : rule.priority, i = 0;
      for (; i < result.length; i++) {
        let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;
        if (nextPriority < priority)
          break;
      }
      result.splice(i, 0, rule);
    }
    for (let name in schema.marks) {
      let rules = schema.marks[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.mark || rule.ignore || rule.clearMark))
            rule.mark = name;
        });
    }
    for (let name in schema.nodes) {
      let rules = schema.nodes[name].spec.parseDOM;
      if (rules)
        rules.forEach((rule) => {
          insert(rule = copy(rule));
          if (!(rule.node || rule.ignore || rule.mark))
            rule.node = name;
        });
    }
    return result;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).
  */
  static fromSchema(schema) {
    return schema.cached.domParser || (schema.cached.domParser = new DOMParser2(schema, DOMParser2.schemaRules(schema)));
  }
};
const blockTags = {
  address: true,
  article: true,
  aside: true,
  blockquote: true,
  canvas: true,
  dd: true,
  div: true,
  dl: true,
  fieldset: true,
  figcaption: true,
  figure: true,
  footer: true,
  form: true,
  h1: true,
  h2: true,
  h3: true,
  h4: true,
  h5: true,
  h6: true,
  header: true,
  hgroup: true,
  hr: true,
  li: true,
  noscript: true,
  ol: true,
  output: true,
  p: true,
  pre: true,
  section: true,
  table: true,
  tfoot: true,
  ul: true
};
const ignoreTags = {
  head: true,
  noscript: true,
  object: true,
  script: true,
  style: true,
  title: true
};
const listTags = { ol: true, ul: true };
const OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;
function wsOptionsFor(type2, preserveWhitespace, base2) {
  if (preserveWhitespace != null)
    return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === "full" ? OPT_PRESERVE_WS_FULL : 0);
  return type2 && type2.whitespace == "pre" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base2 & ~OPT_OPEN_LEFT;
}
class NodeContext {
  constructor(type2, attrs, marks, solid, match, options) {
    this.type = type2;
    this.attrs = attrs;
    this.marks = marks;
    this.solid = solid;
    this.options = options;
    this.content = [];
    this.activeMarks = Mark$1.none;
    this.match = match || (options & OPT_OPEN_LEFT ? null : type2.contentMatch);
  }
  findWrapping(node2) {
    if (!this.match) {
      if (!this.type)
        return [];
      let fill = this.type.contentMatch.fillBefore(Fragment.from(node2));
      if (fill) {
        this.match = this.type.contentMatch.matchFragment(fill);
      } else {
        let start2 = this.type.contentMatch, wrap2;
        if (wrap2 = start2.findWrapping(node2.type)) {
          this.match = start2;
          return wrap2;
        } else {
          return null;
        }
      }
    }
    return this.match.findWrapping(node2.type);
  }
  finish(openEnd) {
    if (!(this.options & OPT_PRESERVE_WS)) {
      let last = this.content[this.content.length - 1], m2;
      if (last && last.isText && (m2 = /[ \t\r\n\u000c]+$/.exec(last.text))) {
        let text = last;
        if (last.text.length == m2[0].length)
          this.content.pop();
        else
          this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m2[0].length));
      }
    }
    let content = Fragment.from(this.content);
    if (!openEnd && this.match)
      content = content.append(this.match.fillBefore(Fragment.empty, true));
    return this.type ? this.type.create(this.attrs, content, this.marks) : content;
  }
  inlineContext(node2) {
    if (this.type)
      return this.type.inlineContent;
    if (this.content.length)
      return this.content[0].isInline;
    return node2.parentNode && !blockTags.hasOwnProperty(node2.parentNode.nodeName.toLowerCase());
  }
}
class ParseContext {
  constructor(parser, options, isOpen) {
    this.parser = parser;
    this.options = options;
    this.isOpen = isOpen;
    this.open = 0;
    this.localPreserveWS = false;
    let topNode = options.topNode, topContext;
    let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);
    if (topNode)
      topContext = new NodeContext(topNode.type, topNode.attrs, Mark$1.none, true, options.topMatch || topNode.type.contentMatch, topOptions);
    else if (isOpen)
      topContext = new NodeContext(null, null, Mark$1.none, true, null, topOptions);
    else
      topContext = new NodeContext(parser.schema.topNodeType, null, Mark$1.none, true, null, topOptions);
    this.nodes = [topContext];
    this.find = options.findPositions;
    this.needsBlock = false;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(dom, marks) {
    if (dom.nodeType == 3)
      this.addTextNode(dom, marks);
    else if (dom.nodeType == 1)
      this.addElement(dom, marks);
  }
  addTextNode(dom, marks) {
    let value = dom.nodeValue;
    let top2 = this.top, preserveWS = top2.options & OPT_PRESERVE_WS_FULL ? "full" : this.localPreserveWS || (top2.options & OPT_PRESERVE_WS) > 0;
    if (preserveWS === "full" || top2.inlineContext(dom) || /[^ \t\r\n\u000c]/.test(value)) {
      if (!preserveWS) {
        value = value.replace(/[ \t\r\n\u000c]+/g, " ");
        if (/^[ \t\r\n\u000c]/.test(value) && this.open == this.nodes.length - 1) {
          let nodeBefore = top2.content[top2.content.length - 1];
          let domNodeBefore = dom.previousSibling;
          if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == "BR" || nodeBefore.isText && /[ \t\r\n\u000c]$/.test(nodeBefore.text))
            value = value.slice(1);
        }
      } else if (preserveWS !== "full") {
        value = value.replace(/\r?\n|\r/g, " ");
      } else {
        value = value.replace(/\r\n?/g, "\n");
      }
      if (value)
        this.insertNode(this.parser.schema.text(value), marks, !/\S/.test(value));
      this.findInText(dom);
    } else {
      this.findInside(dom);
    }
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(dom, marks, matchAfter) {
    let outerWS = this.localPreserveWS, top2 = this.top;
    if (dom.tagName == "PRE" || /pre/.test(dom.style && dom.style.whiteSpace))
      this.localPreserveWS = true;
    let name = dom.nodeName.toLowerCase(), ruleID;
    if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)
      normalizeList(dom);
    let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));
    out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {
      this.findInside(dom);
      this.ignoreFallback(dom, marks);
    } else if (!rule || rule.skip || rule.closeParent) {
      if (rule && rule.closeParent)
        this.open = Math.max(0, this.open - 1);
      else if (rule && rule.skip.nodeType)
        dom = rule.skip;
      let sync, oldNeedsBlock = this.needsBlock;
      if (blockTags.hasOwnProperty(name)) {
        if (top2.content.length && top2.content[0].isInline && this.open) {
          this.open--;
          top2 = this.top;
        }
        sync = true;
        if (!top2.type)
          this.needsBlock = true;
      } else if (!dom.firstChild) {
        this.leafFallback(dom, marks);
        break out;
      }
      let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);
      if (innerMarks)
        this.addAll(dom, innerMarks);
      if (sync)
        this.sync(top2);
      this.needsBlock = oldNeedsBlock;
    } else {
      let innerMarks = this.readStyles(dom, marks);
      if (innerMarks)
        this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : void 0);
    }
    this.localPreserveWS = outerWS;
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(dom, marks) {
    if (dom.nodeName == "BR" && this.top.type && this.top.type.inlineContent)
      this.addTextNode(dom.ownerDocument.createTextNode("\n"), marks);
  }
  // Called for ignored nodes
  ignoreFallback(dom, marks) {
    if (dom.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent))
      this.findPlace(this.parser.schema.text("-"), marks, true);
  }
  // Run any style parser associated with the node's styles. Either
  // return an updated array of marks, or null to indicate some of the
  // styles had a rule with `ignore` set.
  readStyles(dom, marks) {
    let styles = dom.style;
    if (styles && styles.length)
      for (let i = 0; i < this.parser.matchedStyles.length; i++) {
        let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);
        if (value)
          for (let after = void 0; ; ) {
            let rule = this.parser.matchStyle(name, value, this, after);
            if (!rule)
              break;
            if (rule.ignore)
              return null;
            if (rule.clearMark)
              marks = marks.filter((m2) => !rule.clearMark(m2));
            else
              marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));
            if (rule.consuming === false)
              after = rule;
            else
              break;
          }
      }
    return marks;
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(dom, rule, marks, continueAfter) {
    let sync, nodeType;
    if (rule.node) {
      nodeType = this.parser.schema.nodes[rule.node];
      if (!nodeType.isLeaf) {
        let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);
        if (inner) {
          sync = true;
          marks = inner;
        }
      } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == "BR")) {
        this.leafFallback(dom, marks);
      }
    } else {
      let markType = this.parser.schema.marks[rule.mark];
      marks = marks.concat(markType.create(rule.attrs));
    }
    let startIn = this.top;
    if (nodeType && nodeType.isLeaf) {
      this.findInside(dom);
    } else if (continueAfter) {
      this.addElement(dom, marks, continueAfter);
    } else if (rule.getContent) {
      this.findInside(dom);
      rule.getContent(dom, this.parser.schema).forEach((node2) => this.insertNode(node2, marks, false));
    } else {
      let contentDOM = dom;
      if (typeof rule.contentElement == "string")
        contentDOM = dom.querySelector(rule.contentElement);
      else if (typeof rule.contentElement == "function")
        contentDOM = rule.contentElement(dom);
      else if (rule.contentElement)
        contentDOM = rule.contentElement;
      this.findAround(dom, contentDOM, true);
      this.addAll(contentDOM, marks);
      this.findAround(dom, contentDOM, false);
    }
    if (sync && this.sync(startIn))
      this.open--;
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(parent, marks, startIndex, endIndex) {
    let index2 = startIndex || 0;
    for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end2 = endIndex == null ? null : parent.childNodes[endIndex]; dom != end2; dom = dom.nextSibling, ++index2) {
      this.findAtPoint(parent, index2);
      this.addDOM(dom, marks);
    }
    this.findAtPoint(parent, index2);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(node2, marks, cautious) {
    let route, sync;
    for (let depth = this.open, penalty = 0; depth >= 0; depth--) {
      let cx = this.nodes[depth];
      let found2 = cx.findWrapping(node2);
      if (found2 && (!route || route.length > found2.length + penalty)) {
        route = found2;
        sync = cx;
        if (!found2.length)
          break;
      }
      if (cx.solid) {
        if (cautious)
          break;
        penalty += 2;
      }
    }
    if (!route)
      return null;
    this.sync(sync);
    for (let i = 0; i < route.length; i++)
      marks = this.enterInner(route[i], null, marks, false);
    return marks;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(node2, marks, cautious) {
    if (node2.isInline && this.needsBlock && !this.top.type) {
      let block = this.textblockFromContext();
      if (block)
        marks = this.enterInner(block, null, marks);
    }
    let innerMarks = this.findPlace(node2, marks, cautious);
    if (innerMarks) {
      this.closeExtra();
      let top2 = this.top;
      if (top2.match)
        top2.match = top2.match.matchType(node2.type);
      let nodeMarks = Mark$1.none;
      for (let m2 of innerMarks.concat(node2.marks))
        if (top2.type ? top2.type.allowsMarkType(m2.type) : markMayApply(m2.type, node2.type))
          nodeMarks = m2.addToSet(nodeMarks);
      top2.content.push(node2.mark(nodeMarks));
      return true;
    }
    return false;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(type2, attrs, marks, preserveWS) {
    let innerMarks = this.findPlace(type2.create(attrs), marks, false);
    if (innerMarks)
      innerMarks = this.enterInner(type2, attrs, marks, true, preserveWS);
    return innerMarks;
  }
  // Open a node of the given type
  enterInner(type2, attrs, marks, solid = false, preserveWS) {
    this.closeExtra();
    let top2 = this.top;
    top2.match = top2.match && top2.match.matchType(type2);
    let options = wsOptionsFor(type2, preserveWS, top2.options);
    if (top2.options & OPT_OPEN_LEFT && top2.content.length == 0)
      options |= OPT_OPEN_LEFT;
    let applyMarks = Mark$1.none;
    marks = marks.filter((m2) => {
      if (top2.type ? top2.type.allowsMarkType(m2.type) : markMayApply(m2.type, type2)) {
        applyMarks = m2.addToSet(applyMarks);
        return false;
      }
      return true;
    });
    this.nodes.push(new NodeContext(type2, attrs, applyMarks, solid, null, options));
    this.open++;
    return marks;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(openEnd = false) {
    let i = this.nodes.length - 1;
    if (i > this.open) {
      for (; i > this.open; i--)
        this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    this.open = 0;
    this.closeExtra(this.isOpen);
    return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));
  }
  sync(to) {
    for (let i = this.open; i >= 0; i--) {
      if (this.nodes[i] == to) {
        this.open = i;
        return true;
      } else if (this.localPreserveWS) {
        this.nodes[i].options |= OPT_PRESERVE_WS;
      }
    }
    return false;
  }
  get currentPos() {
    this.closeExtra();
    let pos = 0;
    for (let i = this.open; i >= 0; i--) {
      let content = this.nodes[i].content;
      for (let j2 = content.length - 1; j2 >= 0; j2--)
        pos += content[j2].nodeSize;
      if (i)
        pos++;
    }
    return pos;
  }
  findAtPoint(parent, offset2) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == parent && this.find[i].offset == offset2)
          this.find[i].pos = this.currentPos;
      }
  }
  findInside(parent) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))
          this.find[i].pos = this.currentPos;
      }
  }
  findAround(parent, content, before) {
    if (parent != content && this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {
          let pos = content.compareDocumentPosition(this.find[i].node);
          if (pos & (before ? 2 : 4))
            this.find[i].pos = this.currentPos;
        }
      }
  }
  findInText(textNode) {
    if (this.find)
      for (let i = 0; i < this.find.length; i++) {
        if (this.find[i].node == textNode)
          this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);
      }
  }
  // Determines whether the given context string matches this context.
  matchesContext(context) {
    if (context.indexOf("|") > -1)
      return context.split(/\s*\|\s*/).some(this.matchesContext, this);
    let parts = context.split("/");
    let option = this.options.context;
    let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);
    let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);
    let match = (i, depth) => {
      for (; i >= 0; i--) {
        let part = parts[i];
        if (part == "") {
          if (i == parts.length - 1 || i == 0)
            continue;
          for (; depth >= minDepth; depth--)
            if (match(i - 1, depth))
              return true;
          return false;
        } else {
          let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;
          if (!next || next.name != part && !next.isInGroup(part))
            return false;
          depth--;
        }
      }
      return true;
    };
    return match(parts.length - 1, this.open);
  }
  textblockFromContext() {
    let $context = this.options.context;
    if ($context)
      for (let d2 = $context.depth; d2 >= 0; d2--) {
        let deflt = $context.node(d2).contentMatchAt($context.indexAfter(d2)).defaultType;
        if (deflt && deflt.isTextblock && deflt.defaultAttrs)
          return deflt;
      }
    for (let name in this.parser.schema.nodes) {
      let type2 = this.parser.schema.nodes[name];
      if (type2.isTextblock && type2.defaultAttrs)
        return type2;
    }
  }
}
function normalizeList(dom) {
  for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {
    let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;
    if (name && listTags.hasOwnProperty(name) && prevItem) {
      prevItem.appendChild(child);
      child = prevItem;
    } else if (name == "li") {
      prevItem = child;
    } else if (name) {
      prevItem = null;
    }
  }
}
function matches(dom, selector) {
  return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);
}
function copy(obj) {
  let copy2 = {};
  for (let prop in obj)
    copy2[prop] = obj[prop];
  return copy2;
}
function markMayApply(markType, nodeType) {
  let nodes = nodeType.schema.nodes;
  for (let name in nodes) {
    let parent = nodes[name];
    if (!parent.allowsMarkType(markType))
      continue;
    let seen = [], scan = (match) => {
      seen.push(match);
      for (let i = 0; i < match.edgeCount; i++) {
        let { type: type2, next } = match.edge(i);
        if (type2 == nodeType)
          return true;
        if (seen.indexOf(next) < 0 && scan(next))
          return true;
      }
    };
    if (scan(parent.contentMatch))
      return true;
  }
}
class DOMSerializer {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(nodes, marks) {
    this.nodes = nodes;
    this.marks = marks;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(fragment, options = {}, target) {
    if (!target)
      target = doc$2(options).createDocumentFragment();
    let top2 = target, active = [];
    fragment.forEach((node2) => {
      if (active.length || node2.marks.length) {
        let keep2 = 0, rendered = 0;
        while (keep2 < active.length && rendered < node2.marks.length) {
          let next = node2.marks[rendered];
          if (!this.marks[next.type.name]) {
            rendered++;
            continue;
          }
          if (!next.eq(active[keep2][0]) || next.type.spec.spanning === false)
            break;
          keep2++;
          rendered++;
        }
        while (keep2 < active.length)
          top2 = active.pop()[1];
        while (rendered < node2.marks.length) {
          let add = node2.marks[rendered++];
          let markDOM = this.serializeMark(add, node2.isInline, options);
          if (markDOM) {
            active.push([add, top2]);
            top2.appendChild(markDOM.dom);
            top2 = markDOM.contentDOM || markDOM.dom;
          }
        }
      }
      top2.appendChild(this.serializeNodeInner(node2, options));
    });
    return target;
  }
  /**
  @internal
  */
  serializeNodeInner(node2, options) {
    let { dom, contentDOM } = renderSpec(doc$2(options), this.nodes[node2.type.name](node2), null, node2.attrs);
    if (contentDOM) {
      if (node2.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(node2.content, options, contentDOM);
    }
    return dom;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(node2, options = {}) {
    let dom = this.serializeNodeInner(node2, options);
    for (let i = node2.marks.length - 1; i >= 0; i--) {
      let wrap2 = this.serializeMark(node2.marks[i], node2.isInline, options);
      if (wrap2) {
        (wrap2.contentDOM || wrap2.dom).appendChild(dom);
        dom = wrap2.dom;
      }
    }
    return dom;
  }
  /**
  @internal
  */
  serializeMark(mark, inline, options = {}) {
    let toDOM = this.marks[mark.type.name];
    return toDOM && renderSpec(doc$2(options), toDOM(mark, inline), null, mark.attrs);
  }
  static renderSpec(doc2, structure, xmlNS = null, blockArraysIn) {
    return renderSpec(doc2, structure, xmlNS, blockArraysIn);
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(schema) {
    return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(schema) {
    let result = gatherToDOM(schema.nodes);
    if (!result.text)
      result.text = (node2) => node2.text;
    return result;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(schema) {
    return gatherToDOM(schema.marks);
  }
}
function gatherToDOM(obj) {
  let result = {};
  for (let name in obj) {
    let toDOM = obj[name].spec.toDOM;
    if (toDOM)
      result[name] = toDOM;
  }
  return result;
}
function doc$2(options) {
  return options.document || window.document;
}
const suspiciousAttributeCache = /* @__PURE__ */ new WeakMap();
function suspiciousAttributes(attrs) {
  let value = suspiciousAttributeCache.get(attrs);
  if (value === void 0)
    suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));
  return value;
}
function suspiciousAttributesInner(attrs) {
  let result = null;
  function scan(value) {
    if (value && typeof value == "object") {
      if (Array.isArray(value)) {
        if (typeof value[0] == "string") {
          if (!result)
            result = [];
          result.push(value);
        } else {
          for (let i = 0; i < value.length; i++)
            scan(value[i]);
        }
      } else {
        for (let prop in value)
          scan(value[prop]);
      }
    }
  }
  scan(attrs);
  return result;
}
function renderSpec(doc2, structure, xmlNS, blockArraysIn) {
  if (typeof structure == "string")
    return { dom: doc2.createTextNode(structure) };
  if (structure.nodeType != null)
    return { dom: structure };
  if (structure.dom && structure.dom.nodeType != null)
    return structure;
  let tagName = structure[0], suspicious;
  if (typeof tagName != "string")
    throw new RangeError("Invalid array passed to renderSpec");
  if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1)
    throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.");
  let space = tagName.indexOf(" ");
  if (space > 0) {
    xmlNS = tagName.slice(0, space);
    tagName = tagName.slice(space + 1);
  }
  let contentDOM;
  let dom = xmlNS ? doc2.createElementNS(xmlNS, tagName) : doc2.createElement(tagName);
  let attrs = structure[1], start2 = 1;
  if (attrs && typeof attrs == "object" && attrs.nodeType == null && !Array.isArray(attrs)) {
    start2 = 2;
    for (let name in attrs)
      if (attrs[name] != null) {
        let space2 = name.indexOf(" ");
        if (space2 > 0)
          dom.setAttributeNS(name.slice(0, space2), name.slice(space2 + 1), attrs[name]);
        else if (name == "style" && dom.style)
          dom.style.cssText = attrs[name];
        else
          dom.setAttribute(name, attrs[name]);
      }
  }
  for (let i = start2; i < structure.length; i++) {
    let child = structure[i];
    if (child === 0) {
      if (i < structure.length - 1 || i > start2)
        throw new RangeError("Content hole must be the only child of its parent node");
      return { dom, contentDOM: dom };
    } else {
      let { dom: inner, contentDOM: innerContent } = renderSpec(doc2, child, xmlNS, blockArraysIn);
      dom.appendChild(inner);
      if (innerContent) {
        if (contentDOM)
          throw new RangeError("Multiple content holes");
        contentDOM = innerContent;
      }
    }
  }
  return { dom, contentDOM };
}
const lower16 = 65535;
const factor16 = Math.pow(2, 16);
function makeRecover(index2, offset2) {
  return index2 + offset2 * factor16;
}
function recoverIndex(value) {
  return value & lower16;
}
function recoverOffset(value) {
  return (value - (value & lower16)) / factor16;
}
const DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;
class MapResult {
  /**
  @internal
  */
  constructor(pos, delInfo, recover) {
    this.pos = pos;
    this.delInfo = delInfo;
    this.recover = recover;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & DEL_SIDE) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & DEL_ACROSS) > 0;
  }
}
class StepMap {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(ranges, inverted = false) {
    this.ranges = ranges;
    this.inverted = inverted;
    if (!ranges.length && StepMap.empty)
      return StepMap.empty;
  }
  /**
  @internal
  */
  recover(value) {
    let diff = 0, index2 = recoverIndex(value);
    if (!this.inverted)
      for (let i = 0; i < index2; i++)
        diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[index2 * 3] + diff + recoverOffset(value);
  }
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  map(pos, assoc = 1) {
    return this._map(pos, assoc, true);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end2 = start2 + oldSize;
      if (pos <= end2) {
        let side = !oldSize ? assoc : pos == start2 ? -1 : pos == end2 ? 1 : assoc;
        let result = start2 + diff + (side < 0 ? 0 : newSize);
        if (simple)
          return result;
        let recover = pos == (assoc < 0 ? start2 : end2) ? null : makeRecover(i / 3, pos - start2);
        let del = pos == start2 ? DEL_AFTER : pos == end2 ? DEL_BEFORE : DEL_ACROSS;
        if (assoc < 0 ? pos != start2 : pos != end2)
          del |= DEL_SIDE;
        return new MapResult(result, del, recover);
      }
      diff += newSize - oldSize;
    }
    return simple ? pos + diff : new MapResult(pos + diff, 0, null);
  }
  /**
  @internal
  */
  touches(pos, recover) {
    let diff = 0, index2 = recoverIndex(recover);
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i] - (this.inverted ? diff : 0);
      if (start2 > pos)
        break;
      let oldSize = this.ranges[i + oldIndex], end2 = start2 + oldSize;
      if (pos <= end2 && i == index2 * 3)
        return true;
      diff += this.ranges[i + newIndex] - oldSize;
    }
    return false;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(f) {
    let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;
    for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {
      let start2 = this.ranges[i], oldStart = start2 - (this.inverted ? diff : 0), newStart = start2 + (this.inverted ? 0 : diff);
      let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];
      f(oldStart, oldStart + oldSize, newStart, newStart + newSize);
      diff += newSize - oldSize;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new StepMap(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(n) {
    return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);
  }
}
StepMap.empty = new StepMap([]);
class Mapping {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(maps, mirror, from2 = 0, to = maps ? maps.length : 0) {
    this.mirror = mirror;
    this.from = from2;
    this.to = to;
    this._maps = maps || [];
    this.ownData = !(maps || mirror);
  }
  /**
  The step maps in this mapping.
  */
  get maps() {
    return this._maps;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(from2 = 0, to = this.maps.length) {
    return new Mapping(this._maps, this.mirror, from2, to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(map3, mirrors) {
    if (!this.ownData) {
      this._maps = this._maps.slice();
      this.mirror = this.mirror && this.mirror.slice();
      this.ownData = true;
    }
    this.to = this._maps.push(map3);
    if (mirrors != null)
      this.setMirror(this._maps.length - 1, mirrors);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(mapping) {
    for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(n) {
    if (this.mirror) {
      for (let i = 0; i < this.mirror.length; i++)
        if (this.mirror[i] == n)
          return this.mirror[i + (i % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(n, m2) {
    if (!this.mirror)
      this.mirror = [];
    this.mirror.push(n, m2);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(mapping) {
    for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {
      let mirr = mapping.getMirror(i);
      this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let inverse = new Mapping();
    inverse.appendMappingInverted(this);
    return inverse;
  }
  /**
  Map a position through this mapping.
  */
  map(pos, assoc = 1) {
    if (this.mirror)
      return this._map(pos, assoc, true);
    for (let i = this.from; i < this.to; i++)
      pos = this._maps[i].map(pos, assoc);
    return pos;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(pos, assoc = 1) {
    return this._map(pos, assoc, false);
  }
  /**
  @internal
  */
  _map(pos, assoc, simple) {
    let delInfo = 0;
    for (let i = this.from; i < this.to; i++) {
      let map3 = this._maps[i], result = map3.mapResult(pos, assoc);
      if (result.recover != null) {
        let corr = this.getMirror(i);
        if (corr != null && corr > i && corr < this.to) {
          i = corr;
          pos = this._maps[corr].recover(result.recover);
          continue;
        }
      }
      delInfo |= result.delInfo;
      pos = result.pos;
    }
    return simple ? pos : new MapResult(pos, delInfo, null);
  }
}
const stepsByID = /* @__PURE__ */ Object.create(null);
class Step {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return StepMap.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(other) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(schema, json) {
    if (!json || !json.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let type2 = stepsByID[json.stepType];
    if (!type2)
      throw new RangeError(`No step type ${json.stepType} defined`);
    return type2.fromJSON(schema, json);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(id, stepClass) {
    if (id in stepsByID)
      throw new RangeError("Duplicate use of step JSON ID " + id);
    stepsByID[id] = stepClass;
    stepClass.prototype.jsonID = id;
    return stepClass;
  }
}
class StepResult {
  /**
  @internal
  */
  constructor(doc2, failed) {
    this.doc = doc2;
    this.failed = failed;
  }
  /**
  Create a successful step result.
  */
  static ok(doc2) {
    return new StepResult(doc2, null);
  }
  /**
  Create a failed step result.
  */
  static fail(message) {
    return new StepResult(null, message);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(doc2, from2, to, slice2) {
    try {
      return StepResult.ok(doc2.replace(from2, to, slice2));
    } catch (e) {
      if (e instanceof ReplaceError)
        return StepResult.fail(e.message);
      throw e;
    }
  }
}
function mapFragment(fragment, f, parent) {
  let mapped = [];
  for (let i = 0; i < fragment.childCount; i++) {
    let child = fragment.child(i);
    if (child.content.size)
      child = child.copy(mapFragment(child.content, f, child));
    if (child.isInline)
      child = f(child, parent, i);
    mapped.push(child);
  }
  return Fragment.fromArray(mapped);
}
class AddMarkStep extends Step {
  /**
  Create a mark step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to), $from = doc2.resolve(this.from);
    let parent = $from.node($from.sharedDepth(this.to));
    let slice2 = new Slice(mapFragment(oldSlice.content, (node2, parent2) => {
      if (!node2.isAtom || !parent2.type.allowsMarkType(this.mark.type))
        return node2;
      return node2.mark(this.mark.addToSet(node2.marks));
    }, parent), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  }
  invert() {
    return new RemoveMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new AddMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addMark", AddMarkStep);
class RemoveMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(from2, to, mark) {
    super();
    this.from = from2;
    this.to = to;
    this.mark = mark;
  }
  apply(doc2) {
    let oldSlice = doc2.slice(this.from, this.to);
    let slice2 = new Slice(mapFragment(oldSlice.content, (node2) => {
      return node2.mark(this.mark.removeFromSet(node2.marks));
    }, doc2), oldSlice.openStart, oldSlice.openEnd);
    return StepResult.fromReplace(doc2, this.from, this.to, slice2);
  }
  invert() {
    return new AddMarkStep(this.from, this.to, this.mark);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deleted && to.deleted || from2.pos >= to.pos)
      return null;
    return new RemoveMarkStep(from2.pos, to.pos, this.mark);
  }
  merge(other) {
    if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from)
      return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);
    return null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeMark", RemoveMarkStep);
class AddNodeMarkStep extends Step {
  /**
  Create a node mark step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2)
      return StepResult.fail("No node at mark step's position");
    let updated = node2.type.create(node2.attrs, null, this.mark.addToSet(node2.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (node2) {
      let newSet = this.mark.addToSet(node2.marks);
      if (newSet.length == node2.marks.length) {
        for (let i = 0; i < node2.marks.length; i++)
          if (!node2.marks[i].isInSet(newSet))
            return new AddNodeMarkStep(this.pos, node2.marks[i]);
        return new AddNodeMarkStep(this.pos, this.mark);
      }
    }
    return new RemoveNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("addNodeMark", AddNodeMarkStep);
class RemoveNodeMarkStep extends Step {
  /**
  Create a mark-removing step.
  */
  constructor(pos, mark) {
    super();
    this.pos = pos;
    this.mark = mark;
  }
  apply(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2)
      return StepResult.fail("No node at mark step's position");
    let updated = node2.type.create(node2.attrs, null, this.mark.removeFromSet(node2.marks));
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
  }
  invert(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2 || !this.mark.isInSet(node2.marks))
      return this;
    return new AddNodeMarkStep(this.pos, this.mark);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));
  }
}
Step.jsonID("removeNodeMark", RemoveNodeMarkStep);
class ReplaceStep extends Step {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(from2, to, slice2, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.slice = slice2;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && contentBetween(doc2, this.from, this.to))
      return StepResult.fail("Structure replace would overwrite content");
    return StepResult.fromReplace(doc2, this.from, this.to, this.slice);
  }
  getMap() {
    return new StepMap([this.from, this.to - this.from, this.slice.size]);
  }
  invert(doc2) {
    return new ReplaceStep(this.from, this.from + this.slice.size, doc2.slice(this.from, this.to));
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    if (from2.deletedAcross && to.deletedAcross)
      return null;
    return new ReplaceStep(from2.pos, Math.max(from2.pos, to.pos), this.slice, this.structure);
  }
  merge(other) {
    if (!(other instanceof ReplaceStep) || other.structure || this.structure)
      return null;
    if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);
      return new ReplaceStep(this.from, this.to + (other.to - other.from), slice2, this.structure);
    } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {
      let slice2 = this.slice.size + other.slice.size == 0 ? Slice.empty : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);
      return new ReplaceStep(other.from, this.to, slice2, this.structure);
    } else {
      return null;
    }
  }
  toJSON() {
    let json = { stepType: "replace", from: this.from, to: this.to };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);
  }
}
Step.jsonID("replace", ReplaceStep);
let ReplaceAroundStep$1 = class ReplaceAroundStep2 extends Step {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(from2, to, gapFrom, gapTo, slice2, insert, structure = false) {
    super();
    this.from = from2;
    this.to = to;
    this.gapFrom = gapFrom;
    this.gapTo = gapTo;
    this.slice = slice2;
    this.insert = insert;
    this.structure = structure;
  }
  apply(doc2) {
    if (this.structure && (contentBetween(doc2, this.from, this.gapFrom) || contentBetween(doc2, this.gapTo, this.to)))
      return StepResult.fail("Structure gap-replace would overwrite content");
    let gap = doc2.slice(this.gapFrom, this.gapTo);
    if (gap.openStart || gap.openEnd)
      return StepResult.fail("Gap is not a flat range");
    let inserted = this.slice.insertAt(this.insert, gap.content);
    if (!inserted)
      return StepResult.fail("Content does not fit in gap");
    return StepResult.fromReplace(doc2, this.from, this.to, inserted);
  }
  getMap() {
    return new StepMap([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(doc2) {
    let gap = this.gapTo - this.gapFrom;
    return new ReplaceAroundStep2(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc2.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(mapping) {
    let from2 = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);
    let gapFrom = this.from == this.gapFrom ? from2.pos : mapping.map(this.gapFrom, -1);
    let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);
    if (from2.deletedAcross && to.deletedAcross || gapFrom < from2.pos || gapTo > to.pos)
      return null;
    return new ReplaceAroundStep2(from2.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let json = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    if (this.slice.size)
      json.slice = this.slice.toJSON();
    if (this.structure)
      json.structure = true;
    return json;
  }
  /**
  @internal
  */
  static fromJSON(schema, json) {
    if (typeof json.from != "number" || typeof json.to != "number" || typeof json.gapFrom != "number" || typeof json.gapTo != "number" || typeof json.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new ReplaceAroundStep2(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);
  }
};
Step.jsonID("replaceAround", ReplaceAroundStep$1);
function contentBetween(doc2, from2, to) {
  let $from = doc2.resolve(from2), dist2 = to - from2, depth = $from.depth;
  while (dist2 > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {
    depth--;
    dist2--;
  }
  if (dist2 > 0) {
    let next = $from.node(depth).maybeChild($from.indexAfter(depth));
    while (dist2 > 0) {
      if (!next || next.isLeaf)
        return true;
      next = next.firstChild;
      dist2--;
    }
  }
  return false;
}
function addMark(tr, from2, to, mark) {
  let removed = [], added = [];
  let removing, adding;
  tr.doc.nodesBetween(from2, to, (node2, pos, parent) => {
    if (!node2.isInline)
      return;
    let marks = node2.marks;
    if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {
      let start2 = Math.max(pos, from2), end2 = Math.min(pos + node2.nodeSize, to);
      let newSet = mark.addToSet(marks);
      for (let i = 0; i < marks.length; i++) {
        if (!marks[i].isInSet(newSet)) {
          if (removing && removing.to == start2 && removing.mark.eq(marks[i]))
            removing.to = end2;
          else
            removed.push(removing = new RemoveMarkStep(start2, end2, marks[i]));
        }
      }
      if (adding && adding.to == start2)
        adding.to = end2;
      else
        added.push(adding = new AddMarkStep(start2, end2, mark));
    }
  });
  removed.forEach((s) => tr.step(s));
  added.forEach((s) => tr.step(s));
}
function removeMark(tr, from2, to, mark) {
  let matched = [], step = 0;
  tr.doc.nodesBetween(from2, to, (node2, pos) => {
    if (!node2.isInline)
      return;
    step++;
    let toRemove = null;
    if (mark instanceof MarkType) {
      let set = node2.marks, found2;
      while (found2 = mark.isInSet(set)) {
        (toRemove || (toRemove = [])).push(found2);
        set = found2.removeFromSet(set);
      }
    } else if (mark) {
      if (mark.isInSet(node2.marks))
        toRemove = [mark];
    } else {
      toRemove = node2.marks;
    }
    if (toRemove && toRemove.length) {
      let end2 = Math.min(pos + node2.nodeSize, to);
      for (let i = 0; i < toRemove.length; i++) {
        let style2 = toRemove[i], found2;
        for (let j2 = 0; j2 < matched.length; j2++) {
          let m2 = matched[j2];
          if (m2.step == step - 1 && style2.eq(matched[j2].style))
            found2 = m2;
        }
        if (found2) {
          found2.to = end2;
          found2.step = step;
        } else {
          matched.push({ style: style2, from: Math.max(pos, from2), to: end2, step });
        }
      }
    }
  });
  matched.forEach((m2) => tr.step(new RemoveMarkStep(m2.from, m2.to, m2.style)));
}
function clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {
  let node2 = tr.doc.nodeAt(pos);
  let replSteps = [], cur = pos + 1;
  for (let i = 0; i < node2.childCount; i++) {
    let child = node2.child(i), end2 = cur + child.nodeSize;
    let allowed = match.matchType(child.type);
    if (!allowed) {
      replSteps.push(new ReplaceStep(cur, end2, Slice.empty));
    } else {
      match = allowed;
      for (let j2 = 0; j2 < child.marks.length; j2++)
        if (!parentType.allowsMarkType(child.marks[j2].type))
          tr.step(new RemoveMarkStep(cur, end2, child.marks[j2]));
      if (clearNewlines && child.isText && parentType.whitespace != "pre") {
        let m2, newline = /\r?\n|\r/g, slice2;
        while (m2 = newline.exec(child.text)) {
          if (!slice2)
            slice2 = new Slice(Fragment.from(parentType.schema.text(" ", parentType.allowedMarks(child.marks))), 0, 0);
          replSteps.push(new ReplaceStep(cur + m2.index, cur + m2.index + m2[0].length, slice2));
        }
      }
    }
    cur = end2;
  }
  if (!match.validEnd) {
    let fill = match.fillBefore(Fragment.empty, true);
    tr.replace(cur, cur, new Slice(fill, 0, 0));
  }
  for (let i = replSteps.length - 1; i >= 0; i--)
    tr.step(replSteps[i]);
}
function canCut(node2, start2, end2) {
  return (start2 == 0 || node2.canReplace(start2, node2.childCount)) && (end2 == node2.childCount || node2.canReplace(0, end2));
}
function liftTarget(range2) {
  let parent = range2.parent;
  let content = parent.content.cutByIndex(range2.startIndex, range2.endIndex);
  for (let depth = range2.depth; ; --depth) {
    let node2 = range2.$from.node(depth);
    let index2 = range2.$from.index(depth), endIndex = range2.$to.indexAfter(depth);
    if (depth < range2.depth && node2.canReplace(index2, endIndex, content))
      return depth;
    if (depth == 0 || node2.type.spec.isolating || !canCut(node2, index2, endIndex))
      break;
  }
  return null;
}
function lift(tr, range2, target) {
  let { $from, $to, depth } = range2;
  let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);
  let start2 = gapStart, end2 = gapEnd;
  let before = Fragment.empty, openStart = 0;
  for (let d2 = depth, splitting = false; d2 > target; d2--)
    if (splitting || $from.index(d2) > 0) {
      splitting = true;
      before = Fragment.from($from.node(d2).copy(before));
      openStart++;
    } else {
      start2--;
    }
  let after = Fragment.empty, openEnd = 0;
  for (let d2 = depth, splitting = false; d2 > target; d2--)
    if (splitting || $to.after(d2 + 1) < $to.end(d2)) {
      splitting = true;
      after = Fragment.from($to.node(d2).copy(after));
      openEnd++;
    } else {
      end2++;
    }
  tr.step(new ReplaceAroundStep$1(start2, end2, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));
}
function findWrapping(range2, nodeType, attrs = null, innerRange = range2) {
  let around = findWrappingOutside(range2, nodeType);
  let inner = around && findWrappingInside(innerRange, nodeType);
  if (!inner)
    return null;
  return around.map(withAttrs).concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));
}
function withAttrs(type2) {
  return { type: type2, attrs: null };
}
function findWrappingOutside(range2, type2) {
  let { parent, startIndex, endIndex } = range2;
  let around = parent.contentMatchAt(startIndex).findWrapping(type2);
  if (!around)
    return null;
  let outer = around.length ? around[0] : type2;
  return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;
}
function findWrappingInside(range2, type2) {
  let { parent, startIndex, endIndex } = range2;
  let inner = parent.child(startIndex);
  let inside = type2.contentMatch.findWrapping(inner.type);
  if (!inside)
    return null;
  let lastType = inside.length ? inside[inside.length - 1] : type2;
  let innerMatch = lastType.contentMatch;
  for (let i = startIndex; innerMatch && i < endIndex; i++)
    innerMatch = innerMatch.matchType(parent.child(i).type);
  if (!innerMatch || !innerMatch.validEnd)
    return null;
  return inside;
}
function wrap(tr, range2, wrappers) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--) {
    if (content.size) {
      let match = wrappers[i].type.contentMatch.matchFragment(content);
      if (!match || !match.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  }
  let start2 = range2.start, end2 = range2.end;
  tr.step(new ReplaceAroundStep$1(start2, end2, start2, end2, new Slice(content, 0, 0), wrappers.length, true));
}
function setBlockType$1(tr, from2, to, type2, attrs) {
  if (!type2.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let mapFrom = tr.steps.length;
  tr.doc.nodesBetween(from2, to, (node2, pos) => {
    let attrsHere = typeof attrs == "function" ? attrs(node2) : attrs;
    if (node2.isTextblock && !node2.hasMarkup(type2, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type2)) {
      let convertNewlines = null;
      if (type2.schema.linebreakReplacement) {
        let pre = type2.whitespace == "pre", supportLinebreak = !!type2.contentMatch.matchType(type2.schema.linebreakReplacement);
        if (pre && !supportLinebreak)
          convertNewlines = false;
        else if (!pre && supportLinebreak)
          convertNewlines = true;
      }
      if (convertNewlines === false)
        replaceLinebreaks(tr, node2, pos, mapFrom);
      clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type2, void 0, convertNewlines === null);
      let mapping = tr.mapping.slice(mapFrom);
      let startM = mapping.map(pos, 1), endM = mapping.map(pos + node2.nodeSize, 1);
      tr.step(new ReplaceAroundStep$1(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type2.create(attrsHere, null, node2.marks)), 0, 0), 1, true));
      if (convertNewlines === true)
        replaceNewlines(tr, node2, pos, mapFrom);
      return false;
    }
  });
}
function replaceNewlines(tr, node2, pos, mapFrom) {
  node2.forEach((child, offset2) => {
    if (child.isText) {
      let m2, newline = /\r?\n|\r/g;
      while (m2 = newline.exec(child.text)) {
        let start2 = tr.mapping.slice(mapFrom).map(pos + 1 + offset2 + m2.index);
        tr.replaceWith(start2, start2 + 1, node2.type.schema.linebreakReplacement.create());
      }
    }
  });
}
function replaceLinebreaks(tr, node2, pos, mapFrom) {
  node2.forEach((child, offset2) => {
    if (child.type == child.type.schema.linebreakReplacement) {
      let start2 = tr.mapping.slice(mapFrom).map(pos + 1 + offset2);
      tr.replaceWith(start2, start2 + 1, node2.type.schema.text("\n"));
    }
  });
}
function canChangeType(doc2, pos, type2) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return $pos.parent.canReplaceWith(index2, index2 + 1, type2);
}
function setNodeMarkup(tr, pos, type2, attrs, marks) {
  let node2 = tr.doc.nodeAt(pos);
  if (!node2)
    throw new RangeError("No node at given position");
  if (!type2)
    type2 = node2.type;
  let newNode = type2.create(attrs, null, marks || node2.marks);
  if (node2.isLeaf)
    return tr.replaceWith(pos, pos + node2.nodeSize, newNode);
  if (!type2.validContent(node2.content))
    throw new RangeError("Invalid content for node type " + type2.name);
  tr.step(new ReplaceAroundStep$1(pos, pos + node2.nodeSize, pos + 1, pos + node2.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));
}
function canSplit(doc2, pos, depth = 1, typesAfter) {
  let $pos = doc2.resolve(pos), base2 = $pos.depth - depth;
  let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;
  if (base2 < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))
    return false;
  for (let d2 = $pos.depth - 1, i = depth - 2; d2 > base2; d2--, i--) {
    let node2 = $pos.node(d2), index22 = $pos.index(d2);
    if (node2.type.spec.isolating)
      return false;
    let rest = node2.content.cutByIndex(index22, node2.childCount);
    let overrideChild = typesAfter && typesAfter[i + 1];
    if (overrideChild)
      rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));
    let after = typesAfter && typesAfter[i] || node2;
    if (!node2.canReplace(index22 + 1, node2.childCount) || !after.type.validContent(rest))
      return false;
  }
  let index2 = $pos.indexAfter(base2);
  let baseType = typesAfter && typesAfter[0];
  return $pos.node(base2).canReplaceWith(index2, index2, baseType ? baseType.type : $pos.node(base2 + 1).type);
}
function split(tr, pos, depth = 1, typesAfter) {
  let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;
  for (let d2 = $pos.depth, e = $pos.depth - depth, i = depth - 1; d2 > e; d2--, i--) {
    before = Fragment.from($pos.node(d2).copy(before));
    let typeAfter = typesAfter && typesAfter[i];
    after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d2).copy(after));
  }
  tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));
}
function canJoin(doc2, pos) {
  let $pos = doc2.resolve(pos), index2 = $pos.index();
  return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index2, index2 + 1);
}
function canAppendWithSubstitutedLinebreaks(a, b2) {
  if (!b2.content.size)
    a.type.compatibleContent(b2.type);
  let match = a.contentMatchAt(a.childCount);
  let { linebreakReplacement } = a.type.schema;
  for (let i = 0; i < b2.childCount; i++) {
    let child = b2.child(i);
    let type2 = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;
    match = match.matchType(type2);
    if (!match)
      return false;
    if (!a.type.allowsMarks(child.marks))
      return false;
  }
  return match.validEnd;
}
function joinable(a, b2) {
  return !!(a && b2 && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b2));
}
function joinPoint(doc2, pos, dir = -1) {
  let $pos = doc2.resolve(pos);
  for (let d2 = $pos.depth; ; d2--) {
    let before, after, index2 = $pos.index(d2);
    if (d2 == $pos.depth) {
      before = $pos.nodeBefore;
      after = $pos.nodeAfter;
    } else if (dir > 0) {
      before = $pos.node(d2 + 1);
      index2++;
      after = $pos.node(d2).maybeChild(index2);
    } else {
      before = $pos.node(d2).maybeChild(index2 - 1);
      after = $pos.node(d2 + 1);
    }
    if (before && !before.isTextblock && joinable(before, after) && $pos.node(d2).canReplace(index2, index2 + 1))
      return pos;
    if (d2 == 0)
      break;
    pos = dir < 0 ? $pos.before(d2) : $pos.after(d2);
  }
}
function join(tr, pos, depth) {
  let convertNewlines = null;
  let { linebreakReplacement } = tr.doc.type.schema;
  let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;
  if (linebreakReplacement && beforeType.inlineContent) {
    let pre = beforeType.whitespace == "pre";
    let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);
    if (pre && !supportLinebreak)
      convertNewlines = false;
    else if (!pre && supportLinebreak)
      convertNewlines = true;
  }
  let mapFrom = tr.steps.length;
  if (convertNewlines === false) {
    let $after = tr.doc.resolve(pos + depth);
    replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);
  }
  if (beforeType.inlineContent)
    clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);
  let mapping = tr.mapping.slice(mapFrom), start2 = mapping.map(pos - depth);
  tr.step(new ReplaceStep(start2, mapping.map(pos + depth, -1), Slice.empty, true));
  if (convertNewlines === true) {
    let $full = tr.doc.resolve(start2);
    replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);
  }
  return tr;
}
function insertPoint(doc2, pos, nodeType) {
  let $pos = doc2.resolve(pos);
  if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))
    return pos;
  if ($pos.parentOffset == 0)
    for (let d2 = $pos.depth - 1; d2 >= 0; d2--) {
      let index2 = $pos.index(d2);
      if ($pos.node(d2).canReplaceWith(index2, index2, nodeType))
        return $pos.before(d2 + 1);
      if (index2 > 0)
        return null;
    }
  if ($pos.parentOffset == $pos.parent.content.size)
    for (let d2 = $pos.depth - 1; d2 >= 0; d2--) {
      let index2 = $pos.indexAfter(d2);
      if ($pos.node(d2).canReplaceWith(index2, index2, nodeType))
        return $pos.after(d2 + 1);
      if (index2 < $pos.node(d2).childCount)
        return null;
    }
  return null;
}
function dropPoint(doc2, pos, slice2) {
  let $pos = doc2.resolve(pos);
  if (!slice2.content.size)
    return pos;
  let content = slice2.content;
  for (let i = 0; i < slice2.openStart; i++)
    content = content.firstChild.content;
  for (let pass = 1; pass <= (slice2.openStart == 0 && slice2.size ? 2 : 1); pass++) {
    for (let d2 = $pos.depth; d2 >= 0; d2--) {
      let bias = d2 == $pos.depth ? 0 : $pos.pos <= ($pos.start(d2 + 1) + $pos.end(d2 + 1)) / 2 ? -1 : 1;
      let insertPos = $pos.index(d2) + (bias > 0 ? 1 : 0);
      let parent = $pos.node(d2), fits = false;
      if (pass == 1) {
        fits = parent.canReplace(insertPos, insertPos, content);
      } else {
        let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);
        fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);
      }
      if (fits)
        return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d2 + 1) : $pos.after(d2 + 1);
    }
  }
  return null;
}
function replaceStep$1(doc2, from2, to = from2, slice2 = Slice.empty) {
  if (from2 == to && !slice2.size)
    return null;
  let $from = doc2.resolve(from2), $to = doc2.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return new ReplaceStep(from2, to, slice2);
  return new Fitter($from, $to, slice2).fit();
}
function fitsTrivially($from, $to, slice2) {
  return !slice2.openStart && !slice2.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice2.content);
}
class Fitter {
  constructor($from, $to, unplaced) {
    this.$from = $from;
    this.$to = $to;
    this.unplaced = unplaced;
    this.frontier = [];
    this.placed = Fragment.empty;
    for (let i = 0; i <= $from.depth; i++) {
      let node2 = $from.node(i);
      this.frontier.push({
        type: node2.type,
        match: node2.contentMatchAt($from.indexAfter(i))
      });
    }
    for (let i = $from.depth; i > 0; i--)
      this.placed = Fragment.from($from.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    while (this.unplaced.size) {
      let fit = this.findFittable();
      if (fit)
        this.placeNodes(fit);
      else
        this.openMore() || this.dropNode();
    }
    let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;
    let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));
    if (!$to)
      return null;
    let content = this.placed, openStart = $from.depth, openEnd = $to.depth;
    while (openStart && openEnd && content.childCount == 1) {
      content = content.firstChild.content;
      openStart--;
      openEnd--;
    }
    let slice2 = new Slice(content, openStart, openEnd);
    if (moveInline > -1)
      return new ReplaceAroundStep$1($from.pos, moveInline, this.$to.pos, this.$to.end(), slice2, placedSize);
    if (slice2.size || $from.pos != this.$to.pos)
      return new ReplaceStep($from.pos, $to.pos, slice2);
    return null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let startDepth = this.unplaced.openStart;
    for (let cur = this.unplaced.content, d2 = 0, openEnd = this.unplaced.openEnd; d2 < startDepth; d2++) {
      let node2 = cur.firstChild;
      if (cur.childCount > 1)
        openEnd = 0;
      if (node2.type.spec.isolating && openEnd <= d2) {
        startDepth = d2;
        break;
      }
      cur = node2.content;
    }
    for (let pass = 1; pass <= 2; pass++) {
      for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {
        let fragment, parent = null;
        if (sliceDepth) {
          parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;
          fragment = parent.content;
        } else {
          fragment = this.unplaced.content;
        }
        let first2 = fragment.firstChild;
        for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {
          let { type: type2, match } = this.frontier[frontierDepth], wrap2, inject = null;
          if (pass == 1 && (first2 ? match.matchType(first2.type) || (inject = match.fillBefore(Fragment.from(first2), false)) : parent && type2.compatibleContent(parent.type)))
            return { sliceDepth, frontierDepth, parent, inject };
          else if (pass == 2 && first2 && (wrap2 = match.findWrapping(first2.type)))
            return { sliceDepth, frontierDepth, parent, wrap: wrap2 };
          if (parent && match.matchType(parent.type))
            break;
        }
      }
    }
  }
  openMore() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (!inner.childCount || inner.firstChild.isLeaf)
      return false;
    this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));
    return true;
  }
  dropNode() {
    let { content, openStart, openEnd } = this.unplaced;
    let inner = contentAt(content, openStart);
    if (inner.childCount <= 1 && openStart > 0) {
      let openAtEnd = content.size - openStart <= openStart + inner.size;
      this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);
    } else {
      this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);
    }
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap: wrap2 }) {
    while (this.depth > frontierDepth)
      this.closeFrontierNode();
    if (wrap2)
      for (let i = 0; i < wrap2.length; i++)
        this.openFrontierNode(wrap2[i]);
    let slice2 = this.unplaced, fragment = parent ? parent.content : slice2.content;
    let openStart = slice2.openStart - sliceDepth;
    let taken = 0, add = [];
    let { match, type: type2 } = this.frontier[frontierDepth];
    if (inject) {
      for (let i = 0; i < inject.childCount; i++)
        add.push(inject.child(i));
      match = match.matchFragment(inject);
    }
    let openEndCount = fragment.size + sliceDepth - (slice2.content.size - slice2.openEnd);
    while (taken < fragment.childCount) {
      let next = fragment.child(taken), matches2 = match.matchType(next.type);
      if (!matches2)
        break;
      taken++;
      if (taken > 1 || openStart == 0 || next.content.size) {
        match = matches2;
        add.push(closeNodeStart(next.mark(type2.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));
      }
    }
    let toEnd = taken == fragment.childCount;
    if (!toEnd)
      openEndCount = -1;
    this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));
    this.frontier[frontierDepth].match = match;
    if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)
      this.closeFrontierNode();
    for (let i = 0, cur = fragment; i < openEndCount; i++) {
      let node2 = cur.lastChild;
      this.frontier.push({ type: node2.type, match: node2.contentMatchAt(node2.childCount) });
      cur = node2.content;
    }
    this.unplaced = !toEnd ? new Slice(dropFromFragment(slice2.content, sliceDepth, taken), slice2.openStart, slice2.openEnd) : sliceDepth == 0 ? Slice.empty : new Slice(dropFromFragment(slice2.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice2.openEnd : sliceDepth - 1);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let top2 = this.frontier[this.depth], level;
    if (!top2.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top2.type, top2.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth)
      return -1;
    let { depth } = this.$to, after = this.$to.after(depth);
    while (depth > 1 && after == this.$to.end(--depth))
      ++after;
    return after;
  }
  findCloseLevel($to) {
    scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {
      let { match, type: type2 } = this.frontier[i];
      let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));
      let fit = contentAfterFits($to, i, type2, match, dropInner);
      if (!fit)
        continue;
      for (let d2 = i - 1; d2 >= 0; d2--) {
        let { match: match2, type: type3 } = this.frontier[d2];
        let matches2 = contentAfterFits($to, d2, type3, match2, true);
        if (!matches2 || matches2.childCount)
          continue scan;
      }
      return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };
    }
  }
  close($to) {
    let close2 = this.findCloseLevel($to);
    if (!close2)
      return null;
    while (this.depth > close2.depth)
      this.closeFrontierNode();
    if (close2.fit.childCount)
      this.placed = addToFragment(this.placed, close2.depth, close2.fit);
    $to = close2.move;
    for (let d2 = close2.depth + 1; d2 <= $to.depth; d2++) {
      let node2 = $to.node(d2), add = node2.type.contentMatch.fillBefore(node2.content, true, $to.index(d2));
      this.openFrontierNode(node2.type, node2.attrs, add);
    }
    return $to;
  }
  openFrontierNode(type2, attrs = null, content) {
    let top2 = this.frontier[this.depth];
    top2.match = top2.match.matchType(type2);
    this.placed = addToFragment(this.placed, this.depth, Fragment.from(type2.create(attrs, content)));
    this.frontier.push({ type: type2, match: type2.contentMatch });
  }
  closeFrontierNode() {
    let open = this.frontier.pop();
    let add = open.match.fillBefore(Fragment.empty, true);
    if (add.childCount)
      this.placed = addToFragment(this.placed, this.frontier.length, add);
  }
}
function dropFromFragment(fragment, depth, count) {
  if (depth == 0)
    return fragment.cutByIndex(count, fragment.childCount);
  return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));
}
function addToFragment(fragment, depth, content) {
  if (depth == 0)
    return fragment.append(content);
  return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));
}
function contentAt(fragment, depth) {
  for (let i = 0; i < depth; i++)
    fragment = fragment.firstChild.content;
  return fragment;
}
function closeNodeStart(node2, openStart, openEnd) {
  if (openStart <= 0)
    return node2;
  let frag = node2.content;
  if (openStart > 1)
    frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));
  if (openStart > 0) {
    frag = node2.type.contentMatch.fillBefore(frag).append(frag);
    if (openEnd <= 0)
      frag = frag.append(node2.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));
  }
  return node2.copy(frag);
}
function contentAfterFits($to, depth, type2, match, open) {
  let node2 = $to.node(depth), index2 = open ? $to.indexAfter(depth) : $to.index(depth);
  if (index2 == node2.childCount && !type2.compatibleContent(node2.type))
    return null;
  let fit = match.fillBefore(node2.content, true, index2);
  return fit && !invalidMarks(type2, node2.content, index2) ? fit : null;
}
function invalidMarks(type2, fragment, start2) {
  for (let i = start2; i < fragment.childCount; i++)
    if (!type2.allowsMarks(fragment.child(i).marks))
      return true;
  return false;
}
function definesContent(type2) {
  return type2.spec.defining || type2.spec.definingForContent;
}
function replaceRange(tr, from2, to, slice2) {
  if (!slice2.size)
    return tr.deleteRange(from2, to);
  let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
  if (fitsTrivially($from, $to, slice2))
    return tr.step(new ReplaceStep(from2, to, slice2));
  let targetDepths = coveredDepths($from, tr.doc.resolve(to));
  if (targetDepths[targetDepths.length - 1] == 0)
    targetDepths.pop();
  let preferredTarget = -($from.depth + 1);
  targetDepths.unshift(preferredTarget);
  for (let d2 = $from.depth, pos = $from.pos - 1; d2 > 0; d2--, pos--) {
    let spec = $from.node(d2).type.spec;
    if (spec.defining || spec.definingAsContext || spec.isolating)
      break;
    if (targetDepths.indexOf(d2) > -1)
      preferredTarget = d2;
    else if ($from.before(d2) == pos)
      targetDepths.splice(1, 0, -d2);
  }
  let preferredTargetIndex = targetDepths.indexOf(preferredTarget);
  let leftNodes = [], preferredDepth = slice2.openStart;
  for (let content = slice2.content, i = 0; ; i++) {
    let node2 = content.firstChild;
    leftNodes.push(node2);
    if (i == slice2.openStart)
      break;
    content = node2.content;
  }
  for (let d2 = preferredDepth - 1; d2 >= 0; d2--) {
    let leftNode = leftNodes[d2], def = definesContent(leftNode.type);
    if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))
      preferredDepth = d2;
    else if (def || !leftNode.type.isTextblock)
      break;
  }
  for (let j2 = slice2.openStart; j2 >= 0; j2--) {
    let openDepth = (j2 + preferredDepth + 1) % (slice2.openStart + 1);
    let insert = leftNodes[openDepth];
    if (!insert)
      continue;
    for (let i = 0; i < targetDepths.length; i++) {
      let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;
      if (targetDepth < 0) {
        expand = false;
        targetDepth = -targetDepth;
      }
      let parent = $from.node(targetDepth - 1), index2 = $from.index(targetDepth - 1);
      if (parent.canReplaceWith(index2, index2, insert.type, insert.marks))
        return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice2.content, 0, slice2.openStart, openDepth), openDepth, slice2.openEnd));
    }
  }
  let startSteps = tr.steps.length;
  for (let i = targetDepths.length - 1; i >= 0; i--) {
    tr.replace(from2, to, slice2);
    if (tr.steps.length > startSteps)
      break;
    let depth = targetDepths[i];
    if (depth < 0)
      continue;
    from2 = $from.before(depth);
    to = $to.after(depth);
  }
}
function closeFragment(fragment, depth, oldOpen, newOpen, parent) {
  if (depth < oldOpen) {
    let first2 = fragment.firstChild;
    fragment = fragment.replaceChild(0, first2.copy(closeFragment(first2.content, depth + 1, oldOpen, newOpen, first2)));
  }
  if (depth > newOpen) {
    let match = parent.contentMatchAt(0);
    let start2 = match.fillBefore(fragment).append(fragment);
    fragment = start2.append(match.matchFragment(start2).fillBefore(Fragment.empty, true));
  }
  return fragment;
}
function replaceRangeWith(tr, from2, to, node2) {
  if (!node2.isInline && from2 == to && tr.doc.resolve(from2).parent.content.size) {
    let point = insertPoint(tr.doc, from2, node2.type);
    if (point != null)
      from2 = to = point;
  }
  tr.replaceRange(from2, to, new Slice(Fragment.from(node2), 0, 0));
}
function deleteRange(tr, from2, to) {
  let $from = tr.doc.resolve(from2), $to = tr.doc.resolve(to);
  let covered = coveredDepths($from, $to);
  for (let i = 0; i < covered.length; i++) {
    let depth = covered[i], last = i == covered.length - 1;
    if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd)
      return tr.delete($from.start(depth), $to.end(depth));
    if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))
      return tr.delete($from.before(depth), $to.after(depth));
  }
  for (let d2 = 1; d2 <= $from.depth && d2 <= $to.depth; d2++) {
    if (from2 - $from.start(d2) == $from.depth - d2 && to > $from.end(d2) && $to.end(d2) - to != $to.depth - d2 && $from.start(d2 - 1) == $to.start(d2 - 1) && $from.node(d2 - 1).canReplace($from.index(d2 - 1), $to.index(d2 - 1)))
      return tr.delete($from.before(d2), to);
  }
  tr.delete(from2, to);
}
function coveredDepths($from, $to) {
  let result = [], minDepth = Math.min($from.depth, $to.depth);
  for (let d2 = minDepth; d2 >= 0; d2--) {
    let start2 = $from.start(d2);
    if (start2 < $from.pos - ($from.depth - d2) || $to.end(d2) > $to.pos + ($to.depth - d2) || $from.node(d2).type.spec.isolating || $to.node(d2).type.spec.isolating)
      break;
    if (start2 == $to.start(d2) || d2 == $from.depth && d2 == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d2 && $to.start(d2 - 1) == start2 - 1)
      result.push(d2);
  }
  return result;
}
class AttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(pos, attr, value) {
    super();
    this.pos = pos;
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let node2 = doc2.nodeAt(this.pos);
    if (!node2)
      return StepResult.fail("No node at attribute step's position");
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in node2.attrs)
      attrs[name] = node2.attrs[name];
    attrs[this.attr] = this.value;
    let updated = node2.type.create(attrs, null, node2.marks);
    return StepResult.fromReplace(doc2, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node2.isLeaf ? 0 : 1));
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new AttrStep(this.pos, this.attr, doc2.nodeAt(this.pos).attrs[this.attr]);
  }
  map(mapping) {
    let pos = mapping.mapResult(this.pos, 1);
    return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.pos != "number" || typeof json.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new AttrStep(json.pos, json.attr, json.value);
  }
}
Step.jsonID("attr", AttrStep);
class DocAttrStep extends Step {
  /**
  Construct an attribute step.
  */
  constructor(attr, value) {
    super();
    this.attr = attr;
    this.value = value;
  }
  apply(doc2) {
    let attrs = /* @__PURE__ */ Object.create(null);
    for (let name in doc2.attrs)
      attrs[name] = doc2.attrs[name];
    attrs[this.attr] = this.value;
    let updated = doc2.type.create(attrs, doc2.content, doc2.marks);
    return StepResult.ok(updated);
  }
  getMap() {
    return StepMap.empty;
  }
  invert(doc2) {
    return new DocAttrStep(this.attr, doc2.attrs[this.attr]);
  }
  map(mapping) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(schema, json) {
    if (typeof json.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new DocAttrStep(json.attr, json.value);
  }
}
Step.jsonID("docAttr", DocAttrStep);
let TransformError = class extends Error {
};
TransformError = function TransformError2(message) {
  let err = Error.call(this, message);
  err.__proto__ = TransformError2.prototype;
  return err;
};
TransformError.prototype = Object.create(Error.prototype);
TransformError.prototype.constructor = TransformError;
TransformError.prototype.name = "TransformError";
class Transform {
  /**
  Create a transform that starts with the given document.
  */
  constructor(doc2) {
    this.doc = doc2;
    this.steps = [];
    this.docs = [];
    this.mapping = new Mapping();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(step) {
    let result = this.maybeStep(step);
    if (result.failed)
      throw new TransformError(result.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(step) {
    let result = step.apply(this.doc);
    if (!result.failed)
      this.addStep(step, result.doc);
    return result;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    this.docs.push(this.doc);
    this.steps.push(step);
    this.mapping.appendMap(step.getMap());
    this.doc = doc2;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(from2, to = from2, slice2 = Slice.empty) {
    let step = replaceStep$1(this.doc, from2, to, slice2);
    if (step)
      this.step(step);
    return this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(from2, to, content) {
    return this.replace(from2, to, new Slice(Fragment.from(content), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(from2, to) {
    return this.replace(from2, to, Slice.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(pos, content) {
    return this.replaceWith(pos, pos, content);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(from2, to, slice2) {
    replaceRange(this, from2, to, slice2);
    return this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(from2, to, node2) {
    replaceRangeWith(this, from2, to, node2);
    return this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(from2, to) {
    deleteRange(this, from2, to);
    return this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(range2, target) {
    lift(this, range2, target);
    return this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(pos, depth = 1) {
    join(this, pos, depth);
    return this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(range2, wrappers) {
    wrap(this, range2, wrappers);
    return this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(from2, to = from2, type2, attrs = null) {
    setBlockType$1(this, from2, to, type2, attrs);
    return this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(pos, type2, attrs = null, marks) {
    setNodeMarkup(this, pos, type2, attrs, marks);
    return this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(pos, attr, value) {
    this.step(new AttrStep(pos, attr, value));
    return this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(attr, value) {
    this.step(new DocAttrStep(attr, value));
    return this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(pos, mark) {
    this.step(new AddNodeMarkStep(pos, mark));
    return this;
  }
  /**
  Remove a mark (or all marks of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(pos, mark) {
    let node2 = this.doc.nodeAt(pos);
    if (!node2)
      throw new RangeError("No node at position " + pos);
    if (mark instanceof Mark$1) {
      if (mark.isInSet(node2.marks))
        this.step(new RemoveNodeMarkStep(pos, mark));
    } else {
      let set = node2.marks, found2, steps = [];
      while (found2 = mark.isInSet(set)) {
        steps.push(new RemoveNodeMarkStep(pos, found2));
        set = found2.removeFromSet(set);
      }
      for (let i = steps.length - 1; i >= 0; i--)
        this.step(steps[i]);
    }
    return this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split (with the outermost nodes coming first).
  */
  split(pos, depth = 1, typesAfter) {
    split(this, pos, depth, typesAfter);
    return this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(from2, to, mark) {
    addMark(this, from2, to, mark);
    return this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(from2, to, mark) {
    removeMark(this, from2, to, mark);
    return this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(pos, parentType, match) {
    clearIncompatible(this, pos, parentType, match);
    return this;
  }
}
const classesById = /* @__PURE__ */ Object.create(null);
class Selection {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor($anchor, $head, ranges) {
    this.$anchor = $anchor;
    this.$head = $head;
    this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++)
      if (ranges[i].$from.pos != ranges[i].$to.pos)
        return false;
    return true;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, true);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(tr, content = Slice.empty) {
    let lastNode = content.content.lastChild, lastParent = null;
    for (let i = 0; i < content.openEnd; i++) {
      lastParent = lastNode;
      lastNode = lastNode.lastChild;
    }
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);
      if (i == 0)
        selectionToInsertionEnd$1(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(tr, node2) {
    let mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      let from2 = mapping.map($from.pos), to = mapping.map($to.pos);
      if (i) {
        tr.deleteRange(from2, to);
      } else {
        tr.replaceRangeWith(from2, to, node2);
        selectionToInsertionEnd$1(tr, mapFrom, node2.isInline ? -1 : 1);
      }
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom($pos, dir, textOnly = false) {
    let inner = $pos.parent.inlineContent ? new TextSelection$1($pos) : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);
    if (inner)
      return inner;
    for (let depth = $pos.depth - 1; depth >= 0; depth--) {
      let found2 = dir < 0 ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly) : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);
      if (found2)
        return found2;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near($pos, bias = 1) {
    return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(doc2) {
    return findSelectionIn(doc2, doc2, 0, 0, 1) || new AllSelection(doc2);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(doc2) {
    return findSelectionIn(doc2, doc2, doc2.content.size, doc2.childCount, -1) || new AllSelection(doc2);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(doc2, json) {
    if (!json || !json.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let cls = classesById[json.type];
    if (!cls)
      throw new RangeError(`No selection type ${json.type} defined`);
    return cls.fromJSON(doc2, json);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(id, selectionClass) {
    if (id in classesById)
      throw new RangeError("Duplicate use of selection JSON ID " + id);
    classesById[id] = selectionClass;
    selectionClass.prototype.jsonID = id;
    return selectionClass;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return TextSelection$1.between(this.$anchor, this.$head).getBookmark();
  }
}
Selection.prototype.visible = true;
class SelectionRange {
  /**
  Create a range.
  */
  constructor($from, $to) {
    this.$from = $from;
    this.$to = $to;
  }
}
let warnedAboutTextSelection = false;
function checkTextSelection($pos) {
  if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {
    warnedAboutTextSelection = true;
    console["warn"]("TextSelection endpoint not pointing into a node with inline content (" + $pos.parent.type.name + ")");
  }
}
let TextSelection$1 = class TextSelection2 extends Selection {
  /**
  Construct a text selection between the given points.
  */
  constructor($anchor, $head = $anchor) {
    checkTextSelection($anchor);
    checkTextSelection($head);
    super($anchor, $head);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(doc2, mapping) {
    let $head = doc2.resolve(mapping.map(this.head));
    if (!$head.parent.inlineContent)
      return Selection.near($head);
    let $anchor = doc2.resolve(mapping.map(this.anchor));
    return new TextSelection2($anchor.parent.inlineContent ? $anchor : $head, $head);
  }
  replace(tr, content = Slice.empty) {
    super.replace(tr, content);
    if (content == Slice.empty) {
      let marks = this.$from.marksAcross(this.$to);
      if (marks)
        tr.ensureMarks(marks);
    }
  }
  eq(other) {
    return other instanceof TextSelection2 && other.anchor == this.anchor && other.head == this.head;
  }
  getBookmark() {
    return new TextBookmark(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number" || typeof json.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new TextSelection2(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(doc2, anchor, head = anchor) {
    let $anchor = doc2.resolve(anchor);
    return new this($anchor, head == anchor ? $anchor : doc2.resolve(head));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between($anchor, $head, bias) {
    let dPos = $anchor.pos - $head.pos;
    if (!bias || dPos)
      bias = dPos >= 0 ? 1 : -1;
    if (!$head.parent.inlineContent) {
      let found2 = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);
      if (found2)
        $head = found2.$head;
      else
        return Selection.near($head, bias);
    }
    if (!$anchor.parent.inlineContent) {
      if (dPos == 0) {
        $anchor = $head;
      } else {
        $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;
        if ($anchor.pos < $head.pos != dPos < 0)
          $anchor = $head;
      }
    }
    return new TextSelection2($anchor, $head);
  }
};
Selection.jsonID("text", TextSelection$1);
class TextBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    return TextSelection$1.between(doc2.resolve(this.anchor), doc2.resolve(this.head));
  }
}
class NodeSelection extends Selection {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor($pos) {
    let node2 = $pos.nodeAfter;
    let $end = $pos.node(0).resolve($pos.pos + node2.nodeSize);
    super($pos, $end);
    this.node = node2;
  }
  map(doc2, mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    let $pos = doc2.resolve(pos);
    if (deleted)
      return Selection.near($pos);
    return new NodeSelection($pos);
  }
  content() {
    return new Slice(Fragment.from(this.node), 0, 0);
  }
  eq(other) {
    return other instanceof NodeSelection && other.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new NodeBookmark(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new NodeSelection(doc2.resolve(json.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(doc2, from2) {
    return new NodeSelection(doc2.resolve(from2));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(node2) {
    return !node2.isText && node2.type.spec.selectable !== false;
  }
}
NodeSelection.prototype.visible = false;
Selection.jsonID("node", NodeSelection);
class NodeBookmark {
  constructor(anchor) {
    this.anchor = anchor;
  }
  map(mapping) {
    let { deleted, pos } = mapping.mapResult(this.anchor);
    return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.anchor), node2 = $pos.nodeAfter;
    if (node2 && NodeSelection.isSelectable(node2))
      return new NodeSelection($pos);
    return Selection.near($pos);
  }
}
class AllSelection extends Selection {
  /**
  Create an all-selection over the given document.
  */
  constructor(doc2) {
    super(doc2.resolve(0), doc2.resolve(doc2.content.size));
  }
  replace(tr, content = Slice.empty) {
    if (content == Slice.empty) {
      tr.delete(0, tr.doc.content.size);
      let sel = Selection.atStart(tr.doc);
      if (!sel.eq(tr.selection))
        tr.setSelection(sel);
    } else {
      super.replace(tr, content);
    }
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(doc2) {
    return new AllSelection(doc2);
  }
  map(doc2) {
    return new AllSelection(doc2);
  }
  eq(other) {
    return other instanceof AllSelection;
  }
  getBookmark() {
    return AllBookmark;
  }
}
Selection.jsonID("all", AllSelection);
const AllBookmark = {
  map() {
    return this;
  },
  resolve(doc2) {
    return new AllSelection(doc2);
  }
};
function findSelectionIn(doc2, node2, pos, index2, dir, text = false) {
  if (node2.inlineContent)
    return TextSelection$1.create(doc2, pos);
  for (let i = index2 - (dir > 0 ? 0 : 1); dir > 0 ? i < node2.childCount : i >= 0; i += dir) {
    let child = node2.child(i);
    if (!child.isAtom) {
      let inner = findSelectionIn(doc2, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);
      if (inner)
        return inner;
    } else if (!text && NodeSelection.isSelectable(child)) {
      return NodeSelection.create(doc2, pos - (dir < 0 ? child.nodeSize : 0));
    }
    pos += child.nodeSize * dir;
  }
  return null;
}
function selectionToInsertionEnd$1(tr, startLen, bias) {
  let last = tr.steps.length - 1;
  if (last < startLen)
    return;
  let step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep$1))
    return;
  let map3 = tr.mapping.maps[last], end2;
  map3.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 == null)
      end2 = newTo;
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end2), bias));
}
const UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;
class Transaction extends Transform {
  /**
  @internal
  */
  constructor(state2) {
    super(state2.doc);
    this.curSelectionFor = 0;
    this.updated = 0;
    this.meta = /* @__PURE__ */ Object.create(null);
    this.time = Date.now();
    this.curSelection = state2.selection;
    this.storedMarks = state2.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    if (this.curSelectionFor < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));
      this.curSelectionFor = this.steps.length;
    }
    return this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(selection) {
    if (selection.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    this.curSelection = selection;
    this.curSelectionFor = this.steps.length;
    this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;
    this.storedMarks = null;
    return this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & UPDATED_SEL) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(marks) {
    this.storedMarks = marks;
    this.updated |= UPDATED_MARKS;
    return this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(marks) {
    if (!Mark$1.sameSet(this.storedMarks || this.selection.$from.marks(), marks))
      this.setStoredMarks(marks);
    return this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(mark) {
    return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(mark) {
    return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & UPDATED_MARKS) > 0;
  }
  /**
  @internal
  */
  addStep(step, doc2) {
    super.addStep(step, doc2);
    this.updated = this.updated & ~UPDATED_MARKS;
    this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(time2) {
    this.time = time2;
    return this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(slice2) {
    this.selection.replace(this, slice2);
    return this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(node2, inheritMarks = true) {
    let selection = this.selection;
    if (inheritMarks)
      node2 = node2.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : selection.$from.marksAcross(selection.$to) || Mark$1.none));
    selection.replaceWith(this, node2);
    return this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    this.selection.replace(this);
    return this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(text, from2, to) {
    let schema = this.doc.type.schema;
    if (from2 == null) {
      if (!text)
        return this.deleteSelection();
      return this.replaceSelectionWith(schema.text(text), true);
    } else {
      if (to == null)
        to = from2;
      to = to == null ? from2 : to;
      if (!text)
        return this.deleteRange(from2, to);
      let marks = this.storedMarks;
      if (!marks) {
        let $from = this.doc.resolve(from2);
        marks = to == from2 ? $from.marks() : $from.marksAcross(this.doc.resolve(to));
      }
      this.replaceRangeWith(from2, to, schema.text(text, marks));
      if (!this.selection.empty)
        this.setSelection(Selection.near(this.selection.$to));
      return this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(key, value) {
    this.meta[typeof key == "string" ? key : key.key] = value;
    return this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(key) {
    return this.meta[typeof key == "string" ? key : key.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let _2 in this.meta)
      return false;
    return true;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    this.updated |= UPDATED_SCROLL;
    return this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & UPDATED_SCROLL) > 0;
  }
}
function bind(f, self2) {
  return !self2 || !f ? f : f.bind(self2);
}
class FieldDesc {
  constructor(name, desc, self2) {
    this.name = name;
    this.init = bind(desc.init, self2);
    this.apply = bind(desc.apply, self2);
  }
}
const baseFields = [
  new FieldDesc("doc", {
    init(config) {
      return config.doc || config.schema.topNodeType.createAndFill();
    },
    apply(tr) {
      return tr.doc;
    }
  }),
  new FieldDesc("selection", {
    init(config, instance) {
      return config.selection || Selection.atStart(instance.doc);
    },
    apply(tr) {
      return tr.selection;
    }
  }),
  new FieldDesc("storedMarks", {
    init(config) {
      return config.storedMarks || null;
    },
    apply(tr, _marks, _old, state2) {
      return state2.selection.$cursor ? tr.storedMarks : null;
    }
  }),
  new FieldDesc("scrollToSelection", {
    init() {
      return 0;
    },
    apply(tr, prev) {
      return tr.scrolledIntoView ? prev + 1 : prev;
    }
  })
];
class Configuration {
  constructor(schema, plugins) {
    this.schema = schema;
    this.plugins = [];
    this.pluginsByKey = /* @__PURE__ */ Object.create(null);
    this.fields = baseFields.slice();
    if (plugins)
      plugins.forEach((plugin2) => {
        if (this.pluginsByKey[plugin2.key])
          throw new RangeError("Adding different instances of a keyed plugin (" + plugin2.key + ")");
        this.plugins.push(plugin2);
        this.pluginsByKey[plugin2.key] = plugin2;
        if (plugin2.spec.state)
          this.fields.push(new FieldDesc(plugin2.key, plugin2.spec.state, plugin2));
      });
  }
}
class EditorState {
  /**
  @internal
  */
  constructor(config) {
    this.config = config;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(tr) {
    return this.applyTransaction(tr).state;
  }
  /**
  @internal
  */
  filterTransaction(tr, ignore = -1) {
    for (let i = 0; i < this.config.plugins.length; i++)
      if (i != ignore) {
        let plugin2 = this.config.plugins[i];
        if (plugin2.spec.filterTransaction && !plugin2.spec.filterTransaction.call(plugin2, tr, this))
          return false;
      }
    return true;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(rootTr) {
    if (!this.filterTransaction(rootTr))
      return { state: this, transactions: [] };
    let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;
    for (; ; ) {
      let haveNew = false;
      for (let i = 0; i < this.config.plugins.length; i++) {
        let plugin2 = this.config.plugins[i];
        if (plugin2.spec.appendTransaction) {
          let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;
          let tr = n < trs.length && plugin2.spec.appendTransaction.call(plugin2, n ? trs.slice(n) : trs, oldState, newState);
          if (tr && newState.filterTransaction(tr, i)) {
            tr.setMeta("appendedTransaction", rootTr);
            if (!seen) {
              seen = [];
              for (let j2 = 0; j2 < this.config.plugins.length; j2++)
                seen.push(j2 < i ? { state: newState, n: trs.length } : { state: this, n: 0 });
            }
            trs.push(tr);
            newState = newState.applyInner(tr);
            haveNew = true;
          }
          if (seen)
            seen[i] = { state: newState, n: trs.length };
        }
      }
      if (!haveNew)
        return { state: newState, transactions: trs };
    }
  }
  /**
  @internal
  */
  applyInner(tr) {
    if (!tr.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let newInstance = new EditorState(this.config), fields = this.config.fields;
    for (let i = 0; i < fields.length; i++) {
      let field = fields[i];
      newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);
    }
    return newInstance;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new Transaction(this);
  }
  /**
  Create a new state.
  */
  static create(config) {
    let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);
    let instance = new EditorState($config);
    for (let i = 0; i < $config.fields.length; i++)
      instance[$config.fields[i].name] = $config.fields[i].init(config, instance);
    return instance;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(config) {
    let $config = new Configuration(this.schema, config.plugins);
    let fields = $config.fields, instance = new EditorState($config);
    for (let i = 0; i < fields.length; i++) {
      let name = fields[i].name;
      instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);
    }
    return instance;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(pluginFields) {
    let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks)
      result.storedMarks = this.storedMarks.map((m2) => m2.toJSON());
    if (pluginFields && typeof pluginFields == "object")
      for (let prop in pluginFields) {
        if (prop == "doc" || prop == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let plugin2 = pluginFields[prop], state2 = plugin2.spec.state;
        if (state2 && state2.toJSON)
          result[prop] = state2.toJSON.call(plugin2, this[plugin2.key]);
      }
    return result;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(config, json, pluginFields) {
    if (!json)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!config.schema)
      throw new RangeError("Required config field 'schema' missing");
    let $config = new Configuration(config.schema, config.plugins);
    let instance = new EditorState($config);
    $config.fields.forEach((field) => {
      if (field.name == "doc") {
        instance.doc = Node$1$1.fromJSON(config.schema, json.doc);
      } else if (field.name == "selection") {
        instance.selection = Selection.fromJSON(instance.doc, json.selection);
      } else if (field.name == "storedMarks") {
        if (json.storedMarks)
          instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);
      } else {
        if (pluginFields)
          for (let prop in pluginFields) {
            let plugin2 = pluginFields[prop], state2 = plugin2.spec.state;
            if (plugin2.key == field.name && state2 && state2.fromJSON && Object.prototype.hasOwnProperty.call(json, prop)) {
              instance[field.name] = state2.fromJSON.call(plugin2, config, json[prop], instance);
              return;
            }
          }
        instance[field.name] = field.init(config, instance);
      }
    });
    return instance;
  }
}
function bindProps(obj, self2, target) {
  for (let prop in obj) {
    let val = obj[prop];
    if (val instanceof Function)
      val = val.bind(self2);
    else if (prop == "handleDOMEvents")
      val = bindProps(val, self2, {});
    target[prop] = val;
  }
  return target;
}
class Plugin {
  /**
  Create a plugin.
  */
  constructor(spec) {
    this.spec = spec;
    this.props = {};
    if (spec.props)
      bindProps(spec.props, this, this.props);
    this.key = spec.key ? spec.key.key : createKey$1("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(state2) {
    return state2[this.key];
  }
}
const keys$2 = /* @__PURE__ */ Object.create(null);
function createKey$1(name) {
  if (name in keys$2)
    return name + "$" + ++keys$2[name];
  keys$2[name] = 0;
  return name + "$";
}
class PluginKey {
  /**
  Create a plugin key.
  */
  constructor(name = "key") {
    this.key = createKey$1(name);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(state2) {
    return state2.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(state2) {
    return state2[this.key];
  }
}
function callOrGet(value, context = null, ...props) {
  if (typeof value === "function") {
    if (context) return value.bind(context)(...props);
    return value(...props);
  }
  return value;
}
function isEmptyObject(value = {}) {
  return Object.keys(value).length === 0 && value.constructor === Object;
}
const isMacOS = () => {
  return typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
};
const isIOS = () => {
  return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    navigator.platform
  );
};
const isRegExp = (value) => {
  return Object.prototype.toString.call(value) === "[object RegExp]";
};
function objectIncludes(obj1, obj2, options = { strict: true }) {
  const keys2 = Object.keys(obj2);
  if (!keys2.length) return true;
  return keys2.every((key) => {
    if (options.strict) return obj2[key] === obj1[key];
    if (isRegExp(obj2[key])) return obj2[key].test(obj1[key]);
    return obj2[key] === obj1[key];
  });
}
function deleteProps(obj, propOrProps) {
  const isString = typeof propOrProps === "string";
  const props = isString ? [propOrProps] : propOrProps;
  return Object.keys(obj).reduce((newObj, prop) => {
    const contains2 = props.includes(prop);
    if (!contains2) newObj[prop] = obj[prop];
    return newObj;
  }, {});
}
const CSS_DIMENSION_REGEX = /[\d-.]+(\w+)$/;
const DOM_SIZE_UNITS = ["px", "rem", "em", "in", "q", "mm", "cm", "pt", "pc", "vh", "vw", "vmin", "vmax"];
function parseSizeUnit(val = "0") {
  const length2 = val.toString() || "0";
  const value = Number.parseFloat(length2);
  const match = length2.match(CSS_DIMENSION_REGEX);
  const unit = (match?.[1] ?? "").toLowerCase();
  return [value, DOM_SIZE_UNITS.includes(unit) ? unit : null];
}
function minMax(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
async function readFromClipboard(state2) {
  let html = "";
  let text = "";
  if (navigator.clipboard && navigator.clipboard.read) {
    try {
      const items = await navigator.clipboard.read();
      for (const item of items) {
        if (item.types.includes("text/html")) {
          html = await (await item.getType("text/html")).text();
          break;
        } else if (item.types.includes("text/plain")) {
          text = await (await item.getType("text/plain")).text();
        }
      }
    } catch {
      text = await navigator.clipboard.readText();
    }
  } else {
    text = await navigator.clipboard.readText();
  }
  let content = null;
  if (html) {
    try {
      content = DOMParser$1.fromSchema(state2.schema).parseSlice(
        new window.DOMParser().parseFromString(`<body>${html}</body>`, "text/html").body
      ).content;
    } catch (e) {
      console.error("error parsing html", e);
      content = state2.schema.text(text);
    }
  }
  if (!content && text) {
    content = state2.schema.text(text);
  }
  return content;
}
function inchesToTwips(inches) {
  if (inches == null) return;
  if (typeof inches === "string") inches = parseFloat(inches);
  return Math.round(inches * 1440);
}
function twipsToInches(twips) {
  if (twips == null) return;
  if (typeof twips === "string") twips = parseInt(twips, 10);
  return Math.round(twips / 1440 * 100) / 100;
}
function twipsToPixels(twips) {
  if (twips == null) return;
  twips = twipsToInches(twips);
  return Math.round(twips * 96);
}
function pixelsToTwips(pixels) {
  if (pixels == null) return;
  pixels = pixels / 96;
  return inchesToTwips(pixels);
}
function twipsToLines(twips) {
  if (twips == null) return;
  return twips / 240;
}
function linesToTwips(lines) {
  if (lines == null) return;
  return lines * 240;
}
function halfPointToPoints(halfPoints) {
  if (halfPoints == null) return;
  return Math.round(halfPoints / 2);
}
function emuToPixels(emu) {
  if (emu == null) return;
  if (typeof emu === "string") emu = parseFloat(emu);
  const pixels = emu * 96 / 914400;
  return Math.round(pixels);
}
function pixelsToEmu(px) {
  if (px == null) return;
  if (typeof px === "string") px = parseFloat(px);
  return Math.round(px * 9525);
}
function eigthPointsToPixels(eigthPoints) {
  if (eigthPoints == null) return;
  const points = parseFloat(eigthPoints) / 8;
  const pixels = points * 1.3333;
  return pixels;
}
function pixelsToEightPoints(pixels) {
  if (pixels == null) return;
  return Math.round(pixels * 6);
}
function twipsToPt(twips) {
  if (twips == null) return;
  return twips / 20;
}
function ptToTwips(pt) {
  if (pt == null) return;
  return pt * 20;
}
const getTextIndentExportValue = (indent) => {
  const [value, unit] = parseSizeUnit(indent);
  const functionsMap = {
    pt: ptToTwips,
    in: inchesToTwips
  };
  const exportValue = functionsMap[unit] ? functionsMap[unit](value) : pixelsToTwips(value);
  return exportValue;
};
const getArrayBufferFromUrl = async (input, isHeadless) => {
  const isLikelyUrl = /^https?:|^blob:|^file:|^data:/i.test(input);
  if (isHeadless && isLikelyUrl && typeof fetch === "function") {
    const res = await fetch(input);
    if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);
    return await res.arrayBuffer();
  }
  const base64 = input.includes(",") ? input.split(",", 2)[1] : input.trim().replace(/\s/g, "");
  try {
    if (typeof globalThis.atob === "function") {
      const binary = globalThis.atob(base64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    }
  } catch (err) {
    console.warn("atob failed, falling back to Buffer:", err);
  }
  const buf = Buffer2.from(base64, "base64");
  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
};
const getContentTypesFromXml = (contentTypesXml) => {
  const parser = new window.DOMParser();
  const xmlDoc = parser.parseFromString(contentTypesXml, "text/xml");
  const defaults = xmlDoc.querySelectorAll("Default");
  return Array.from(defaults).map((item) => item.getAttribute("Extension"));
};
const getHexColorFromDocxSystem = (docxColor) => {
  const colorMap = /* @__PURE__ */ new Map([
    ["yellow", "#ffff00"],
    ["green", "#00ff00"],
    ["blue", "#0000FFFF"],
    ["cyan", "#00ffff"],
    ["magenta", "#ff00ff"],
    ["red", "#ff0000"],
    ["darkYellow", "#808000FF"],
    ["darkGreen", "#008000FF"],
    ["darkBlue", "#000080"],
    ["darkCyan", "#008080FF"],
    ["darkMagenta", "#800080FF"],
    ["darkGray", "#808080FF"],
    ["darkRed", "#800000FF"],
    ["lightGray", "#C0C0C0FF"],
    ["black", "#000"]
  ]);
  return colorMap.get(docxColor) || null;
};
function isValidHexColor(color) {
  if (!color || typeof color !== "string") return false;
  switch (color.length) {
    case 3:
      return /^[0-9A-F]{3}$/i.test(color);
    case 6:
      return /^[0-9A-F]{6}$/i.test(color);
    case 8:
      return /^[0-9A-F]{8}$/i.test(color);
    default:
      return false;
  }
}
const componentToHex = (val) => {
  const a = Number(val).toString(16);
  return a.length === 1 ? "0" + a : a;
};
const rgbToHex = (rgb) => {
  return "#" + rgb.match(/\d+/g).map(componentToHex).join("");
};
const getLineHeightValueString = (lineHeight2, defaultUnit, lineRule = "", isObject2 = false) => {
  let [value, unit] = parseSizeUnit(lineHeight2);
  if (Number.isNaN(value) || value === 0) return {};
  if (lineRule === "atLeast" && value < 1) return {};
  unit = unit ? unit : defaultUnit;
  return isObject2 ? { ["line-height"]: `${value}${unit}` } : `line-height: ${value}${unit}`;
};
const deobfuscateFont = (arrayBuffer, guidHex) => {
  const dta = new Uint8Array(arrayBuffer);
  const guidStr = guidHex.replace(/[-{}]/g, "");
  if (guidStr.length !== 32) {
    console.error("Invalid GUID");
    return;
  }
  const guidBytes = new Uint8Array(16);
  for (let i = 0, j2 = 0; i < 32; i += 2, j2++) {
    const hexByte = guidStr[i] + guidStr[i + 1];
    guidBytes[j2] = parseInt(hexByte, 16);
  }
  for (let i = 0; i < 32; i++) {
    const gi = 15 - i % 16;
    dta[i] ^= guidBytes[gi];
  }
  return dta.buffer;
};
const hasSomeParentWithClass = (element, classname) => {
  if (element.className?.split(" ")?.indexOf(classname) >= 0) return true;
  return element.parentNode && hasSomeParentWithClass(element.parentNode, classname);
};
function generateDocxRandomId(length2 = 8) {
  const characters = "0123456789abcdef";
  let id = [];
  for (let i = 0; i < length2; i++) {
    const randomIndex = Math.floor(Math.random() * characters.length);
    id.push(characters[randomIndex]);
  }
  return id.join("");
}
function generateRandom32BitHex() {
  const val = Math.floor(Math.random() * 2147483647);
  return val.toString(16).toUpperCase().padStart(8, "0");
}
const DEFAULT_DOCX_DEFS = {
  "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
  "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
  "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
  "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
  "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
  "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
  "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
  "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
  "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
  "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
  "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
  "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
  "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
  "xmlns:o": "urn:schemas-microsoft-com:office:office",
  "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
  "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
  "xmlns:v": "urn:schemas-microsoft-com:vml",
  "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
  "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
  "xmlns:w10": "urn:schemas-microsoft-com:office:word",
  "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
  "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
  "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
  "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
  "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
  "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
  "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
  "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
  "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
  "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
  "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
  "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
  "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
  "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
  "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
};
const DEFAULT_CUSTOM_XML = {
  elements: [
    {
      type: "element",
      name: "Properties",
      attributes: {
        xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
        "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
      },
      elements: []
    }
  ]
};
const SETTINGS_CUSTOM_XML = {
  elements: [
    {
      type: "element",
      name: "w:settings",
      attributes: {
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
      },
      elements: []
    }
  ]
};
const COMMENT_REF = {
  type: "element",
  name: "w:r",
  elements: [
    {
      type: "element",
      name: "w:rPr",
      elements: [
        {
          type: "element",
          name: "w:rStyle",
          attributes: {
            "w:val": "CommentReference"
          }
        }
      ]
    },
    {
      type: "element",
      name: "w:annotationRef"
    }
  ]
};
const DEFAULT_LINKED_STYLES = {
  Normal: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:default": "1",
      "w:styleId": "Normal"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      }
    ]
  },
  Title: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Title"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "Title"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "TitleChar"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "10"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00B72667"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:contextualSpacing"
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "majorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "majorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:val": "-10"
            }
          },
          {
            type: "element",
            name: "w:kern",
            attributes: {
              "w:val": "28"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "56"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "56"
            }
          }
        ]
      }
    ]
  },
  Subtitle: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Subtitle"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "Subtitle"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "SubtitleChar"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "11"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00B72667"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:numPr",
            elements: [
              {
                type: "element",
                name: "w:ilvl",
                attributes: {
                  "w:val": "1"
                }
              }
            ]
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:after": "160"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "minorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "minorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "595959",
              "w:themeColor": "text1",
              "w:themeTint": "A6"
            }
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:val": "15"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "28"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "28"
            }
          }
        ]
      }
    ]
  },
  Heading1: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Heading1"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "heading 1"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "Heading1Char"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "9"
        }
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00233D7B"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:keepNext"
          },
          {
            type: "element",
            name: "w:keepLines"
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:before": "360",
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:outlineLvl",
            attributes: {
              "w:val": "0"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "majorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "majorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "0F4761",
              "w:themeColor": "accent1",
              "w:themeShade": "BF"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "40"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "40"
            }
          }
        ]
      }
    ]
  },
  Heading2: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Heading2"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "heading 2"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "Heading2Char"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "9"
        }
      },
      {
        type: "element",
        name: "w:semiHidden"
      },
      {
        type: "element",
        name: "w:unhideWhenUsed"
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00233D7B"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:keepNext"
          },
          {
            type: "element",
            name: "w:keepLines"
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:before": "160",
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:outlineLvl",
            attributes: {
              "w:val": "1"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:asciiTheme": "majorHAnsi",
              "w:eastAsiaTheme": "majorEastAsia",
              "w:hAnsiTheme": "majorHAnsi",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "0F4761",
              "w:themeColor": "accent1",
              "w:themeShade": "BF"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "32"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "32"
            }
          }
        ]
      }
    ]
  },
  Heading3: {
    type: "element",
    name: "w:style",
    attributes: {
      "w:type": "paragraph",
      "w:styleId": "Heading3"
    },
    elements: [
      {
        type: "element",
        name: "w:name",
        attributes: {
          "w:val": "heading 3"
        }
      },
      {
        type: "element",
        name: "w:basedOn",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:next",
        attributes: {
          "w:val": "Normal"
        }
      },
      {
        type: "element",
        name: "w:link",
        attributes: {
          "w:val": "Heading3Char"
        }
      },
      {
        type: "element",
        name: "w:uiPriority",
        attributes: {
          "w:val": "9"
        }
      },
      {
        type: "element",
        name: "w:semiHidden"
      },
      {
        type: "element",
        name: "w:unhideWhenUsed"
      },
      {
        type: "element",
        name: "w:qFormat"
      },
      {
        type: "element",
        name: "w:rsid",
        attributes: {
          "w:val": "00233D7B"
        }
      },
      {
        type: "element",
        name: "w:pPr",
        elements: [
          {
            type: "element",
            name: "w:keepNext"
          },
          {
            type: "element",
            name: "w:keepLines"
          },
          {
            type: "element",
            name: "w:spacing",
            attributes: {
              "w:before": "160",
              "w:after": "80"
            }
          },
          {
            type: "element",
            name: "w:outlineLvl",
            attributes: {
              "w:val": "2"
            }
          }
        ]
      },
      {
        type: "element",
        name: "w:rPr",
        elements: [
          {
            type: "element",
            name: "w:rFonts",
            attributes: {
              "w:eastAsiaTheme": "majorEastAsia",
              "w:cstheme": "majorBidi"
            }
          },
          {
            type: "element",
            name: "w:color",
            attributes: {
              "w:val": "0F4761",
              "w:themeColor": "accent1",
              "w:themeShade": "BF"
            }
          },
          {
            type: "element",
            name: "w:sz",
            attributes: {
              "w:val": "28"
            }
          },
          {
            type: "element",
            name: "w:szCs",
            attributes: {
              "w:val": "28"
            }
          }
        ]
      }
    ]
  }
};
const COMMENTS_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w:comments",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
      },
      elements: []
    }
  ]
};
const COMMENTS_EXTENDED_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w15:commentsEx",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
      },
      elements: []
    }
  ]
};
const COMMENTS_EXTENSIBLE_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w16cex:commentsExtensible",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:cr": "http://schemas.microsoft.com/office/comments/2020/reactions",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl cr w16du wp14"
      },
      elements: []
    }
  ]
};
const COMMENTS_IDS_XML_DEF = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w16cid:commentsIds",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16sdtfl": "http://schemas.microsoft.com/office/word/2024/wordml/sdtformatlock",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16sdtfl w16du wp14"
      },
      elements: []
    }
  ]
};
const DOCUMENT_RELS_XML_DEF = {
  elements: [
    {
      type: "element",
      name: "Relationships",
      attributes: {
        xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
      },
      elements: [
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId8",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/fontTable",
            Target: "fontTable.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId3",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/webSettings",
            Target: "webSettings.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId7",
            Type: "http://schemas.microsoft.com/office/2018/08/relationships/commentsExtensible",
            Target: "commentsExtensible.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId2",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/settings",
            Target: "settings.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId1",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
            Target: "styles.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId6",
            Type: "http://schemas.microsoft.com/office/2016/09/relationships/commentsIds",
            Target: "commentsIds.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId5",
            Type: "http://schemas.microsoft.com/office/2011/relationships/commentsExtended",
            Target: "commentsExtended.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId10",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
            Target: "theme/theme1.xml"
          }
        },
        {
          type: "element",
          name: "Relationship",
          attributes: {
            Id: "rId4",
            Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
            Target: "comments.xml"
          }
        }
        // {
        //     "type": "element",
        //     "name": "Relationship",
        //     "attributes": {
        //         "Id": "rId9",
        //         "Type": "http://schemas.microsoft.com/office/2011/relationships/people",
        //         "Target": "people.xml"
        //     }
        // }
      ]
    }
  ]
};
const CONTENT_TYPES = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "Types",
      attributes: {
        xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
      },
      elements: [
        {
          type: "element",
          name: "Default",
          attributes: {
            Extension: "rels",
            ContentType: "application/vnd.openxmlformats-package.relationships+xml"
          }
        },
        {
          type: "element",
          name: "Default",
          attributes: {
            Extension: "xml",
            ContentType: "application/xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/document.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/styles.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/settings.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/webSettings.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.webSettings+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/comments.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/commentsExtended.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtended+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/commentsIds.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsIds+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/commentsExtensible.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtensible+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/fontTable.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.fontTable+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/people.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.people+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/theme/theme1.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.theme+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/docProps/core.xml",
            ContentType: "application/vnd.openxmlformats-package.core-properties+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/docProps/app.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml"
          }
        },
        {
          type: "element",
          name: "Override",
          attributes: {
            PartName: "/word/numbering.xml",
            ContentType: "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml"
          }
        }
      ]
    }
  ]
};
const COMMENTS_XML_DEFINITIONS = {
  COMMENTS_XML_DEF,
  COMMENTS_EXTENDED_XML_DEF,
  COMMENTS_EXTENSIBLE_XML_DEF,
  COMMENTS_IDS_XML_DEF,
  DOCUMENT_RELS_XML_DEF,
  CONTENT_TYPES
};
const TrackInsertMarkName = "trackInsert";
const TrackDeleteMarkName = "trackDelete";
const TrackFormatMarkName = "trackFormat";
const carbonCopy = (obj) => {
  if (!obj) return void 0;
  try {
    return JSON.parse(JSON.stringify(obj));
  } catch (e) {
    console.error("Error in carbonCopy", obj, e);
    return void 0;
  }
};
function translateCommentNode(params2, type2) {
  const { node: node2, commentsExportType, exportedCommentDefs = [] } = params2;
  if (!exportedCommentDefs.length || commentsExportType === "clean") return;
  const nodeId = node2.attrs["w:id"];
  const originalComment = params2.comments.find((comment) => {
    return comment.commentId == nodeId;
  });
  if (!originalComment) return;
  const commentIndex = params2.comments?.findIndex((comment) => comment.commentId === originalComment.commentId);
  const parentId = originalComment.parentCommentId;
  let parentComment;
  if (parentId) {
    parentComment = params2.comments.find((c2) => c2.commentId === parentId || c2.importedId === parentId);
  }
  const isInternal = parentComment?.isInternal || originalComment.isInternal;
  if (commentsExportType === "external" && isInternal) return;
  const isResolved = !!originalComment.resolvedTime;
  if (isResolved) return;
  let commentSchema = getCommentSchema(type2, commentIndex);
  if (type2 === "End") {
    const commentReference = {
      name: "w:r",
      elements: [{ name: "w:commentReference", attributes: { "w:id": String(commentIndex) } }]
    };
    commentSchema = [commentSchema, commentReference];
  }
  return commentSchema;
}
const getCommentSchema = (type2, commentId) => {
  return {
    name: `w:commentRange${type2}`,
    attributes: {
      "w:id": String(commentId)
    }
  };
};
const prepareCommentParaIds = (comment) => {
  const newComment = {
    ...comment,
    commentParaId: generateRandom32BitHex()
  };
  return newComment;
};
const getCommentDefinition = (comment, commentId, allComments, editor) => {
  const translatedText = translateParagraphNode({ editor, node: comment.commentJSON });
  const attributes = {
    "w:id": String(commentId),
    "w:author": comment.creatorName || comment.importedAuthor?.name,
    "w:email": comment.creatorEmail || comment.importedAuthor?.email,
    "w:date": toIsoNoFractional(comment.createdTime),
    "w:initials": getInitials(comment.creatorName),
    "w:done": comment.resolvedTime ? "1" : "0",
    "w15:paraId": comment.commentParaId,
    "custom:internalId": comment.commentId || comment.internalId,
    "custom:trackedChange": comment.trackedChange,
    "custom:trackedChangeText": comment.trackedChangeText || null,
    "custom:trackedChangeType": comment.trackedChangeType,
    "custom:trackedDeletedText": comment.deletedText || null
  };
  if (comment?.parentCommentId) {
    const parentComment = allComments.find((c2) => c2.commentId === comment.parentCommentId);
    attributes["w15:paraIdParent"] = parentComment.commentParaId;
  }
  return {
    type: "element",
    name: "w:comment",
    attributes,
    elements: [translatedText]
  };
};
const getInitials = (name) => {
  if (!name) return null;
  const preparedText = name.replace("(imported)", "").trim();
  const initials = preparedText.split(" ").map((word) => word[0]).join("");
  return initials;
};
const toIsoNoFractional = (unixMillis) => {
  const date = new Date(unixMillis || Date.now());
  return date.toISOString().replace(/\.\d{3}Z$/, "Z");
};
const updateCommentsXml = (commentDefs = [], commentsXml) => {
  const newCommentsXml = carbonCopy(commentsXml);
  commentDefs.forEach((commentDef) => {
    const elements = commentDef.elements[0].elements;
    elements.unshift(COMMENT_REF);
    const paraId = commentDef.attributes["w15:paraId"];
    commentDef.elements[0].attributes["w14:paraId"] = paraId;
    commentDef.attributes = {
      "w:id": commentDef.attributes["w:id"],
      "w:author": commentDef.attributes["w:author"],
      "w:email": commentDef.attributes["w:email"],
      "w:date": commentDef.attributes["w:date"],
      "w:initials": commentDef.attributes["w:initials"],
      "custom:internalId": commentDef.attributes["custom:internalId"],
      "custom:trackedChange": commentDef.attributes["custom:trackedChange"],
      "custom:trackedChangeText": commentDef.attributes["custom:trackedChangeText"],
      "custom:trackedChangeType": commentDef.attributes["custom:trackedChangeType"],
      "custom:trackedDeletedText": commentDef.attributes["custom:trackedDeletedText"],
      "xmlns:custom": "http://schemas.openxmlformats.org/wordprocessingml/2006/main"
    };
  });
  newCommentsXml.elements[0].elements = commentDefs;
  return newCommentsXml;
};
const updateCommentsExtendedXml = (comments = [], commentsExtendedXml) => {
  const xmlCopy = carbonCopy(commentsExtendedXml);
  const commentsEx = comments.map((comment) => {
    const attributes = {
      "w15:paraId": comment.commentParaId,
      "w15:done": comment.resolvedTime ? "1" : "0"
    };
    const parentId = comment.parentCommentId;
    if (parentId) {
      const parentComment = comments.find((c2) => c2.commentId === parentId);
      attributes["w15:paraIdParent"] = parentComment.commentParaId;
    }
    return {
      type: "element",
      name: "w15:commentEx",
      attributes
    };
  });
  xmlCopy.elements[0].elements = commentsEx;
  return xmlCopy;
};
const updateCommentsIdsAndExtensible = (comments = [], commentsIds, extensible) => {
  const documentIdsUpdated = carbonCopy(commentsIds);
  const extensibleUpdated = carbonCopy(extensible);
  documentIdsUpdated.elements[0].elements = [];
  extensibleUpdated.elements[0].elements = [];
  comments.forEach((comment) => {
    const newDurableId = generateRandom32BitHex();
    const newCommentIdDef = {
      type: "element",
      name: "w16cid:commentId",
      attributes: {
        "w16cid:paraId": comment.commentParaId,
        "w16cid:durableId": newDurableId
      }
    };
    documentIdsUpdated.elements[0].elements.push(newCommentIdDef);
    const newExtensible = {
      type: "element",
      name: "w16cex:commentExtensible",
      attributes: {
        "w16cex:durableId": newDurableId,
        "w16cex:dateUtc": toIsoNoFractional()
      }
    };
    extensibleUpdated.elements[0].elements.push(newExtensible);
  });
  return {
    documentIdsUpdated,
    extensibleUpdated
  };
};
const generateConvertedXmlWithCommentFiles = (convertedXml) => {
  const newXml = carbonCopy(convertedXml);
  newXml["word/comments.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_XML_DEF;
  newXml["word/commentsExtended.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_EXTENDED_XML_DEF;
  newXml["word/commentsExtensible.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_EXTENSIBLE_XML_DEF;
  newXml["word/commentsIds.xml"] = COMMENTS_XML_DEFINITIONS.COMMENTS_IDS_XML_DEF;
  newXml["[Content_Types].xml"] = COMMENTS_XML_DEFINITIONS.CONTENT_TYPES;
  return newXml;
};
const removeCommentsFilesFromConvertedXml = (convertedXml) => {
  const updatedXml = carbonCopy(convertedXml);
  delete updatedXml["word/comments.xml"];
  delete updatedXml["word/commentsExtended.xml"];
  delete updatedXml["word/commentsExtensible.xml"];
  delete updatedXml["word/commentsIds.xml"];
  return updatedXml;
};
const generateRelationship = (target) => {
  const relsDefault = COMMENTS_XML_DEFINITIONS.DOCUMENT_RELS_XML_DEF.elements[0].elements;
  const rel = relsDefault.find((rel2) => rel2.attributes.Target === target);
  return { ...rel };
};
const prepareCommentsXmlFilesForExport = ({ convertedXml, defs, commentsWithParaIds, exportType }) => {
  const relationships = [];
  if (exportType === "clean") {
    const documentXml = removeCommentsFilesFromConvertedXml(convertedXml);
    return { documentXml, relationships };
  }
  const updatedXml = generateConvertedXmlWithCommentFiles(convertedXml);
  updatedXml["word/comments.xml"] = updateCommentsXml(defs, updatedXml["word/comments.xml"]);
  relationships.push(generateRelationship("comments.xml"));
  updatedXml["word/commentsExtended.xml"] = updateCommentsExtendedXml(
    commentsWithParaIds,
    updatedXml["word/commentsExtended.xml"]
  );
  relationships.push(generateRelationship("commentsExtended.xml"));
  const { documentIdsUpdated, extensibleUpdated } = updateCommentsIdsAndExtensible(
    commentsWithParaIds,
    updatedXml["word/commentsIds.xml"],
    updatedXml["word/commentsExtensible.xml"]
  );
  updatedXml["word/commentsIds.xml"] = documentIdsUpdated;
  updatedXml["word/commentsExtensible.xml"] = extensibleUpdated;
  relationships.push(generateRelationship("commentsIds.xml"));
  relationships.push(generateRelationship("commentsExtensible.xml"));
  return {
    relationships,
    documentXml: updatedXml
  };
};
const getColStyleDeclaration = (minWidth, width) => {
  if (width) {
    return ["width", `${Math.max(width, minWidth)}px`];
  }
  return ["min-width", `${minWidth}px`];
};
const createColGroup = (node2, cellMinWidth, overrideCol, overrideValue) => {
  let totalWidth = 0;
  let fixedWidth = true;
  const cols = [];
  const colsValues = [];
  const row = node2.firstChild;
  if (!row) return {};
  for (let i = 0, col = 0; i < row.childCount; i++) {
    const { colspan, colwidth } = row.child(i).attrs;
    for (let j2 = 0; j2 < colspan; j2++, col++) {
      const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j2];
      totalWidth += hasWidth || cellMinWidth;
      if (!hasWidth) fixedWidth = false;
      const [prop, value] = getColStyleDeclaration(cellMinWidth, hasWidth);
      cols.push(["col", { style: `${prop}: ${value}` }]);
      colsValues.push(parseInt(value, 10));
    }
  }
  const tableWidth = fixedWidth ? `${totalWidth}px` : "";
  const tableMinWidth = fixedWidth ? "" : `${totalWidth}px`;
  const colgroup = ["colgroup", {}, ...cols];
  const colgroupValues = [...colsValues];
  return {
    colgroup,
    tableWidth,
    tableMinWidth,
    colgroupValues
  };
};
function chainableEditorState(transaction, state2) {
  let { selection, doc: doc2, storedMarks } = transaction;
  return {
    ...state2,
    apply: state2.apply.bind(state2),
    applyTransaction: state2.applyTransaction.bind(state2),
    plugins: state2.plugins,
    schema: state2.schema,
    reconfigure: state2.reconfigure.bind(state2),
    toJSON: state2.toJSON.bind(state2),
    get storedMarks() {
      return storedMarks;
    },
    get selection() {
      return selection;
    },
    get doc() {
      return doc2;
    },
    get tr() {
      selection = transaction.selection;
      doc2 = transaction.doc;
      storedMarks = transaction.storedMarks;
      return transaction;
    }
  };
}
class CommandService {
  /**
   * @param {import('./commands/types/index.js').CommandServiceOptions} props
   */
  constructor(props) {
    __publicField$2(this, "editor");
    __publicField$2(this, "rawCommands");
    this.editor = props.editor;
    this.rawCommands = this.editor.extensionService.commands;
  }
  /**
   * Static method for creating a service.
   * @param {import('./commands/types/index.js').CommandServiceOptions} params for the constructor.
   * @returns {CommandService} New instance of CommandService
   */
  static create(params2) {
    return new CommandService(params2);
  }
  /**
   * Get editor state.
   * @returns {import("prosemirror-state").EditorState} Editor state
   */
  get state() {
    return this.editor.state;
  }
  /**
   * Get all editor commands
   * @returns {import('./commands/types/index.js').EditorCommands} Commands object
   */
  get commands() {
    const { editor, state: state2 } = this;
    const { view } = editor;
    const { tr } = state2;
    const props = this.createProps(tr);
    const entries = Object.entries(this.rawCommands).map(([name, command2]) => {
      const method = (...args) => {
        const fn2 = command2(...args)(props);
        if (!tr.getMeta("preventDispatch")) {
          view.dispatch(tr);
        }
        return fn2;
      };
      return [name, method];
    });
    return (
      /** @type {import('./commands/types/index.js').EditorCommands} */
      Object.fromEntries(entries)
    );
  }
  /**
   * Create a chain of commands to call multiple commands at once.
   * @returns {(startTr?: Transaction, shouldDispatch?: boolean) => ChainableCommandObject} Function that creates a command chain
   */
  get chain() {
    return () => this.createChain();
  }
  /**
   * Check if a command or a chain of commands can be executed. Without executing it.
   * @returns {() => import('./commands/types/index.js').CanObject} Function that creates a can object
   */
  get can() {
    return () => this.createCan();
  }
  /**
   * Creates a chain of commands.
   * @param {import("prosemirror-state").Transaction} [startTr] - Start transaction.
   * @param {boolean} [shouldDispatch=true] - Whether to dispatch the transaction.
   * @returns {import('./commands/types/index.js').ChainableCommandObject} The command chain.
   */
  createChain(startTr, shouldDispatch = true) {
    const { editor, state: state2, rawCommands } = this;
    const { view } = editor;
    const callbacks2 = [];
    const hasStartTr = !!startTr;
    const tr = startTr || state2.tr;
    const run2 = () => {
      if (!hasStartTr && shouldDispatch && !tr.getMeta("preventDispatch")) {
        view.dispatch(tr);
      }
      return callbacks2.every((cb) => cb === true);
    };
    const entries = Object.entries(rawCommands).map(([name, command2]) => {
      const chainedCommand = (...args) => {
        const props = this.createProps(tr, shouldDispatch);
        const callback = command2(...args)(props);
        callbacks2.push(callback);
        return chain;
      };
      return [name, chainedCommand];
    });
    const chain = {
      ...Object.fromEntries(entries),
      run: run2
    };
    return chain;
  }
  /**
   * Creates a can check for commands.
   * @param {import("prosemirror-state").Transaction} [startTr] - Start transaction.
   * @returns {import('./commands/types/index.js').CanObject} The can object.
   */
  createCan(startTr) {
    const { rawCommands, state: state2 } = this;
    const dispatch = false;
    const tr = startTr || state2.tr;
    const props = this.createProps(tr, dispatch);
    const commands2 = Object.fromEntries(
      Object.entries(rawCommands).map(([name, command2]) => {
        return [name, (...args) => command2(...args)({ ...props, dispatch: void 0 })];
      })
    );
    const result = {
      ...commands2,
      chain: () => this.createChain(tr, dispatch)
    };
    return (
      /** @type {import('./commands/types/index.js').CanObject} */
      result
    );
  }
  /**
   * Creates default props for the command method.
   * @param {import("prosemirror-state").Transaction} tr Transaction.
   * @param {boolean} shouldDispatch Check if should dispatch.
   * @returns {Object} Props object.
   */
  createProps(tr, shouldDispatch = true) {
    const { editor, state: state2, rawCommands } = this;
    const { view } = editor;
    const props = {
      tr,
      editor,
      view,
      state: chainableEditorState(tr, state2),
      dispatch: shouldDispatch ? () => void 0 : void 0,
      chain: () => this.createChain(tr, shouldDispatch),
      can: () => this.createCan(tr),
      get commands() {
        return Object.fromEntries(
          Object.entries(rawCommands).map(([name, command2]) => {
            return [name, (...args) => command2(...args)(props)];
          })
        );
      }
    };
    return props;
  }
}
function getHTMLFromFragment(fragment, schema) {
  const documentFragment = DOMSerializer.fromSchema(schema).serializeFragment(fragment);
  const temporaryDocument = document.implementation.createHTMLDocument();
  const container = temporaryDocument.createElement("div");
  container.appendChild(documentFragment);
  return container.innerHTML;
}
const getTextContentFromNodes = ($from, maxMatch = 500) => {
  let textBefore = "";
  const sliceEndPos = $from.parentOffset;
  $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node2, pos, parent, index2) => {
    const chunk = node2.type.spec.toText?.({
      node: node2,
      pos,
      parent,
      index: index2
    }) || node2.textContent || "%leaf%";
    textBefore += node2.isAtom && !node2.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));
  });
  return textBefore;
};
const handleListNode = (params2) => {
  const { nodes, docx } = params2;
  if (nodes.length === 0 || nodes[0].name !== "w:p" || nodes[0].isList) {
    return { nodes: [], consumed: 0 };
  }
  const node2 = carbonCopy(nodes[0]);
  const isList2 = testForList(node2, docx);
  if (isList2) {
    node2.isList = true;
    const result = handleListNodes(params2, node2);
    return {
      nodes: [result],
      consumed: 1
    };
  } else {
    return { nodes: [], consumed: 0 };
  }
};
const listHandlerEntity = {
  handlerName: "listHandler",
  handler: handleListNode
};
function handleListNodes(params2, node2) {
  const { docx, nodeListHandler: nodeListHandler2, lists } = params2;
  const initialpPr = node2.elements.find((el) => el.name === "w:pPr");
  const styleTag = initialpPr?.elements?.find((el) => el.name === "w:pStyle");
  const styleId = styleTag?.attributes["w:val"];
  const { numPr: numPrTag, type: numPrType } = getNumPrRecursive({ node: node2, styleId, docx });
  const currentListNumId = getNumIdFromTag(numPrTag);
  const iLvlTag = numPrTag?.elements?.find((el) => el.name === "w:ilvl");
  let iLvl = Number(iLvlTag?.attributes["w:val"]);
  if (!iLvl && iLvl !== 0) iLvl = getOutlineLevelFromStyleTag(styleId, docx);
  let numberingDefinition = getNodeNumberingDefinition(node2, iLvl, docx);
  if (!Object.keys(numberingDefinition).length) {
    const { definition, ilvl } = getNodeNumberingDefinitionByStyle(node2, docx);
    if (definition) numberingDefinition = definition;
    if (Number.isNaN(iLvl)) iLvl = ilvl;
  }
  const { listType, listOrderingType, listpPrs, start: start2, lvlText, customFormat } = numberingDefinition;
  if (!listType) {
    const pPrIndex = node2.elements.findIndex((el) => el.name === "w:pPr");
    const pPr = node2.elements[pPrIndex];
    const numPrIndex2 = pPr?.elements?.findIndex((el) => el.name === "w:numPr");
    if (numPrIndex2 >= 0) {
      pPr?.elements?.splice(numPrIndex2, 1);
      node2.elements[pPrIndex] = pPr;
    }
    const styleIdIndex = pPr?.elements?.findIndex((el) => el.name === "w:pStyle");
    if (styleIdIndex >= 0) pPr?.elements?.splice(styleIdIndex, 1);
    const fallBack = nodeListHandler2.handler({ ...params2, nodes: [node2] })?.filter((n) => n);
    return fallBack[0];
  }
  if (!lists[currentListNumId]) lists[currentListNumId] = { levels: {} };
  const currentListByNumId = lists[currentListNumId];
  if (!currentListByNumId.levels[iLvl]) currentListByNumId.levels[iLvl] = Number(start2) || 1;
  else currentListByNumId.levels[iLvl]++;
  Object.keys(currentListByNumId.levels).forEach((key) => {
    const level = Number(key);
    if (level > iLvl) {
      delete currentListByNumId.levels[level];
    }
  });
  const path = generateListPath$1(iLvl, currentListNumId, styleId, currentListByNumId.levels, docx);
  if (!path.length) path.push(currentListByNumId.levels[iLvl]);
  const attrs = {};
  attrs.lvlText = lvlText;
  attrs.listLevel = path;
  attrs.listNumberingType = listOrderingType;
  attrs.numId = currentListNumId;
  attrs.level = iLvl;
  attrs.numPrType = numPrType;
  attrs.styleId = styleId;
  attrs.customFormat = customFormat;
  node2.isList = true;
  const nodePpr = node2.attrs?.paragraphProperties?.elements?.find((el) => el.name === "w:pPr");
  const numPrIndex = node2.attrs?.paragraphProperties?.elements?.findIndex((el) => el.name === "w:numPr");
  nodePpr?.elements?.splice(numPrIndex, 1);
  const listContents = nodeListHandler2.handler({ ...params2, nodes: [node2] });
  const innerParagraph = listContents.find((el) => el.type === "paragraph");
  const firstElement = innerParagraph.content[0];
  firstElement?.marks?.find((mark) => mark.type === "textStyle");
  attrs.indent = listpPrs?.indent;
  const processedContents = listContents.map((el, index2) => {
    const { attrs: elementAttrs } = el;
    const { indent, textIndent, paragraphProperties, ...rest } = elementAttrs;
    if (index2 === 0 && !attrs.indent) attrs.indent = indent;
    return {
      ...el,
      attrs: rest
    };
  });
  const listItem = {
    type: "listItem",
    content: processedContents || [],
    attrs
  };
  const resultingList = {
    type: listType,
    content: [listItem],
    attrs: {
      "list-style-type": listOrderingType,
      listId: currentListNumId
    }
  };
  return resultingList;
}
const getOutlineLevelFromStyleTag = (styleTag, docx) => {
  const matchedStyle = getStyleTagFromStyleId(styleTag, docx);
  const pPr = matchedStyle?.elements?.find((style2) => style2.name === "w:pPr");
  const outlineLevel = pPr?.elements?.find((style2) => style2.name === "w:outlineLvl");
  try {
    return parseInt(outlineLevel?.attributes["w:val"]);
  } catch {
  }
};
function testForList(node2, docx) {
  const { elements } = node2;
  const pPr = elements?.find((el) => el.name === "w:pPr");
  if (!pPr) return false;
  const paragraphStyle = pPr.elements?.find((el) => el.name === "w:pStyle");
  let numPr = pPr.elements?.find((el) => el.name === "w:numPr");
  let numId = getNumIdFromTag(numPr);
  const ilvlTag = numPr?.elements?.find((el) => el.name === "w:ilvl");
  let ilvl = ilvlTag?.attributes["w:val"];
  let outlinelvl;
  const styleId = paragraphStyle?.attributes["w:val"];
  const styleTag = getStyleTagFromStyleId(styleId, docx);
  if (styleTag && !numId) {
    const { numPr: numPrRecursve } = getNumPrRecursive({ node: node2, styleId, docx });
    numPr = numPrRecursve;
    numId = getNumIdFromTag(numPr);
    const stylePpr = styleTag?.elements?.find((el) => el.name === "w:pPr");
    ilvl = stylePpr?.elements?.find((el) => el.name === "w:ilvl")?.attributes["w:val"];
    outlinelvl = stylePpr?.elements?.find((el) => el.name === "w:outlineLvl")?.attributes["w:val"];
    ilvl = outlinelvl || ilvl;
  }
  const abstractNumDefinition = getAbstractDefinition(numId, docx);
  const levelDefinition = abstractNumDefinition?.elements?.find(
    (el) => el.name === "w:lvl" && el.attributes?.["w:ilvl"] == ilvl
  );
  if (numId && !levelDefinition && abstractNumDefinition) {
    return true;
  }
  if (!levelDefinition) return false;
  return !!numId;
}
const getNumIdFromTag = (tag) => {
  return tag?.elements?.find((el) => el.name === "w:numId")?.attributes["w:val"];
};
function getStyleTagFromStyleId(styleId, docx) {
  const styles = docx["word/styles.xml"];
  if (!styles) return {};
  const styleEls = styles.elements;
  const wStyles = styleEls.find((el) => el.name === "w:styles");
  const styleTags = wStyles.elements.filter((style2) => style2.name === "w:style");
  const styleDef = styleTags.find((tag) => tag.attributes["w:styleId"] === styleId);
  return styleDef;
}
function getNumPrRecursive({ node: node2, styleId, docx, seenStyleIds = /* @__PURE__ */ new Set() }) {
  const initialPpr = node2?.elements?.find((el) => el.name === "w:pPr");
  const initialNumPr = initialPpr?.elements?.find((el) => el.name === "w:numPr");
  let numPr = initialNumPr;
  let numId = getNumIdFromTag(numPr);
  if (numId) return { numPr, type: "inline" };
  const matchedStyle = getStyleTagFromStyleId(styleId, docx);
  const pPr = matchedStyle?.elements?.find((style2) => style2.name === "w:pPr");
  numPr = pPr?.elements?.find((style2) => style2.name === "w:numPr");
  numId = getNumIdFromTag(numPr);
  const basedOn = matchedStyle?.elements?.find((style2) => style2.name === "w:basedOn");
  if (!numId && !seenStyleIds.has(styleId)) {
    const basedOnStyleId = basedOn?.attributes["w:val"];
    seenStyleIds.add(styleId);
    if (!basedOnStyleId) return {};
    return getNumPrRecursive({ styleId: basedOnStyleId, docx, seenStyleIds });
  }
  return { numPr, type: "numbering" };
}
const orderedListTypes = [
  "decimal",
  // eg: 1, 2, 3, 4, 5, ...
  "decimalZero",
  // eg: 01, 02, 03, 04, 05, ...
  "lowerRoman",
  // eg: i, ii, iii, iv, v, ...
  "upperRoman",
  // eg: I, II, III, IV, V, ...
  "lowerLetter",
  // eg: a, b, c, d, e, ...
  "upperLetter",
  // eg: A, B, C, D, E, ...
  "ordinal",
  // eg: 1st, 2nd, 3rd, 4th, 5th, ...
  "cardinalText",
  // eg: one, two, three, four, five, ...
  "ordinalText",
  // eg: first, second, third, fourth, fifth, ...
  "hex",
  // eg: 0, 1, 2, ..., 9, A, B, C, ..., F, 10, 11, ...
  "chicago",
  // eg: (0, 1, 2, ..., 9, 10, 11, 12, ..., 19, 1A, 1B, 1C, ..., 1Z, 20, 21, ..., 2Z)
  "none"
  // No bullet
];
const unorderedListTypes = [
  "bullet",
  // A standard bullet point (•)
  "square",
  // Square bullets (▪)
  "circle",
  // Circle bullets (◦)
  "disc"
  // Disc bullets (●)
];
const getListNumIdFromStyleRef = (styleId, docx) => {
  const styles = docx["word/styles.xml"];
  if (!styles) return null;
  const { elements } = styles;
  const styleTags = elements[0].elements.filter((style22) => style22.name === "w:style");
  const style2 = styleTags.find((tag) => tag.attributes["w:styleId"] === styleId) || {};
  const pPr = style2?.elements?.find((style22) => style22.name === "w:pPr");
  if (!pPr) return null;
  let numPr = pPr?.elements?.find((style22) => style22.name === "w:numPr");
  if (!numPr) return null;
  let numIdTag = numPr?.elements?.find((style22) => style22.name === "w:numId") || {};
  let numId = getNumIdFromTag(numPr);
  let ilvlTag = numPr?.elements?.find((style22) => style22.name === "w:ilvl");
  let ilvl = ilvlTag?.attributes?.["w:val"];
  const basedOnTag = style2?.elements?.find((style22) => style22.name === "w:basedOn");
  const basedOnId = basedOnTag?.attributes?.["w:val"];
  let loopCount = 0;
  while (numPr && !numId && loopCount < 10) {
    const basedOnStyle = styleTags.find((tag) => tag.attributes["w:styleId"] === basedOnId) || {};
    const basedOnPPr = basedOnStyle?.elements?.find((style22) => style22.name === "w:pPr");
    numPr = basedOnPPr?.elements?.find((style22) => style22.name === "w:numPr");
    numIdTag = numPr?.elements?.find((style22) => style22.name === "w:numId") || {};
    numId = numIdTag?.attributes?.["w:val"];
    if (!ilvlTag) {
      ilvlTag = numPr?.elements?.find((style22) => style22.name === "w:ilvl");
      ilvl = ilvlTag?.attributes?.["w:val"];
    }
    loopCount++;
  }
  return { numId, ilvl };
};
const getAbstractDefinition = (numId, docx) => {
  const def = docx["word/numbering.xml"];
  if (!def) return {};
  const { elements } = def;
  const listData = elements[0];
  const numberingElements = listData.elements;
  const abstractDefinitions = numberingElements?.filter((style2) => style2.name === "w:abstractNum");
  const numDefinitions = numberingElements?.filter((style2) => style2.name === "w:num");
  const numDefinition = numDefinitions?.find((style2) => style2.attributes["w:numId"] == numId);
  const abstractNumId = numDefinition?.elements[0].attributes["w:val"];
  let listDefinitionForThisNumId = abstractDefinitions?.find(
    (style2) => style2.attributes["w:abstractNumId"] === abstractNumId
  );
  const templateIdTag = listDefinitionForThisNumId?.elements?.find((el) => el.name === "w:tmpl");
  const templateId = templateIdTag?.attributes?.["w:val"];
  if (templateId) {
    listDefinitionForThisNumId = numberingElements?.find((el) => {
      if (el.name !== "w:abstractNum") return false;
      const tmpl = el.elements?.find((el2) => el2.name === "w:tmpl");
      if (!tmpl) return false;
      const hasLevels = el.elements?.some((el2) => el2.name === "w:lvl");
      const tmplId = tmpl.attributes?.["w:val"];
      return tmplId && hasLevels && tmplId === templateId;
    });
  }
  return listDefinitionForThisNumId;
};
const generateListPath$1 = (level, numId, styleId, levels, docx) => {
  const iLvl = Number(level);
  const path = [];
  if (iLvl > 0) {
    for (let i = iLvl; i >= 0; i--) {
      const { start: lvlStart } = getListLevelDefinitionTag(numId, i, styleId, docx);
      if (!levels[i]) levels[i] = Number(lvlStart) || 1;
      path.unshift(levels[i]);
    }
  }
  return path;
};
const getListLevelDefinitionTag = (numId, level, pStyleId, docx) => {
  if (pStyleId) {
    const { numId: numIdFromStyles, ilvl: iLvlFromStyles } = getListNumIdFromStyleRef(pStyleId, docx) || {};
    if (!numId && numIdFromStyles) numId = numIdFromStyles;
    if (!level && iLvlFromStyles) level = iLvlFromStyles ? parseInt(iLvlFromStyles) : null;
  }
  const listDefinitionForThisNumId = getAbstractDefinition(numId, docx);
  const currentLevel = getDefinitionForLevel(listDefinitionForThisNumId, level);
  const numStyleLink = listDefinitionForThisNumId?.elements?.find((style2) => style2.name === "w:numStyleLink");
  const numStyleLinkId = numStyleLink?.attributes["w:val"];
  if (numStyleLinkId) {
    const current = getListNumIdFromStyleRef(numStyleLinkId, docx);
    return getListLevelDefinitionTag(current.numId, level, null, docx);
  }
  const start2 = currentLevel?.elements?.find((style2) => style2.name === "w:start")?.attributes["w:val"];
  let numFmtTag = currentLevel?.elements?.find((style2) => style2.name === "w:numFmt");
  let numFmt = numFmtTag?.attributes["w:val"];
  if (!numFmt) {
    const altChoice = currentLevel?.elements.find((style2) => style2.name === "mc:AlternateContent");
    const choice = altChoice?.elements.find((style2) => style2.name === "mc:Choice");
    const choiceNumFmtTag = choice?.elements.find((style2) => style2.name === "w:numFmt");
    const choiceNumFmt = choiceNumFmtTag?.attributes["w:val"];
    if (choiceNumFmt) {
      numFmtTag = choiceNumFmtTag;
      numFmt = choiceNumFmt;
    }
  }
  let lvlText = currentLevel?.elements?.find((style2) => style2.name === "w:lvlText").attributes["w:val"];
  lvlText = normalizeLvlTextChar(lvlText);
  let customFormat;
  if (numFmt === "custom") customFormat = numFmtTag?.attributes?.["w:format"];
  const lvlJc = currentLevel?.elements?.find((style2) => style2.name === "w:lvlJc").attributes["w:val"];
  const pPr = currentLevel?.elements?.find((style2) => style2.name === "w:pPr");
  const rPr = currentLevel?.elements?.find((style2) => style2.name === "w:rPr");
  return { start: start2, numFmt, lvlText, lvlJc, pPr, rPr, customFormat };
};
function normalizeLvlTextChar(lvlText) {
  const normalizeChars = ["", "", "○", "o", "■", "□"];
  if (!lvlText || !normalizeChars.includes(lvlText)) return lvlText;
  if (lvlText === "") lvlText = "•";
  if (lvlText === "○" || lvlText === "o") lvlText = "◦";
  if (lvlText === "■" || lvlText === "") lvlText = "▪";
  if (lvlText === "□") lvlText = "◯";
  return lvlText;
}
function getNodeNumberingDefinition(item, level, docx) {
  if (!item) return {};
  const { attributes = {} } = item;
  const { paragraphProperties = {} } = attributes;
  const { elements: listStyles = [] } = paragraphProperties;
  const initialPpr = item.elements.find((el) => el.name === "w:pPr");
  const styleTag = initialPpr?.elements?.find((el) => el.name === "w:pStyle");
  const styleId = styleTag?.attributes["w:val"];
  const { numPr: numPrTag } = getNumPrRecursive({ node: item, styleId, docx });
  if (!numPrTag) return {};
  const numIdTag = numPrTag?.elements.find((style2) => style2.name === "w:numId");
  const numId = numIdTag?.attributes["w:val"];
  const pStyle = listStyles.find((style2) => style2.name === "w:pStyle");
  const pStyleId = pStyle?.attributes["w:val"];
  const {
    start: start2,
    numFmt: listTypeDef,
    lvlText,
    lvlJc,
    pPr,
    rPr,
    customFormat
  } = getListLevelDefinitionTag(numId, level, pStyleId, docx);
  let listpPrs, listrPrs;
  if (pPr) listpPrs = _processListParagraphProperties(pPr, initialPpr);
  if (rPr) listrPrs = _processListRunProperties(rPr);
  let listType;
  if (unorderedListTypes.includes(listTypeDef?.toLowerCase())) listType = "bulletList";
  else if (orderedListTypes.includes(listTypeDef)) listType = "orderedList";
  else if (listTypeDef === "custom") {
    listType = "orderedList";
  } else {
    return {};
  }
  return { listType, listOrderingType: listTypeDef, listrPrs, listpPrs, start: start2, lvlText, lvlJc, customFormat };
}
function getNodeNumberingDefinitionByStyle(item, docx) {
  if (!item) return {};
  const initialPpr = item.elements?.find((el) => el.name === "w:pPr");
  const styleTag = initialPpr?.elements?.find((el) => el.name === "w:pStyle");
  const styleId = styleTag?.attributes["w:val"];
  const styleDef = getStyleTagFromStyleId(styleId, docx);
  if (!styleDef) return {};
  const pPr = styleDef.elements?.find((el) => el.name === "w:pPr");
  const numPr = pPr?.elements?.find((el) => el.name === "w:numPr");
  const numIdTag = numPr?.elements?.find((el) => el.name === "w:numId");
  const numId = numIdTag?.attributes?.["w:val"];
  if (!numId) return {};
  const abstractNumId = getAbstractNumIdByNumId(numId, docx);
  if (!abstractNumId) return {};
  const levelData = getLevelDataFromAbstractNum(abstractNumId, styleId, docx);
  if (!levelData) return {};
  const definition = extractDefinitionFromLevel(levelData.level, initialPpr);
  return {
    definition,
    ilvl: levelData.ilvl
  };
}
function getAbstractNumIdByNumId(numId, docx) {
  const numbering = docx["word/numbering.xml"];
  if (!numbering) return null;
  const { elements } = numbering;
  const listData = elements[0];
  const numberingElements = listData.elements || [];
  const numDef = numberingElements.find((el) => el.name === "w:num" && el.attributes?.["w:numId"] === numId);
  if (!numDef) return null;
  const abstractNumIdRef = numDef.elements?.find((el) => el.name === "w:abstractNumId");
  return abstractNumIdRef?.attributes?.["w:val"];
}
function getLevelDataFromAbstractNum(abstractNumId, styleId, docx) {
  const numbering = docx["word/numbering.xml"];
  if (!numbering) return null;
  const { elements } = numbering;
  const listData = elements[0];
  const numberingElements = listData.elements || [];
  const abstractNum = numberingElements.find(
    (el) => el.name === "w:abstractNum" && el.attributes?.["w:abstractNumId"] === abstractNumId
  );
  if (!abstractNum) return null;
  const levels = abstractNum.elements?.filter((el) => el.name === "w:lvl") || [];
  for (const level of levels) {
    const pStyle = level.elements?.find((el) => el.name === "w:pStyle");
    if (pStyle?.attributes?.["w:val"] === styleId) {
      const found2 = {
        level,
        ilvl: Number(level.attributes?.["w:ilvl"]) || 0
      };
      return found2;
    }
  }
  const level0 = levels.find((level) => level.attributes?.["w:ilvl"] === "0");
  if (level0) {
    return {
      level: level0,
      ilvl: 0
    };
  }
  return null;
}
function extractDefinitionFromLevel(level, initialPpr) {
  if (!level) return {};
  const start2 = level.elements?.find((el) => el.name === "w:start")?.attributes?.["w:val"];
  let numFmtTag = level.elements?.find((el) => el.name === "w:numFmt");
  let numFmt = numFmtTag?.attributes?.["w:val"];
  let lvlText = level.elements?.find((el) => el.name === "w:lvlText")?.attributes?.["w:val"];
  lvlText = normalizeLvlTextChar(lvlText);
  let customFormat;
  if (numFmt === "custom") customFormat = numFmtTag?.attributes?.["w:format"];
  const lvlJc = level.elements?.find((el) => el.name === "w:lvlJc")?.attributes?.["w:val"];
  const pPr = level.elements?.find((el) => el.name === "w:pPr");
  const rPr = level.elements?.find((el) => el.name === "w:rPr");
  let listpPrs, listrPrs;
  if (pPr) listpPrs = _processListParagraphProperties(pPr, initialPpr);
  if (rPr) listrPrs = _processListRunProperties(rPr);
  let listType;
  if (unorderedListTypes.includes(numFmt?.toLowerCase())) {
    listType = "bulletList";
  } else if (orderedListTypes.includes(numFmt)) {
    listType = "orderedList";
  } else if (numFmt === "custom") {
    listType = "orderedList";
  } else {
    return {};
  }
  return {
    listType,
    listOrderingType: numFmt,
    listrPrs,
    listpPrs,
    start: start2,
    lvlText,
    lvlJc,
    customFormat
  };
}
function getDefinitionForLevel(data, level) {
  return data?.elements?.find((item) => Number(item.attributes["w:ilvl"]) === level);
}
function parseIndentElement(indElem) {
  if (!indElem || !indElem.attributes) return {};
  const out = {};
  if (indElem.attributes["w:left"] != null) out.left = twipsToPixels(indElem.attributes["w:left"]);
  if (indElem.attributes["w:right"] != null) out.right = twipsToPixels(indElem.attributes["w:right"]);
  if (indElem.attributes["w:firstLine"] != null) out.firstLine = twipsToPixels(indElem.attributes["w:firstLine"]);
  if (indElem.attributes["w:hanging"] != null) out.hanging = twipsToPixels(indElem.attributes["w:hanging"]);
  if (indElem.attributes["w:leftChars"] != null) out.leftChars = twipsToPixels(indElem.attributes["w:leftChars"]);
  return out;
}
function combineIndents(ind1, ind2) {
  ind1 = ind1 && typeof ind1 === "object" ? ind1 : {};
  ind2 = ind2 && typeof ind2 === "object" ? ind2 : {};
  const indent = {};
  ["left", "right", "firstLine", "hanging"].forEach((prop) => {
    const v1 = ind1[prop] !== void 0 ? Number(ind1[prop]) : null;
    const v2 = ind2[prop] !== void 0 ? Number(ind2[prop]) : null;
    if (v1 != null && v2 != null) {
      indent[prop] = prop === "left" || prop === "hanging" ? Math.max(v1, v2) : v1;
    } else if (v1 != null) {
      indent[prop] = v1;
    } else if (v2 != null) {
      indent[prop] = v2;
    }
  });
  return indent;
}
function _processListParagraphProperties(data, inlinePpr) {
  const { elements } = data;
  const expectedTypes = ["w:ind", "w:jc", "w:tabs"];
  const paragraphProperties = {};
  if (!elements) return paragraphProperties;
  elements.forEach((item) => {
    if (!expectedTypes.includes(item.name)) {
      console.warn(`[numbering.xml] Unexpected list paragraph prop found: ${item.name}`);
    }
  });
  const inlineIndent = inlinePpr?.elements?.find((item) => item.name === "w:ind");
  const parsedInlineIndent = parseIndentElement(inlineIndent);
  const styleIndent = elements.find((item) => item.name === "w:ind");
  parseIndentElement(styleIndent);
  paragraphProperties.indent = parsedInlineIndent;
  const justify = elements.find((item) => item.name === "w:jc");
  if (justify) {
    const justifyAttrs = {};
    if (!justify.attributes) justify.attributes = {};
    if (justify.attributes["w:val"] !== void 0) justifyAttrs.val = justify.attributes["w:val"];
    paragraphProperties.justify = justifyAttrs;
  }
  const tabs = elements.find((item) => item.name === "w:tabs");
  if (tabs) {
    const tabElements = tabs.elements.filter((item) => item.name === "w:tab");
    const tabStops = [];
    tabElements.forEach((tab) => {
      const tabStop = {};
      if (!tab.attributes) tab.attributes = {};
      if (tab.attributes["w:val"] !== void 0) tabStop.val = tab.attributes["w:val"];
      if (tab.attributes["w:leader"] !== void 0) tabStop.leader = tab.attributes["w:leader"];
      if (tab.attributes["w:pos"] !== void 0) tabStop.pos = twipsToPixels(tab.attributes["w:pos"]);
      tabStops.push(tabStop);
    });
    paragraphProperties.tabStops = tabStops;
  }
  return paragraphProperties;
}
function _processListRunProperties(data) {
  const { elements } = data;
  const expectedTypes = [
    "w:rFonts",
    "w:b",
    "w:bCs",
    "w:i",
    "w:iCs",
    "w:strike",
    "w:dstrike",
    "w:color",
    "w:sz",
    "w:szCs",
    "w:u",
    "w:bdr",
    "w:shd",
    "w:vertAlign",
    "w:jc",
    "w:spacing",
    "w:w",
    "w:smallCaps",
    "w:position",
    "w:lang"
  ];
  const runProperties = {};
  if (!elements) return runProperties;
  elements.forEach((item) => {
    if (!expectedTypes.includes(item.name)) ;
    const { attributes = {} } = item;
    Object.keys(attributes).forEach((key) => {
      runProperties[key] = attributes[key];
    });
  });
  return runProperties;
}
const docxNumberigHelpers = {
  getListLevelDefinitionTag,
  combineIndents,
  parseIndentElement,
  generateListPath: generateListPath$1,
  normalizeLvlTextChar
};
const baseOrderedListDef = {
  type: "element",
  name: "w:abstractNum",
  attributes: {
    "w:abstractNumId": "1",
    "w15:restartNumberingAfterBreak": "0"
  },
  elements: [
    {
      type: "element",
      name: "w:multiLevelType",
      attributes: {
        "w:val": "hybridMultilevel"
      }
    },
    {
      type: "element",
      name: "w:tmpl",
      attributes: {
        "w:val": "EE6417C4"
      }
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "0",
        "w:tplc": "0409000F"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "decimal"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%1."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "720",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "1",
        "w:tplc": "04090019",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerLetter"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%2."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "1440",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "2",
        "w:tplc": "0409001B",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerRoman"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%3."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "right"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2160",
                "w:hanging": "180"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "3",
        "w:tplc": "0409000F",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "decimal"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%4."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2880",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "4",
        "w:tplc": "04090019",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerLetter"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%5."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "3600",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "5",
        "w:tplc": "0409001B",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerRoman"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%6."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "right"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "4320",
                "w:hanging": "180"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "6",
        "w:tplc": "0409000F",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "decimal"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%7."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5040",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "7",
        "w:tplc": "04090019",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerLetter"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%8."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5760",
                "w:hanging": "360"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "8",
        "w:tplc": "0409001B",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "lowerRoman"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "%9."
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "right"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "6480",
                "w:hanging": "180"
              }
            }
          ]
        }
      ]
    }
  ]
};
const baseBulletList = {
  type: "element",
  name: "w:abstractNum",
  attributes: {
    "w:abstractNumId": "0",
    "w15:restartNumberingAfterBreak": "0"
  },
  elements: [
    {
      type: "element",
      name: "w:nsid",
      attributes: {
        "w:val": "16126B07"
      }
    },
    {
      type: "element",
      name: "w:multiLevelType",
      attributes: {
        "w:val": "hybridMultilevel"
      }
    },
    {
      type: "element",
      name: "w:tmpl",
      attributes: {
        "w:val": "51EC4E08"
      }
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "0",
        "w:tplc": "04090001"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "•"
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "720",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Symbol",
                "w:hAnsi": "Symbol",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "1",
        "w:tplc": "04090003",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "◦"
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "1440",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Courier New",
                "w:hAnsi": "Courier New",
                "w:cs": "Courier New",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "2",
        "w:tplc": "04090005",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "▪"
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2160",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Wingdings",
                "w:hAnsi": "Wingdings",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "3",
        "w:tplc": "04090001",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "•"
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "2880",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Symbol",
                "w:hAnsi": "Symbol",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "4",
        "w:tplc": "04090003",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "◦"
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "3600",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Courier New",
                "w:hAnsi": "Courier New",
                "w:cs": "Courier New",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "5",
        "w:tplc": "04090005",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "▪"
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "4320",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Wingdings",
                "w:hAnsi": "Wingdings",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "6",
        "w:tplc": "04090001",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5040",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Symbol",
                "w:hAnsi": "Symbol",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "7",
        "w:tplc": "04090003",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": "o"
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "5760",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Courier New",
                "w:hAnsi": "Courier New",
                "w:cs": "Courier New",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    },
    {
      type: "element",
      name: "w:lvl",
      attributes: {
        "w:ilvl": "8",
        "w:tplc": "04090005",
        "w:tentative": "1"
      },
      elements: [
        {
          type: "element",
          name: "w:start",
          attributes: {
            "w:val": "1"
          }
        },
        {
          type: "element",
          name: "w:numFmt",
          attributes: {
            "w:val": "bullet"
          }
        },
        {
          type: "element",
          name: "w:lvlText",
          attributes: {
            "w:val": ""
          }
        },
        {
          type: "element",
          name: "w:lvlJc",
          attributes: {
            "w:val": "left"
          }
        },
        {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:ind",
              attributes: {
                "w:left": "6480",
                "w:hanging": "360"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:rPr",
          elements: [
            {
              type: "element",
              name: "w:rFonts",
              attributes: {
                "w:ascii": "Wingdings",
                "w:hAnsi": "Wingdings",
                "w:hint": "default"
              }
            }
          ]
        }
      ]
    }
  ]
};
function createDocument(converter, schema, editor, { check = false } = {}) {
  const documentData = converter.getSchema(editor);
  if (documentData) {
    const documentNode = schema.nodeFromJSON(documentData);
    if (check) {
      documentNode.check();
    }
    return documentNode;
  }
  return schema.topNodeType.createAndFill();
}
function getExtensionConfigField(extension, field, context = {}) {
  if (typeof extension.config[field] === "function") {
    const value = extension.config[field].bind({ ...context });
    return value;
  }
  return extension.config[field];
}
function getSchemaTypeByName(name, schema) {
  return schema.nodes[name] || schema.marks[name] || null;
}
function cleanSchemaItem(schemaItem) {
  const entries = Object.entries(schemaItem).filter(([key, value]) => {
    if (key === "attrs" && isEmptyObject(value)) {
      return false;
    }
    return value !== null && value !== void 0;
  });
  return Object.fromEntries(entries);
}
function getNodeType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.nodes[nameOrType]) {
      throw Error(`There is no node type named '${nameOrType}' in schema.`);
    }
    return schema.nodes[nameOrType];
  }
  return nameOrType;
}
function getMarkType(nameOrType, schema) {
  if (typeof nameOrType === "string") {
    if (!schema.marks[nameOrType]) {
      throw Error(`There is no mark type named '${nameOrType}' in schema.`);
    }
    return schema.marks[nameOrType];
  }
  return nameOrType;
}
function defaultBlockAt$1(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    const { type: type2 } = match.edge(i);
    if (type2.isTextblock && !type2.hasRequiredAttrs()) return type2;
  }
  return null;
}
const findParentNodeClosestToPos = ($pos, predicate) => {
  for (let i = $pos.depth; i > 0; i--) {
    const node2 = $pos.node(i);
    if (predicate(node2)) {
      return {
        pos: i > 0 ? $pos.before(i) : 0,
        start: $pos.start(i),
        depth: i,
        node: node2
      };
    }
  }
};
const findParentNode = (predicate) => {
  return ({ $from }) => findParentNodeClosestToPos($from, predicate);
};
const isList$1 = (name, extensions) => {
  const nodeExtensions = extensions.filter((e) => e.type === "node");
  const extension = nodeExtensions.find((i) => i.name === name);
  if (!extension) return false;
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage
  };
  const group = callOrGet(getExtensionConfigField(extension, "group", context));
  if (typeof group !== "string") return false;
  return group.split(" ").includes("list");
};
function generateDocxListAttributes(listType) {
  const listTypesMap = {
    bulletList: 1,
    orderedList: 2
  };
  return {
    attributes: {
      parentAttributes: {
        "w14:paraId": generateDocxRandomId(),
        "w14:textId": generateDocxRandomId(),
        "w:rsidR": generateDocxRandomId(),
        "w:rsidRDefault": generateDocxRandomId(),
        "w:rsidP": generateDocxRandomId(),
        paragraphProperties: {
          type: "element",
          name: "w:pPr",
          elements: [
            {
              type: "element",
              name: "w:pStyle",
              attributes: {
                "w:val": "ListParagraph"
              }
            },
            {
              type: "element",
              name: "w:numPr",
              elements: [
                {
                  type: "element",
                  name: "w:ilvl",
                  attributes: {
                    "w:val": "0"
                  }
                },
                {
                  type: "element",
                  name: "w:numId",
                  attributes: {
                    "w:val": listTypesMap[listType] || 0
                  }
                }
              ]
            }
          ]
        }
      }
    }
  };
}
const isTextSelection = (value) => {
};
function findMarkInSet(marks, type2, attrs = {}) {
  return marks.find((item) => {
    return item.type === type2 && objectIncludes(item.attrs, attrs);
  });
}
function isMarkInSet(marks, type2, attrs = {}) {
  return !!findMarkInSet(marks, type2, attrs);
}
function getMarkRange($pos, type2, attrs = {}) {
  if (!$pos || !type2) return;
  let start2 = $pos.parent.childAfter($pos.parentOffset);
  if ($pos.parentOffset === start2.offset && start2.offset !== 0) {
    start2 = $pos.parent.childBefore($pos.parentOffset);
  }
  if (!start2.node) return;
  const mark = findMarkInSet([...start2.node.marks], type2, attrs);
  if (!mark) return;
  let startIndex = start2.index;
  let startPos = $pos.start() + start2.offset;
  let endIndex = startIndex + 1;
  let endPos = startPos + start2.node.nodeSize;
  findMarkInSet([...start2.node.marks], type2, attrs);
  while (startIndex > 0 && mark.isInSet($pos.parent.child(startIndex - 1).marks)) {
    startIndex -= 1;
    startPos -= $pos.parent.child(startIndex).nodeSize;
  }
  while (endIndex < $pos.parent.childCount && isMarkInSet([...$pos.parent.child(endIndex).marks], type2, attrs)) {
    endPos += $pos.parent.child(endIndex).nodeSize;
    endIndex += 1;
  }
  return { from: startPos, to: endPos };
}
function isMarkActive(state2, typeOrName, attrs = {}) {
  const { empty: empty2, ranges } = state2.selection;
  const type2 = typeOrName ? getMarkType(typeOrName, state2.schema) : null;
  if (empty2) {
    return !!(state2.storedMarks || state2.selection.$from.marks()).filter((mark) => {
      if (!type2) return true;
      return type2.name === mark.type.name;
    }).find((mark) => objectIncludes(mark.attrs, attrs, { strict: false }));
  }
  let selectionRange = 0;
  const markRanges = [];
  ranges.forEach(({ $from, $to }) => {
    const from2 = $from.pos;
    const to = $to.pos;
    state2.doc.nodesBetween(from2, to, (node2, pos) => {
      if (!node2.isText && !node2.marks.length) return;
      const relativeFrom = Math.max(from2, pos);
      const relativeTo = Math.min(to, pos + node2.nodeSize);
      const range3 = relativeTo - relativeFrom;
      selectionRange += range3;
      markRanges.push(
        ...node2.marks.map((mark) => ({
          mark,
          from: relativeFrom,
          to: relativeTo
        }))
      );
    });
  });
  if (selectionRange === 0) return false;
  const matchedRange = markRanges.filter((markRange) => {
    if (!type2) return true;
    return type2.name === markRange.mark.type.name;
  }).filter((markRange) => objectIncludes(markRange.mark.attrs, attrs, { strict: false })).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const excludedRange = markRanges.filter((markRange) => {
    if (!type2) return true;
    return markRange.mark.type !== type2 && markRange.mark.type.excludes(type2);
  }).reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);
  const range2 = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;
  return range2 >= selectionRange;
}
function getMarksBetween(from2, to, doc2) {
  const marks = [];
  if (from2 === to) {
    doc2.resolve(from2).marks().forEach((mark) => {
      const $pos = doc2.resolve(from2 - 1);
      const range2 = getMarkRange($pos, mark.type);
      if (!range2) {
        return;
      }
      marks.push({
        mark,
        ...range2
      });
    });
  } else {
    doc2.nodesBetween(from2, to, (node2, pos) => {
      if (!node2 || node2?.nodeSize === void 0) {
        return;
      }
      marks.push(
        ...node2.marks.map((mark) => ({
          from: pos,
          to: pos + node2.nodeSize,
          mark
        }))
      );
    });
  }
  return marks;
}
function getSchemaTypeNameByName(name, schema) {
  if (schema.nodes[name]) return "node";
  if (schema.marks[name]) return "mark";
  return null;
}
function isNodeActive(state2, typeOrName, attrs = {}) {
  const { from: from2, to, empty: empty2 } = state2.selection;
  const type2 = typeOrName ? getNodeType(typeOrName, state2.schema) : null;
  const nodeRanges = [];
  state2.doc.nodesBetween(from2, to, (node2, pos) => {
    if (node2.isText) return;
    const relativeFrom = Math.max(from2, pos);
    const relativeTo = Math.min(to, pos + node2.nodeSize);
    nodeRanges.push({
      node: node2,
      from: relativeFrom,
      to: relativeTo
    });
  });
  const selectionRange = to - from2;
  const matchedNodeRanges = nodeRanges.filter((nodeRange) => {
    if (!type2) return true;
    return type2.name === nodeRange.node.type.name;
  }).filter((nodeRange) => objectIncludes(nodeRange.node.attrs, attrs, { strict: false }));
  if (empty2) return !!matchedNodeRanges.length;
  const range2 = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);
  return range2 >= selectionRange;
}
function isActive(state2, name, attrs = {}) {
  if (!name) {
    return isNodeActive(state2, null, attrs) || isMarkActive(state2, null, attrs);
  }
  const schemaType = getSchemaTypeNameByName(name, state2.schema);
  if (schemaType === "node") {
    return isNodeActive(state2, name, attrs);
  }
  if (schemaType === "mark") {
    return isMarkActive(state2, name, attrs);
  }
  return false;
}
function getMarksFromSelection(state2) {
  const { from: from2, to, empty: empty2 } = state2.selection;
  const marks = [];
  if (empty2) {
    if (state2.storedMarks) {
      marks.push(...state2.storedMarks);
    }
    marks.push(...state2.selection.$head.marks());
  } else {
    state2.doc.nodesBetween(from2, to, (node2) => {
      marks.push(...node2.marks);
    });
  }
  return marks;
}
const findMark = (state2, markType, toArr = false) => {
  const { selection, doc: doc2 } = state2;
  const { $from, $to } = selection;
  const fromMark = $from.marks().find((mark) => mark.type === markType);
  const toMark = $to.marks().find((mark) => mark.type === markType);
  let markFound;
  const marksFound = [];
  doc2.nodesBetween($from.pos, $to.pos, (node2, from2) => {
    if (node2.marks) {
      const actualMark = node2.marks.find((mark) => mark.type === markType);
      if (actualMark) {
        markFound = {
          from: from2,
          to: from2 + node2.nodeSize,
          attrs: actualMark.attrs,
          contained: !fromMark || !toMark || fromMark === toMark
        };
        marksFound.push(markFound);
      }
    }
  });
  if (toArr) {
    return marksFound;
  }
  return markFound;
};
function getActiveFormatting(editor) {
  const { state: state2 } = editor;
  const { selection } = state2;
  const marks = getMarksFromSelection(state2);
  const markAttrs = selection.$head.parent.attrs.marksAttrs;
  const marksToProcess = marks.filter((mark) => !["textStyle", "link"].includes(mark.type.name)).map((mark) => ({ name: mark.type.name, attrs: mark.attrs }));
  const textStyleMarks = marks.filter((mark) => mark.type.name === "textStyle");
  marksToProcess.push(...textStyleMarks.flatMap(unwrapTextMarks));
  if (markAttrs) {
    const marksFromAttrs = markAttrs.filter((mark) => !["textStyle", "link"].includes(mark.type)).map((mark) => ({ name: mark.type, attrs: mark.attrs || {} }));
    const textStyleMarksFromAttrs = markAttrs.filter((mark) => mark.type === "textStyle");
    marksToProcess.push(...marksFromAttrs);
    marksToProcess.push(...textStyleMarksFromAttrs.flatMap(unwrapTextMarks));
  }
  const linkMarkType = state2.schema.marks["link"];
  const linkMark = findMark(state2, linkMarkType);
  if (linkMark) {
    let { from: from2, to, attrs } = linkMark;
    if (selection.from >= from2 && selection.to <= to) {
      marksToProcess.push({ name: "link", attrs });
    }
  }
  const ignoreKeys = ["paragraphSpacing"];
  const attributes = getActiveAttributes(state2);
  Object.keys(attributes).forEach((key) => {
    if (ignoreKeys.includes(key)) return;
    const attrs = {};
    attrs[key] = attributes[key];
    marksToProcess.push({ name: key, attrs });
  });
  const textColor = marksToProcess.find((i) => i.name === "textColor");
  const textHightlight = marksToProcess.find((i) => i.name === "textHighlight");
  if (textColor) {
    marksToProcess.push({
      name: "color",
      attrs: { color: textColor.attrs?.textColor }
    });
  }
  if (textHightlight) {
    marksToProcess.push({
      name: "highlight",
      attrs: { color: textHightlight.attrs?.textHighlight }
    });
  }
  const hasPendingFormatting = !!editor.storage.formatCommands?.storedStyle;
  if (hasPendingFormatting) marksToProcess.push({ name: "copyFormat", attrs: true });
  return marksToProcess;
}
function unwrapTextMarks(textStyleMark) {
  const processedMarks = [];
  const { attrs } = textStyleMark;
  Object.keys(attrs).forEach((key) => {
    if (!attrs[key]) return;
    processedMarks.push({ name: key, attrs: { [key]: attrs[key] } });
  });
  return processedMarks;
}
function getActiveAttributes(state2) {
  try {
    const { from: from2, to, empty: empty2 } = state2.selection;
    const attributes = {};
    const getAttrs = (node2) => {
      Object.keys(node2.attrs).forEach((key) => {
        const value = node2.attrs[key];
        if (value) {
          attributes[key] = value;
        }
      });
    };
    let start2 = from2;
    let end2 = to;
    if (empty2) state2.doc.nodesBetween(start2, end2 + 1, (node2) => getAttrs(node2));
    else state2.doc.nodesBetween(from2, to, (node2) => getAttrs(node2));
    return attributes;
  } catch {
    return {};
  }
}
function findChildren$5(node2, predicate) {
  const nodesWithPos = [];
  node2.descendants((child, pos) => {
    if (predicate(child)) {
      nodesWithPos.push({
        node: child,
        pos
      });
    }
  });
  return nodesWithPos;
}
function posToDOMRect(view, from2, to) {
  const minPos = 0;
  const maxPos = view.state.doc.content.size;
  const resolvedFrom = minMax(from2, minPos, maxPos);
  const resolvedEnd = minMax(to, minPos, maxPos);
  const start2 = view.coordsAtPos(resolvedFrom);
  const end2 = view.coordsAtPos(resolvedEnd, -1);
  const top2 = Math.min(start2.top, end2.top);
  const bottom2 = Math.max(start2.bottom, end2.bottom);
  const left2 = Math.min(start2.left, end2.left);
  const right2 = Math.max(start2.right, end2.right);
  const width = right2 - left2;
  const height = bottom2 - top2;
  const x = left2;
  const y2 = top2;
  const data = {
    top: top2,
    bottom: bottom2,
    left: left2,
    right: right2,
    width,
    height,
    x,
    y: y2
  };
  return {
    ...data,
    toJSON: () => data
  };
}
const isInTable$1 = (state2) => {
  const { $head } = state2.selection;
  for (let d2 = $head.depth; d2 > 0; d2 -= 1) {
    if ($head.node(d2).type?.spec?.tableRole === "row") {
      return true;
    }
  }
  return false;
};
function createDocFromHTML(content, schema) {
  let parsedContent;
  if (typeof content === "string") {
    const tempDiv = document.createElement("div");
    tempDiv.innerHTML = content;
    parsedContent = tempDiv;
  } else {
    parsedContent = content;
  }
  return DOMParser$1.fromSchema(schema).parse(parsedContent);
}
function L() {
  return { async: false, breaks: false, extensions: null, gfm: true, hooks: null, pedantic: false, renderer: null, silent: false, tokenizer: null, walkTokens: null };
}
var O = L();
function H(l3) {
  O = l3;
}
var E = { exec: () => null };
function h(l3, e = "") {
  let t = typeof l3 == "string" ? l3 : l3.source, n = { replace: (r2, i) => {
    let s = typeof i == "string" ? i : i.source;
    return s = s.replace(m.caret, "$1"), t = t.replace(r2, s), n;
  }, getRegex: () => new RegExp(t, e) };
  return n;
}
var m = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (l3) => new RegExp(`^( {0,3}${l3})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}#`), htmlBeginRegex: (l3) => new RegExp(`^ {0,${Math.min(3, l3 - 1)}}<(?:[a-z].*>|!--)`, "i") }, xe = /^(?:[ \t]*(?:\n|$))+/, be = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/, Re = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, C = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, Oe = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, j = /(?:[*+-]|\d{1,9}[.)])/, se = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/, ie$2 = h(se).replace(/bull/g, j).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex(), Te = h(se).replace(/bull/g, j).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(), F = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, we = /^[^\n]+/, Q = /(?!\s*\])(?:\\.|[^\[\]\\])+/, ye = h(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Q).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), Pe = h(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, j).getRegex(), v = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", U = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, Se = h("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))", "i").replace("comment", U).replace("tag", v).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), oe = h(F).replace("hr", C).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex(), $e = h(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", oe).getRegex(), K$1 = { blockquote: $e, code: be, def: ye, fences: Re, heading: Oe, hr: C, html: Se, lheading: ie$2, list: Pe, newline: xe, paragraph: oe, table: E, text: we }, re = h("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", C).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}	)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex(), _e = { ...K$1, lheading: Te, table: re, paragraph: h(F).replace("hr", C).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", re).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v).getRegex() }, Le = { ...K$1, html: h(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", U).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: E, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: h(F).replace("hr", C).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", ie$2).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() }, Me = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, ze = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, ae = /^( {2,}|\\)\n(?!\s*$)/, Ae = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, D = /[\p{P}\p{S}]/u, W = /[\s\p{P}\p{S}]/u, le = /[^\s\p{P}\p{S}]/u, Ee = h(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, W).getRegex(), ue = /(?!~)[\p{P}\p{S}]/u, Ce = /(?!~)[\s\p{P}\p{S}]/u, Ie = /(?:[^\s\p{P}\p{S}]|~)/u, Be = /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<(?! )[^<>]*?>/g, pe = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/, qe = h(pe, "u").replace(/punct/g, D).getRegex(), ve = h(pe, "u").replace(/punct/g, ue).getRegex(), ce = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)", De = h(ce, "gu").replace(/notPunctSpace/g, le).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), Ze = h(ce, "gu").replace(/notPunctSpace/g, Ie).replace(/punctSpace/g, Ce).replace(/punct/g, ue).getRegex(), Ge = h("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, le).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), He = h(/\\(punct)/, "gu").replace(/punct/g, D).getRegex(), Ne = h(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), je = h(U).replace("(?:-->|$)", "-->").getRegex(), Fe = h("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", je).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), q = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, Qe = h(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", q).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), he = h(/^!?\[(label)\]\[(ref)\]/).replace("label", q).replace("ref", Q).getRegex(), de = h(/^!?\[(ref)\](?:\[\])?/).replace("ref", Q).getRegex(), Ue = h("reflink|nolink(?!\\()", "g").replace("reflink", he).replace("nolink", de).getRegex(), X = { _backpedal: E, anyPunctuation: He, autolink: Ne, blockSkip: Be, br: ae, code: ze, del: E, emStrongLDelim: qe, emStrongRDelimAst: De, emStrongRDelimUnd: Ge, escape: Me, link: Qe, nolink: de, punctuation: Ee, reflink: he, reflinkSearch: Ue, tag: Fe, text: Ae, url: E }, Ke = { ...X, link: h(/^!?\[(label)\]\((.*?)\)/).replace("label", q).getRegex(), reflink: h(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", q).getRegex() }, N = { ...X, emStrongRDelimAst: Ze, emStrongLDelim: ve, url: h(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }, We = { ...N, br: h(ae).replace("{2,}", "*").getRegex(), text: h(N.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }, I = { normal: K$1, gfm: _e, pedantic: Le }, M = { normal: X, gfm: N, breaks: We, pedantic: Ke };
var Xe = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, ke = (l3) => Xe[l3];
function w(l3, e) {
  if (e) {
    if (m.escapeTest.test(l3)) return l3.replace(m.escapeReplace, ke);
  } else if (m.escapeTestNoEncode.test(l3)) return l3.replace(m.escapeReplaceNoEncode, ke);
  return l3;
}
function J(l3) {
  try {
    l3 = encodeURI(l3).replace(m.percentDecode, "%");
  } catch {
    return null;
  }
  return l3;
}
function V(l3, e) {
  let t = l3.replace(m.findPipe, (i, s, o) => {
    let a = false, u = s;
    for (; --u >= 0 && o[u] === "\\"; ) a = !a;
    return a ? "|" : " |";
  }), n = t.split(m.splitPipe), r2 = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) if (n.length > e) n.splice(e);
  else for (; n.length < e; ) n.push("");
  for (; r2 < n.length; r2++) n[r2] = n[r2].trim().replace(m.slashPipe, "|");
  return n;
}
function z(l3, e, t) {
  let n = l3.length;
  if (n === 0) return "";
  let r2 = 0;
  for (; r2 < n; ) {
    let i = l3.charAt(n - r2 - 1);
    if (i === e && true) r2++;
    else break;
  }
  return l3.slice(0, n - r2);
}
function ge(l3, e) {
  if (l3.indexOf(e[1]) === -1) return -1;
  let t = 0;
  for (let n = 0; n < l3.length; n++) if (l3[n] === "\\") n++;
  else if (l3[n] === e[0]) t++;
  else if (l3[n] === e[1] && (t--, t < 0)) return n;
  return t > 0 ? -2 : -1;
}
function fe(l3, e, t, n, r2) {
  let i = e.href, s = e.title || null, o = l3[1].replace(r2.other.outputLinkReplace, "$1");
  n.state.inLink = true;
  let a = { type: l3[0].charAt(0) === "!" ? "image" : "link", raw: t, href: i, title: s, text: o, tokens: n.inlineTokens(o) };
  return n.state.inLink = false, a;
}
function Je(l3, e, t) {
  let n = l3.match(t.other.indentCodeCompensation);
  if (n === null) return e;
  let r2 = n[1];
  return e.split(`
`).map((i) => {
    let s = i.match(t.other.beginningSpace);
    if (s === null) return i;
    let [o] = s;
    return o.length >= r2.length ? i.slice(r2.length) : i;
  }).join(`
`);
}
var y = class {
  constructor(e) {
    __publicField$2(this, "options");
    __publicField$2(this, "rules");
    __publicField$2(this, "lexer");
    this.options = e || O;
  }
  space(e) {
    let t = this.rules.block.newline.exec(e);
    if (t && t[0].length > 0) return { type: "space", raw: t[0] };
  }
  code(e) {
    let t = this.rules.block.code.exec(e);
    if (t) {
      let n = t[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : z(n, `
`) };
    }
  }
  fences(e) {
    let t = this.rules.block.fences.exec(e);
    if (t) {
      let n = t[0], r2 = Je(n, t[3] || "", this.rules);
      return { type: "code", raw: n, lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2], text: r2 };
    }
  }
  heading(e) {
    let t = this.rules.block.heading.exec(e);
    if (t) {
      let n = t[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let r2 = z(n, "#");
        (this.options.pedantic || !r2 || this.rules.other.endingSpaceChar.test(r2)) && (n = r2.trim());
      }
      return { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(e) {
    let t = this.rules.block.hr.exec(e);
    if (t) return { type: "hr", raw: z(t[0], `
`) };
  }
  blockquote(e) {
    let t = this.rules.block.blockquote.exec(e);
    if (t) {
      let n = z(t[0], `
`).split(`
`), r2 = "", i = "", s = [];
      for (; n.length > 0; ) {
        let o = false, a = [], u;
        for (u = 0; u < n.length; u++) if (this.rules.other.blockquoteStart.test(n[u])) a.push(n[u]), o = true;
        else if (!o) a.push(n[u]);
        else break;
        n = n.slice(u);
        let p = a.join(`
`), c2 = p.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        r2 = r2 ? `${r2}
${p}` : p, i = i ? `${i}
${c2}` : c2;
        let f = this.lexer.state.top;
        if (this.lexer.state.top = true, this.lexer.blockTokens(c2, s, true), this.lexer.state.top = f, n.length === 0) break;
        let k = s.at(-1);
        if (k?.type === "code") break;
        if (k?.type === "blockquote") {
          let x = k, g = x.raw + `
` + n.join(`
`), T = this.blockquote(g);
          s[s.length - 1] = T, r2 = r2.substring(0, r2.length - x.raw.length) + T.raw, i = i.substring(0, i.length - x.text.length) + T.text;
          break;
        } else if (k?.type === "list") {
          let x = k, g = x.raw + `
` + n.join(`
`), T = this.list(g);
          s[s.length - 1] = T, r2 = r2.substring(0, r2.length - k.raw.length) + T.raw, i = i.substring(0, i.length - x.raw.length) + T.raw, n = g.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: r2, tokens: s, text: i };
    }
  }
  list(e) {
    let t = this.rules.block.list.exec(e);
    if (t) {
      let n = t[1].trim(), r2 = n.length > 1, i = { type: "list", raw: "", ordered: r2, start: r2 ? +n.slice(0, -1) : "", loose: false, items: [] };
      n = r2 ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r2 ? n : "[*+-]");
      let s = this.rules.other.listItemRegex(n), o = false;
      for (; e; ) {
        let u = false, p = "", c2 = "";
        if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break;
        p = t[0], e = e.substring(p.length);
        let f = t[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (Z) => " ".repeat(3 * Z.length)), k = e.split(`
`, 1)[0], x = !f.trim(), g = 0;
        if (this.options.pedantic ? (g = 2, c2 = f.trimStart()) : x ? g = t[1].length + 1 : (g = t[2].search(this.rules.other.nonSpaceChar), g = g > 4 ? 1 : g, c2 = f.slice(g), g += t[1].length), x && this.rules.other.blankLine.test(k) && (p += k + `
`, e = e.substring(k.length + 1), u = true), !u) {
          let Z = this.rules.other.nextBulletRegex(g), ee = this.rules.other.hrRegex(g), te = this.rules.other.fencesBeginRegex(g), ne = this.rules.other.headingBeginRegex(g), me = this.rules.other.htmlBeginRegex(g);
          for (; e; ) {
            let G = e.split(`
`, 1)[0], A;
            if (k = G, this.options.pedantic ? (k = k.replace(this.rules.other.listReplaceNesting, "  "), A = k) : A = k.replace(this.rules.other.tabCharGlobal, "    "), te.test(k) || ne.test(k) || me.test(k) || Z.test(k) || ee.test(k)) break;
            if (A.search(this.rules.other.nonSpaceChar) >= g || !k.trim()) c2 += `
` + A.slice(g);
            else {
              if (x || f.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || te.test(f) || ne.test(f) || ee.test(f)) break;
              c2 += `
` + k;
            }
            !x && !k.trim() && (x = true), p += G + `
`, e = e.substring(G.length + 1), f = A.slice(g);
          }
        }
        i.loose || (o ? i.loose = true : this.rules.other.doubleBlankLine.test(p) && (o = true));
        let T = null, Y2;
        this.options.gfm && (T = this.rules.other.listIsTask.exec(c2), T && (Y2 = T[0] !== "[ ] ", c2 = c2.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: p, task: !!T, checked: Y2, loose: false, text: c2, tokens: [] }), i.raw += p;
      }
      let a = i.items.at(-1);
      if (a) a.raw = a.raw.trimEnd(), a.text = a.text.trimEnd();
      else return;
      i.raw = i.raw.trimEnd();
      for (let u = 0; u < i.items.length; u++) if (this.lexer.state.top = false, i.items[u].tokens = this.lexer.blockTokens(i.items[u].text, []), !i.loose) {
        let p = i.items[u].tokens.filter((f) => f.type === "space"), c2 = p.length > 0 && p.some((f) => this.rules.other.anyLine.test(f.raw));
        i.loose = c2;
      }
      if (i.loose) for (let u = 0; u < i.items.length; u++) i.items[u].loose = true;
      return i;
    }
  }
  html(e) {
    let t = this.rules.block.html.exec(e);
    if (t) return { type: "html", block: true, raw: t[0], pre: t[1] === "pre" || t[1] === "script" || t[1] === "style", text: t[0] };
  }
  def(e) {
    let t = this.rules.block.def.exec(e);
    if (t) {
      let n = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r2 = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3];
      return { type: "def", tag: n, raw: t[0], href: r2, title: i };
    }
  }
  table(e) {
    let t = this.rules.block.table.exec(e);
    if (!t || !this.rules.other.tableDelimiter.test(t[2])) return;
    let n = V(t[1]), r2 = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: t[0], header: [], align: [], rows: [] };
    if (n.length === r2.length) {
      for (let o of r2) this.rules.other.tableAlignRight.test(o) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(o) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(o) ? s.align.push("left") : s.align.push(null);
      for (let o = 0; o < n.length; o++) s.header.push({ text: n[o], tokens: this.lexer.inline(n[o]), header: true, align: s.align[o] });
      for (let o of i) s.rows.push(V(o, s.header.length).map((a, u) => ({ text: a, tokens: this.lexer.inline(a), header: false, align: s.align[u] })));
      return s;
    }
  }
  lheading(e) {
    let t = this.rules.block.lheading.exec(e);
    if (t) return { type: "heading", raw: t[0], depth: t[2].charAt(0) === "=" ? 1 : 2, text: t[1], tokens: this.lexer.inline(t[1]) };
  }
  paragraph(e) {
    let t = this.rules.block.paragraph.exec(e);
    if (t) {
      let n = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
      return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(e) {
    let t = this.rules.block.text.exec(e);
    if (t) return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) };
  }
  escape(e) {
    let t = this.rules.inline.escape.exec(e);
    if (t) return { type: "escape", raw: t[0], text: t[1] };
  }
  tag(e) {
    let t = this.rules.inline.tag.exec(e);
    if (t) return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = false), { type: "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: false, text: t[0] };
  }
  link(e) {
    let t = this.rules.inline.link.exec(e);
    if (t) {
      let n = t[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n)) return;
        let s = z(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0) return;
      } else {
        let s = ge(t[2], "()");
        if (s === -2) return;
        if (s > -1) {
          let a = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
          t[2] = t[2].substring(0, s), t[0] = t[0].substring(0, a).trim(), t[3] = "";
        }
      }
      let r2 = t[2], i = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(r2);
        s && (r2 = s[1], i = s[3]);
      } else i = t[3] ? t[3].slice(1, -1) : "";
      return r2 = r2.trim(), this.rules.other.startAngleBracket.test(r2) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? r2 = r2.slice(1) : r2 = r2.slice(1, -1)), fe(t, { href: r2 && r2.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, t[0], this.lexer, this.rules);
    }
  }
  reflink(e, t) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      let r2 = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = t[r2.toLowerCase()];
      if (!i) {
        let s = n[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return fe(n, i, n[0], this.lexer, this.rules);
    }
  }
  emStrong(e, t, n = "") {
    let r2 = this.rules.inline.emStrongLDelim.exec(e);
    if (!r2 || r2[3] && n.match(this.rules.other.unicodeAlphaNumeric)) return;
    if (!(r2[1] || r2[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
      let s = [...r2[0]].length - 1, o, a, u = s, p = 0, c2 = r2[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (c2.lastIndex = 0, t = t.slice(-1 * e.length + s); (r2 = c2.exec(t)) != null; ) {
        if (o = r2[1] || r2[2] || r2[3] || r2[4] || r2[5] || r2[6], !o) continue;
        if (a = [...o].length, r2[3] || r2[4]) {
          u += a;
          continue;
        } else if ((r2[5] || r2[6]) && s % 3 && !((s + a) % 3)) {
          p += a;
          continue;
        }
        if (u -= a, u > 0) continue;
        a = Math.min(a, a + u + p);
        let f = [...r2[0]][0].length, k = e.slice(0, s + r2.index + f + a);
        if (Math.min(s, a) % 2) {
          let g = k.slice(1, -1);
          return { type: "em", raw: k, text: g, tokens: this.lexer.inlineTokens(g) };
        }
        let x = k.slice(2, -2);
        return { type: "strong", raw: k, text: x, tokens: this.lexer.inlineTokens(x) };
      }
    }
  }
  codespan(e) {
    let t = this.rules.inline.code.exec(e);
    if (t) {
      let n = t[2].replace(this.rules.other.newLineCharGlobal, " "), r2 = this.rules.other.nonSpaceChar.test(n), i = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return r2 && i && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: t[0], text: n };
    }
  }
  br(e) {
    let t = this.rules.inline.br.exec(e);
    if (t) return { type: "br", raw: t[0] };
  }
  del(e) {
    let t = this.rules.inline.del.exec(e);
    if (t) return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) };
  }
  autolink(e) {
    let t = this.rules.inline.autolink.exec(e);
    if (t) {
      let n, r2;
      return t[2] === "@" ? (n = t[1], r2 = "mailto:" + n) : (n = t[1], r2 = n), { type: "link", raw: t[0], text: n, href: r2, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(e) {
    let t;
    if (t = this.rules.inline.url.exec(e)) {
      let n, r2;
      if (t[2] === "@") n = t[0], r2 = "mailto:" + n;
      else {
        let i;
        do
          i = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "";
        while (i !== t[0]);
        n = t[0], t[1] === "www." ? r2 = "http://" + t[0] : r2 = t[0];
      }
      return { type: "link", raw: t[0], text: n, href: r2, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  inlineText(e) {
    let t = this.rules.inline.text.exec(e);
    if (t) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: t[0], text: t[0], escaped: n };
    }
  }
};
var b = class l {
  constructor(e) {
    __publicField$2(this, "tokens");
    __publicField$2(this, "options");
    __publicField$2(this, "state");
    __publicField$2(this, "tokenizer");
    __publicField$2(this, "inlineQueue");
    this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = e || O, this.options.tokenizer = this.options.tokenizer || new y(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
    let t = { other: m, block: I.normal, inline: M.normal };
    this.options.pedantic ? (t.block = I.pedantic, t.inline = M.pedantic) : this.options.gfm && (t.block = I.gfm, this.options.breaks ? t.inline = M.breaks : t.inline = M.gfm), this.tokenizer.rules = t;
  }
  static get rules() {
    return { block: I, inline: M };
  }
  static lex(e, t) {
    return new l(t).lex(e);
  }
  static lexInline(e, t) {
    return new l(t).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(m.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let t = 0; t < this.inlineQueue.length; t++) {
      let n = this.inlineQueue[t];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, t = [], n = false) {
    for (this.options.pedantic && (e = e.replace(m.tabCharGlobal, "    ").replace(m.spaceLine, "")); e; ) {
      let r2;
      if (this.options.extensions?.block?.some((s) => (r2 = s.call({ lexer: this }, e, t)) ? (e = e.substring(r2.raw.length), t.push(r2), true) : false)) continue;
      if (r2 = this.tokenizer.space(e)) {
        e = e.substring(r2.raw.length);
        let s = t.at(-1);
        r2.raw.length === 1 && s !== void 0 ? s.raw += `
` : t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.code(e)) {
        e = e.substring(r2.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s.text += `
` + r2.text, this.inlineQueue.at(-1).src = s.text) : t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.fences(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.heading(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.hr(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.blockquote(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.list(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.html(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.def(e)) {
        e = e.substring(r2.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s.text += `
` + r2.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[r2.tag] || (this.tokens.links[r2.tag] = { href: r2.href, title: r2.title }, t.push(r2));
        continue;
      }
      if (r2 = this.tokenizer.table(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      if (r2 = this.tokenizer.lheading(e)) {
        e = e.substring(r2.raw.length), t.push(r2);
        continue;
      }
      let i = e;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, o = e.slice(1), a;
        this.options.extensions.startBlock.forEach((u) => {
          a = u.call({ lexer: this }, o), typeof a == "number" && a >= 0 && (s = Math.min(s, a));
        }), s < 1 / 0 && s >= 0 && (i = e.substring(0, s + 1));
      }
      if (this.state.top && (r2 = this.tokenizer.paragraph(i))) {
        let s = t.at(-1);
        n && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s.text += `
` + r2.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r2), n = i.length !== e.length, e = e.substring(r2.raw.length);
        continue;
      }
      if (r2 = this.tokenizer.text(e)) {
        e = e.substring(r2.raw.length);
        let s = t.at(-1);
        s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r2.raw, s.text += `
` + r2.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r2);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else throw new Error(s);
      }
    }
    return this.state.top = true, t;
  }
  inline(e, t = []) {
    return this.inlineQueue.push({ src: e, tokens: t }), t;
  }
  inlineTokens(e, t = []) {
    let n = e, r2 = null;
    if (this.tokens.links) {
      let o = Object.keys(this.tokens.links);
      if (o.length > 0) for (; (r2 = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; ) o.includes(r2[0].slice(r2[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, r2.index) + "[" + "a".repeat(r2[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (; (r2 = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; ) n = n.slice(0, r2.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (; (r2 = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; ) n = n.slice(0, r2.index) + "[" + "a".repeat(r2[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    let i = false, s = "";
    for (; e; ) {
      i || (s = ""), i = false;
      let o;
      if (this.options.extensions?.inline?.some((u) => (o = u.call({ lexer: this }, e, t)) ? (e = e.substring(o.raw.length), t.push(o), true) : false)) continue;
      if (o = this.tokenizer.escape(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.tag(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.link(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(o.raw.length);
        let u = t.at(-1);
        o.type === "text" && u?.type === "text" ? (u.raw += o.raw, u.text += o.text) : t.push(o);
        continue;
      }
      if (o = this.tokenizer.emStrong(e, n, s)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.codespan(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.br(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.del(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.autolink(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (!this.state.inLink && (o = this.tokenizer.url(e))) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      let a = e;
      if (this.options.extensions?.startInline) {
        let u = 1 / 0, p = e.slice(1), c2;
        this.options.extensions.startInline.forEach((f) => {
          c2 = f.call({ lexer: this }, p), typeof c2 == "number" && c2 >= 0 && (u = Math.min(u, c2));
        }), u < 1 / 0 && u >= 0 && (a = e.substring(0, u + 1));
      }
      if (o = this.tokenizer.inlineText(a)) {
        e = e.substring(o.raw.length), o.raw.slice(-1) !== "_" && (s = o.raw.slice(-1)), i = true;
        let u = t.at(-1);
        u?.type === "text" ? (u.raw += o.raw, u.text += o.text) : t.push(o);
        continue;
      }
      if (e) {
        let u = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(u);
          break;
        } else throw new Error(u);
      }
    }
    return t;
  }
};
var P = class {
  constructor(e) {
    __publicField$2(this, "options");
    __publicField$2(this, "parser");
    this.options = e || O;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: t, escaped: n }) {
    let r2 = (t || "").match(m.notSpaceStart)?.[0], i = e.replace(m.endingNewline, "") + `
`;
    return r2 ? '<pre><code class="language-' + w(r2) + '">' + (n ? i : w(i, true)) + `</code></pre>
` : "<pre><code>" + (n ? i : w(i, true)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  def(e) {
    return "";
  }
  heading({ tokens: e, depth: t }) {
    return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    let t = e.ordered, n = e.start, r2 = "";
    for (let o = 0; o < e.items.length; o++) {
      let a = e.items[o];
      r2 += this.listitem(a);
    }
    let i = t ? "ol" : "ul", s = t && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + i + s + `>
` + r2 + "</" + i + `>
`;
  }
  listitem(e) {
    let t = "";
    if (e.task) {
      let n = this.checkbox({ checked: !!e.checked });
      e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = n + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = n + " " + w(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = true)) : e.tokens.unshift({ type: "text", raw: n + " ", text: n + " ", escaped: true }) : t += n + " ";
    }
    return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let t = "", n = "";
    for (let i = 0; i < e.header.length; i++) n += this.tablecell(e.header[i]);
    t += this.tablerow({ text: n });
    let r2 = "";
    for (let i = 0; i < e.rows.length; i++) {
      let s = e.rows[i];
      n = "";
      for (let o = 0; o < s.length; o++) n += this.tablecell(s[o]);
      r2 += this.tablerow({ text: n });
    }
    return r2 && (r2 = `<tbody>${r2}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + r2 + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    let t = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + t + `</${n}>
`;
  }
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${w(e, true)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: t, tokens: n }) {
    let r2 = this.parser.parseInline(n), i = J(e);
    if (i === null) return r2;
    e = i;
    let s = '<a href="' + e + '"';
    return t && (s += ' title="' + w(t) + '"'), s += ">" + r2 + "</a>", s;
  }
  image({ href: e, title: t, text: n, tokens: r2 }) {
    r2 && (n = this.parser.parseInline(r2, this.parser.textRenderer));
    let i = J(e);
    if (i === null) return w(n);
    e = i;
    let s = `<img src="${e}" alt="${n}"`;
    return t && (s += ` title="${w(t)}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : "escaped" in e && e.escaped ? e.text : w(e.text);
  }
};
var S = class {
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
};
var R = class l2 {
  constructor(e) {
    __publicField$2(this, "options");
    __publicField$2(this, "renderer");
    __publicField$2(this, "textRenderer");
    this.options = e || O, this.options.renderer = this.options.renderer || new P(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new S();
  }
  static parse(e, t) {
    return new l2(t).parse(e);
  }
  static parseInline(e, t) {
    return new l2(t).parseInline(e);
  }
  parse(e, t = true) {
    let n = "";
    for (let r2 = 0; r2 < e.length; r2++) {
      let i = e[r2];
      if (this.options.extensions?.renderers?.[i.type]) {
        let o = i, a = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (a !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(o.type)) {
          n += a || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "space": {
          n += this.renderer.space(s);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(s);
          continue;
        }
        case "code": {
          n += this.renderer.code(s);
          continue;
        }
        case "table": {
          n += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          n += this.renderer.list(s);
          continue;
        }
        case "html": {
          n += this.renderer.html(s);
          continue;
        }
        case "def": {
          n += this.renderer.def(s);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let o = s, a = this.renderer.text(o);
          for (; r2 + 1 < e.length && e[r2 + 1].type === "text"; ) o = e[++r2], a += `
` + this.renderer.text(o);
          t ? n += this.renderer.paragraph({ type: "paragraph", raw: a, text: a, tokens: [{ type: "text", raw: a, text: a, escaped: true }] }) : n += a;
          continue;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
  parseInline(e, t = this.renderer) {
    let n = "";
    for (let r2 = 0; r2 < e.length; r2++) {
      let i = e[r2];
      if (this.options.extensions?.renderers?.[i.type]) {
        let o = this.options.extensions.renderers[i.type].call({ parser: this }, i);
        if (o !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type)) {
          n += o || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "escape": {
          n += t.text(s);
          break;
        }
        case "html": {
          n += t.html(s);
          break;
        }
        case "link": {
          n += t.link(s);
          break;
        }
        case "image": {
          n += t.image(s);
          break;
        }
        case "strong": {
          n += t.strong(s);
          break;
        }
        case "em": {
          n += t.em(s);
          break;
        }
        case "codespan": {
          n += t.codespan(s);
          break;
        }
        case "br": {
          n += t.br(s);
          break;
        }
        case "del": {
          n += t.del(s);
          break;
        }
        case "text": {
          n += t.text(s);
          break;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent) return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
};
var $ = (_a = class {
  constructor(e) {
    __publicField$2(this, "options");
    __publicField$2(this, "block");
    this.options = e || O;
  }
  preprocess(e) {
    return e;
  }
  postprocess(e) {
    return e;
  }
  processAllTokens(e) {
    return e;
  }
  provideLexer() {
    return this.block ? b.lex : b.lexInline;
  }
  provideParser() {
    return this.block ? R.parse : R.parseInline;
  }
}, __publicField$2(_a, "passThroughHooks", /* @__PURE__ */ new Set(["preprocess", "postprocess", "processAllTokens"])), _a);
var B = class {
  constructor(...e) {
    __publicField$2(this, "defaults", L());
    __publicField$2(this, "options", this.setOptions);
    __publicField$2(this, "parse", this.parseMarkdown(true));
    __publicField$2(this, "parseInline", this.parseMarkdown(false));
    __publicField$2(this, "Parser", R);
    __publicField$2(this, "Renderer", P);
    __publicField$2(this, "TextRenderer", S);
    __publicField$2(this, "Lexer", b);
    __publicField$2(this, "Tokenizer", y);
    __publicField$2(this, "Hooks", $);
    this.use(...e);
  }
  walkTokens(e, t) {
    let n = [];
    for (let r2 of e) switch (n = n.concat(t.call(this, r2)), r2.type) {
      case "table": {
        let i = r2;
        for (let s of i.header) n = n.concat(this.walkTokens(s.tokens, t));
        for (let s of i.rows) for (let o of s) n = n.concat(this.walkTokens(o.tokens, t));
        break;
      }
      case "list": {
        let i = r2;
        n = n.concat(this.walkTokens(i.items, t));
        break;
      }
      default: {
        let i = r2;
        this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
          let o = i[s].flat(1 / 0);
          n = n.concat(this.walkTokens(o, t));
        }) : i.tokens && (n = n.concat(this.walkTokens(i.tokens, t)));
      }
    }
    return n;
  }
  use(...e) {
    let t = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      let r2 = { ...n };
      if (r2.async = this.defaults.async || r2.async || false, n.extensions && (n.extensions.forEach((i) => {
        if (!i.name) throw new Error("extension name required");
        if ("renderer" in i) {
          let s = t.renderers[i.name];
          s ? t.renderers[i.name] = function(...o) {
            let a = i.renderer.apply(this, o);
            return a === false && (a = s.apply(this, o)), a;
          } : t.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
          let s = t[i.level];
          s ? s.unshift(i.tokenizer) : t[i.level] = [i.tokenizer], i.start && (i.level === "block" ? t.startBlock ? t.startBlock.push(i.start) : t.startBlock = [i.start] : i.level === "inline" && (t.startInline ? t.startInline.push(i.start) : t.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens);
      }), r2.extensions = t), n.renderer) {
        let i = this.defaults.renderer || new P(this.defaults);
        for (let s in n.renderer) {
          if (!(s in i)) throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s)) continue;
          let o = s, a = n.renderer[o], u = i[o];
          i[o] = (...p) => {
            let c2 = a.apply(i, p);
            return c2 === false && (c2 = u.apply(i, p)), c2 || "";
          };
        }
        r2.renderer = i;
      }
      if (n.tokenizer) {
        let i = this.defaults.tokenizer || new y(this.defaults);
        for (let s in n.tokenizer) {
          if (!(s in i)) throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s)) continue;
          let o = s, a = n.tokenizer[o], u = i[o];
          i[o] = (...p) => {
            let c2 = a.apply(i, p);
            return c2 === false && (c2 = u.apply(i, p)), c2;
          };
        }
        r2.tokenizer = i;
      }
      if (n.hooks) {
        let i = this.defaults.hooks || new $();
        for (let s in n.hooks) {
          if (!(s in i)) throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s)) continue;
          let o = s, a = n.hooks[o], u = i[o];
          $.passThroughHooks.has(s) ? i[o] = (p) => {
            if (this.defaults.async) return Promise.resolve(a.call(i, p)).then((f) => u.call(i, f));
            let c2 = a.call(i, p);
            return u.call(i, c2);
          } : i[o] = (...p) => {
            let c2 = a.apply(i, p);
            return c2 === false && (c2 = u.apply(i, p)), c2;
          };
        }
        r2.hooks = i;
      }
      if (n.walkTokens) {
        let i = this.defaults.walkTokens, s = n.walkTokens;
        r2.walkTokens = function(o) {
          let a = [];
          return a.push(s.call(this, o)), i && (a = a.concat(i.call(this, o))), a;
        };
      }
      this.defaults = { ...this.defaults, ...r2 };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, t) {
    return b.lex(e, t ?? this.defaults);
  }
  parser(e, t) {
    return R.parse(e, t ?? this.defaults);
  }
  parseMarkdown(e) {
    return (n, r2) => {
      let i = { ...r2 }, s = { ...this.defaults, ...i }, o = this.onError(!!s.silent, !!s.async);
      if (this.defaults.async === true && i.async === false) return o(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof n > "u" || n === null) return o(new Error("marked(): input parameter is undefined or null"));
      if (typeof n != "string") return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
      s.hooks && (s.hooks.options = s, s.hooks.block = e);
      let a = s.hooks ? s.hooks.provideLexer() : e ? b.lex : b.lexInline, u = s.hooks ? s.hooks.provideParser() : e ? R.parse : R.parseInline;
      if (s.async) return Promise.resolve(s.hooks ? s.hooks.preprocess(n) : n).then((p) => a(p, s)).then((p) => s.hooks ? s.hooks.processAllTokens(p) : p).then((p) => s.walkTokens ? Promise.all(this.walkTokens(p, s.walkTokens)).then(() => p) : p).then((p) => u(p, s)).then((p) => s.hooks ? s.hooks.postprocess(p) : p).catch(o);
      try {
        s.hooks && (n = s.hooks.preprocess(n));
        let p = a(n, s);
        s.hooks && (p = s.hooks.processAllTokens(p)), s.walkTokens && this.walkTokens(p, s.walkTokens);
        let c2 = u(p, s);
        return s.hooks && (c2 = s.hooks.postprocess(c2)), c2;
      } catch (p) {
        return o(p);
      }
    };
  }
  onError(e, t) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        let r2 = "<p>An error occurred:</p><pre>" + w(n.message + "", true) + "</pre>";
        return t ? Promise.resolve(r2) : r2;
      }
      if (t) return Promise.reject(n);
      throw n;
    };
  }
};
var _ = new B();
function d(l3, e) {
  return _.parse(l3, e);
}
d.options = d.setOptions = function(l3) {
  return _.setOptions(l3), d.defaults = _.defaults, H(d.defaults), d;
};
d.getDefaults = L;
d.defaults = O;
d.use = function(...l3) {
  return _.use(...l3), d.defaults = _.defaults, H(d.defaults), d;
};
d.walkTokens = function(l3, e) {
  return _.walkTokens(l3, e);
};
d.parseInline = _.parseInline;
d.Parser = R;
d.parser = R.parse;
d.Renderer = P;
d.TextRenderer = S;
d.Lexer = b;
d.lexer = b.lex;
d.Tokenizer = y;
d.Hooks = $;
d.parse = d;
d.options;
d.setOptions;
d.use;
d.walkTokens;
d.parseInline;
R.parse;
b.lex;
d.use({
  breaks: false,
  // Use proper paragraphs, not <br> tags
  gfm: true
  // GitHub Flavored Markdown support
});
function createDocFromMarkdown(markdown, schema) {
  const html = convertMarkdownToHTML(markdown);
  return createDocFromHTML(html, schema);
}
function convertMarkdownToHTML(markdown) {
  let html = d.parse(markdown, { async: false });
  return html.replace(/<\/p>\n<ul>/g, "</p>\n<p>&nbsp;</p>\n<ul>").replace(/<\/p>\n<ol>/g, "</p>\n<p>&nbsp;</p>\n<ol>").replace(/<\/ul>\n<h/g, "</ul>\n<p>&nbsp;</p>\n<h").replace(/<\/ol>\n<h/g, "</ol>\n<p>&nbsp;</p>\n<h");
}
const helpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  chainableEditorState,
  cleanSchemaItem,
  convertMarkdownToHTML,
  createDocFromHTML,
  createDocFromMarkdown,
  createDocument,
  defaultBlockAt: defaultBlockAt$1,
  findChildren: findChildren$5,
  findMark,
  findParentNode,
  findParentNodeClosestToPos,
  generateDocxListAttributes,
  generateDocxRandomId,
  generateRandom32BitHex,
  getActiveFormatting,
  getExtensionConfigField,
  getMarkRange,
  getMarkType,
  getMarksBetween,
  getMarksFromSelection,
  getNodeType,
  getSchemaTypeByName,
  getSchemaTypeNameByName,
  isActive,
  isInTable: isInTable$1,
  isList: isList$1,
  isMarkActive,
  isNodeActive,
  isTextSelection,
  posToDOMRect
}, Symbol.toStringTag, { value: "Module" }));
const generateNewListDefinition = ({ numId, listType, level, start: start2, text, fmt, editor }) => {
  if (typeof listType === "string") listType = editor.schema.nodes[listType];
  const definition = listType.name === "orderedList" ? baseOrderedListDef : baseBulletList;
  const numbering = editor.converter.numbering;
  const newNumbering = { ...numbering };
  let skipAddingNewAbstract = false;
  let newAbstractId = getNewListId(editor, "abstracts");
  let newAbstractDef = JSON.parse(
    JSON.stringify({
      ...definition,
      attributes: {
        ...definition.attributes,
        "w:abstractNumId": String(newAbstractId)
      }
    })
  );
  if (level && start2 && text && fmt) {
    if (newNumbering.definitions[numId]) {
      const abstractId = newNumbering.definitions[numId]?.elements[0]?.attributes["w:val"];
      newAbstractId = abstractId;
      const abstract = editor.converter.numbering.abstracts[abstractId];
      newAbstractDef = { ...abstract };
      skipAddingNewAbstract = true;
    }
    const levelDefIndex = newAbstractDef.elements.findIndex(
      (el) => el.name === "w:lvl" && el.attributes["w:ilvl"] === level
    );
    const levelProps = newAbstractDef.elements[levelDefIndex];
    const elToFilter = ["w:numFmt", "w:lvlText", "w:start"];
    const oldElements = levelProps.elements.filter((el) => !elToFilter.includes(el.name));
    levelProps.elements = [
      ...oldElements,
      {
        type: "element",
        name: "w:start",
        attributes: {
          "w:val": start2
        }
      },
      {
        type: "element",
        name: "w:numFmt",
        attributes: {
          "w:val": fmt
        }
      },
      {
        type: "element",
        name: "w:lvlText",
        attributes: {
          "w:val": text
        }
      }
    ];
  }
  if (!skipAddingNewAbstract) newNumbering.abstracts[newAbstractId] = newAbstractDef;
  const newNumDef = getBasicNumIdTag(numId, newAbstractId);
  newNumbering.definitions[numId] = newNumDef;
  editor.converter.numbering = newNumbering;
  const change = { numDef: newNumDef, abstractDef: newAbstractDef, editor };
  editor.emit("list-definitions-change", { change, numbering: newNumbering, editor });
  return { abstract: newAbstractDef, definition: newNumDef };
};
const changeNumIdSameAbstract = (numId, level, listType, editor) => {
  const newId = getNewListId(editor, "definitions");
  const { abstract } = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  const numbering = editor.converter.numbering;
  const newNumbering = { ...numbering };
  const newAbstractId = getNewListId(editor, "abstracts");
  const newAbstractDef = {
    ...abstract,
    attributes: {
      ...abstract.attributes,
      "w:abstractNumId": String(newAbstractId)
    }
  };
  newNumbering.abstracts[newAbstractId] = newAbstractDef;
  const newNumDef = getBasicNumIdTag(newId, newAbstractId);
  newNumbering.definitions[newId] = newNumDef;
  return newId;
};
const getBasicNumIdTag = (numId, abstractId) => {
  return {
    type: "element",
    name: "w:num",
    attributes: {
      "w:numId": String(numId)
    },
    elements: [{ name: "w:abstractNumId", attributes: { "w:val": String(abstractId) } }]
  };
};
const getNewListId = (editor, grouping = "definitions") => {
  const defs = editor.converter.numbering[grouping] || {};
  const intKeys = Object.keys(defs).map((k) => Number(k)).filter((n) => Number.isInteger(n));
  const max2 = intKeys.length ? Math.max(...intKeys) : 0;
  return max2 + 1;
};
const getListDefinitionDetails = ({ numId, level, listType, editor, tries = 0 }) => {
  const { definitions, abstracts } = editor.converter.numbering;
  if (!numId) return {};
  const numDef = definitions[numId];
  if (!numDef && listType) {
    ListHelpers.generateNewListDefinition({ numId, listType, editor });
  }
  const abstractId = definitions[numId]?.elements?.find((item) => item.name === "w:abstractNumId")?.attributes?.["w:val"];
  const abstract = abstracts[abstractId];
  if (!abstract) {
    return {
      start: null,
      numFmt: null,
      lvlText: null,
      listNumberingType: null,
      customFormat: null,
      abstract: null,
      abstractId
    };
  }
  const numStyleLink = abstract.elements?.find((item) => item.name === "w:numStyleLink");
  const styleId = numStyleLink?.attributes?.["w:val"];
  if (styleId && tries < 1) {
    const styleDefinition = getStyleTagFromStyleId(styleId, editor.converter.convertedXml);
    const linkedNumId = styleDefinition?.elements?.find((el) => el.name === "w:pPr")?.elements?.find((el) => el.name === "w:numPr")?.elements?.find((el) => el.name === "w:numId")?.attributes?.["w:val"];
    if (linkedNumId) {
      return getListDefinitionDetails({
        numId: Number(linkedNumId),
        level,
        listType,
        editor,
        tries: tries + 1
      });
    }
  }
  const listDefinition = abstract.elements?.find(
    (item) => item.name === "w:lvl" && item.attributes?.["w:ilvl"] == level
  );
  if (!listDefinition) {
    return {
      start: null,
      numFmt: null,
      lvlText: null,
      listNumberingType: null,
      customFormat: null,
      abstract,
      abstractId
    };
  }
  const findElement = (name) => listDefinition.elements?.find((item) => item.name === name);
  const startElement = findElement("w:start");
  const numFmtElement = findElement("w:numFmt");
  const lvlTextElement = findElement("w:lvlText");
  const start2 = startElement?.attributes?.["w:val"];
  const numFmt = numFmtElement?.attributes?.["w:val"];
  const lvlText = lvlTextElement?.attributes?.["w:val"];
  const listNumberingType = numFmt;
  const customFormat = numFmt === "custom" ? numFmtElement?.attributes?.["w:format"] : void 0;
  return {
    start: start2,
    numFmt,
    lvlText,
    listNumberingType,
    customFormat,
    abstract,
    abstractId
  };
};
const removeListDefinitions = (listId, editor) => {
  const { numbering } = editor.converter;
  if (!numbering) return;
  const { definitions, abstracts } = numbering;
  const abstractId = definitions[listId].elements[0].attributes["w:val"];
  delete definitions[listId];
  delete abstracts[abstractId];
  editor.converter.numbering = {
    definitions,
    abstracts
  };
};
const createListItemNodeJSON = ({ level, lvlText, numId, numFmt, listLevel, contentNode }) => {
  if (!contentNode) {
    contentNode = {
      type: "paragraph",
      content: []
    };
  }
  if (!Array.isArray(contentNode)) contentNode = [contentNode];
  const attrs = {
    lvlText,
    listLevel,
    level,
    numId,
    numPrType: "inline",
    listNumberingType: numFmt
  };
  const listItem = {
    type: "listItem",
    attrs,
    content: [...contentNode]
  };
  return listItem;
};
const createSchemaOrderedListNode = ({ level, numId, listType, editor, listLevel, contentNode }) => {
  level = Number(level);
  numId = Number(numId);
  const { start: start2, lvlText, numFmt } = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  const listNodeJSON = createListItemNodeJSON({ level, lvlText, numFmt, numId, listLevel, contentNode });
  const node2 = {
    type: "orderedList",
    attrs: {
      "list-style-type": numFmt,
      listId: numId,
      order: level
    },
    content: [listNodeJSON]
  };
  return editor.schema.nodeFromJSON(node2);
};
const createNewList = ({ listType, tr, editor }) => {
  const numId = ListHelpers.getNewListId(editor);
  if (typeof listType === "string") listType = editor.schema.nodes[listType];
  ListHelpers.generateNewListDefinition({ numId, listType, editor });
  const { selection } = tr;
  const { $from } = selection;
  const content = $from.parent;
  const level = 0;
  const listNode = ListHelpers.createSchemaOrderedListNode({
    level,
    numId,
    listType,
    editor,
    listLevel: [1],
    contentNode: content?.toJSON()
  });
  const replaceFrom = $from.before($from.depth);
  const replaceTo = $from.after($from.depth);
  return insertNewList(tr, replaceFrom, replaceTo, listNode);
};
const getCurrentListItem = (state2) => {
  return findParentNode((node2) => node2.type.name === "listItem")(state2.selection);
};
const getParentOrderedList = (state2) => {
  return findParentNode((node2) => node2.type.name === "orderedList")(state2.selection);
};
const setSelectionInsideNewList = (tr, basePos) => {
  try {
    const $pos = tr.doc.resolve(basePos + 3);
    tr.setSelection(TextSelection$1.near($pos));
  } catch {
    const $fallback = tr.doc.resolve(basePos + 1);
    tr.setSelection(TextSelection$1.near($fallback));
  }
};
const replaceListWithNode = ({ tr, from: from2, to, newNode }) => {
  tr.replaceWith(from2, to, newNode);
};
const convertListItemToParagraph = ({ state: state2, tr, currentNode, replaceFrom, replaceTo }) => {
  const paragraphContent = currentNode.node.content.firstChild;
  if (!paragraphContent) return false;
  const paragraphNode = state2.schema.nodes.paragraph.create(
    paragraphContent.attrs,
    paragraphContent.content,
    paragraphContent.marks
  );
  replaceListWithNode({ tr, from: replaceFrom, to: replaceTo, newNode: paragraphNode });
  const newPos = replaceFrom + 1;
  const $pos = tr.doc.resolve(newPos);
  tr.setSelection(TextSelection$1.near($pos));
  return true;
};
const insertNewList = (tr, replaceFrom, replaceTo, listNode, marks = []) => {
  tr.replaceWith(replaceFrom, replaceTo, listNode);
  tr.ensureMarks(marks);
  const listStart = replaceFrom;
  const $paragraphStart = tr.doc.resolve(listStart + 2);
  const paragraphNode = $paragraphStart.parent;
  const endPos = $paragraphStart.pos + paragraphNode.content.size;
  const $endPos = tr.doc.resolve(endPos);
  tr.setSelection(TextSelection$1.near($endPos));
  return true;
};
const getListItemStyleDefinitions = ({ styleId, numId, level, editor, tries }) => {
  if (tries) return {};
  if (typeof numId === "string") numId = Number(numId);
  if (typeof level === "string") level = Number(level);
  const docx = { ...editor?.converter?.convertedXml };
  const newNumbering = { ...editor?.converter?.numbering };
  const styleDefinition = getStyleTagFromStyleId(styleId, docx);
  const stylePpr = styleDefinition?.elements.find((el) => el.name === "w:pPr");
  let abstractDefinition = getAbstractDefinition(numId, docx);
  if (!abstractDefinition) {
    const listDef = newNumbering.definitions[numId];
    const abstractId = listDef?.elements?.find((item) => item.name === "w:abstractNumId")?.attributes?.["w:val"];
    abstractDefinition = newNumbering.abstracts[abstractId];
  }
  const numDefinition = getDefinitionForLevel(abstractDefinition, level);
  const numDefPpr = numDefinition?.elements.find((el) => el.name === "w:pPr");
  const numLvlJs = numDefinition?.elements.find((el) => el.name === "w:lvlJc");
  return {
    stylePpr,
    numDefPpr,
    numLvlJs
  };
};
const addInlineTextMarks = (currentNode, filteredMarks) => {
  const newMarks = [...filteredMarks];
  try {
    const textMarks = currentNode.children[0].children[0].marks;
    const inlineTextStyleFromSplitBlock = textMarks.find((m2) => m2.type.name === "textStyle");
    inlineTextStyleFromSplitBlock && newMarks.push(inlineTextStyleFromSplitBlock);
  } catch {
  }
  return newMarks;
};
const ListHelpers = {
  getCurrentListItem,
  getParentOrderedList,
  setSelectionInsideNewList,
  replaceListWithNode,
  convertListItemToParagraph,
  // DOCX helpers
  insertNewList,
  getListDefinitionDetails,
  generateNewListDefinition,
  getBasicNumIdTag,
  getNewListId,
  removeListDefinitions,
  getListItemStyleDefinitions,
  // Schema helpers
  createNewList,
  createSchemaOrderedListNode,
  createListItemNodeJSON,
  addInlineTextMarks,
  changeNumIdSameAbstract,
  // Base list definitions
  baseOrderedListDef,
  baseBulletList
};
const extractListLevelStyles = (cssText, listId, level, numId) => {
  const pattern = new RegExp(`@list\\s+l${listId}:level${level}(?:\\s+lfo${numId})?\\s*\\{([^}]+)\\}`, "i");
  const match = cssText.match(pattern);
  if (!match) return null;
  const rawStyles = match[1].split(";").map((line) => line.trim()).filter(Boolean);
  const styleMap = {};
  for (const style2 of rawStyles) {
    const [key, value] = style2.split(":").map((s) => s.trim());
    styleMap[key] = value;
  }
  return styleMap;
};
const numDefMap = /* @__PURE__ */ new Map([
  ["decimal", "decimal"],
  ["alpha-lower", "lowerLetter"],
  ["alpha-upper", "upperLetter"],
  ["roman-lower", "lowerRoman"],
  ["roman-upper", "upperRoman"],
  ["bullet", "bullet"]
]);
const numDefByTypeMap = /* @__PURE__ */ new Map([
  ["1", "decimal"],
  ["a", "lowerLetter"],
  ["A", "upperLetter"],
  ["I", "upperRoman"],
  ["i", "lowerRoman"]
]);
function getStartNumber(lvlText) {
  const match = lvlText.match(/^(\d+)/);
  if (match) return parseInt(match[1], 10);
  return null;
}
function letterToNumber(letter) {
  return letter.toLowerCase().charCodeAt(0) - "a".charCodeAt(0) + 1;
}
function getStartNumberFromAlpha(lvlText) {
  const match = lvlText.match(/^([a-zA-Z])/);
  if (match) return letterToNumber(match[1]);
  return null;
}
function romanToNumber(roman) {
  const map3 = { I: 1, V: 5, X: 10, L: 50, C: 100, D: 500, M: 1e3 };
  let num = 0, prev = 0;
  for (let i = roman.length - 1; i >= 0; i--) {
    const curr = map3[roman[i].toUpperCase()] || 0;
    if (curr < prev) num -= curr;
    else num += curr;
    prev = curr;
  }
  return num;
}
function getStartNumberFromRoman(lvlText) {
  const match = lvlText.match(/^([ivxlcdmIVXLCDM]+)/);
  if (match) return romanToNumber(match[1]);
  return null;
}
const startHelperMap = /* @__PURE__ */ new Map([
  ["decimal", getStartNumber],
  ["lowerLetter", getStartNumberFromAlpha],
  ["upperLetter", getStartNumberFromAlpha],
  ["lowerRoman", getStartNumberFromRoman],
  ["upperRoman", getStartNumberFromRoman],
  ["bullet", () => 1]
]);
const googleNumDefMap = /* @__PURE__ */ new Map([
  ["decimal", "decimal"],
  ["decimal-leading-zero", "decimal"],
  ["lower-alpha", "lowerLetter"],
  ["upper-alpha", "upperLetter"],
  ["lower-roman", "lowerRoman"],
  ["upper-roman", "upperRoman"],
  ["bullet", "bullet"]
]);
const getLvlTextForGoogleList = (fmt, level, editor) => {
  const bulletListDef = editor.converter.numbering.abstracts[0];
  const bulletDefForLevel = bulletListDef.elements.find(
    (el) => el.name === "w:lvl" && el.attributes?.["w:ilvl"] === (level - 1).toString()
  );
  const bulletLvlText = bulletDefForLevel.elements.find((el) => el.name === "w:lvlText")?.attributes?.["w:val"];
  switch (fmt) {
    case "decimal-leading-zero":
      return `0%${level}.`;
    case "bullet":
      return bulletLvlText;
    default:
      return `%${level}.`;
  }
};
const handleDocxPaste = (html, editor, view) => {
  const { converter } = editor;
  if (!converter || !converter.convertedXml) return handleHtmlPaste(html, editor);
  let cleanedHtml = convertEmToPt(html);
  cleanedHtml = cleanHtmlUnnecessaryTags(cleanedHtml);
  const tempDiv = document.createElement("div");
  tempDiv.innerHTML = cleanedHtml;
  const data = tempDiv.querySelectorAll("p, li");
  const startMap = {};
  data.forEach((item) => {
    let type2;
    if (item.localName === "li") {
      type2 = "listItem";
    } else {
      const html2 = item.innerHTML;
      type2 = "p";
      if (!html2.includes("<!--[if !supportLists]")) return;
    }
    const styleAttr = item.getAttribute("style") || "";
    const msoListMatch = styleAttr.match(/mso-list:\s*l(\d+)\s+level(\d+)\s+lfo(\d+)/);
    const css = tempDiv.querySelector("style").innerHTML;
    if (msoListMatch) {
      const [, abstractId, level, numId] = msoListMatch;
      const styles = extractListLevelStyles(css, abstractId, level, numId) || {};
      let start2, numFmt, lvlText;
      if (type2 === "listItem") {
        const listType = item.parentNode.getAttribute("type");
        const startAttr = item.parentNode.getAttribute("start");
        if (!startMap[numId]) startMap[numId] = startAttr;
        start2 = startMap[numId];
        numFmt = numDefByTypeMap.get(listType);
        lvlText = `%${level}.`;
      } else {
        const msoNumFormat = styles["mso-level-number-format"] || "decimal";
        numFmt = numDefMap.get(msoNumFormat);
        const punc = item.innerText?.match(/^\s*[a-zA-Z0-9]+([.()])/i)?.[1] || ".";
        lvlText = numFmt === "bullet" ? normalizeLvlTextChar(styles["mso-level-text"]) : `%${level}${punc}`;
        const startGetter = startHelperMap.get(numFmt);
        if (!startMap[numId]) startMap[numId] = startGetter(item.children[0]?.innerText || "1");
        start2 = startMap[numId];
      }
      item.setAttribute("data-num-id", numId);
      item.setAttribute("data-list-level", parseInt(level) - 1);
      item.setAttribute("data-start", start2);
      item.setAttribute("data-lvl-text", lvlText);
      item.setAttribute("data-num-fmt", numFmt);
      const ptToPxRatio = 1.333;
      const indent = parseInt(styles["margin-left"]) * ptToPxRatio || 0;
      if (indent > 0) item.setAttribute("data-left-indent", indent);
    }
    extractAndRemoveConditionalPrefix(item);
  });
  transformWordLists(tempDiv, editor);
  const doc2 = DOMParser$1.fromSchema(editor.schema).parse(tempDiv);
  tempDiv.remove();
  const { dispatch } = editor.view;
  if (!dispatch) return false;
  dispatch(view.state.tr.replaceSelectionWith(doc2, true));
  return true;
};
const transformWordLists = (container, editor) => {
  const listItems = Array.from(container.querySelectorAll("[data-num-id]"));
  const lists = {};
  const mappedLists = {};
  for (const item of listItems) {
    const level = parseInt(item.getAttribute("data-list-level"));
    const numFmt = item.getAttribute("data-num-fmt");
    const start2 = item.getAttribute("data-start");
    const lvlText = item.getAttribute("data-lvl-text");
    const indent = item.getAttribute("data-left-indent");
    const importedId = item.getAttribute("data-num-id");
    if (!mappedLists[importedId]) mappedLists[importedId] = ListHelpers.getNewListId(editor);
    const id = mappedLists[importedId];
    const listType = numFmt === "bullet" ? "bulletList" : "orderedList";
    ListHelpers.generateNewListDefinition({
      numId: id,
      listType,
      level: level.toString(),
      start: start2,
      fmt: numFmt,
      text: lvlText,
      editor
    });
    if (!lists[id]) lists[id] = { levels: {} };
    const currentListByNumId = lists[id];
    if (!currentListByNumId.levels[level]) currentListByNumId.levels[level] = Number(start2) || 1;
    else currentListByNumId.levels[level]++;
    Object.keys(currentListByNumId.levels).forEach((key) => {
      const level1 = Number(key);
      if (level1 > level) {
        delete currentListByNumId.levels[level1];
      }
    });
    const path = generateListPath(level, currentListByNumId.levels, start2);
    if (!path.length) path.push(currentListByNumId.levels[level]);
    const li = document.createElement("li");
    li.innerHTML = item.innerHTML;
    li.setAttribute("data-num-id", id);
    li.setAttribute("data-list-level", JSON.stringify(path));
    li.setAttribute("data-level", level);
    li.setAttribute("data-lvl-text", lvlText);
    li.setAttribute("data-num-fmt", numFmt);
    if (indent) li.setAttribute("data-indent", JSON.stringify({ left: indent }));
    if (item.hasAttribute("data-font-family")) {
      li.setAttribute("data-font-family", item.getAttribute("data-font-family"));
    }
    if (item.hasAttribute("data-font-size")) {
      li.setAttribute("data-font-size", item.getAttribute("data-font-size"));
    }
    const parentNode2 = item.parentNode;
    let listForLevel;
    const newList = numFmt === "bullet" ? document.createElement("ul") : document.createElement("ol");
    newList.setAttribute("data-list-id", id);
    newList.level = level;
    parentNode2.insertBefore(newList, item);
    listForLevel = newList;
    listForLevel.appendChild(li);
    item.remove();
  }
};
const generateListPath = (level, levels, start2) => {
  const iLvl = Number(level);
  const path = [];
  if (iLvl > 0) {
    for (let i = iLvl; i >= 0; i--) {
      if (!levels[i]) levels[i] = Number(start2);
      path.unshift(levels[i]);
    }
  }
  return path;
};
function extractAndRemoveConditionalPrefix(item) {
  const nodes = Array.from(item.childNodes);
  let fontFamily2 = null;
  let fontSize2 = null;
  let start2 = -1, end2 = -1;
  nodes.forEach((node2, index2) => {
    if (node2.nodeType === Node.COMMENT_NODE && node2.nodeValue.includes("[if !supportLists]")) {
      start2 = index2;
    }
    if (start2 !== -1 && node2.nodeType === Node.COMMENT_NODE && node2.nodeValue.includes("[endif]")) {
      end2 = index2;
    }
  });
  if (start2 !== -1 && end2 !== -1) {
    for (let i = start2 + 1; i < end2; i++) {
      const node2 = nodes[i];
      if (node2.nodeType === Node.ELEMENT_NODE && node2.style) {
        fontFamily2 = fontFamily2 || node2.style.fontFamily;
        fontSize2 = fontSize2 || node2.style.fontSize;
      }
    }
    for (let i = end2; i >= start2; i--) {
      item.removeChild(item.childNodes[i]);
    }
    if (fontFamily2) item.setAttribute("data-font-family", fontFamily2);
    if (fontSize2) item.setAttribute("data-font-size", fontSize2);
  }
}
function flattenListsInHtml$1(html, editor) {
  let parser, NodeInterface;
  if (editor.options?.mockDocument) {
    const win = editor.options.mockDocument.defaultView;
    parser = new win.DOMParser();
    NodeInterface = win.Node;
  } else {
    parser = new DOMParser();
    NodeInterface = window.Node;
  }
  const doc2 = parser.parseFromString(html, "text/html");
  let foundList;
  while (foundList = findListToFlatten$1(doc2)) {
    flattenFoundList$1(foundList, editor, NodeInterface);
  }
  return doc2.body.innerHTML;
}
function findListToFlatten$1(doc2) {
  let list = doc2.querySelector("ol:not([data-list-id]), ul:not([data-list-id])");
  if (list) return list;
  const allLists = doc2.querySelectorAll("ol[data-list-id], ul[data-list-id]");
  for (const list2 of allLists) {
    const liChildren = Array.from(list2.children).filter((c2) => c2.tagName.toLowerCase() === "li");
    if (liChildren.length > 1) {
      return list2;
    }
    const nestedLists = list2.querySelectorAll("ol, ul");
    if (nestedLists.length > 0) {
      return list2;
    }
  }
  return null;
}
function flattenFoundList$1(listElem, editor, NodeInterface) {
  const localDoc = listElem.ownerDocument;
  const tag = listElem.tagName.toLowerCase();
  let rootNumId = listElem.getAttribute("data-list-id");
  if (!rootNumId) {
    rootNumId = ListHelpers.getNewListId(editor);
    ListHelpers.generateNewListDefinition({
      numId: rootNumId,
      listType: tag === "ol" ? "orderedList" : "bulletList",
      editor
    });
  }
  let level = 0;
  let ancestor = listElem.parentElement;
  while (ancestor && ancestor !== localDoc.body) {
    if (ancestor.tagName && ancestor.tagName.toLowerCase() === "li") {
      level++;
    }
    ancestor = ancestor.parentElement;
  }
  const items = Array.from(listElem.children).filter((c2) => c2.tagName.toLowerCase() === "li");
  const newLists = [];
  items.forEach((li) => {
    const nestedLists = Array.from(li.querySelectorAll("ol, ul"));
    const nestedListsData = nestedLists.map((nl) => ({
      element: nl.cloneNode(true),
      parent: nl.parentNode
    }));
    nestedLists.forEach((nl) => nl.parentNode.removeChild(nl));
    const newList = createSingleItemList({ li, tag, rootNumId, level, editor, NodeInterface });
    newLists.push(newList);
    nestedListsData.forEach((data) => {
      newLists.push(data.element);
    });
  });
  const parent = listElem.parentNode;
  const nextSibling = listElem.nextSibling;
  parent.removeChild(listElem);
  newLists.forEach((list) => {
    parent.insertBefore(list, nextSibling);
  });
}
function createSingleItemList({ li, tag, rootNumId, level, listLevel, editor, NodeInterface }) {
  const localDoc = li.ownerDocument;
  const ELEMENT_NODE = NodeInterface.ELEMENT_NODE;
  const TEXT_NODE = NodeInterface.TEXT_NODE;
  const newList = localDoc.createElement(tag);
  const newLi = localDoc.createElement("li");
  Array.from(li.attributes).forEach((attr) => {
    if (!attr.name.startsWith("data-num-") && !attr.name.startsWith("data-level") && !attr.name.startsWith("data-list-")) {
      newLi.setAttribute(attr.name, attr.value);
    }
  });
  newList.setAttribute("data-list-id", rootNumId);
  newLi.setAttribute("data-num-id", rootNumId);
  newLi.setAttribute("data-level", String(level));
  const { listNumberingType, lvlText } = ListHelpers.getListDefinitionDetails({
    numId: rootNumId,
    level,
    editor
  });
  newLi.setAttribute("data-num-fmt", listNumberingType);
  newLi.setAttribute("data-lvl-text", lvlText || "");
  newLi.setAttribute("data-list-level", JSON.stringify(listLevel || [level + 1]));
  Array.from(li.childNodes).forEach((node2) => {
    if (node2.nodeType === ELEMENT_NODE || node2.nodeType === TEXT_NODE && node2.textContent.trim()) {
      newLi.appendChild(node2.cloneNode(true));
    }
  });
  if (newLi.childNodes.length === 0 || newLi.childNodes.length === 1 && newLi.childNodes[0].nodeType === TEXT_NODE) {
    const textContent2 = newLi.textContent.trim();
    if (textContent2) {
      newLi.innerHTML = "";
      const p = localDoc.createElement("p");
      p.textContent = textContent2;
      newLi.appendChild(p);
    }
  }
  newList.appendChild(newLi);
  return newList;
}
function unflattenListsInHtml(html) {
  const parser = new DOMParser();
  const doc2 = parser.parseFromString(html, "text/html");
  const allNodes = [...doc2.body.children];
  const listSequences = [];
  let currentSequence = null;
  allNodes.forEach((node2, index2) => {
    const isFlattenList = node2.tagName && (node2.tagName === "OL" || node2.tagName === "UL") && node2.hasAttribute("data-list-id");
    if (isFlattenList) {
      const listId = node2.getAttribute("data-list-id");
      if (currentSequence && currentSequence.id === listId) {
        currentSequence.lists.push({ element: node2, index: index2 });
      } else {
        currentSequence = {
          id: listId,
          lists: [{ element: node2, index: index2 }]
        };
        listSequences.push(currentSequence);
      }
    } else {
      currentSequence = null;
    }
  });
  listSequences.reverse().forEach((sequence) => {
    const sequenceLists = sequence.lists;
    if (sequenceLists.length === 0) {
      return;
    }
    const items = sequenceLists.map(({ element: list }) => {
      const liElement = list.querySelector("li");
      if (!liElement) return null;
      return {
        element: liElement,
        level: parseInt(liElement.getAttribute("data-level") || "0"),
        numFmt: liElement.getAttribute("data-num-fmt") || "bullet",
        listLevel: JSON.parse(liElement.getAttribute("data-list-level") || "[1]")
      };
    }).filter((item) => item !== null);
    if (items.length === 0) {
      return;
    }
    const rootList = buildNestedList({ items });
    const firstOriginalList = sequenceLists[0].element;
    firstOriginalList?.parentNode?.insertBefore(rootList, firstOriginalList);
    sequenceLists.forEach(({ element: list }) => {
      if (list.parentNode) list.parentNode.removeChild(list);
    });
  });
  return doc2.body.innerHTML;
}
function buildNestedList({ items }) {
  if (!items.length) {
    return null;
  }
  const [rootItem] = items;
  const doc2 = rootItem.element.ownerDocument;
  const isOrderedList = rootItem.numFmt && !["bullet", "none"].includes(rootItem.numFmt);
  const rootList = doc2.createElement(isOrderedList ? "ol" : "ul");
  if (isOrderedList && rootItem.listLevel?.[0] && rootItem.listLevel[0] > 1) {
    rootList.setAttribute("start", rootItem.listLevel[0]);
  }
  const lastLevelItem = /* @__PURE__ */ new Map();
  items.forEach((item) => {
    const { element: liElement, level, numFmt } = item;
    const cleanLi = cleanListItem(liElement.cloneNode(true));
    if (level === 0) {
      rootList.append(cleanLi);
      lastLevelItem.set(0, cleanLi);
    } else {
      const parentLi = lastLevelItem.get(level - 1);
      if (!parentLi) {
        rootList.append(cleanLi);
        lastLevelItem.set(level, cleanLi);
        return;
      }
      let nestedList = null;
      [...parentLi.children].forEach((child) => {
        if (child.tagName && (child.tagName === "OL" || child.tagName === "UL")) {
          nestedList = child;
        }
      });
      if (!nestedList) {
        const listType = numFmt && !["bullet", "none"].includes(numFmt) ? "ol" : "ul";
        nestedList = doc2.createElement(listType);
        parentLi.append(nestedList);
      }
      nestedList.append(cleanLi);
      lastLevelItem.set(level, cleanLi);
    }
  });
  return rootList;
}
function cleanListItem(listItem) {
  const attrs = [
    "data-num-id",
    "data-level",
    "data-num-fmt",
    "data-lvl-text",
    "data-list-level",
    "data-marker-type",
    "aria-label"
  ];
  attrs.forEach((attr) => {
    listItem.removeAttribute(attr);
  });
  return listItem;
}
const handleGoogleDocsHtml = (html, editor, view) => {
  const htmlWithPtSizing = convertEmToPt(html);
  const cleanedHtml = sanitizeHtml(htmlWithPtSizing).innerHTML;
  const tempDiv = document.createElement("div");
  tempDiv.innerHTML = cleanedHtml;
  const htmlWithMergedLists = mergeSeparateLists(tempDiv);
  const flattenHtml = flattenListsInHtml(htmlWithMergedLists, editor);
  const doc2 = DOMParser$1.fromSchema(editor.schema).parse(flattenHtml);
  tempDiv.remove();
  const { dispatch } = editor.view;
  if (!dispatch) return false;
  dispatch(view.state.tr.replaceSelectionWith(doc2, true));
  return true;
};
function flattenListsInHtml(container, editor) {
  let foundList;
  while (foundList = findListToFlatten(container)) {
    flattenFoundList(foundList, editor);
  }
  return container;
}
function findListToFlatten(container) {
  let list = container.querySelector("ol:not([data-list-id]), ul:not([data-list-id])");
  if (list) return list;
  return null;
}
function flattenFoundList(listElem, editor) {
  let NodeInterface;
  if (editor.options.mockDocument) {
    const win = editor.options.mockDocument.defaultView;
    NodeInterface = win.Node;
  } else {
    NodeInterface = window.Node;
  }
  const tag = listElem.tagName.toLowerCase();
  const rootListLevel = Number(listElem.children[0].getAttribute("aria-level"));
  const rootListFmt = listElem.children[0].style["list-style-type"] || "decimal";
  const start2 = listElem.getAttribute("start") || 1;
  const rootNumId = ListHelpers.getNewListId(editor);
  ListHelpers.generateNewListDefinition({
    numId: rootNumId,
    listType: tag === "ol" ? "orderedList" : "bulletList",
    editor,
    fmt: googleNumDefMap.get(rootListFmt),
    level: (rootListLevel - 1).toString(),
    start: start2,
    text: getLvlTextForGoogleList(rootListFmt, rootListLevel, editor)
  });
  const newLists = [];
  const items = Array.from(listElem.children).filter((c2) => c2.tagName.toLowerCase() === "li");
  items.forEach((li) => {
    const level = Number(li.getAttribute("aria-level")) - 1;
    const listLevel = [level + 1];
    const nestedLists = getNestedLists([li.nextSibling]);
    const newList = createSingleItemList({ li, tag, rootNumId, level, listLevel, editor, NodeInterface });
    newLists.push(newList);
    nestedLists.forEach((list) => {
      newLists.push(list.cloneNode(true));
    });
    if (nestedLists.length && ["OL", "UL"].includes(li.nextSibling.tagName)) {
      li.nextSibling?.remove();
    }
  });
  const parent = listElem.parentNode;
  const nextSibling = listElem.nextSibling;
  parent.removeChild(listElem);
  newLists.forEach((list) => {
    parent.insertBefore(list, nextSibling);
  });
}
function getNestedLists(nodes) {
  let result = [];
  const nodesArray = Array.from(nodes).filter((n) => n !== null);
  for (let item of nodesArray) {
    if (item.tagName === "OL" || item.tagName === "UL") {
      result.push(item);
      result.push(...getNestedLists(item.children));
    }
  }
  return result;
}
function mergeSeparateLists(container) {
  const tempCont = container.cloneNode(true);
  const rootLevelLists = Array.from(tempCont.querySelectorAll("ol:not(ol ol):not(ul ol)") || []);
  const mainList = rootLevelLists.find((list) => !list.getAttribute("start"));
  const hasStartAttr = rootLevelLists.some((list) => list.getAttribute("start") !== null);
  if (hasStartAttr) {
    const listsWithStartAttr = rootLevelLists.filter((list) => list.getAttribute("start") !== null);
    for (let [index2, item] of listsWithStartAttr.entries()) {
      if (item.getAttribute("start") === (index2 + 2).toString()) {
        mainList.append(...item.childNodes);
        item.remove();
      }
    }
  }
  return tempCont;
}
class InputRule {
  constructor(config) {
    __publicField$2(this, "match");
    __publicField$2(this, "handler");
    this.match = config.match;
    this.handler = config.handler;
  }
}
const inputRuleMatcherHandler = (text, match) => {
  if (isRegExp(match)) {
    return match.exec(text);
  }
  const inputRuleMatch = match(text);
  if (!inputRuleMatch) {
    return null;
  }
  const result = [inputRuleMatch.text];
  result.index = inputRuleMatch.index;
  result.input = text;
  result.data = inputRuleMatch.data;
  if (inputRuleMatch.replaceWith) {
    if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {
      console.warn('[super-editor warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".');
    }
    result.push(inputRuleMatch.replaceWith);
  }
  return result;
};
const run = (config) => {
  const { editor, from: from2, to, text, rules, plugin: plugin2 } = config;
  const { view } = editor;
  if (view.composing) {
    return false;
  }
  const $from = view.state.doc.resolve(from2);
  if ($from.parent.type.spec.code || !!($from.nodeBefore || $from.nodeAfter)?.marks.find((mark) => mark.type.spec.code)) {
    return false;
  }
  let matched = false;
  const textBefore = getTextContentFromNodes($from) + text;
  rules.forEach((rule) => {
    if (matched) {
      return;
    }
    const match = inputRuleMatcherHandler(textBefore, rule.match);
    if (!match) {
      return;
    }
    const tr = view.state.tr;
    const state2 = chainableEditorState(tr, view.state);
    const range2 = {
      from: from2 - (match[0].length - text.length),
      to
    };
    const { commands: commands2, chain, can } = new CommandService({
      editor,
      state: state2
    });
    const handler = rule.handler({
      state: state2,
      range: range2,
      match,
      commands: commands2,
      chain,
      can
    });
    if (handler === null || !tr.steps.length) {
      return;
    }
    tr.setMeta(plugin2, {
      transform: tr,
      from: from2,
      to,
      text
    });
    view.dispatch(tr);
    matched = true;
  });
  return matched;
};
const inputRulesPlugin = ({ editor, rules }) => {
  const plugin2 = new Plugin({
    key: new PluginKey("inputRulesPlugin"),
    state: {
      init() {
        return null;
      },
      apply(tr, prev, state2) {
        const stored = tr.getMeta(plugin2);
        if (stored) {
          return stored;
        }
        const simulatedInputMeta = tr.getMeta("applyInputRules");
        const isSimulatedInput = !!simulatedInputMeta;
        if (isSimulatedInput) {
          setTimeout(() => {
            let { text } = simulatedInputMeta;
            if (typeof text !== "string") {
              text = getHTMLFromFragment(Fragment.from(text), state2.schema);
            }
            const { from: from2 } = simulatedInputMeta;
            const to = from2 + text.length;
            run({
              editor,
              from: from2,
              to,
              text,
              rules,
              plugin: plugin2
            });
          });
        }
        return tr.selectionSet || tr.docChanged ? null : prev;
      }
    },
    props: {
      handleTextInput(view, from2, to, text) {
        return run({
          editor,
          from: from2,
          to,
          text,
          rules,
          plugin: plugin2
        });
      },
      // add support for input rules to trigger on enter
      // this is useful for example for code blocks
      handleKeyDown(view, event) {
        if (event.key !== "Enter") {
          return false;
        }
        const { $cursor } = view.state.selection;
        if ($cursor) {
          return run({
            editor,
            from: $cursor.pos,
            to: $cursor.pos,
            text: "\n",
            rules,
            plugin: plugin2
          });
        }
        return false;
      },
      // Paste handler
      handlePaste(view, event, slice2) {
        const clipboard = event.clipboardData;
        const html = clipboard.getData("text/html");
        const fieldAnnotationContent = slice2.content.content.filter((item) => item.type.name === "fieldAnnotation");
        if (fieldAnnotationContent.length) {
          return false;
        }
        return handleClipboardPaste({ editor, view }, html);
      }
    },
    isInputRules: true
  });
  return plugin2;
};
function isWordHtml(html) {
  return /class=["']?Mso|xmlns:o=["']?urn:schemas-microsoft-com|<!--\[if gte mso|<meta[^>]+name=["']?Generator["']?[^>]+Word/i.test(
    html
  );
}
function isGoogleDocsHtml(html) {
  return /docs-internal-guid-/.test(html);
}
function handleHtmlPaste(html, editor, source) {
  let cleanedHtml;
  cleanedHtml = htmlHandler(html, editor);
  const doc2 = DOMParser$1.fromSchema(editor.schema).parse(cleanedHtml);
  const { dispatch, state: state2 } = editor.view;
  if (!dispatch) return false;
  const { $from } = state2.selection;
  const isInParagraph = $from.parent.type.name === "paragraph";
  const isSingleParagraph = doc2.childCount === 1 && doc2.firstChild.type.name === "paragraph";
  if (isInParagraph && isSingleParagraph) {
    const paragraphContent = doc2.firstChild.content;
    const tr = state2.tr.replaceSelectionWith(paragraphContent, false);
    dispatch(tr);
  } else if (isInParagraph) {
    const allContent = [];
    doc2.content.forEach((node2, index2) => {
      if (node2.type.name === "paragraph") {
        allContent.push(...node2.content.content);
        if (index2 < doc2.content.childCount - 1) {
          allContent.push(editor.schema.text("\n"));
        }
      }
    });
    if (allContent.length > 0) {
      const fragment = Fragment.from(allContent);
      const tr = state2.tr.replaceSelectionWith(fragment, false);
      dispatch(tr);
    } else {
      dispatch(state2.tr.replaceSelectionWith(doc2, true));
    }
  } else {
    dispatch(state2.tr.replaceSelectionWith(doc2, true));
  }
  return true;
}
function htmlHandler(html, editor) {
  const flatHtml = flattenListsInHtml$1(html, editor);
  const htmlWithPtSizing = convertEmToPt(flatHtml);
  return sanitizeHtml(htmlWithPtSizing);
}
const convertEmToPt = (html) => {
  return html.replace(/font-size\s*:\s*([\d.]+)em/gi, (_2, emValue) => {
    const em = parseFloat(emValue);
    const pt = Math.round(em * 12 * 100) / 100;
    return `font-size: ${pt}pt`;
  });
};
function cleanHtmlUnnecessaryTags(html) {
  return html.replace(/<o:p>.*?<\/o:p>/gi, "").replace(/&nbsp;/gi, " ").replace(/<span[^>]*>\s*<\/span>/gi, "").replace(/<p[^>]*>\s*<\/p>/gi, "").trim();
}
function sanitizeHtml(html, forbiddenTags = ["meta", "svg", "script", "style", "button"]) {
  const container = document.createElement("div");
  container.innerHTML = html;
  const walkAndClean = (node2) => {
    for (const child of [...node2.children]) {
      if (forbiddenTags.includes(child.tagName.toLowerCase())) {
        child.remove();
        continue;
      }
      if (child.hasAttribute("linebreaktype")) {
        child.removeAttribute("linebreaktype");
      }
      walkAndClean(child);
    }
  };
  walkAndClean(container);
  return container;
}
function handleClipboardPaste({ editor, view }, html) {
  let source;
  if (!html) {
    source = "plain-text";
  } else if (isWordHtml(html)) {
    source = "word-html";
  } else if (isGoogleDocsHtml(html)) {
    source = "google-docs";
  } else {
    source = "browser-html";
  }
  switch (source) {
    case "plain-text":
      return false;
    case "word-html":
      if (editor.options.mode === "docx") {
        return handleDocxPaste(html, editor, view);
      }
      break;
    case "google-docs":
      return handleGoogleDocsHtml(html, editor, view);
    // falls through to browser-html handling when not in DOCX mode
    case "browser-html":
      return handleHtmlPaste(html, editor);
  }
  return false;
}
function translateChildNodes(params2) {
  const { content: nodes } = params2.node;
  if (!nodes) return [];
  const translatedNodes = [];
  nodes.forEach((node2) => {
    let translatedNode = exportSchemaToJson({ ...params2, node: node2 });
    if (translatedNode instanceof Array) translatedNodes.push(...translatedNode);
    else translatedNodes.push(translatedNode);
  });
  return translatedNodes.filter((n) => n);
}
const baseNumbering = {
  declaration: {
    attributes: {
      version: "1.0",
      encoding: "UTF-8",
      standalone: "yes"
    }
  },
  elements: [
    {
      type: "element",
      name: "w:numbering",
      attributes: {
        "xmlns:wpc": "http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas",
        "xmlns:cx": "http://schemas.microsoft.com/office/drawing/2014/chartex",
        "xmlns:cx1": "http://schemas.microsoft.com/office/drawing/2015/9/8/chartex",
        "xmlns:cx2": "http://schemas.microsoft.com/office/drawing/2015/10/21/chartex",
        "xmlns:cx3": "http://schemas.microsoft.com/office/drawing/2016/5/9/chartex",
        "xmlns:cx4": "http://schemas.microsoft.com/office/drawing/2016/5/10/chartex",
        "xmlns:cx5": "http://schemas.microsoft.com/office/drawing/2016/5/11/chartex",
        "xmlns:cx6": "http://schemas.microsoft.com/office/drawing/2016/5/12/chartex",
        "xmlns:cx7": "http://schemas.microsoft.com/office/drawing/2016/5/13/chartex",
        "xmlns:cx8": "http://schemas.microsoft.com/office/drawing/2016/5/14/chartex",
        "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
        "xmlns:aink": "http://schemas.microsoft.com/office/drawing/2016/ink",
        "xmlns:am3d": "http://schemas.microsoft.com/office/drawing/2017/model3d",
        "xmlns:o": "urn:schemas-microsoft-com:office:office",
        "xmlns:oel": "http://schemas.microsoft.com/office/2019/extlst",
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "xmlns:m": "http://schemas.openxmlformats.org/officeDocument/2006/math",
        "xmlns:v": "urn:schemas-microsoft-com:vml",
        "xmlns:wp14": "http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing",
        "xmlns:wp": "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing",
        "xmlns:w10": "urn:schemas-microsoft-com:office:word",
        "xmlns:w": "http://schemas.openxmlformats.org/wordprocessingml/2006/main",
        "xmlns:w14": "http://schemas.microsoft.com/office/word/2010/wordml",
        "xmlns:w15": "http://schemas.microsoft.com/office/word/2012/wordml",
        "xmlns:w16cex": "http://schemas.microsoft.com/office/word/2018/wordml/cex",
        "xmlns:w16cid": "http://schemas.microsoft.com/office/word/2016/wordml/cid",
        "xmlns:w16": "http://schemas.microsoft.com/office/word/2018/wordml",
        "xmlns:w16du": "http://schemas.microsoft.com/office/word/2023/wordml/word16du",
        "xmlns:w16sdtdh": "http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash",
        "xmlns:w16se": "http://schemas.microsoft.com/office/word/2015/wordml/symex",
        "xmlns:wpg": "http://schemas.microsoft.com/office/word/2010/wordprocessingGroup",
        "xmlns:wpi": "http://schemas.microsoft.com/office/word/2010/wordprocessingInk",
        "xmlns:wne": "http://schemas.microsoft.com/office/word/2006/wordml",
        "xmlns:wps": "http://schemas.microsoft.com/office/word/2010/wordprocessingShape",
        "mc:Ignorable": "w14 w15 w16se w16cid w16 w16cex w16sdtdh w16du wp14"
      },
      elements: [
        {
          type: "element",
          name: "w:abstractNum",
          attributes: {
            "w:abstractNumId": "0",
            "w15:restartNumberingAfterBreak": "0"
          },
          elements: [
            {
              type: "element",
              name: "w:nsid",
              attributes: {
                "w:val": "16126B07"
              }
            },
            {
              type: "element",
              name: "w:multiLevelType",
              attributes: {
                "w:val": "hybridMultilevel"
              }
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "0",
                "w:tplc": "04090001"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "720",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Symbol",
                        "w:hAnsi": "Symbol",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "1",
                "w:tplc": "04090003",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "o"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "1440",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Courier New",
                        "w:hAnsi": "Courier New",
                        "w:cs": "Courier New",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "2",
                "w:tplc": "04090005",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2160",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Wingdings",
                        "w:hAnsi": "Wingdings",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "3",
                "w:tplc": "04090001",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2880",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Symbol",
                        "w:hAnsi": "Symbol",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "4",
                "w:tplc": "04090003",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "o"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "3600",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Courier New",
                        "w:hAnsi": "Courier New",
                        "w:cs": "Courier New",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "5",
                "w:tplc": "04090005",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "4320",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Wingdings",
                        "w:hAnsi": "Wingdings",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "6",
                "w:tplc": "04090001",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5040",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Symbol",
                        "w:hAnsi": "Symbol",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "7",
                "w:tplc": "04090003",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "o"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5760",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Courier New",
                        "w:hAnsi": "Courier New",
                        "w:cs": "Courier New",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "8",
                "w:tplc": "04090005",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "bullet"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": ""
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "6480",
                        "w:hanging": "360"
                      }
                    }
                  ]
                },
                {
                  type: "element",
                  name: "w:rPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:rFonts",
                      attributes: {
                        "w:ascii": "Wingdings",
                        "w:hAnsi": "Wingdings",
                        "w:hint": "default"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          type: "element",
          name: "w:abstractNum",
          attributes: {
            "w:abstractNumId": "1",
            "w15:restartNumberingAfterBreak": "0"
          },
          elements: [
            {
              type: "element",
              name: "w:nsid",
              attributes: {
                "w:val": "587013BA"
              }
            },
            {
              type: "element",
              name: "w:multiLevelType",
              attributes: {
                "w:val": "hybridMultilevel"
              }
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "0",
                "w:tplc": "0409000F"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "decimal"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%1."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "720",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "1",
                "w:tplc": "04090019",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerLetter"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%2."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "1440",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "2",
                "w:tplc": "0409001B",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerRoman"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%3."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "right"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2160",
                        "w:hanging": "180"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "3",
                "w:tplc": "0409000F",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "decimal"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%4."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "2880",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "4",
                "w:tplc": "04090019",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerLetter"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%5."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "3600",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "5",
                "w:tplc": "0409001B",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerRoman"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%6."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "right"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "4320",
                        "w:hanging": "180"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "6",
                "w:tplc": "0409000F",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "decimal"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%7."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5040",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "7",
                "w:tplc": "04090019",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerLetter"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%8."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "left"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "5760",
                        "w:hanging": "360"
                      }
                    }
                  ]
                }
              ]
            },
            {
              type: "element",
              name: "w:lvl",
              attributes: {
                "w:ilvl": "8",
                "w:tplc": "0409001B",
                "w:tentative": "1"
              },
              elements: [
                {
                  type: "element",
                  name: "w:start",
                  attributes: {
                    "w:val": "1"
                  }
                },
                {
                  type: "element",
                  name: "w:numFmt",
                  attributes: {
                    "w:val": "lowerRoman"
                  }
                },
                {
                  type: "element",
                  name: "w:lvlText",
                  attributes: {
                    "w:val": "%9."
                  }
                },
                {
                  type: "element",
                  name: "w:lvlJc",
                  attributes: {
                    "w:val": "right"
                  }
                },
                {
                  type: "element",
                  name: "w:pPr",
                  elements: [
                    {
                      type: "element",
                      name: "w:ind",
                      attributes: {
                        "w:left": "6480",
                        "w:hanging": "180"
                      }
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          type: "element",
          name: "w:num",
          attributes: {
            "w:numId": "1",
            "w16cid:durableId": "100147962"
          },
          elements: [
            {
              type: "element",
              name: "w:abstractNumId",
              attributes: {
                "w:val": "0"
              }
            }
          ]
        },
        {
          type: "element",
          name: "w:num",
          attributes: {
            "w:numId": "2",
            "w16cid:durableId": "485517411"
          },
          elements: [
            {
              type: "element",
              name: "w:abstractNumId",
              attributes: {
                "w:val": "1"
              }
            }
          ]
        }
      ]
    }
  ]
};
const translateDocumentSection = (params2) => {
  const { node: node2 } = params2;
  const { attrs = {} } = node2;
  const childContent = translateChildNodes({ ...params2, nodes: node2.content });
  const nodeElements = [
    {
      name: "w:sdtContent",
      elements: childContent
    }
  ];
  const exportedTag = JSON.stringify({
    type: "documentSection",
    description: attrs.description
  });
  const sdtPr = generateSdtPrTagForDocumentSection(attrs.id, attrs.title, exportedTag);
  const { isLocked } = attrs;
  if (isLocked) {
    sdtPr.elements.push({
      name: "w:lock",
      attributes: {
        "w:val": "sdtContentLocked"
      }
    });
  }
  nodeElements.unshift(sdtPr);
  return {
    name: "w:sdt",
    elements: nodeElements
  };
};
const generateSdtPrTagForDocumentSection = (id, title, tag) => {
  return {
    name: "w:sdtPr",
    elements: [
      {
        name: "w:id",
        attributes: {
          "w:val": id
        }
      },
      {
        name: "w:alias",
        attributes: {
          "w:val": title
        }
      },
      {
        name: "w:tag",
        attributes: {
          "w:val": tag
        }
      }
    ]
  };
};
function exportSchemaToJson(params2) {
  const { type: type2 } = params2.node || {};
  const router = {
    doc: translateDocumentNode,
    body: translateBodyNode,
    heading: translateHeadingNode,
    paragraph: translateParagraphNode,
    text: translateTextNode,
    bulletList: translateList,
    orderedList: translateList,
    lineBreak: translateLineBreak,
    table: translateTable,
    tableRow: translateTableRow,
    tableCell: translateTableCell,
    bookmarkStart: translateBookmarkStart,
    fieldAnnotation: translateFieldAnnotation,
    tab: translateTab,
    image: translateImageNode,
    hardBreak: translateHardBreak,
    commentRangeStart: () => translateCommentNode(params2, "Start"),
    commentRangeEnd: () => translateCommentNode(params2, "End"),
    commentReference: () => null,
    shapeContainer: translateShapeContainer,
    shapeTextbox: translateShapeTextbox,
    contentBlock: translateContentBlock,
    structuredContent: translateStructuredContent,
    structuredContentBlock: translateStructuredContent,
    documentSection: translateDocumentSection,
    "page-number": translatePageNumberNode,
    "total-page-number": translateTotalPageNumberNode
  };
  if (!router[type2]) {
    console.error("No translation function found for node type:", type2);
    return null;
  }
  return router[type2](params2);
}
function translateBodyNode(params2) {
  let sectPr = params2.bodyNode?.elements.find((n) => n.name === "w:sectPr") || {};
  if (params2.converter) {
    const hasHeader = sectPr?.elements?.some((n) => n.name === "w:headerReference");
    const hasDefaultHeader = params2.converter.headerIds?.default;
    if (!hasHeader && hasDefaultHeader && !params2.editor.options.isHeaderOrFooter) {
      const defaultHeader = generateDefaultHeaderFooter("header", params2.converter.headerIds?.default);
      sectPr.elements.push(defaultHeader);
    }
    const hasFooter = sectPr?.elements?.some((n) => n.name === "w:footerReference");
    const hasDefaultFooter = params2.converter.footerIds?.default;
    if (!hasFooter && hasDefaultFooter && !params2.editor.options.isHeaderOrFooter) {
      const defaultFooter = generateDefaultHeaderFooter("footer", params2.converter.footerIds?.default);
      sectPr.elements.push(defaultFooter);
    }
    const newMargins = params2.converter.pageStyles.pageMargins;
    const sectPrMargins = sectPr.elements.find((n) => n.name === "w:pgMar");
    const { attributes } = sectPrMargins;
    Object.entries(newMargins).forEach(([key, value]) => {
      const convertedValue = inchesToTwips(value);
      attributes[`w:${key}`] = convertedValue;
    });
    sectPrMargins.attributes = attributes;
  }
  const elements = translateChildNodes(params2);
  if (params2.isHeaderFooter) {
    return {
      name: "w:body",
      elements: [...elements]
    };
  }
  return {
    name: "w:body",
    elements: [...elements, sectPr]
  };
}
const generateDefaultHeaderFooter = (type2, id) => {
  return {
    type: "element",
    name: `w:${type2}Reference`,
    attributes: {
      "w:type": "default",
      "r:id": id
    }
  };
};
function translateHeadingNode(params2) {
  const { node: node2 } = params2;
  const { level = 1, ...otherAttrs } = node2.attrs;
  const paragraphNode = {
    type: "paragraph",
    content: node2.content,
    attrs: {
      ...otherAttrs,
      styleId: `Heading${level}`
      // Maps to Heading1, Heading2, etc. in Word
    }
  };
  return translateParagraphNode({ ...params2, node: paragraphNode });
}
function translateParagraphNode(params2) {
  const elements = translateChildNodes(params2);
  const htmlAnnotationChild = elements.find((element) => element.name === "htmlAnnotation");
  if (htmlAnnotationChild) {
    return htmlAnnotationChild.elements;
  }
  const pPr = generateParagraphProperties(params2.node);
  if (pPr) elements.unshift(pPr);
  let attributes = {};
  if (params2.node.attrs?.rsidRDefault) {
    attributes["w:rsidRDefault"] = params2.node.attrs.rsidRDefault;
  }
  const result = {
    name: "w:p",
    elements,
    attributes
  };
  return result;
}
function normalizeLineHeight(value) {
  if (typeof value === "string" && value.trim().endsWith("%")) {
    const parsed2 = parseFloat(value);
    return Number.isFinite(parsed2) ? parsed2 / 100 : null;
  }
  const parsed = parseFloat(value);
  return Number.isFinite(parsed) ? parsed : null;
}
function generateParagraphProperties(node2) {
  const { attrs = {} } = node2;
  const pPrElements = [];
  const { styleId } = attrs;
  if (styleId) pPrElements.push({ name: "w:pStyle", attributes: { "w:val": styleId } });
  const { spacing, indent, textAlign, textIndent, lineHeight: lineHeight2, marksAttrs, keepLines, keepNext, dropcap } = attrs;
  if (spacing) {
    const { lineSpaceBefore, lineSpaceAfter, lineRule } = spacing;
    const attributes = {};
    if (lineSpaceBefore >= 0) attributes["w:before"] = pixelsToTwips(lineSpaceBefore);
    if (lineSpaceAfter >= 0) attributes["w:after"] = pixelsToTwips(lineSpaceAfter);
    const normalized = normalizeLineHeight(lineHeight2);
    if (normalized !== null) {
      if (lineRule === "exact") {
        attributes["w:line"] = ptToTwips(normalized);
      } else {
        attributes["w:line"] = linesToTwips(normalized);
      }
    }
    attributes["w:lineRule"] = lineRule || "auto";
    const spacingElement = {
      name: "w:spacing",
      attributes
    };
    pPrElements.push(spacingElement);
  }
  if (lineHeight2 && !spacing) {
    const spacingElement = {
      name: "w:spacing",
      attributes: {
        "w:line": linesToTwips(lineHeight2)
      }
    };
    pPrElements.push(spacingElement);
  }
  if (indent && Object.values(indent).some((v2) => v2 !== 0)) {
    const { left: left2, right: right2, firstLine, hanging } = indent;
    const attributes = {};
    if (left2 || left2 === 0) attributes["w:left"] = pixelsToTwips(left2);
    if (right2 || right2 === 0) attributes["w:right"] = pixelsToTwips(right2);
    if (firstLine || firstLine === 0) attributes["w:firstLine"] = pixelsToTwips(firstLine);
    if (hanging || hanging === 0) attributes["w:hanging"] = pixelsToTwips(hanging);
    if (textIndent && !attributes["w:left"]) {
      attributes["w:left"] = getTextIndentExportValue(textIndent);
    }
    const indentElement = {
      name: "w:ind",
      attributes
    };
    pPrElements.push(indentElement);
  } else if (textIndent && textIndent !== "0in") {
    const indentElement = {
      name: "w:ind",
      attributes: {
        "w:left": getTextIndentExportValue(textIndent)
      }
    };
    pPrElements.push(indentElement);
  }
  if (textAlign) {
    const textAlignElement = {
      name: "w:jc",
      attributes: { "w:val": textAlign === "justify" ? "both" : textAlign }
    };
    pPrElements.push(textAlignElement);
  }
  if (marksAttrs) {
    const outputMarks = processOutputMarks(marksAttrs);
    const rPrElement = generateRunProps(outputMarks);
    pPrElements.push(rPrElement);
  }
  if (keepLines) {
    pPrElements.push({
      name: "w:keepLines",
      attributes: { "w:val": keepLines }
    });
  }
  if (keepNext) {
    pPrElements.push({
      name: "w:keepNext",
      attributes: { "w:val": keepNext }
    });
  }
  if (dropcap) {
    pPrElements.push({
      name: "w:framePr",
      attributes: {
        "w:dropCap": dropcap.type,
        "w:lines": dropcap.lines,
        "w:wrap": dropcap.wrap,
        "w:vAnchor": dropcap.vAnchor,
        "w:hAnchor": dropcap.hAnchor
      }
    });
  }
  const sectPr = node2.attrs?.paragraphProperties?.sectPr;
  if (sectPr) {
    pPrElements.push(sectPr);
  }
  const { tabStops } = attrs;
  if (tabStops && tabStops.length > 0) {
    const tabElements = tabStops.map((tab) => {
      const tabAttributes = {
        "w:val": tab.val || "start",
        "w:pos": pixelsToTwips(tab.pos).toString()
      };
      if (tab.leader) {
        tabAttributes["w:leader"] = tab.leader;
      }
      return {
        name: "w:tab",
        attributes: tabAttributes
      };
    });
    pPrElements.push({
      name: "w:tabs",
      elements: tabElements
    });
  }
  const numPr = node2.attrs?.paragraphProperties?.elements?.find((n) => n.name === "w:numPr");
  const hasNumPr = pPrElements.some((n) => n.name === "w:numPr");
  if (numPr && !hasNumPr) pPrElements.push(numPr);
  if (!pPrElements.length) return null;
  return {
    name: "w:pPr",
    elements: pPrElements
  };
}
function translateDocumentNode(params2) {
  const bodyNode = {
    type: "body",
    content: params2.node.content
  };
  const translatedBodyNode = exportSchemaToJson({ ...params2, node: bodyNode });
  const node2 = {
    name: "w:document",
    elements: [translatedBodyNode],
    attributes: DEFAULT_DOCX_DEFS
  };
  return [node2, params2];
}
function getTextNodeForExport(text, marks, params2) {
  const hasLeadingOrTrailingSpace = /^\s|\s$/.test(text);
  const space = hasLeadingOrTrailingSpace ? "preserve" : null;
  const nodeAttrs = space ? { "xml:space": space } : null;
  const textNodes = [];
  const outputMarks = processOutputMarks(marks);
  textNodes.push({
    name: "w:t",
    elements: [{ text, type: "text" }],
    attributes: nodeAttrs
  });
  if (params2) {
    const { editor } = params2;
    const customMarks = editor.extensionService.extensions.filter((e) => e.isExternal === true);
    marks.forEach((mark) => {
      const isCustomMark = customMarks.some((customMark) => {
        const customMarkName = customMark.name;
        return mark.type === customMarkName;
      });
      if (!isCustomMark) return;
      let attrsString = "";
      Object.entries(mark.attrs).forEach(([key, value]) => {
        if (value) {
          attrsString += `${key}=${value};`;
        }
      });
      if (isCustomMark) {
        textNodes.unshift({
          type: "element",
          name: "w:bookmarkStart",
          attributes: {
            "w:id": "5000",
            "w:name": mark.type + ";" + attrsString
          }
        });
        textNodes.push({
          type: "element",
          name: "w:bookmarkEnd",
          attributes: {
            "w:id": "5000"
          }
        });
      }
    });
  }
  return wrapTextInRun(textNodes, outputMarks);
}
function translateTextNode(params2) {
  const { node: node2 } = params2;
  const trackedMarks = [TrackInsertMarkName, TrackDeleteMarkName];
  const isTrackedNode = node2.marks?.some((m2) => trackedMarks.includes(m2.type));
  if (isTrackedNode) return translateTrackedNode(params2);
  const isLinkNode = node2.marks?.some((m2) => m2.type === "link");
  if (isLinkNode) return translateLinkNode(params2);
  const { text, marks = [] } = node2;
  return getTextNodeForExport(text, marks, params2);
}
function createTrackStyleMark(marks) {
  const trackStyleMark = marks.find((mark) => mark.type === TrackFormatMarkName);
  if (trackStyleMark) {
    const markElement = {
      type: "element",
      name: "w:rPrChange",
      attributes: {
        "w:id": trackStyleMark.attrs.id,
        "w:author": trackStyleMark.attrs.author,
        "w:authorEmail": trackStyleMark.attrs.authorEmail,
        "w:date": trackStyleMark.attrs.date
      },
      elements: trackStyleMark.attrs.before.map((mark) => processOutputMarks([mark])).filter((r2) => r2 !== void 0)
    };
    return markElement;
  }
  return void 0;
}
function translateTrackedNode(params2) {
  const { node: node2 } = params2;
  const marks = node2.marks;
  const trackingMarks = [TrackInsertMarkName, TrackDeleteMarkName, TrackFormatMarkName];
  const trackedMark = marks.find((m2) => trackingMarks.includes(m2.type));
  const isInsert = trackedMark.type === TrackInsertMarkName;
  const trackStyleMark = createTrackStyleMark(marks);
  node2.marks = marks.filter((m2) => !trackingMarks.includes(m2.type));
  if (trackStyleMark) {
    node2.marks.push(trackStyleMark);
  }
  const translatedTextNode = exportSchemaToJson({ ...params2, node: node2 });
  if (!isInsert) {
    const textNode = translatedTextNode.elements.find((n) => n.name === "w:t");
    textNode.name = "w:delText";
  }
  const trackedNode = {
    name: isInsert ? "w:ins" : "w:del",
    type: "element",
    attributes: {
      "w:id": trackedMark.attrs.id,
      "w:author": trackedMark.attrs.author,
      "w:authorEmail": trackedMark.attrs.authorEmail,
      "w:date": trackedMark.attrs.date
    },
    elements: [translatedTextNode]
  };
  return trackedNode;
}
function wrapTextInRun(nodeOrNodes, marks) {
  let elements = [];
  if (Array.isArray(nodeOrNodes)) elements = nodeOrNodes;
  else elements = [nodeOrNodes];
  if (marks && marks.length) elements.unshift(generateRunProps(marks));
  return {
    name: "w:r",
    elements
  };
}
function generateRunProps(marks = []) {
  return {
    name: "w:rPr",
    elements: marks.filter((mark) => !!Object.keys(mark).length)
  };
}
function processOutputMarks(marks = []) {
  return marks.flatMap((mark) => {
    if (mark.type === "textStyle") {
      return Object.entries(mark.attrs).filter(([, value]) => value).map(([key]) => {
        const unwrappedMark = { type: key, attrs: mark.attrs };
        return translateMark(unwrappedMark);
      });
    } else {
      return translateMark(mark);
    }
  });
}
function translateLinkNode(params2) {
  const { node: node2 } = params2;
  const linkMark = node2.marks.find((m2) => m2.type === "link");
  const link = linkMark.attrs.href;
  let rId = linkMark.attrs.rId;
  if (!rId) {
    rId = addNewLinkRelationship(params2, link);
  }
  node2.marks = node2.marks.filter((m2) => m2.type !== "link");
  const outputNode = exportSchemaToJson({ ...params2, node: node2 });
  const contentNode = processLinkContentNode(outputNode);
  const newNode = {
    name: "w:hyperlink",
    type: "element",
    attributes: {
      "r:id": rId
    },
    elements: [contentNode]
  };
  return newNode;
}
function processLinkContentNode(node2) {
  if (!node2) return node2;
  const contentNode = carbonCopy(node2);
  if (!contentNode) return contentNode;
  const hyperlinkStyle = {
    name: "w:rStyle",
    attributes: { "w:val": "Hyperlink" }
  };
  const color = {
    name: "w:color",
    attributes: { "w:val": "467886" }
  };
  const underline = {
    name: "w:u",
    attributes: {
      "w:val": "none"
    }
  };
  if (contentNode.name === "w:r") {
    const runProps = contentNode.elements.find((el) => el.name === "w:rPr");
    if (runProps) {
      const foundColor = runProps.elements.find((el) => el.name === "w:color");
      const foundHyperlinkStyle = runProps.elements.find((el) => el.name === "w:rStyle");
      const underlineMark = runProps.elements.find((el) => el.name === "w:u");
      if (!foundColor) runProps.elements.unshift(color);
      if (!foundHyperlinkStyle) runProps.elements.unshift(hyperlinkStyle);
      if (!underlineMark) runProps.elements.unshift(underline);
    } else {
      const runProps2 = {
        name: "w:rPr",
        elements: [hyperlinkStyle, color]
      };
      contentNode.elements.unshift(runProps2);
    }
  }
  return contentNode;
}
function addNewLinkRelationship(params2, link) {
  const newId = "rId" + generateDocxRandomId();
  if (!params2.relationships || !Array.isArray(params2.relationships)) {
    params2.relationships = [];
  }
  params2.relationships.push({
    type: "element",
    name: "Relationship",
    attributes: {
      Id: newId,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
      Target: link,
      TargetMode: "External"
    }
  });
  return newId;
}
function addNewImageRelationship(params2, imagePath) {
  const newId = "rId" + generateDocxRandomId();
  const newRel = {
    type: "element",
    name: "Relationship",
    attributes: {
      Id: newId,
      Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
      Target: imagePath
    }
  };
  params2.relationships.push(newRel);
  return newId;
}
function translateList(params2) {
  const { node: node2, editor } = params2;
  const listItem = node2.content[0];
  const { numId, level } = listItem.attrs;
  const listType = node2.type.name;
  const listDef = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  if (!listDef) {
    ListHelpers.generateNewListDefinition({
      numId,
      listType,
      editor
    });
  }
  let numPrTag;
  if (numId !== void 0 && numId !== null) {
    numPrTag = generateNumPrTag(numId, level);
  }
  const collapsedParagraphNode = convertMultipleListItemsIntoSingleNode(listItem);
  let outputNode = exportSchemaToJson({ ...params2, node: collapsedParagraphNode });
  if (Array.isArray(outputNode) && params2.isFinalDoc) {
    const parsedElements = [];
    outputNode?.forEach((node3, index2) => {
      if (node3?.elements) {
        const runs = node3.elements?.filter((n) => n.name === "w:r");
        parsedElements.push(...runs);
        if (node3.name === "w:p" && index2 < outputNode.length - 1) {
          parsedElements.push({
            name: "w:br"
          });
        }
      }
    });
    outputNode = {
      name: "w:p",
      elements: [{ name: "w:pPr", elements: [] }, ...parsedElements]
    };
  }
  let nodesToFlatten = [];
  const sdtNodes = outputNode.elements?.filter((n) => n.name === "w:sdt");
  if (sdtNodes && sdtNodes.length > 0) {
    nodesToFlatten = sdtNodes;
    nodesToFlatten?.forEach((sdtNode) => {
      const sdtContent = sdtNode.elements.find((n) => n.name === "w:sdtContent");
      const foundRun = sdtContent.elements?.find((el) => el.name === "w:r");
      if (sdtContent && sdtContent.elements && !foundRun) {
        const parsedElements = [];
        sdtContent.elements.forEach((element, index2) => {
          if (element.name === "w:rPr" && element.elements?.length) {
            parsedElements.push(element);
          }
          const runs = element.elements?.filter((n) => n.name === "w:r");
          if (runs && runs.length) {
            parsedElements.push(...runs);
          }
          if (element.name === "w:p" && index2 < sdtContent.elements.length - 1) {
            parsedElements.push({
              name: "w:br"
            });
          }
        });
        sdtContent.elements = parsedElements;
      }
    });
  }
  const pPr = outputNode.elements?.find((n) => n.name === "w:pPr");
  if (pPr && pPr.elements && numPrTag) {
    pPr.elements.unshift(numPrTag);
  }
  const indentTag = restoreIndent(listItem.attrs.indent);
  indentTag && pPr?.elements?.push(indentTag);
  const runNode = outputNode.elements?.find((n) => n.name === "w:r");
  const rPr = runNode?.elements?.find((n) => n.name === "w:rPr");
  if (rPr) pPr.elements.push(rPr);
  if (listItem.attrs.numPrType !== "inline") {
    const numPrIndex = pPr?.elements?.findIndex((e) => e?.name === "w:numPr");
    if (numPrIndex !== -1) {
      pPr?.elements?.splice(numPrIndex, 1);
    }
  }
  return [outputNode];
}
const convertMultipleListItemsIntoSingleNode = (listItem) => {
  const { content } = listItem;
  if (!content || content.length === 0) {
    return null;
  }
  const firstParagraph = content[0];
  const collapsedParagraph = {
    ...firstParagraph,
    content: []
  };
  content.forEach((item, index2) => {
    if (item.type === "paragraph") {
      if (index2 > 0) {
        collapsedParagraph.content.push({
          type: "lineBreak",
          attrs: {},
          content: []
        });
      }
      if (item.content && item.content.length > 0) {
        collapsedParagraph.content.push(...item.content);
      }
    } else {
      collapsedParagraph.content.push(item);
    }
  });
  return collapsedParagraph;
};
const restoreIndent = (indent) => {
  const attributes = {};
  if (!indent) indent = {};
  if (indent.left || indent.left === 0) attributes["w:left"] = pixelsToTwips(indent.left);
  if (indent.right || indent.right === 0) attributes["w:right"] = pixelsToTwips(indent.right);
  if (indent.firstLine || indent.firstLine === 0) attributes["w:firstLine"] = pixelsToTwips(indent.firstLine);
  if (indent.hanging || indent.hanging === 0) attributes["w:hanging"] = pixelsToTwips(indent.hanging);
  if (indent.leftChars || indent.leftChars === 0) attributes["w:leftChars"] = pixelsToTwips(indent.leftChars);
  if (!Object.keys(attributes).length) return;
  return {
    name: "w:ind",
    type: "element",
    attributes
  };
};
const generateNumPrTag = (numId, level) => {
  return {
    name: "w:numPr",
    type: "element",
    elements: [
      {
        name: "w:numId",
        type: "element",
        attributes: { "w:val": numId }
      },
      {
        name: "w:ilvl",
        type: "element",
        attributes: { "w:val": level }
      }
    ]
  };
};
function translateLineBreak(params2) {
  const attributes = {};
  const { lineBreakType } = params2.node?.attrs || {};
  if (lineBreakType) {
    attributes["w:type"] = lineBreakType;
  }
  return {
    name: "w:r",
    elements: [
      {
        name: "w:br",
        attributes
      }
    ],
    attributes
  };
}
function translateTable(params2) {
  params2.node = preProcessVerticalMergeCells(params2.node, params2);
  const elements = translateChildNodes(params2);
  const tableProperties = generateTableProperties(params2.node);
  const gridProperties = generateTableGrid(params2.node, params2);
  elements.unshift(tableProperties);
  elements.unshift(gridProperties);
  return {
    name: "w:tbl",
    elements
  };
}
function preProcessVerticalMergeCells(table, { editorSchema }) {
  const { content } = table;
  for (let rowIndex = 0; rowIndex < content.length; rowIndex++) {
    const row = content[rowIndex];
    if (!row.content) continue;
    for (let cellIndex = 0; cellIndex < row.content?.length; cellIndex++) {
      const cell = row.content[cellIndex];
      if (!cell) continue;
      const { attrs } = cell;
      if (attrs.rowspan > 1) {
        const rowsToChange = content.slice(rowIndex + 1, rowIndex + attrs.rowspan);
        const mergedCell = {
          type: cell.type,
          content: [
            // cells must end with a paragraph
            editorSchema.nodes.paragraph.createAndFill().toJSON()
          ],
          attrs: {
            ...cell.attrs,
            // reset colspan and rowspan
            colspan: null,
            rowspan: null,
            // to add vMerge
            continueMerge: true
          }
        };
        rowsToChange.forEach((rowToChange) => {
          rowToChange.content.splice(cellIndex, 0, mergedCell);
        });
      }
    }
  }
  return table;
}
function translateTab(params2) {
  const { marks = [] } = params2.node;
  const outputMarks = processOutputMarks(marks);
  const tabNode = {
    name: "w:tab"
  };
  return wrapTextInRun(tabNode, outputMarks);
}
function generateTableProperties(node2) {
  const elements = [];
  const { attrs } = node2;
  const { tableWidth, tableStyleId, borders, tableIndent, tableLayout, tableCellSpacing, justification } = attrs;
  if (tableStyleId) {
    const tableStyleElement = {
      name: "w:tblStyle",
      attributes: { "w:val": tableStyleId }
    };
    elements.push(tableStyleElement);
  }
  if (borders) {
    const borderElement = generateTableBorders(node2);
    elements.push(borderElement);
  }
  if (tableIndent) {
    const { width, type: type2 } = tableIndent;
    const tableIndentElement = {
      name: "w:tblInd",
      attributes: { "w:w": pixelsToTwips(width), "w:type": type2 }
    };
    elements.push(tableIndentElement);
  }
  if (tableLayout) {
    const tableLayoutElement = {
      name: "w:tblLayout",
      attributes: { "w:type": tableLayout }
    };
    elements.push(tableLayoutElement);
  }
  if (tableWidth && tableWidth.width) {
    const tableWidthElement = {
      name: "w:tblW",
      attributes: { "w:w": pixelsToTwips(tableWidth.width), "w:type": tableWidth.type }
    };
    elements.push(tableWidthElement);
  }
  if (tableCellSpacing) {
    elements.push({
      name: "w:tblCellSpacing",
      attributes: {
        "w:w": tableCellSpacing.w,
        "w:type": tableCellSpacing.type
      }
    });
  }
  if (justification) {
    const justificationElement = {
      name: "w:jc",
      attributes: { "w:val": justification }
    };
    elements.push(justificationElement);
  }
  return {
    name: "w:tblPr",
    elements
  };
}
function generateTableBorders(node2) {
  const { borders } = node2.attrs;
  const elements = [];
  if (!borders) return;
  const borderTypes = ["top", "bottom", "left", "right", "insideH", "insideV"];
  borderTypes.forEach((type2) => {
    const border = borders[type2];
    if (!border) return;
    let attributes = {};
    if (!Object.keys(border).length || !border.size) {
      attributes = {
        "w:val": "nil"
      };
    } else {
      attributes = {
        "w:val": "single",
        "w:sz": pixelsToEightPoints(border.size),
        "w:space": border.space || 0,
        "w:color": border?.color?.substring(1) || "000000"
      };
    }
    const borderElement = {
      name: `w:${type2}`,
      attributes
    };
    elements.push(borderElement);
  });
  return {
    name: "w:tblBorders",
    elements
  };
}
function generateTableGrid(node2, params2) {
  const { editorSchema } = params2;
  let colgroup = [];
  try {
    const pmNode = editorSchema.nodeFromJSON(node2);
    const cellMinWidth = 10;
    const { colgroupValues } = createColGroup(pmNode, cellMinWidth);
    colgroup = colgroupValues;
  } catch {
    colgroup = [];
  }
  const elements = [];
  colgroup?.forEach((width) => {
    elements.push({
      name: "w:gridCol",
      attributes: { "w:w": pixelsToTwips(width) }
    });
  });
  return {
    name: "w:tblGrid",
    elements
  };
}
function translateTableRow(params2) {
  const elements = translateChildNodes(params2);
  const tableRowProperties = generateTableRowProperties(params2.node);
  if (tableRowProperties.elements.length) elements.unshift(tableRowProperties);
  return {
    name: "w:tr",
    elements
  };
}
function generateTableRowProperties(node2) {
  const { attrs } = node2;
  const elements = [];
  const { rowHeight, rowHeightType } = attrs;
  if (rowHeight) {
    const attributes = { "w:val": pixelsToTwips(rowHeight) };
    if (rowHeightType) attributes["w:hRule"] = rowHeightType;
    const rowHeightElement = {
      name: "w:trHeight",
      attributes
    };
    elements.push(rowHeightElement);
  }
  return {
    name: "w:trPr",
    elements
  };
}
function translateTableCell(params2) {
  const elements = translateChildNodes({
    ...params2,
    tableCell: params2.node
  });
  const cellProps = generateTableCellProperties(params2.node);
  elements.unshift(cellProps);
  return {
    name: "w:tc",
    elements
  };
}
function generateTableCellProperties(node2) {
  const elements = [];
  const { attrs } = node2;
  const { colwidth = [], cellWidthType = "dxa", background = {}, colspan, rowspan, widthUnit } = attrs;
  const colwidthSum = colwidth.reduce((acc, curr) => acc + curr, 0);
  const cellWidthElement = {
    name: "w:tcW",
    attributes: {
      "w:w": widthUnit === "px" ? pixelsToTwips(colwidthSum) : inchesToTwips(colwidthSum),
      "w:type": cellWidthType
    }
  };
  elements.push(cellWidthElement);
  if (colspan) {
    const gridSpanElement = {
      name: "w:gridSpan",
      attributes: { "w:val": `${colspan}` }
    };
    elements.push(gridSpanElement);
  }
  const { color } = background || {};
  if (color) {
    const cellBgElement = {
      name: "w:shd",
      attributes: { "w:fill": color }
    };
    elements.push(cellBgElement);
  }
  const { cellMargins } = attrs;
  if (cellMargins) {
    const cellMarginsElement = {
      name: "w:tcMar",
      elements: generateCellMargins(cellMargins)
    };
    elements.push(cellMarginsElement);
  }
  const { verticalAlign } = attrs;
  if (verticalAlign) {
    const vertAlignElement = {
      name: "w:vAlign",
      attributes: { "w:val": verticalAlign }
    };
    elements.push(vertAlignElement);
  }
  if (rowspan && rowspan > 1) {
    const vMergeElement = {
      name: "w:vMerge",
      type: "element",
      attributes: { "w:val": "restart" }
    };
    elements.push(vMergeElement);
  } else if (attrs.continueMerge) {
    const vMergeElement = {
      name: "w:vMerge",
      type: "element"
    };
    elements.push(vMergeElement);
  }
  const { borders = {} } = attrs;
  if (!!borders && Object.keys(borders).length) {
    const cellBordersElement = {
      name: "w:tcBorders",
      elements: Object.entries(borders).map(([key, value]) => {
        if (!value.size || value.val === "none") {
          return {
            name: `w:${key}`,
            attributes: {
              "w:val": "nil"
            }
          };
        }
        return {
          name: `w:${key}`,
          attributes: {
            "w:val": "single",
            "w:color": value.color ? value.color.substring(1) : "auto",
            "w:sz": pixelsToEightPoints(value.size),
            "w:space": value.space || 0
          }
        };
      })
    };
    elements.push(cellBordersElement);
  }
  return {
    name: "w:tcPr",
    elements
  };
}
function generateCellMargins(cellMargins) {
  const elements = [];
  const { top: top2, right: right2, bottom: bottom2, left: left2 } = cellMargins;
  if (top2 != null) elements.push({ name: "w:top", attributes: { "w:w": pixelsToTwips(top2) } });
  if (right2 != null) elements.push({ name: "w:right", attributes: { "w:w": pixelsToTwips(right2) } });
  if (bottom2 != null) elements.push({ name: "w:bottom", attributes: { "w:w": pixelsToTwips(bottom2) } });
  if (left2 != null) elements.push({ name: "w:left", attributes: { "w:w": pixelsToTwips(left2) } });
  return elements;
}
function translateBookmarkStart(params2) {
  const bookmarkStartNode = {
    name: "w:bookmarkStart",
    attributes: {
      "w:id": params2.node.attrs.id,
      "w:name": params2.node.attrs.name
    }
  };
  const bookmarkEndNode = {
    name: "w:bookmarkEnd",
    attributes: {
      "w:id": params2.node.attrs.id
    }
  };
  return [bookmarkStartNode, bookmarkEndNode];
}
function translateMark(mark) {
  const xmlMark = SuperConverter.markTypes.find((m2) => m2.type === mark.type);
  if (!xmlMark) {
    return {};
  }
  const markElement = { name: xmlMark.name, attributes: {} };
  const { attrs } = mark;
  let value;
  switch (mark.type) {
    case "bold":
      if (attrs?.value) {
        markElement.attributes["w:val"] = attrs.value;
      } else {
        delete markElement.attributes;
      }
      markElement.type = "element";
      break;
    case "italic":
      delete markElement.attributes;
      markElement.type = "element";
      break;
    case "underline":
      markElement.type = "element";
      markElement.attributes["w:val"] = attrs.underlineType;
      break;
    // Text style cases
    case "fontSize":
      value = attrs.fontSize;
      markElement.attributes["w:val"] = value.slice(0, -2) * 2;
      break;
    case "fontFamily":
      value = attrs.fontFamily;
      ["w:ascii", "w:eastAsia", "w:hAnsi", "w:cs"].forEach((attr) => {
        const parsedValue = value.split(", ");
        markElement.attributes[attr] = parsedValue[0] ? parsedValue[0] : value;
      });
      break;
    // Add ability to get run styleIds from textStyle marks and inject to run properties in word
    case "styleId":
      markElement.name = "w:rStyle";
      markElement.attributes["w:val"] = attrs.styleId;
      break;
    case "color":
      let processedColor = attrs.color.replace(/^#/, "").replace(/;$/, "");
      if (processedColor.startsWith("rgb")) {
        processedColor = rgbToHex(processedColor);
      }
      markElement.attributes["w:val"] = processedColor;
      break;
    case "textAlign":
      markElement.attributes["w:val"] = attrs.textAlign;
      break;
    case "textIndent":
      markElement.attributes["w:firstline"] = inchesToTwips(attrs.textIndent);
      break;
    case "textTransform":
      if (attrs?.textTransform === "none") {
        markElement.attributes["w:val"] = "0";
      } else {
        delete markElement.attributes;
      }
      markElement.type = "element";
      break;
    case "lineHeight":
      markElement.attributes["w:line"] = linesToTwips(attrs.lineHeight);
      break;
    case "highlight":
      markElement.attributes["w:fill"] = attrs.color?.substring(1);
      markElement.attributes["w:color"] = "auto";
      markElement.attributes["w:val"] = "clear";
      markElement.name = "w:shd";
      break;
  }
  return markElement;
}
function getPngDimensions(base64) {
  if (!base64) return {};
  const type2 = base64.split(";")[0].split("/")[1];
  if (!base64 || type2 !== "png") {
    return {
      originalWidth: void 0,
      originalHeight: void 0
    };
  }
  let header = base64.split(",")[1].slice(0, 50);
  let uint8 = Uint8Array.from(atob(header), (c2) => c2.charCodeAt(0));
  let dataView = new DataView(uint8.buffer, 0, 28);
  return {
    originalWidth: dataView.getInt32(16),
    originalHeight: dataView.getInt32(20)
  };
}
function getScaledSize(originalWidth, originalHeight, maxWidth, maxHeight) {
  let scaledWidth = originalWidth;
  let scaledHeight = originalHeight;
  let ratio = Math.min(maxWidth / originalWidth, maxHeight / originalHeight);
  scaledWidth = Math.round(scaledWidth * ratio);
  scaledHeight = Math.round(scaledHeight * ratio);
  return { scaledWidth, scaledHeight };
}
function translateImageNode(params2, imageSize) {
  const {
    node: { attrs = {} },
    tableCell
  } = params2;
  let imageId = attrs.rId;
  const src = attrs.src || attrs.imageSrc;
  const { originalWidth, originalHeight } = getPngDimensions(src);
  const imageName = params2.node.type === "image" ? src?.split("word/media/")[1] : attrs.fieldId?.replace("-", "_");
  let size2 = attrs.size ? {
    w: pixelsToEmu(attrs.size.width),
    h: pixelsToEmu(attrs.size.height)
  } : imageSize;
  if (originalWidth && originalHeight) {
    const boxWidthPx = emuToPixels(size2.w);
    const boxHeightPx = emuToPixels(size2.h);
    const { scaledWidth, scaledHeight } = getScaledSize(originalWidth, originalHeight, boxWidthPx, boxHeightPx);
    size2 = {
      w: pixelsToEmu(scaledWidth),
      h: pixelsToEmu(scaledHeight)
    };
  }
  if (tableCell) {
    const colwidthSum = tableCell.attrs.colwidth.reduce((acc, curr) => acc + curr, 0);
    const leftMargin = tableCell.attrs.cellMargins?.left || 8;
    const rightMargin = tableCell.attrs.cellMargins?.right || 8;
    const maxWidthEmu = pixelsToEmu(colwidthSum - (leftMargin + rightMargin));
    const { width: w2, height: h2 } = resizeKeepAspectRatio(size2.w, size2.h, maxWidthEmu);
    if (w2 && h2) size2 = { w: w2, h: h2 };
  }
  if (params2.node.type === "image" && !imageId) {
    const path = src?.split("word/")[1];
    imageId = addNewImageRelationship(params2, path);
  } else if (params2.node.type === "fieldAnnotation" && !imageId) {
    const type2 = src?.split(";")[0].split("/")[1];
    if (!type2) {
      return prepareTextAnnotation(params2);
    }
    const imageUrl = `media/${imageName}_${attrs.hash}.${type2}`;
    imageId = addNewImageRelationship(params2, imageUrl);
    params2.media[`${imageName}_${attrs.hash}.${type2}`] = src;
  }
  let inlineAttrs = attrs.originalPadding || {
    distT: 0,
    distB: 0,
    distL: 0,
    distR: 0
  };
  const anchorElements = [];
  let wrapProp = [];
  if (attrs.isAnchor) {
    inlineAttrs = {
      ...inlineAttrs,
      simplePos: attrs.originalAttributes?.simplePos,
      relativeHeight: 1,
      behindDoc: attrs.originalAttributes?.behindDoc,
      locked: attrs.originalAttributes?.locked,
      layoutInCell: attrs.originalAttributes?.layoutInCell,
      allowOverlap: attrs.originalAttributes?.allowOverlap
    };
    if (attrs.simplePos) {
      anchorElements.push({
        name: "wp:simplePos",
        attributes: {
          x: 0,
          y: 0
        }
      });
    }
    if (attrs.anchorData) {
      anchorElements.push({
        name: "wp:positionH",
        attributes: {
          relativeFrom: attrs.anchorData.hRelativeFrom
        },
        ...attrs.marginOffset.left !== void 0 && {
          elements: [
            {
              name: "wp:posOffset",
              elements: [
                {
                  type: "text",
                  text: pixelsToEmu(attrs.marginOffset.left).toString()
                }
              ]
            }
          ]
        },
        ...attrs.anchorData.alignH && {
          elements: [
            {
              name: "wp:align",
              elements: [
                {
                  type: "text",
                  text: attrs.anchorData.alignH
                }
              ]
            }
          ]
        }
      });
      anchorElements.push({
        name: "wp:positionV",
        attributes: {
          relativeFrom: attrs.anchorData.vRelativeFrom
        },
        ...attrs.marginOffset.top !== void 0 && {
          elements: [
            {
              name: "wp:posOffset",
              elements: [
                {
                  type: "text",
                  text: pixelsToEmu(attrs.marginOffset.top).toString()
                }
              ]
            }
          ]
        },
        ...attrs.anchorData.alignV && {
          elements: [
            {
              name: "wp:align",
              elements: [
                {
                  type: "text",
                  text: attrs.anchorData.alignV
                }
              ]
            }
          ]
        }
      });
    }
    if (attrs.wrapText) {
      wrapProp.push({
        name: "wp:wrapSquare",
        attributes: {
          wrapText: attrs.wrapText
        }
      });
    }
    if (attrs.wrapTopAndBottom) {
      wrapProp.push({
        name: "wp:wrapTopAndBottom"
      });
    }
    if (attrs.isAnchor && !wrapProp.length) {
      wrapProp.push({
        name: "wp:wrapNone"
      });
    }
  }
  const drawingXmlns = "http://schemas.openxmlformats.org/drawingml/2006/main";
  const pictureXmlns = "http://schemas.openxmlformats.org/drawingml/2006/picture";
  const textNode = wrapTextInRun(
    {
      name: "w:drawing",
      elements: [
        {
          name: attrs.isAnchor ? "wp:anchor" : "wp:inline",
          attributes: inlineAttrs,
          elements: [
            ...anchorElements,
            {
              name: "wp:extent",
              attributes: {
                cx: size2.w,
                cy: size2.h
              }
            },
            {
              name: "wp:effectExtent",
              attributes: {
                l: 0,
                t: 0,
                r: 0,
                b: 0
              }
            },
            ...wrapProp,
            {
              name: "wp:docPr",
              attributes: {
                id: attrs.id || 0,
                name: attrs.alt || `Picture ${imageName}`
              }
            },
            {
              name: "wp:cNvGraphicFramePr",
              elements: [
                {
                  name: "a:graphicFrameLocks",
                  attributes: {
                    "xmlns:a": drawingXmlns,
                    noChangeAspect: 1
                  }
                }
              ]
            },
            {
              name: "a:graphic",
              attributes: { "xmlns:a": drawingXmlns },
              elements: [
                {
                  name: "a:graphicData",
                  attributes: { uri: pictureXmlns },
                  elements: [
                    {
                      name: "pic:pic",
                      attributes: { "xmlns:pic": pictureXmlns },
                      elements: [
                        {
                          name: "pic:nvPicPr",
                          elements: [
                            {
                              name: "pic:cNvPr",
                              attributes: {
                                id: attrs.id || 0,
                                name: attrs.title || `Picture ${imageName}`
                              }
                            },
                            {
                              name: "pic:cNvPicPr",
                              elements: [
                                {
                                  name: "a:picLocks",
                                  attributes: {
                                    noChangeAspect: 1,
                                    noChangeArrowheads: 1
                                  }
                                }
                              ]
                            }
                          ]
                        },
                        {
                          name: "pic:blipFill",
                          elements: [
                            {
                              name: "a:blip",
                              attributes: {
                                "r:embed": imageId
                              }
                            },
                            {
                              name: "a:stretch",
                              elements: [{ name: "a:fillRect" }]
                            }
                          ]
                        },
                        {
                          name: "pic:spPr",
                          attributes: {
                            bwMode: "auto"
                          },
                          elements: [
                            {
                              name: "a:xfrm",
                              elements: [
                                {
                                  name: "a:ext",
                                  attributes: {
                                    cx: size2.w,
                                    cy: size2.h
                                  }
                                },
                                {
                                  name: "a:off",
                                  attributes: {
                                    x: 0,
                                    y: 0
                                  }
                                }
                              ]
                            },
                            {
                              name: "a:prstGeom",
                              attributes: { prst: "rect" },
                              elements: [{ name: "a:avLst" }]
                            },
                            {
                              name: "a:noFill"
                            }
                          ]
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    []
  );
  return textNode;
}
function prepareTextAnnotation(params2) {
  const {
    node: { attrs = {}, marks = [] }
  } = params2;
  const marksFromAttrs = translateFieldAttrsToMarks(attrs);
  return getTextNodeForExport(attrs.displayLabel, [...marks, ...marksFromAttrs], params2);
}
function prepareCheckboxAnnotation(params2) {
  const {
    node: { attrs = {}, marks = [] }
  } = params2;
  const content = he$1.decode(attrs.displayLabel);
  return getTextNodeForExport(content, marks, params2);
}
function prepareHtmlAnnotation(params2) {
  const {
    node: { attrs = {}, marks = [] },
    editorSchema
  } = params2;
  let html = attrs.rawHtml || attrs.displayLabel;
  const paragraphHtmlContainer = sanitizeHtml(html);
  const marksFromAttrs = translateFieldAttrsToMarks(attrs);
  const allMarks = [...marks, ...marksFromAttrs];
  let state2 = EditorState.create({
    doc: DOMParser$1.fromSchema(editorSchema).parse(paragraphHtmlContainer)
  });
  if (allMarks.length) {
    state2 = applyMarksToHtmlAnnotation(state2, allMarks);
  }
  const htmlAnnotationNode = state2.doc.toJSON();
  const listTypes = ["bulletList", "orderedList"];
  const { editor } = params2;
  const seenLists = /* @__PURE__ */ new Map();
  state2.doc.descendants((node2) => {
    if (listTypes.includes(node2.type.name)) {
      const listItem = node2.firstChild;
      const { attrs: attrs2 } = listItem;
      const { level, numId } = attrs2;
      if (!seenLists.has(numId)) {
        const newNumId = ListHelpers.changeNumIdSameAbstract(numId, level, node2.type.name, editor);
        listItem.attrs.numId = newNumId;
        seenLists.set(numId, newNumId);
      } else {
        const newNumId = seenLists.get(numId);
        listItem.attrs.numId = newNumId;
      }
    }
  });
  const elements = translateChildNodes({
    ...params2,
    node: htmlAnnotationNode
  });
  return {
    name: "htmlAnnotation",
    elements
  };
}
function prepareImageAnnotation(params2, imageSize) {
  return translateImageNode(params2, imageSize);
}
function prepareUrlAnnotation(params2) {
  const {
    node: { attrs = {}, marks = [] }
  } = params2;
  const newId = addNewLinkRelationship(params2, attrs.linkUrl);
  const linkTextNode = getTextNodeForExport(attrs.linkUrl, marks, params2);
  const contentNode = processLinkContentNode(linkTextNode);
  return {
    name: "w:hyperlink",
    type: "element",
    attributes: {
      "r:id": newId,
      "w:history": 1
    },
    elements: [contentNode]
  };
}
function getTranslationByAnnotationType(annotationType, annotationFieldType) {
  if (annotationType === "text" && annotationFieldType === "FILEUPLOADER") {
    return null;
  }
  const imageEmuSize = {
    w: 4286250,
    h: 4286250
  };
  const signatureEmuSize = {
    w: 99e4,
    h: 495e3
  };
  const dictionary = {
    text: prepareTextAnnotation,
    image: (params2) => prepareImageAnnotation(params2, imageEmuSize),
    signature: (params2) => prepareImageAnnotation(params2, signatureEmuSize),
    checkbox: prepareCheckboxAnnotation,
    html: prepareHtmlAnnotation,
    link: prepareUrlAnnotation
  };
  return dictionary[annotationType];
}
const translateFieldAttrsToMarks = (attrs = {}) => {
  const { fontFamily: fontFamily2, fontSize: fontSize2, bold, underline, italic, textColor, textHighlight } = attrs;
  const marks = [];
  if (fontFamily2) marks.push({ type: "fontFamily", attrs: { fontFamily: fontFamily2 } });
  if (fontSize2) marks.push({ type: "fontSize", attrs: { fontSize: fontSize2 } });
  if (bold) marks.push({ type: "bold", attrs: {} });
  if (underline) marks.push({ type: "underline", attrs: {} });
  if (italic) marks.push({ type: "italic", attrs: {} });
  if (textColor) marks.push({ type: "color", attrs: { color: textColor } });
  if (textHighlight) marks.push({ type: "highlight", attrs: { color: textHighlight } });
  return marks;
};
function translateFieldAnnotation(params2) {
  const { node: node2, isFinalDoc, fieldsHighlightColor } = params2;
  const { attrs = {} } = node2;
  const annotationHandler = getTranslationByAnnotationType(attrs.type, attrs.fieldType);
  if (!annotationHandler) return {};
  let processedNode;
  let sdtContentElements;
  if ((attrs.type === "image" || attrs.type === "signature") && !attrs.hash) {
    attrs.hash = generateDocxRandomId(4);
  }
  if (isFinalDoc) {
    return annotationHandler(params2);
  } else {
    processedNode = annotationHandler(params2);
    sdtContentElements = [processedNode];
    if (attrs.type === "html") {
      sdtContentElements = [...processedNode.elements];
    }
  }
  sdtContentElements = [...sdtContentElements];
  const fieldBackgroundTag = getFieldHighlightJson(fieldsHighlightColor);
  if (fieldBackgroundTag) {
    sdtContentElements.unshift(fieldBackgroundTag);
  }
  const annotationAttrs = {
    displayLabel: attrs.displayLabel,
    defaultDisplayLabel: attrs.defaultDisplayLabel,
    fieldId: attrs.fieldId,
    fieldType: attrs.fieldType,
    fieldTypeShort: attrs.type,
    fieldColor: attrs.fieldColor,
    fieldMultipleImage: attrs.multipleImage,
    fieldFontFamily: attrs.fontFamily,
    fieldFontSize: attrs.fontSize,
    fieldTextColor: attrs.textColor,
    fieldTextHighlight: attrs.textHighlight,
    hash: attrs.hash
  };
  const annotationAttrsJson = JSON.stringify(annotationAttrs);
  const result = {
    name: "w:sdt",
    elements: [
      {
        name: "w:sdtPr",
        elements: [
          { name: "w:tag", attributes: { "w:val": annotationAttrsJson } },
          { name: "w:alias", attributes: { "w:val": attrs.displayLabel } }
        ]
      },
      {
        name: "w:sdtContent",
        elements: sdtContentElements
      }
    ]
  };
  return result;
}
function translateHardBreak(params2) {
  const { node: node2 = {} } = params2;
  const { attrs = {} } = node2;
  const { pageBreakSource } = attrs;
  if (pageBreakSource === "sectPr") return null;
  return {
    name: "w:r",
    elements: [
      {
        name: "w:br",
        type: "element",
        attributes: { "w:type": "page" }
      }
    ]
  };
}
function translateShapeContainer(params2) {
  const { node: node2 } = params2;
  const elements = translateChildNodes(params2);
  const shape = {
    name: "v:shape",
    attributes: {
      ...node2.attrs.attributes,
      fillcolor: node2.attrs.fillcolor
    },
    elements: [
      ...elements,
      ...node2.attrs.wrapAttributes ? [
        {
          name: "w10:wrap",
          attributes: { ...node2.attrs.wrapAttributes }
        }
      ] : []
    ]
  };
  const pict = {
    name: "w:pict",
    attributes: {
      "w14:anchorId": Math.floor(Math.random() * 4294967295).toString()
    },
    elements: [shape]
  };
  const par = {
    name: "w:p",
    elements: [wrapTextInRun(pict)]
  };
  return par;
}
function translateShapeTextbox(params2) {
  const { node: node2 } = params2;
  const elements = translateChildNodes(params2);
  const textboxContent = {
    name: "w:txbxContent",
    elements
  };
  const textbox = {
    name: "v:textbox",
    attributes: {
      ...node2.attrs.attributes
    },
    elements: [textboxContent]
  };
  return textbox;
}
function translateContentBlock(params2) {
  const { node: node2 } = params2;
  const { drawingContent, vmlAttributes, horizontalRule } = node2.attrs;
  if (vmlAttributes || horizontalRule) {
    return translateVRectContentBlock(params2);
  }
  const drawing = {
    name: "w:drawing",
    elements: [...drawingContent ? [...drawingContent.elements || []] : []]
  };
  const choice = {
    name: "mc:Choice",
    attributes: { Requires: "wps" },
    elements: [drawing]
  };
  const alternateContent = {
    name: "mc:AlternateContent",
    elements: [choice]
  };
  return wrapTextInRun(alternateContent);
}
function translateVRectContentBlock(params2) {
  const { node: node2 } = params2;
  const { vmlAttributes, background, attributes, style: style2 } = node2.attrs;
  const rectAttrs = {
    id: attributes?.id || `_x0000_i${Math.floor(Math.random() * 1e4)}`
  };
  if (style2) {
    rectAttrs.style = style2;
  }
  if (background) {
    rectAttrs.fillcolor = background;
  }
  if (vmlAttributes) {
    if (vmlAttributes.hralign) rectAttrs["o:hralign"] = vmlAttributes.hralign;
    if (vmlAttributes.hrstd) rectAttrs["o:hrstd"] = vmlAttributes.hrstd;
    if (vmlAttributes.hr) rectAttrs["o:hr"] = vmlAttributes.hr;
    if (vmlAttributes.stroked) rectAttrs.stroked = vmlAttributes.stroked;
  }
  if (attributes) {
    Object.entries(attributes).forEach(([key, value]) => {
      if (!rectAttrs[key] && value !== void 0) {
        rectAttrs[key] = value;
      }
    });
  }
  const rect = {
    name: "v:rect",
    attributes: rectAttrs
  };
  const pict = {
    name: "w:pict",
    attributes: {
      "w14:anchorId": Math.floor(Math.random() * 4294967295).toString()
    },
    elements: [rect]
  };
  return wrapTextInRun(pict);
}
class DocxExporter {
  constructor(converter) {
    __privateAdd$2(this, _DocxExporter_instances);
    this.converter = converter;
  }
  schemaToXml(data, debug = false) {
    const result = __privateMethod$2(this, _DocxExporter_instances, generate_xml_as_list_fn).call(this, data, debug);
    return result.join("");
  }
}
_DocxExporter_instances = /* @__PURE__ */ new WeakSet();
generate_xml_as_list_fn = function(data, debug = false) {
  const json = JSON.parse(JSON.stringify(data));
  const declaration = this.converter.declaration.attributes;
  const xmlTag = `<?xml${Object.entries(declaration).map(([key, value]) => ` ${key}="${value}"`).join("")}?>`;
  const result = __privateMethod$2(this, _DocxExporter_instances, generateXml_fn).call(this, json, debug);
  const final = [xmlTag, ...result];
  return final;
};
replaceSpecialCharacters_fn = function(text) {
  if (!text) return;
  return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
};
generateXml_fn = function(node2) {
  if (!node2) return null;
  let { name } = node2;
  const { elements, attributes } = node2;
  let tag = `<${name}`;
  for (let attr in attributes) {
    const parsedAttrName = typeof attributes[attr] === "string" ? __privateMethod$2(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, attributes[attr]) : attributes[attr];
    tag += ` ${attr}="${parsedAttrName}"`;
  }
  const selfClosing = name && (!elements || !elements.length);
  if (selfClosing) tag += " />";
  else tag += ">";
  let tags = [tag];
  if (!name && node2.type === "text") {
    return node2.text;
  }
  if (elements) {
    if (name === "w:instrText") {
      tags.push(elements[0].text);
    } else if (name === "w:t" || name === "w:delText" || name === "wp:posOffset") {
      try {
        let text = String(elements[0].text);
        text = __privateMethod$2(this, _DocxExporter_instances, replaceSpecialCharacters_fn).call(this, text);
        tags.push(text);
      } catch (error) {
        console.error("Text element does not contain valid string:", error);
      }
    } else {
      if (elements) {
        for (let child of elements) {
          const newElements = __privateMethod$2(this, _DocxExporter_instances, generateXml_fn).call(this, child);
          if (!newElements) continue;
          if (typeof newElements === "string") {
            tags.push(newElements);
            continue;
          }
          const removeUndefined = newElements.filter((el) => {
            return el !== "<undefined>" && el !== "</undefined>";
          });
          tags.push(...removeUndefined);
        }
      }
    }
  }
  if (!selfClosing) tags.push(`</${name}>`);
  return tags;
};
function resizeKeepAspectRatio(width, height, maxWidth) {
  if (width > maxWidth) {
    let scale = maxWidth / width;
    let newHeight = Math.round(height * scale);
    return { width: maxWidth, height: newHeight };
  }
  return { width, height };
}
function applyMarksToHtmlAnnotation(state2, marks) {
  const { tr, doc: doc2, schema } = state2;
  const allowedMarks = ["fontFamily", "fontSize", "highlight"];
  if (!marks.some((m2) => allowedMarks.includes(m2.type))) {
    return state2;
  }
  const fontFamily2 = marks.find((m2) => m2.type === "fontFamily");
  const fontSize2 = marks.find((m2) => m2.type === "fontSize");
  const highlight = marks.find((m2) => m2.type === "highlight");
  const textStyleType = schema.marks.textStyle;
  const highlightType = schema.marks.highlight;
  doc2.descendants((node2, pos) => {
    if (!node2.isText) return;
    const foundTextStyle = node2.marks.find((m2) => m2.type.name === "textStyle");
    const foundHighlight = node2.marks.find((m2) => m2.type.name === "highlight");
    if (!foundTextStyle) {
      tr.addMark(
        pos,
        pos + node2.nodeSize,
        textStyleType.create({
          ...fontFamily2?.attrs,
          ...fontSize2?.attrs
        })
      );
    } else if (!foundTextStyle?.attrs.fontFamily && fontFamily2) {
      tr.addMark(
        pos,
        pos + node2.nodeSize,
        textStyleType.create({
          ...foundTextStyle?.attrs,
          ...fontFamily2.attrs
        })
      );
    } else if (!foundTextStyle?.attrs.fontSize && fontSize2) {
      tr.addMark(
        pos,
        pos + node2.nodeSize,
        textStyleType.create({
          ...foundTextStyle?.attrs,
          ...fontSize2.attrs
        })
      );
    }
    if (!foundHighlight) {
      tr.addMark(
        pos,
        pos + node2.nodeSize,
        highlightType.create({
          ...highlight?.attrs
        })
      );
    }
  });
  return state2.apply(tr);
}
function translateStructuredContent(params2) {
  const { node: node2 } = params2;
  const { attrs = {} } = node2;
  const childContent = translateChildNodes({ ...params2, nodes: node2.content });
  const nodeElements = [
    {
      name: "w:sdtContent",
      elements: childContent
    }
  ];
  nodeElements.unshift(attrs.sdtPr);
  return {
    name: "w:sdt",
    elements: nodeElements
  };
}
const translatePageNumberNode = (params2) => {
  const outputMarks = processOutputMarks(params2.node.attrs?.marksAsAttrs || []);
  return getAutoPageJson("PAGE", outputMarks);
};
const translateTotalPageNumberNode = (params2) => {
  const outputMarks = processOutputMarks(params2.node.attrs?.marksAsAttrs || []);
  return getAutoPageJson("NUMPAGES", outputMarks);
};
const getAutoPageJson = (type2, outputMarks = []) => {
  return [
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "begin"
          }
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:instrText",
          elements: [
            {
              type: "text",
              text: ` ${type2}`
            }
          ]
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "separate"
          }
        }
      ]
    },
    {
      name: "w:r",
      elements: [
        {
          name: "w:rPr",
          elements: outputMarks
        },
        {
          name: "w:fldChar",
          attributes: {
            "w:fldCharType": "end"
          }
        }
      ]
    }
  ];
};
const getFieldHighlightJson = (fieldsHighlightColor) => {
  if (!fieldsHighlightColor) return null;
  let parsedColor = fieldsHighlightColor.trim();
  const hexRegex2 = /^#?([A-Fa-f0-9]{3}|[A-Fa-f0-9]{4}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{8})$/;
  if (!hexRegex2.test(parsedColor)) {
    console.warn(`Invalid HEX color provided to fieldsHighlightColor export param: ${fieldsHighlightColor}`);
    return null;
  }
  if (parsedColor.startsWith("#")) {
    parsedColor = parsedColor.slice(1);
  }
  return {
    name: "w:rPr",
    elements: [
      {
        name: "w:shd",
        attributes: {
          "w:fill": `#${parsedColor}`,
          "w:color": "auto",
          "w:val": "clear"
        }
      }
    ]
  };
};
const defaultInitialXml = `<w:document xmlns:wpc="http://schemas.microsoft.com/office/word/2010/wordprocessingCanvas" xmlns:cx="http://schemas.microsoft.com/office/drawing/2014/chartex" xmlns:cx1="http://schemas.microsoft.com/office/drawing/2015/9/8/chartex" xmlns:cx2="http://schemas.microsoft.com/office/drawing/2015/10/21/chartex" xmlns:cx3="http://schemas.microsoft.com/office/drawing/2016/5/9/chartex" xmlns:cx4="http://schemas.microsoft.com/office/drawing/2016/5/10/chartex" xmlns:cx5="http://schemas.microsoft.com/office/drawing/2016/5/11/chartex" xmlns:cx6="http://schemas.microsoft.com/office/drawing/2016/5/12/chartex" xmlns:cx7="http://schemas.microsoft.com/office/drawing/2016/5/13/chartex" xmlns:cx8="http://schemas.microsoft.com/office/drawing/2016/5/14/chartex" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:aink="http://schemas.microsoft.com/office/drawing/2016/ink" xmlns:am3d="http://schemas.microsoft.com/office/drawing/2017/model3d" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:oel="http://schemas.microsoft.com/office/2019/extlst" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:m="http://schemas.openxmlformats.org/officeDocument/2006/math" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:wp14="http://schemas.microsoft.com/office/word/2010/wordprocessingDrawing" xmlns:wp="http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing" xmlns:w10="urn:schemas-microsoft-com:office:word" xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main" xmlns:w14="http://schemas.microsoft.com/office/word/2010/wordml" xmlns:w15="http://schemas.microsoft.com/office/word/2012/wordml" xmlns:w16cex="http://schemas.microsoft.com/office/word/2018/wordml/cex" xmlns:w16cid="http://schemas.microsoft.com/office/word/2016/wordml/cid" xmlns:w16="http://schemas.microsoft.com/office/word/2018/wordml" xmlns:w16sdtdh="http://schemas.microsoft.com/office/word/2020/wordml/sdtdatahash" xmlns:w16se="http://schemas.microsoft.com/office/word/2015/wordml/symex" xmlns:wpg="http://schemas.microsoft.com/office/word/2010/wordprocessingGroup" xmlns:wpi="http://schemas.microsoft.com/office/word/2010/wordprocessingInk" xmlns:wne="http://schemas.microsoft.com/office/word/2006/wordml" xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape" mc:Ignorable="w14 w15 w16se w16cid w16 w16cex w16sdtdh wp14"><w:body></w:body></w:document>`;
const parseXmlToJson = (xml) => {
  return JSON.parse(xmljs.xml2json(xml, null, 2));
};
const getInitialJSON = (parsedDocx, fallbackXml = defaultInitialXml) => {
  return parsedDocx["word/document.xml"] || parseXmlToJson(fallbackXml);
};
const handleAllTableNodes = (params2) => {
  const { nodes } = params2;
  if (nodes.length === 0) {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  switch (node2.name) {
    case "w:tbl":
      return { nodes: [handleTableNode(node2, params2)], consumed: 1 };
  }
  return { nodes: [], consumed: 0 };
};
const tableNodeHandlerEntity = {
  handlerName: "tableNodeHandler",
  handler: handleAllTableNodes
};
function handleTableNode(node2, params2) {
  const { docx, nodeListHandler: nodeListHandler2 } = params2;
  const tblPr = node2.elements.find((el) => el.name === "w:tblPr");
  const tableBordersElement = tblPr.elements.find((el) => el.name === "w:tblBorders");
  const tableBorders = tableBordersElement?.elements || [];
  const { borders, rowBorders } = processTableBorders(tableBorders);
  const tblStyleTag = tblPr.elements.find((el) => el.name === "w:tblStyle");
  const tableStyleId = tblStyleTag?.attributes["w:val"];
  const attrs = { tableStyleId };
  const tableIndent = tblPr?.elements.find((el) => el.name === "w:tblInd");
  if (tableIndent) {
    const { "w:w": width, "w:type": type2 } = tableIndent.attributes;
    attrs["tableIndent"] = { width: twipsToPixels(width), type: type2 };
  }
  const tableLayout = tblPr?.elements.find((el) => el.name === "w:tblLayout");
  if (tableLayout) {
    const { "w:type": type2 } = tableLayout.attributes;
    attrs["tableLayout"] = type2;
  }
  const referencedStyles = getReferencedTableStyles(tblStyleTag, docx);
  const tblW = tblPr.elements.find((el) => el.name === "w:tblW");
  if (tblW) {
    attrs["tableWidth"] = {
      width: twipsToPixels(tblW.attributes["w:w"]),
      type: tblW.attributes["w:type"]
    };
  }
  const tblCellSpacing = tblPr.elements.find((el) => el.name === "w:tblCellSpacing");
  if (tblCellSpacing) {
    attrs["tableCellSpacing"] = {
      w: tblCellSpacing.attributes["w:w"],
      type: tblCellSpacing.attributes["w:type"]
    };
    attrs["borderCollapse"] = "separate";
  }
  const tblJustification = tblPr.elements.find((el) => el.name === "w:jc");
  if (tblJustification?.attributes) {
    attrs["justification"] = tblJustification.attributes["w:val"];
  }
  const rows = node2.elements.filter((el) => el.name === "w:tr");
  const refStylesBorders = referencedStyles?.borders || {};
  const refStylesRowBorders = referencedStyles?.rowBorders || {};
  const borderData = Object.keys(borders)?.length ? Object.assign(refStylesBorders, borders) : refStylesBorders;
  const borderRowData = Object.keys(rowBorders)?.length ? Object.assign(refStylesRowBorders, rowBorders) : refStylesRowBorders;
  attrs["borders"] = borderData;
  const content = [];
  rows.forEach((row) => {
    const result = handleTableRowNode(row, node2, borderRowData, tblStyleTag, params2);
    if (result.content?.length) content.push(result);
  });
  return {
    type: "table",
    content,
    attrs
  };
}
function handleTableCellNode(node2, row, table, rowBorders, columnWidth = null, styleTag, params2, columnIndex) {
  const { docx, nodeListHandler: nodeListHandler2 } = params2;
  const tcPr = node2.elements.find((el) => el.name === "w:tcPr");
  const borders = tcPr?.elements?.find((el) => el.name === "w:tcBorders");
  const inlineBorders = processInlineCellBorders(borders, rowBorders);
  const gridColumnWidths = getGridColumnWidths(table);
  const tcWidth = tcPr?.elements?.find((el) => el.name === "w:tcW");
  let width = tcWidth ? twipsToPixels(tcWidth.attributes["w:w"]) : null;
  const widthType = tcWidth?.attributes["w:type"];
  if (!width && columnWidth) width = columnWidth;
  const vMerge = getTableCellMergeTag(node2);
  const { attributes: vMergeAttrs } = vMerge || {};
  const backgroundColor = tcPr?.elements?.find((el) => el.name === "w:shd");
  const background = {
    color: backgroundColor?.attributes["w:fill"]
  };
  const colspanTag = tcPr?.elements?.find((el) => el.name === "w:gridSpan");
  const colspan = colspanTag?.attributes["w:val"];
  const marginTag = tcPr?.elements?.find((el) => el.name === "w:tcMar");
  const verticalAlignTag = tcPr?.elements?.find((el) => el.name === "w:vAlign");
  const verticalAlign = verticalAlignTag?.attributes["w:val"] || "top";
  const attributes = {};
  const referencedStyles = getReferencedTableStyles(styleTag, docx) || {};
  attributes.cellMargins = getTableCellMargins(marginTag, referencedStyles);
  const { fontSize: fontSize2, fonts = {} } = referencedStyles;
  const fontFamily2 = fonts["ascii"];
  if (width) {
    attributes["colwidth"] = [width];
    attributes["widthUnit"] = "px";
    const defaultColWidths = gridColumnWidths;
    const hasDefaultColWidths = gridColumnWidths && gridColumnWidths.length > 0;
    const colspanNum = parseInt(colspan || 1, 10);
    if (colspanNum && colspanNum > 1 && hasDefaultColWidths) {
      let colwidth = [];
      for (let i = 0; i < colspanNum; i++) {
        let colwidthValue = defaultColWidths[columnIndex + i];
        let defaultColwidth = 100;
        if (typeof colwidthValue !== "undefined") {
          colwidth.push(colwidthValue);
        } else {
          colwidth.push(defaultColwidth);
        }
      }
      if (colwidth.length) {
        attributes["colwidth"] = [...colwidth];
      }
    }
  }
  if (widthType) attributes["widthType"] = widthType;
  if (colspan) attributes["colspan"] = parseInt(colspan, 10);
  if (background) attributes["background"] = background;
  attributes["verticalAlign"] = verticalAlign;
  if (fontSize2) attributes["fontSize"] = fontSize2;
  if (fontFamily2) attributes["fontFamily"] = fontFamily2["ascii"];
  if (rowBorders) attributes["borders"] = { ...rowBorders };
  if (inlineBorders) attributes["borders"] = Object.assign(attributes["borders"] || {}, inlineBorders);
  if (vMergeAttrs && vMergeAttrs["w:val"] === "restart") {
    const rows = table.elements.filter((el) => el.name === "w:tr");
    const currentRowIndex = rows.findIndex((r2) => r2 === row);
    const remainingRows = rows.slice(currentRowIndex + 1);
    const cellsInRow = row.elements.filter((el) => el.name === "w:tc");
    let cellIndex = cellsInRow.findIndex((el) => el === node2);
    let rowspan = 1;
    for (let remainingRow of remainingRows) {
      const firstCell = remainingRow.elements.findIndex((el) => el.name === "w:tc");
      const cellAtIndex = remainingRow.elements[firstCell + cellIndex];
      if (!cellAtIndex) break;
      const vMerge2 = getTableCellMergeTag(cellAtIndex);
      const { attributes: currentCellMergeAttrs } = vMerge2 || {};
      if (!vMerge2 && !currentCellMergeAttrs || currentCellMergeAttrs && currentCellMergeAttrs["w:val"] === "restart") {
        break;
      }
      rowspan++;
      remainingRow.elements.splice(firstCell + cellIndex, 1);
    }
    attributes["rowspan"] = rowspan;
  }
  return {
    type: "tableCell",
    content: nodeListHandler2.handler({ ...params2, nodes: node2.elements }),
    attrs: attributes
  };
}
const getTableCellMergeTag = (node2) => {
  const tcPr = node2.elements.find((el) => el.name === "w:tcPr");
  const vMerge = tcPr?.elements?.find((el) => el.name === "w:vMerge");
  return vMerge;
};
const processBorder = (borders, direction, rowBorders = {}) => {
  const borderAttrs = borders?.elements?.find((el) => el.name === `w:${direction}`)?.attributes;
  if (borderAttrs && borderAttrs["w:val"] !== "nil") {
    const border = {};
    const color = borderAttrs["w:color"];
    if (color) border["color"] = color === "auto" ? "#000000" : `#${color}`;
    const size2 = borderAttrs["w:sz"];
    if (size2) border["size"] = eigthPointsToPixels(size2);
    return border;
  }
  if (borderAttrs && borderAttrs["w:val"] === "nil") {
    const border = Object.assign({}, rowBorders[direction] || {});
    if (!Object.keys(border)) return null;
    border["val"] = "none";
    return border;
  }
  return null;
};
const processInlineCellBorders = (borders, rowBorders) => {
  if (!borders) return null;
  const processedBorders = {};
  const inlineBorderBottom = processBorder(borders, "bottom", rowBorders);
  if (inlineBorderBottom) processedBorders["bottom"] = inlineBorderBottom;
  const inlineBorderTop = processBorder(borders, "top", rowBorders);
  if (inlineBorderTop) processedBorders["top"] = inlineBorderTop;
  const inlineBorderLeft = processBorder(borders, "left", rowBorders);
  if (inlineBorderLeft) processedBorders["left"] = inlineBorderLeft;
  const inlineBorderRight = processBorder(borders, "right", rowBorders);
  if (inlineBorderRight) processedBorders["right"] = inlineBorderRight;
  return processedBorders;
};
function getReferencedTableStyles(tblStyleTag, docx) {
  if (!tblStyleTag) return null;
  const stylesToReturn = {};
  const { attributes = {} } = tblStyleTag;
  const tableStyleReference = attributes["w:val"];
  if (!tableStyleReference) return null;
  const styles = docx["word/styles.xml"];
  const { elements } = styles.elements[0];
  const styleElements = elements.filter((el) => el.name === "w:style");
  const styleTag = styleElements.find((el) => el.attributes["w:styleId"] === tableStyleReference);
  if (!styleTag) return null;
  stylesToReturn.name = styleTag.elements.find((el) => el.name === "w:name");
  const basedOn = styleTag.elements.find((el) => el.name === "w:basedOn");
  let baseTblPr;
  if (basedOn?.attributes) {
    const baseStyles = styleElements.find((el) => el.attributes["w:styleId"] === basedOn.attributes["w:val"]);
    baseTblPr = baseStyles ? baseStyles.elements.find((el) => el.name === "w:tblPr") : {};
  }
  const pPr = styleTag.elements.find((el) => el.name === "w:pPr");
  if (pPr) {
    const justification = pPr.elements.find((el) => el.name === "w:jc");
    if (justification?.attributes) stylesToReturn.justification = justification.attributes["w:val"];
  }
  const rPr = styleTag?.elements.find((el) => el.name === "w:rPr");
  if (rPr) {
    const fonts = rPr.elements.find((el) => el.name === "w:rFonts");
    if (fonts) {
      const { "w:ascii": ascii, "w:hAnsi": hAnsi, "w:cs": cs } = fonts.attributes;
      stylesToReturn.fonts = { ascii, hAnsi, cs };
    }
    const fontSize2 = rPr.elements.find((el) => el.name === "w:sz");
    if (fontSize2?.attributes) stylesToReturn.fontSize = halfPointToPoints(fontSize2.attributes["w:val"]) + "pt";
  }
  const tblPr = styleTag.elements.find((el) => el.name === "w:tblPr");
  if (tblPr && tblPr.elements) {
    if (baseTblPr && baseTblPr.elements) {
      tblPr.elements.push(...baseTblPr.elements);
    }
    const tableBorders = tblPr?.elements?.find((el) => el.name === "w:tblBorders");
    const { elements: borderElements = [] } = tableBorders || {};
    const { borders, rowBorders } = processTableBorders(borderElements);
    if (borders) stylesToReturn.borders = borders;
    if (rowBorders) stylesToReturn.rowBorders = rowBorders;
    const tableCellMargin = tblPr?.elements.find((el) => el.name === "w:tblCellMar");
    if (tableCellMargin) {
      const marginLeft = tableCellMargin.elements.find((el) => el.name === "w:left");
      const marginRight = tableCellMargin.elements.find((el) => el.name === "w:right");
      const marginTop = tableCellMargin.elements.find((el) => el.name === "w:top");
      const marginBottom = tableCellMargin.elements.find((el) => el.name === "w:bottom");
      stylesToReturn.cellMargins = {
        marginLeft: marginLeft?.attributes["w:w"],
        marginRight: marginRight?.attributes["w:w"],
        marginTop: marginTop?.attributes["w:w"],
        marginBottom: marginBottom?.attributes["w:w"]
      };
    }
  }
  return stylesToReturn;
}
function processTableBorders(borderElements) {
  const borders = {};
  const rowBorders = {};
  borderElements.forEach((borderElement) => {
    const { name } = borderElement;
    const borderName = name.split("w:")[1];
    const { attributes } = borderElement;
    const attrs = {};
    const color = attributes["w:color"];
    const size2 = attributes["w:sz"];
    if (color && color !== "auto") attrs["color"] = color.startsWith("#") ? color : `#${color}`;
    if (size2 && size2 !== "auto") attrs["size"] = eigthPointsToPixels(size2);
    const rowBorderNames = ["insideH", "insideV"];
    if (rowBorderNames.includes(borderName)) rowBorders[borderName] = attrs;
    borders[borderName] = attrs;
  });
  return {
    borders,
    rowBorders
  };
}
function handleTableRowNode(node2, table, rowBorders, styleTag, params2) {
  const attrs = {};
  const tPr = node2.elements.find((el) => el.name === "w:trPr");
  const rowHeightTag = tPr?.elements?.find((el) => el.name === "w:trHeight");
  const rowHeight = rowHeightTag?.attributes["w:val"];
  const borders = {};
  if (rowBorders?.insideH) borders["bottom"] = rowBorders.insideH;
  if (rowBorders?.insideV) borders["right"] = rowBorders.insideV;
  attrs["borders"] = borders;
  if (rowHeight) {
    attrs["rowHeight"] = twipsToPixels(rowHeight);
  }
  const gridColumnWidths = getGridColumnWidths(table);
  const cellNodes = node2.elements.filter((el) => el.name === "w:tc");
  let currentColumnIndex = 0;
  const content = cellNodes?.map((n) => {
    let colWidth = gridColumnWidths?.[currentColumnIndex] || null;
    const result = handleTableCellNode(n, node2, table, borders, colWidth, styleTag, params2, currentColumnIndex);
    const tcPr = n.elements?.find((el) => el.name === "w:tcPr");
    const colspanTag = tcPr?.elements?.find((el) => el.name === "w:gridSpan");
    const colspan = parseInt(colspanTag?.attributes["w:val"] || 1, 10);
    currentColumnIndex += colspan;
    return result;
  }) || [];
  const newNode = {
    type: "tableRow",
    content,
    attrs
  };
  return newNode;
}
const getTableCellMargins = (marginTag, referencedStyles) => {
  const inlineMarginLeftTag = marginTag?.elements?.find((el) => el.name === "w:left");
  const inlineMarginRightTag = marginTag?.elements?.find((el) => el.name === "w:right");
  const inlineMarginTopTag = marginTag?.elements?.find((el) => el.name === "w:top");
  const inlineMarginBottomTag = marginTag?.elements?.find((el) => el.name === "w:bottom");
  const inlineMarginLeftValue = inlineMarginLeftTag?.attributes["w:w"];
  const inlineMarginRightValue = inlineMarginRightTag?.attributes["w:w"];
  const inlineMarginTopValue = inlineMarginTopTag?.attributes["w:w"];
  const inlineMarginBottomValue = inlineMarginBottomTag?.attributes["w:w"];
  const { cellMargins = {} } = referencedStyles;
  const {
    marginLeft: marginLeftStyle,
    marginRight: marginRightStyle,
    marginTop: marginTopStyle,
    marginBottom: marginBottomStyle
  } = cellMargins;
  const margins = {
    left: twipsToPixels(inlineMarginLeftValue ?? marginLeftStyle),
    right: twipsToPixels(inlineMarginRightValue ?? marginRightStyle),
    top: twipsToPixels(inlineMarginTopValue ?? marginTopStyle),
    bottom: twipsToPixels(inlineMarginBottomValue ?? marginBottomStyle)
  };
  return margins;
};
const getGridColumnWidths = (tableNode) => {
  const tblGrid = tableNode.elements.find((el) => el.name === "w:tblGrid");
  if (!tblGrid) return [];
  const columnWidths = tblGrid?.elements?.flatMap((el) => {
    if (el.name !== "w:gridCol") return [];
    return twipsToPixels(el.attributes["w:w"]);
  }) || [];
  return columnWidths;
};
const handleDrawingNode = (params2) => {
  const { nodes, filename } = params2;
  const validNodes = ["w:drawing", "w:p"];
  if (nodes.length === 0 || !validNodes.includes(nodes[0].name)) {
    return { nodes: [], consumed: 0 };
  }
  const mainNode = nodes[0];
  let node2;
  if (mainNode.name === "w:drawing") node2 = mainNode;
  else node2 = mainNode.elements.find((el) => el.name === "w:drawing");
  if (!node2) return { nodes: [], consumed: 0 };
  let result;
  const { elements } = node2;
  const currentFileName = filename || null;
  const isAnchor = elements.find((el) => el.name === "wp:anchor");
  if (isAnchor) {
    result = handleImageImport(elements[0], currentFileName, params2);
    if (result && result.attrs) result.attrs.isAnchor = isAnchor;
  }
  const inlineImage = elements.find((el) => el.name === "wp:inline");
  if (inlineImage) result = handleImageImport(inlineImage, currentFileName, params2);
  return { nodes: result ? [result] : [], consumed: 1 };
};
function handleImageImport(node2, currentFileName, params2) {
  const { docx } = params2;
  const { attributes } = node2;
  const padding = {
    top: emuToPixels(attributes["distT"]),
    bottom: emuToPixels(attributes["distB"]),
    left: emuToPixels(attributes["distL"]),
    right: emuToPixels(attributes["distR"])
  };
  const extent = node2.elements.find((el) => el.name === "wp:extent");
  const size2 = {
    width: emuToPixels(extent.attributes?.cx),
    height: emuToPixels(extent.attributes?.cy)
  };
  const graphic = node2.elements.find((el) => el.name === "a:graphic");
  const graphicData = graphic.elements.find((el) => el.name === "a:graphicData");
  const { uri: uri2 } = graphicData?.attributes || {};
  const shapeURI = "http://schemas.microsoft.com/office/word/2010/wordprocessingShape";
  if (!!uri2 && uri2 === shapeURI) {
    return handleShapeDrawing(params2, node2, graphicData);
  }
  const picture = graphicData.elements.find((el) => el.name === "pic:pic");
  if (!picture || !picture.elements) return null;
  const blipFill = picture.elements.find((el) => el.name === "pic:blipFill");
  const blip = blipFill.elements.find((el) => el.name === "a:blip");
  const positionHTag = node2.elements.find((el) => el.name === "wp:positionH");
  const positionH = positionHTag?.elements.find((el) => el.name === "wp:posOffset");
  const positionHValue = emuToPixels(positionH?.elements[0]?.text);
  const hRelativeFrom = positionHTag?.attributes.relativeFrom;
  const alignH = positionHTag?.elements.find((el) => el.name === "wp:align")?.elements[0]?.text;
  const positionVTag = node2.elements.find((el) => el.name === "wp:positionV");
  const positionV = positionVTag?.elements?.find((el) => el.name === "wp:posOffset");
  const positionVValue = emuToPixels(positionV?.elements[0]?.text);
  const vRelativeFrom = positionVTag?.attributes.relativeFrom;
  const alignV = positionVTag?.elements?.find((el) => el.name === "wp:align")?.elements[0]?.text;
  const simplePos = node2.elements.find((el) => el.name === "wp:simplePos");
  const wrapSquare = node2.elements.find((el) => el.name === "wp:wrapSquare");
  const wrapTopAndBottom = node2.elements.find((el) => el.name === "wp:wrapTopAndBottom");
  const docPr = node2.elements.find((el) => el.name === "wp:docPr");
  let anchorData = null;
  if (hRelativeFrom || alignH || vRelativeFrom || alignV) {
    anchorData = {
      hRelativeFrom,
      vRelativeFrom,
      alignH,
      alignV
    };
  }
  const marginOffset = {
    left: positionHValue,
    top: positionVValue
  };
  const { attributes: blipAttributes = {} } = blip;
  const rEmbed = blipAttributes["r:embed"];
  if (!rEmbed) return null;
  const currentFile = currentFileName || "document.xml";
  let rels = docx[`word/_rels/${currentFile}.rels`];
  if (!rels) rels = docx[`word/_rels/document.xml.rels`];
  const relationships = rels.elements.find((el) => el.name === "Relationships");
  const { elements } = relationships;
  const rel = elements.find((el) => el.attributes["Id"] === rEmbed);
  if (!rel) return null;
  const { attributes: relAttributes } = rel;
  const path = `word/${relAttributes["Target"]}`;
  return {
    type: "image",
    attrs: {
      src: path,
      alt: docPr?.attributes.name || "Image",
      id: docPr?.attributes.id || "",
      title: docPr?.attributes.descr || "Image",
      inline: true,
      padding,
      marginOffset,
      size: size2,
      anchorData,
      ...simplePos && {
        simplePos: {
          x: simplePos.attributes.x,
          y: simplePos.attributes.y
        }
      },
      ...wrapSquare && {
        wrapText: wrapSquare.attributes.wrapText
      },
      wrapTopAndBottom: !!wrapTopAndBottom,
      originalPadding: {
        distT: attributes["distT"],
        distB: attributes["distB"],
        distL: attributes["distL"],
        distR: attributes["distR"]
      },
      originalAttributes: node2.attributes,
      rId: relAttributes["Id"]
    }
  };
}
const handleShapeDrawing = (params2, node2, graphicData) => {
  const wsp = graphicData.elements.find((el) => el.name === "wps:wsp");
  const textBox = wsp.elements.find((el) => el.name === "wps:txbx");
  const textBoxContent = textBox?.elements?.find((el) => el.name === "w:txbxContent");
  node2.elements.find((el) => el.name === "wp:docPr");
  const spPr = wsp.elements.find((el) => el.name === "wps:spPr");
  const prstGeom = spPr?.elements.find((el) => el.name === "a:prstGeom");
  if (!!prstGeom && prstGeom.attributes["prst"] === "rect") {
    return getRectangleShape(params2, spPr);
  }
  if (!textBoxContent) {
    return null;
  }
  const { nodeListHandler: nodeListHandler2 } = params2;
  const translatedElement = nodeListHandler2.handler({
    ...params2,
    node: textBoxContent.elements[0],
    nodes: textBoxContent.elements
  });
  return translatedElement[0];
};
const getRectangleShape = (params2, node2) => {
  const schemaAttrs = {};
  const [drawingNode] = params2.nodes;
  if (drawingNode?.name === "w:drawing") {
    schemaAttrs.drawingContent = drawingNode;
  }
  const xfrm = node2.elements.find((el) => el.name === "a:xfrm");
  const start2 = xfrm.elements.find((el) => el.name === "a:off");
  const size2 = xfrm.elements.find((el) => el.name === "a:ext");
  const solidFill = node2.elements.find((el) => el.name === "a:solidFill");
  node2.elements.find((el) => el.name === "a:ln");
  const rectangleSize = {
    top: emuToPixels(start2.attributes["y"]),
    left: emuToPixels(start2.attributes["x"]),
    width: emuToPixels(size2.attributes["cx"]),
    height: emuToPixels(size2.attributes["cy"])
  };
  schemaAttrs.size = rectangleSize;
  const background = solidFill?.elements[0]?.attributes["val"];
  if (background) {
    schemaAttrs.background = "#" + background;
  }
  return {
    type: "contentBlock",
    attrs: schemaAttrs
  };
};
const drawingNodeHandlerEntity = {
  handlerName: "drawingNodeHandler",
  handler: handleDrawingNode
};
function parseMarks(property2, unknownMarks = [], docx = null) {
  const marks = [];
  const seen = /* @__PURE__ */ new Set();
  const lang = property2?.elements?.find((el) => el.name === "w:lang");
  lang?.attributes || {};
  property2?.elements?.forEach((element) => {
    const marksForType = SuperConverter.markTypes.filter((mark) => mark.name === element.name);
    if (!marksForType.length) {
      const missingMarks = [
        "w:shd",
        "w:rStyle",
        "w:pStyle",
        "w:numPr",
        "w:outlineLvl",
        "w:bdr",
        "w:pBdr",
        "w:noProof",
        "w:contextualSpacing",
        "w:keepNext",
        "w:tabs",
        "w:keepLines"
      ];
      if (missingMarks.includes(element.name)) {
        unknownMarks.push(element.name);
      }
    }
    let filteredMarksForType = marksForType;
    if (element.name === "w:spacing") {
      const attrs = element.attributes || {};
      const hasLetterSpacing = attrs["w:val"];
      filteredMarksForType = marksForType.filter((m2) => {
        if (hasLetterSpacing) {
          return m2.type === "letterSpacing";
        }
        return m2.type === "lineHeight";
      });
    }
    filteredMarksForType.forEach((m2) => {
      if (!m2 || seen.has(m2.type)) return;
      seen.add(m2.type);
      const { attributes = {} } = element;
      const newMark = { type: m2.type };
      const exceptionMarks = ["w:b", "w:caps"];
      if ((attributes["w:val"] === "0" || attributes["w:val"] === "none") && !exceptionMarks.includes(m2.name)) {
        return;
      }
      const requiresValue = ["w:u"];
      if (requiresValue.includes(m2.name) && !attributes["w:val"]) {
        return;
      }
      if (m2.mark) newMark.type = m2.mark;
      if (m2.name === "w:caps") {
        newMark.attrs = {};
        if (attributes["w:val"] === "0") {
          newMark.attrs[m2.property] = "none";
        } else {
          newMark.attrs[m2.property] = "uppercase";
        }
        marks.push(newMark);
        return;
      }
      if (Object.keys(attributes).length) {
        const value = getMarkValue(m2.type, attributes, docx);
        if (value === null || value === void 0) return;
        newMark.attrs = {};
        newMark.attrs[m2.property] = value;
      }
      marks.push(newMark);
    });
  });
  return createImportMarks(marks);
}
function handleStyleChangeMarks(rPr, currentMarks) {
  const styleChangeMark = rPr.elements?.find((el) => el.name === "w:rPrChange");
  if (!styleChangeMark) {
    return [];
  }
  const { attributes } = styleChangeMark;
  const mappedAttributes = {
    id: attributes["w:id"],
    date: attributes["w:date"],
    author: attributes["w:author"],
    authorEmail: attributes["w:authorEmail"]
  };
  const submarks = parseMarks(styleChangeMark);
  return [{ type: TrackFormatMarkName, attrs: { ...mappedAttributes, before: submarks, after: [...currentMarks] } }];
}
function createImportMarks(marks) {
  const textStyleMarksToCombine = marks.filter((mark) => mark.type === "textStyle");
  const remainingMarks = marks.filter((mark) => mark.type !== "textStyle");
  const combinedTextAttrs = {};
  if (textStyleMarksToCombine.length) {
    textStyleMarksToCombine.forEach((mark) => {
      const { attrs = {} } = mark;
      Object.keys(attrs).forEach((attr) => {
        combinedTextAttrs[attr] = attrs[attr];
      });
    });
  }
  const result = [...remainingMarks, { type: "textStyle", attrs: combinedTextAttrs }];
  return result;
}
function getMarkValue(markType, attributes, docx) {
  if (markType === "tabs") markType = "textIndent";
  const markValueMapper = {
    color: () => `#${attributes["w:val"]}`,
    fontSize: () => `${attributes["w:val"] / 2}pt`,
    textIndent: () => getIndentValue(attributes),
    fontFamily: () => getFontFamilyValue(attributes, docx),
    lineHeight: () => getLineHeightValue(attributes),
    letterSpacing: () => `${twipsToPt(attributes["w:val"])}pt`,
    textAlign: () => attributes["w:val"],
    link: () => attributes["href"],
    underline: () => attributes["w:val"],
    bold: () => attributes?.["w:val"] || null,
    italic: () => attributes?.["w:val"] || null,
    highlight: () => getHighLightValue(attributes),
    strike: () => getStrikeValue(attributes)
  };
  if (markType in markValueMapper) {
    return markValueMapper[markType]();
  }
}
function getFontFamilyValue(attributes, docx) {
  const ascii = attributes["w:ascii"];
  const themeAscii = attributes["w:asciiTheme"];
  if (!docx || !themeAscii) return ascii;
  const theme = docx["word/theme/theme1.xml"];
  if (!theme) return ascii;
  const { elements: topElements } = theme;
  const { elements } = topElements[0];
  const themeElements = elements.find((el) => el.name === "a:themeElements");
  const fontScheme = themeElements.elements.find((el) => el.name === "a:fontScheme");
  const majorFont = fontScheme.elements.find((el) => el.name === "a:majorFont");
  const latin = majorFont.elements.find((el) => el.name === "a:latin");
  const typeface = latin.attributes["typeface"];
  return typeface;
}
function getIndentValue(attributes) {
  let value = attributes["w:left"];
  if (!value) return null;
  return `${twipsToInches(value)}in`;
}
function getLineHeightValue(attributes) {
  const value = attributes["w:line"];
  const lineRule = attributes["w:lineRule"];
  if (!value || value === "0") return null;
  if (lineRule === "exact") return `${twipsToPt(value)}pt`;
  return `${twipsToLines(value)}`;
}
function getHighLightValue(attributes) {
  const fill = attributes["w:fill"];
  if (fill && fill !== "auto") return `#${fill}`;
  if (isValidHexColor(attributes?.["w:val"])) return `#${attributes["w:val"]}`;
  return getHexColorFromDocxSystem(attributes?.["w:val"]) || null;
}
function getStrikeValue(attributes) {
  return attributes?.["w:val"] === "1" ? attributes["w:val"] : null;
}
function parseProperties(node2) {
  const marks = [];
  const unknownMarks = [];
  const { attributes = {}, elements = [] } = node2;
  const { nodes, paragraphProperties = {}, runProperties = {} } = splitElementsAndProperties(elements);
  const hasRun = elements.find((element) => element.name === "w:r");
  if (hasRun) paragraphProperties.elements = paragraphProperties?.elements?.filter((el) => el.name !== "w:rPr");
  if (runProperties && runProperties?.elements?.length) {
    marks.push(...parseMarks(runProperties, unknownMarks));
  }
  if (paragraphProperties && paragraphProperties.elements?.length) {
    const disallowedParagraphProperties = ["w:u"];
    const filteredParagraphProperties = {
      ...paragraphProperties,
      elements: paragraphProperties.elements?.filter((el) => !disallowedParagraphProperties.includes(el.name))
    };
    marks.push(...parseMarks(filteredParagraphProperties, unknownMarks));
  }
  marks.push(...handleStyleChangeMarks(runProperties, marks));
  if (paragraphProperties && paragraphProperties.elements?.length) {
    attributes["paragraphProperties"] = paragraphProperties;
  }
  if (marks && node2.name === "w:p") {
    marks.forEach((mark) => {
      const attrValue = Object.keys(mark.attrs ?? {})[0];
      if (attrValue) {
        const value = mark.attrs[attrValue];
        attributes[attrValue] = value;
      }
    });
  }
  return { elements: nodes, attributes, marks, unknownMarks };
}
function splitElementsAndProperties(elements) {
  const pPr = elements.find((el) => el.name === "w:pPr");
  const rPr = elements.find((el) => el.name === "w:rPr");
  const sectPr = elements.find((el) => el.name === "w:sectPr");
  const els = elements.filter((el) => el.name !== "w:pPr" && el.name !== "w:rPr" && el.name !== "w:sectPr");
  return {
    nodes: els,
    paragraphProperties: pPr,
    runProperties: rPr,
    sectionProperties: sectPr
  };
}
function getElementName(element) {
  return SuperConverter.allowedElements[element.name || element.type];
}
const isPropertiesElement = (element) => {
  return !!SuperConverter.propertyTypes[element.name || element.type];
};
const handleTrackChangeNode = (params2) => {
  const { nodes, nodeListHandler: nodeListHandler2 } = params2;
  if (nodes.length === 0 || !(nodes[0].name === "w:del" || nodes[0].name === "w:ins" || nodes[0].name === "w:sdt")) {
    return { nodes: [], consumed: 0 };
  }
  const mainNode = nodes[0];
  let node2;
  if (["w:ins", "w:del"].includes(mainNode.name)) {
    node2 = mainNode;
  } else {
    const sdtContent = mainNode.elements.find((el) => el.name === "w:sdtContent");
    const trackedChange = sdtContent?.elements.find((el) => ["w:ins", "w:del"].includes(el.name));
    if (trackedChange) node2 = trackedChange;
  }
  if (!node2) {
    return { nodes: [], consumed: 0 };
  }
  const { name } = node2;
  const { attributes, elements } = parseProperties(node2);
  const subs = nodeListHandler2.handler({ ...params2, insideTrackChange: true, nodes: elements });
  const changeType = name === "w:del" ? TrackDeleteMarkName : TrackInsertMarkName;
  const mappedAttributes = {
    id: attributes["w:id"],
    date: attributes["w:date"],
    author: attributes["w:author"],
    authorEmail: attributes["w:authorEmail"],
    importedAuthor: `${attributes["w:author"]} (imported)`
  };
  subs.forEach((subElement) => {
    if (subElement.marks === void 0) subElement.marks = [];
    subElement.marks.push({ type: changeType, attrs: mappedAttributes });
  });
  return { nodes: subs, consumed: 1 };
};
const trackChangeNodeHandlerEntity = {
  handlerName: "trackChangeNodeHandler",
  handler: handleTrackChangeNode
};
const handleHyperlinkNode = (params2) => {
  const { nodes, docx, nodeListHandler: nodeListHandler2 } = params2;
  if (nodes.length === 0 || nodes[0].name !== "w:hyperlink") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const rels = docx["word/_rels/document.xml.rels"];
  const relationships = rels.elements.find((el) => el.name === "Relationships");
  const { elements } = relationships;
  const { attributes } = node2;
  const rId = attributes["r:id"];
  const anchor = attributes["w:anchor"];
  attributes["w:history"];
  const rel = elements.find((el) => el.attributes["Id"] === rId) || {};
  const { attributes: relAttributes = {} } = rel;
  let href = relAttributes["Target"];
  if (anchor && !href) href = `#${anchor}`;
  const runNodes = node2.elements.filter((el) => el.name === "w:r");
  const linkMark = { type: "link", attrs: { href, rId } };
  for (const runNode of runNodes) {
    if (!runNode.marks) runNode.marks = [];
    runNode.marks.push(linkMark);
    const rPr = runNode.elements.find((el) => el.name === "w:rPr");
    if (rPr) {
      const styleRel = rPr.elements.find((el) => el.name === "w:rStyle");
      if (styleRel) {
        const styles = docx["word/styles.xml"];
        const { elements: elements2 } = styles.elements[0];
        const styleElements = elements2.filter((el) => el.name === "w:style");
        const style2 = styleElements.find((el) => el.attributes["w:styleId"] === "Hyperlink");
        const styleRpr = style2?.elements?.find((el) => el.name === "w:rPr");
        if (styleRpr) {
          styleRpr.elements.forEach((styleEl) => {
            const hasElInRPr = rPr.elements.find((el) => el.name === styleEl.name);
            if (!hasElInRPr) rPr.elements.push(styleEl);
          });
        }
      }
    }
  }
  const updatedNode = nodeListHandler2.handler({ ...params2, nodes: runNodes });
  return { nodes: updatedNode, consumed: 1 };
};
const hyperlinkNodeHandlerEntity = {
  handlerName: "hyperlinkNodeHandler",
  handler: handleHyperlinkNode
};
const handleRunNode = (params2) => {
  const { nodes, nodeListHandler: nodeListHandler2, parentStyleId, docx } = params2;
  if (nodes.length === 0 || nodes[0].name !== "w:r") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const childParams = { ...params2, nodes: node2.elements };
  let processedRun = nodeListHandler2.handler(childParams)?.filter((n) => n) || [];
  const hasRunProperties = node2.elements?.some((el) => el.name === "w:rPr");
  const defaultNodeStyles = getMarksFromStyles(docx, parentStyleId);
  if (hasRunProperties) {
    const { marks = [] } = parseProperties(node2);
    let runStyleAttributes = [];
    const runStyleElement = node2.elements?.find((el) => el.name === "w:rPr")?.elements?.find((el) => el.name === "w:rStyle");
    let runStyleId;
    if (runStyleElement && runStyleElement.attributes?.["w:val"] && docx) {
      runStyleId = runStyleElement.attributes["w:val"];
      const runStyleDefinition = getMarksFromStyles(docx, runStyleId);
      if (runStyleDefinition.marks && runStyleDefinition.marks.length > 0) {
        runStyleAttributes = runStyleDefinition.marks;
      }
    }
    let paragraphStyleAttributes = [];
    if (defaultNodeStyles.marks) {
      paragraphStyleAttributes = defaultNodeStyles.marks.filter((mark) => {
        if (["bold"].includes(mark.type) && marks.find((m2) => m2.type === "bold")?.attrs?.value === "0") {
          return false;
        }
        return true;
      });
    }
    const combinedMarks = [...paragraphStyleAttributes];
    runStyleAttributes.forEach((runStyle) => {
      const exists2 = combinedMarks.some(
        (mark) => mark.type === runStyle.type && JSON.stringify(mark.attrs || {}) === JSON.stringify(runStyle.attrs || {})
      );
      if (!exists2) {
        combinedMarks.push(runStyle);
      }
    });
    marks.forEach((mark) => {
      const exists2 = combinedMarks.some(
        (existing) => existing.type === mark.type && JSON.stringify(existing.attrs || {}) === JSON.stringify(mark.attrs || {})
      );
      if (!exists2) {
        combinedMarks.push(mark);
      }
    });
    if (runStyleId) combinedMarks.push({ type: "textStyle", attrs: { styleId: runStyleId } });
    if (node2.marks) combinedMarks.push(...node2.marks);
    const newMarks = createImportMarks(combinedMarks);
    processedRun = processedRun.map((n) => {
      const existingMarks = n.marks || [];
      return {
        ...n,
        marks: [...newMarks, ...existingMarks]
      };
    });
  }
  return { nodes: processedRun, consumed: 1 };
};
const getMarksFromStyles = (docx, styleId) => {
  const styles = docx?.["word/styles.xml"];
  if (!styles) {
    return {};
  }
  const styleTags = styles.elements[0].elements.filter((style22) => style22.name === "w:style");
  const style2 = styleTags.find((tag) => tag.attributes["w:styleId"] === styleId) || {};
  if (!style2) return {};
  return parseProperties(style2);
};
const runNodeHandlerEntity = {
  handlerName: "runNodeHandler",
  handler: handleRunNode
};
const handleTextNode = (params2) => {
  const { nodes, insideTrackChange } = params2;
  if (nodes.length === 0 || !(nodes[0].name === "w:t" || insideTrackChange && nodes[0].name === "w:delText")) {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const { type: type2 } = node2;
  const { attributes, elements, marks = [] } = parseProperties(node2);
  let text;
  if (elements.length === 1) {
    text = elements[0].text;
    text = text.replace(/\[\[sdspace\]\]/g, "");
  } else if (!elements.length && "attributes" in node2 && node2.attributes["xml:space"] === "preserve") {
    text = " ";
  } else return { nodes: [], consumed: 0 };
  return {
    nodes: [
      {
        type: getElementName(node2),
        text,
        attrs: { type: type2, attributes: attributes || {} },
        marks
      }
    ],
    consumed: 1
  };
};
const textNodeHandlerEntity = {
  handlerName: "textNodeHandler",
  handler: handleTextNode
};
const mergeTextNodes = (nodes) => {
  if (!nodes || !Array.isArray(nodes)) {
    return nodes;
  }
  let mergedNodes = [];
  let prevTextNode = null;
  for (let node2 of nodes) {
    if (node2.type === "text") {
      if (prevTextNode && canMergeTextNodes(prevTextNode, node2)) {
        prevTextNode = {
          ...prevTextNode,
          text: prevTextNode.text += node2.text
        };
      } else {
        if (prevTextNode) mergedNodes.push(prevTextNode);
        prevTextNode = { ...node2 };
      }
    } else {
      if (prevTextNode) {
        mergedNodes.push(prevTextNode);
        prevTextNode = null;
      }
      mergedNodes.push(node2);
    }
  }
  if (prevTextNode) {
    mergedNodes.push(prevTextNode);
  }
  return mergedNodes;
};
const canMergeTextNodes = (nodeA, nodeB) => {
  if (!nodeA || !nodeB) return false;
  let marksA = nodeA.marks ?? [];
  let marksB = nodeB.marks ?? [];
  if (marksA.length !== marksB.length) {
    return false;
  }
  for (let i = 0; i < marksA.length; i++) {
    if (!marksA[i].attrs) marksA[i].attrs = {};
    if (!marksB[i].attrs) marksB[i].attrs = {};
    if (marksA[i].type !== marksB[i].type || Object.keys(marksA[i].attrs).length !== Object.keys(marksB[i].attrs).length || !areAttrsEqual(marksA[i].attrs, marksB[i].attrs)) {
      return false;
    }
  }
  return true;
};
const areAttrsEqual = (attrsA = {}, attrsB = {}) => {
  return objectIncludes(attrsA, attrsB);
};
const kebabCase$1 = (str) => str.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);
const comments_module_events = Object.freeze({
  RESOLVED: "resolved",
  NEW: "new",
  ADD: "add",
  UPDATE: "update",
  DELETED: "deleted",
  PENDING: "pending",
  SELECTED: "selected",
  // Comments list
  COMMENTS_LIST: "comments-list",
  // Tracked changes
  CHANGE_ACCEPTED: "change-accepted",
  CHANGE_REJECTED: "change-rejected"
});
const getFileObject = async (fileUrl, name, type2) => {
  const response = await fetch(fileUrl);
  const blob = await response.blob();
  return new File([blob], name, { type: type2 });
};
const vClickOutside = {
  mounted(el, binding) {
    const clickOutsideHandler = (event) => {
      if (!el.contains(event.target)) {
        binding.value(event);
      }
    };
    document.addEventListener("click", clickOutsideHandler);
    el.__clickOutsideHandler = clickOutsideHandler;
  },
  unmounted(el) {
    document.removeEventListener("click", el.__clickOutsideHandler);
    delete el.__clickOutsideHandler;
  }
};
const _hoisted_1$g = ["accept"];
const _sfc_main$h = {
  __name: "BasicUpload",
  props: {
    accept: {
      type: String,
      default: ".docx, .pdf, .html, .md"
    }
  },
  emits: ["file-change"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const onFileChange = (event) => {
      emit("file-change", event.target.files[0]);
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", null, [
        vue.createBaseVNode("input", {
          type: "file",
          id: "fileInput",
          onChange: onFileChange,
          accept: __props.accept
        }, null, 40, _hoisted_1$g)
      ]);
    };
  }
};
const handleParagraphNode = (params2) => {
  const { nodes, docx, nodeListHandler: nodeListHandler2, filename } = params2;
  if (nodes.length === 0 || nodes[0].name !== "w:p") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = carbonCopy(nodes[0]);
  let schemaNode;
  let processedElements = preProcessNodesForFldChar(node2.elements);
  node2.elements = processedElements;
  const handleStandardNode2 = nodeListHandler2.handlerEntities.find(
    (e) => e.handlerName === "standardNodeHandler"
  )?.handler;
  if (!handleStandardNode2) {
    console.error("Standard node handler not found");
    return { nodes: [], consumed: 0 };
  }
  const updatedParams = { ...params2, nodes: [node2] };
  const result = handleStandardNode2(updatedParams);
  if (result.nodes.length === 1) {
    schemaNode = result.nodes[0];
  }
  const pPr = node2.elements?.find((el) => el.name === "w:pPr");
  const styleTag = pPr?.elements?.find((el) => el.name === "w:pStyle");
  const nestedRPr = pPr?.elements?.find((el) => el.name === "w:rPr");
  const framePr = pPr?.elements?.find((el) => el.name === "w:framePr");
  if (nestedRPr) {
    let marks = parseMarks(nestedRPr, []);
    if (!schemaNode.content?.length) {
      let highlightIndex = marks?.findIndex((i) => i.type === "highlight");
      if (highlightIndex !== -1) {
        marks.splice(highlightIndex, 1);
      }
    }
    schemaNode.attrs.marksAttrs = marks;
  }
  let styleId;
  if (styleTag) {
    styleId = styleTag.attributes["w:val"];
    schemaNode.attrs["styleId"] = styleId;
  }
  if (docx) {
    const indent = getParagraphIndent(node2, docx, styleId);
    if (!schemaNode.attrs.indent) {
      schemaNode.attrs.indent = {};
    }
    if (indent.left || indent.left === 0) {
      schemaNode.attrs.indent.left = indent.left;
    }
    if (indent.right || indent.right === 0) {
      schemaNode.attrs.indent.right = indent.right;
    }
    if (indent.firstLine || indent.firstLine === 0) {
      schemaNode.attrs.indent.firstLine = indent.firstLine;
    }
    if (indent.hanging || indent.hanging === 0) {
      schemaNode.attrs.indent.hanging = indent.hanging;
    }
    if (indent.textIndent || indent.textIndent === 0) {
      schemaNode.attrs.textIndent = `${indent.textIndent}in`;
    }
  }
  const justify = pPr?.elements?.find((el) => el.name === "w:jc");
  if (justify && justify.attributes) {
    schemaNode.attrs["textAlign"] = justify.attributes["w:val"];
  }
  const keepLines = pPr?.elements?.find((el) => el.name === "w:keepLines");
  if (keepLines && keepLines.attributes) {
    schemaNode.attrs["keepLines"] = keepLines.attributes["w:val"];
  }
  const keepNext = pPr?.elements?.find((el) => el.name === "w:keepNext");
  if (keepNext && keepNext.attributes) {
    schemaNode.attrs["keepNext"] = keepNext.attributes["w:val"];
  }
  if (docx) {
    const defaultStyleId = node2.attributes?.["w:rsidRDefault"];
    schemaNode.attrs["spacing"] = getParagraphSpacing(node2, docx, styleId, schemaNode.attrs.marksAttrs);
    schemaNode.attrs["rsidRDefault"] = defaultStyleId;
  }
  if (docx) {
    const { justify: justify2 } = getDefaultParagraphStyle(docx, styleId);
    if (justify2) {
      schemaNode.attrs.justify = {
        val: justify2["w:val"]
      };
    }
  }
  if (framePr && framePr.attributes["w:dropCap"]) {
    schemaNode.attrs.dropcap = {
      type: framePr.attributes["w:dropCap"],
      lines: framePr.attributes["w:lines"],
      wrap: framePr.attributes["w:wrap"],
      hAnchor: framePr.attributes["w:hAnchor"],
      vAnchor: framePr.attributes["w:vAnchor"]
    };
  }
  schemaNode.attrs["filename"] = filename;
  const tabs = pPr?.elements?.find((el) => el.name === "w:tabs");
  if (tabs && tabs.elements) {
    const tabStops = tabs.elements.filter((el) => el.name === "w:tab").map((tab) => {
      let val = tab.attributes["w:val"] || "start";
      if (val == "left") {
        val = "start";
      } else if (val == "right") {
        val = "end";
      }
      const tabStop = {
        val,
        pos: twipsToPixels(tab.attributes["w:pos"])
      };
      if (tab.attributes["w:leader"]) {
        tabStop.leader = tab.attributes["w:leader"];
      }
      return tabStop;
    });
    if (tabStops.length > 0) {
      schemaNode.attrs.tabStops = tabStops;
    }
  }
  if (schemaNode && schemaNode.content) {
    schemaNode = {
      ...schemaNode,
      content: mergeTextNodes(schemaNode.content)
    };
  }
  const sectPr = pPr?.elements?.find((el) => el.name === "w:sectPr");
  if (sectPr) {
    if (!schemaNode.attrs.paragraphProperties) schemaNode.attrs.paragraphProperties = {};
    schemaNode.attrs.paragraphProperties.sectPr = sectPr;
    schemaNode.attrs.pageBreakSource = "sectPr";
  }
  return { nodes: schemaNode ? [schemaNode] : [], consumed: 1 };
};
const getParagraphIndent = (node2, docx, styleId = "") => {
  const indent = {
    left: 0,
    right: 0,
    firstLine: 0,
    hanging: 0,
    textIndent: 0
  };
  const { indent: pDefaultIndent = {} } = getDefaultParagraphStyle(docx, styleId);
  const pPr = node2.elements?.find((el) => el.name === "w:pPr");
  const inLineIndentTag = pPr?.elements?.find((el) => el.name === "w:ind");
  const inLineIndent = inLineIndentTag?.attributes || {};
  const leftIndent = inLineIndent?.["w:left"] || pDefaultIndent?.["w:left"];
  const rightIndent = inLineIndent?.["w:right"] || pDefaultIndent?.["w:right"];
  const firstLine = inLineIndent?.["w:firstLine"] || pDefaultIndent?.["w:firstLine"];
  const hanging = inLineIndent?.["w:hanging"] || pDefaultIndent?.["w:hanging"];
  if (leftIndent) {
    indent.left = twipsToPixels(leftIndent);
  }
  if (rightIndent) {
    indent.right = twipsToPixels(rightIndent);
  }
  if (firstLine) {
    indent.firstLine = twipsToPixels(firstLine);
  }
  if (hanging) {
    indent.hanging = twipsToPixels(hanging);
  }
  const textIndentValue = leftIndent - parseInt(hanging || 0) || 0;
  if (textIndentValue) {
    indent.textIndent = twipsToInches(textIndentValue);
  }
  return indent;
};
const getParagraphSpacing = (node2, docx, styleId = "", marks = []) => {
  const spacing = {};
  const { spacing: pDefaultSpacing = {} } = getDefaultParagraphStyle(docx, styleId);
  let lineSpaceAfter, lineSpaceBefore, line, lineRuleStyle;
  const pPr = node2.elements?.find((el) => el.name === "w:pPr");
  const inLineSpacingTag = pPr?.elements?.find((el) => el.name === "w:spacing");
  const inLineSpacing = inLineSpacingTag?.attributes || {};
  const textStyleMark = marks.find((el) => el.type === "textStyle");
  const fontSize2 = textStyleMark?.attrs?.fontSize;
  const lineSpacing = inLineSpacing?.["w:line"] || line || pDefaultSpacing?.["w:line"];
  if (lineSpacing) spacing.line = twipsToLines(lineSpacing);
  const lineRule = inLineSpacing?.["w:lineRule"] || lineRuleStyle || pDefaultSpacing?.["w:lineRule"];
  if (lineRule) spacing.lineRule = lineRule;
  if (lineRule === "exact" && lineSpacing) {
    spacing.line = `${twipsToPt(lineSpacing)}pt`;
  }
  const beforeSpacing = inLineSpacing?.["w:before"] || lineSpaceBefore || pDefaultSpacing?.["w:before"];
  if (beforeSpacing) spacing.lineSpaceBefore = twipsToPixels(beforeSpacing);
  const beforeAutospacing = inLineSpacing?.["w:beforeAutospacing"];
  if (beforeAutospacing === "1" && fontSize2) {
    spacing.lineSpaceBefore += Math.round(parseInt(fontSize2) * 0.5 * 96 / 72);
  }
  const afterSpacing = inLineSpacing?.["w:after"] || lineSpaceAfter || pDefaultSpacing?.["w:after"];
  if (afterSpacing) spacing.lineSpaceAfter = twipsToPixels(afterSpacing);
  const afterAutospacing = inLineSpacing?.["w:afterAutospacing"];
  if (afterAutospacing === "1" && fontSize2) {
    spacing.lineSpaceAfter += Math.round(parseInt(fontSize2) * 0.5 * 96 / 72);
  }
  return spacing;
};
const getDefaultParagraphStyle = (docx, styleId = "") => {
  const styles = docx["word/styles.xml"];
  if (!styles) {
    return {};
  }
  const defaults = styles.elements[0].elements?.find((el) => el.name === "w:docDefaults");
  const pDefault = defaults.elements.find((el) => el.name === "w:pPrDefault");
  const pPrDefault = pDefault?.elements?.find((el) => el.name === "w:pPr");
  const pPrDefaultSpacingTag = pPrDefault?.elements?.find((el) => el.name === "w:spacing") || {};
  const pPrDefaultIndentTag = pPrDefault?.elements?.find((el) => el.name === "w:ind") || {};
  const stylesNormal = styles.elements[0].elements?.find(
    (el) => el.name === "w:style" && el.attributes["w:styleId"] === "Normal"
  );
  const pPrNormal = stylesNormal?.elements?.find((el) => el.name === "w:pPr");
  const pPrNormalSpacingTag = pPrNormal?.elements?.find((el) => el.name === "w:spacing") || {};
  const pPrNormalIndentTag = pPrNormal?.elements?.find((el) => el.name === "w:ind") || {};
  const isNormalAsDefault = stylesNormal?.attributes?.["w:default"] === "1";
  let pPrStyleIdSpacingTag = {};
  let pPrStyleIdIndentTag = {};
  let pPrStyleJc = {};
  if (styleId) {
    const stylesById = styles.elements[0].elements?.find(
      (el) => el.name === "w:style" && el.attributes["w:styleId"] === styleId
    );
    const pPrById = stylesById?.elements?.find((el) => el.name === "w:pPr");
    pPrStyleIdSpacingTag = pPrById?.elements?.find((el) => el.name === "w:spacing") || {};
    pPrStyleIdIndentTag = pPrById?.elements?.find((el) => el.name === "w:ind") || {};
    pPrStyleJc = pPrById?.elements?.find((el) => el.name === "w:jc") || {};
  }
  const { attributes: pPrDefaultSpacingAttr } = pPrDefaultSpacingTag;
  const { attributes: pPrNormalSpacingAttr } = pPrNormalSpacingTag;
  const { attributes: pPrByIdSpacingAttr } = pPrStyleIdSpacingTag;
  const { attributes: pPrByIdJcAttr } = pPrStyleJc;
  const { attributes: pPrDefaultIndentAttr } = pPrDefaultIndentTag;
  const { attributes: pPrNormalIndentAttr } = pPrNormalIndentTag;
  const { attributes: pPrByIdIndentAttr } = pPrStyleIdIndentTag;
  const spacingRest = isNormalAsDefault ? pPrNormalSpacingAttr || pPrDefaultSpacingAttr : pPrDefaultSpacingAttr || pPrNormalSpacingAttr;
  const indentRest = isNormalAsDefault ? pPrNormalIndentAttr || pPrDefaultIndentAttr : pPrDefaultIndentAttr || pPrNormalIndentAttr;
  return {
    spacing: pPrByIdSpacingAttr || spacingRest,
    indent: pPrByIdIndentAttr || indentRest,
    justify: pPrByIdJcAttr
  };
};
const paragraphNodeHandlerEntity = {
  handlerName: "paragraphNodeHandler",
  handler: handleParagraphNode
};
function getDefaultStyleDefinition(defaultStyleId, docx) {
  const result = { lineSpaceBefore: null, lineSpaceAfter: null };
  if (!defaultStyleId) return result;
  const styles = docx["word/styles.xml"];
  if (!styles) return result;
  const { elements } = styles.elements[0];
  const elementsWithId = elements.filter((el) => {
    const { attributes } = el;
    return attributes && attributes["w:styleId"] === defaultStyleId;
  });
  const firstMatch = elementsWithId[0];
  if (!firstMatch) return result;
  const qFormat = elementsWithId.find((el) => {
    const qFormat2 = el.elements.find((innerEl) => innerEl.name === "w:qFormat");
    return qFormat2;
  });
  const name = elementsWithId.find((el) => el.elements.some((inner) => inner.name === "w:name"))?.elements.find((inner) => inner.name === "w:name")?.attributes["w:val"];
  const pPr = firstMatch.elements.find((el) => el.name === "w:pPr");
  const spacing = pPr?.elements?.find((el) => el.name === "w:spacing");
  const justify = pPr?.elements?.find((el) => el.name === "w:jc");
  const indent = pPr?.elements?.find((el) => el.name === "w:ind");
  let lineSpaceBefore, lineSpaceAfter, line;
  if (spacing) {
    lineSpaceBefore = twipsToPixels(spacing?.attributes["w:before"]);
    lineSpaceAfter = twipsToPixels(spacing?.attributes["w:after"]);
    line = twipsToLines(spacing?.attributes["w:line"]);
  }
  let textAlign, leftIndent, rightIndent, firstLine;
  if (indent) {
    textAlign = justify?.attributes["w:val"];
    leftIndent = twipsToPixels(indent?.attributes["w:left"]);
    rightIndent = twipsToPixels(indent?.attributes["w:right"]);
    firstLine = twipsToPixels(indent?.attributes["w:firstLine"]);
  }
  const keepNext = pPr?.elements?.find((el) => el.name === "w:keepNext");
  const keepLines = pPr?.elements?.find((el) => el.name === "w:keepLines");
  const outlineLevel = pPr?.elements?.find((el) => el.name === "w:outlineLvl");
  const outlineLvlValue = outlineLevel?.attributes["w:val"];
  const pageBreakBefore = pPr?.elements?.find((el) => el.name === "w:pageBreakBefore");
  let pageBreakBeforeVal = 0;
  if (pageBreakBefore) {
    if (!pageBreakBefore.attributes?.["w:val"]) pageBreakBeforeVal = 1;
    else pageBreakBeforeVal = Number(pageBreakBefore?.attributes?.["w:val"]);
  }
  const pageBreakAfter = pPr?.elements?.find((el) => el.name === "w:pageBreakAfter");
  let pageBreakAfterVal;
  if (pageBreakAfter) {
    if (!pageBreakAfter.attributes?.["w:val"]) pageBreakAfterVal = 1;
    else pageBreakAfterVal = Number(pageBreakAfter?.attributes?.["w:val"]);
  }
  const basedOn = elementsWithId.find((el) => el.elements.some((inner) => inner.name === "w:basedOn"))?.elements.find((inner) => inner.name === "w:basedOn")?.attributes["w:val"];
  const parsedAttrs = {
    name,
    qFormat: qFormat ? true : false,
    keepNext: keepNext ? true : false,
    keepLines: keepLines ? true : false,
    outlineLevel: outlineLevel ? parseInt(outlineLvlValue) : null,
    pageBreakBefore: pageBreakBeforeVal ? true : false,
    pageBreakAfter: pageBreakAfterVal ? true : false,
    basedOn: basedOn ?? null
  };
  const rPr = firstMatch.elements.find((el) => el.name === "w:rPr");
  const parsedMarks = parseMarks(rPr, [], docx) || {};
  const parsedStyles = {
    spacing: { lineSpaceAfter, lineSpaceBefore, line },
    textAlign,
    indent: { leftIndent, rightIndent, firstLine }
  };
  parsedMarks.forEach((mark) => {
    const { type: type2, attrs } = mark;
    if (type2 === "textStyle") {
      Object.entries(attrs).forEach(([key, value]) => {
        parsedStyles[kebabCase$1(key)] = value;
      });
      return;
    }
    parsedStyles[type2] = attrs;
  });
  return {
    attrs: parsedAttrs,
    styles: parsedStyles
  };
}
function preProcessNodesForFldChar(nodes = []) {
  const processedNodes = [];
  let buffer2 = [];
  let collecting = false;
  for (const node2 of nodes) {
    const fldCharEl = node2.elements?.find((el) => el.name === "w:fldChar");
    const fldType = fldCharEl?.attributes?.["w:fldCharType"];
    if (fldType === "begin") {
      buffer2 = [node2];
      collecting = true;
      continue;
    }
    if (fldType === "separate" && collecting) {
      buffer2.push(node2);
      continue;
    }
    if (fldType === "end" && collecting) {
      buffer2.push(node2);
      processedNodes.push(...processCombinedNodesForFldChar(buffer2));
      buffer2 = [];
      collecting = false;
      continue;
    }
    if (collecting) {
      buffer2.push(node2);
    } else {
      processedNodes.push(node2);
    }
  }
  if (buffer2.length) {
    processedNodes.push(...buffer2);
  }
  return processedNodes;
}
const processCombinedNodesForFldChar = (nodesToCombine = []) => {
  let processedNodes = [];
  let hasPageMarker = false;
  let isNumPages = false;
  const textStart = nodesToCombine.findIndex(
    (n) => n.elements?.some((el) => el.name === "w:fldChar" && el.attributes["w:fldCharType"] === "separate")
  );
  const textEnd = nodesToCombine.findIndex(
    (n) => n.elements?.some((el) => el.name === "w:fldChar" && el.attributes["w:fldCharType"] === "end")
  );
  const textNodes = nodesToCombine.slice(textStart + 1, textEnd);
  const instrTextContainer = nodesToCombine.find((n) => n.elements?.some((el) => el.name === "w:instrText"));
  const instrTextNode = instrTextContainer?.elements?.find((el) => el.name === "w:instrText");
  const instrText = instrTextNode?.elements[0].text;
  if (!hasPageMarker) hasPageMarker = instrText?.trim().startsWith("PAGE");
  if (!isNumPages) isNumPages = instrText?.trim().startsWith("NUMPAGES");
  const urlMatch = instrText?.match(/HYPERLINK\s+"([^"]+)"/);
  if (hasPageMarker) {
    const pageNumNode = {
      name: "sd:autoPageNumber",
      type: "element"
    };
    nodesToCombine.forEach((n) => {
      const rPrNode = n.elements.find((el) => el.name === "w:rPr");
      if (rPrNode) pageNumNode.elements = [rPrNode];
    });
    processedNodes.push(pageNumNode);
  } else if (isNumPages) {
    const totalPageNumNode = {
      name: "sd:totalPageNumber",
      type: "element"
    };
    nodesToCombine.forEach((n) => {
      const rPrNode = n.elements.find((el) => el.name === "w:rPr");
      if (rPrNode) totalPageNumNode.elements = [rPrNode];
    });
    processedNodes.push(totalPageNumNode);
  } else if (urlMatch && urlMatch?.length >= 2) {
    const url = urlMatch[1];
    const textMarks = [];
    textNodes.forEach((n) => {
      const rPr2 = n.elements.find((el) => el.name === "w:rPr");
      if (!rPr2) return;
      const { elements } = rPr2;
      elements.forEach((el) => {
        textMarks.push(el);
      });
    });
    const linkMark = { name: "link", attributes: { href: url } };
    const rPr = { name: "w:rPr", type: "element", elements: [linkMark, ...textMarks] };
    processedNodes.push({
      name: "w:r",
      type: "element",
      elements: [rPr, ...textNodes]
    });
  }
  return processedNodes;
};
const tableOfContentsHandler = (params2) => {
  return nodeListHandler.handler({ ...params2, nodes: node.elements });
};
const handleDocPartObj = (params2) => {
  const { nodes } = params2;
  if (nodes.length === 0 || nodes[0].name !== "w:sdt") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const sdtPr = node2.elements.find((el) => el.name === "w:sdtPr");
  const docPartObj = sdtPr?.elements.find((el) => el.name === "w:docPartObj");
  const docPartGallery = docPartObj?.elements.find((el) => el.name === "w:docPartGallery");
  const docPartGalleryType = docPartGallery?.attributes["w:val"];
  if (!docPartGalleryType) {
    return { nodes: [], consumed: 0 };
  }
  if (!validGalleryTypeMap[docPartGalleryType]) {
    return { nodes: [], consumed: 0 };
  }
  const content = node2?.elements.find((el) => el.name === "w:sdtContent");
  const handler = validGalleryTypeMap[docPartGalleryType];
  const result = handler({ ...params2, nodes: [content] });
  return {
    nodes: result,
    consumed: 1
  };
};
const validGalleryTypeMap = {
  "Table of Contents": tableOfContentsHandler
};
const handleAnnotationNode = (params2) => {
  const { nodes, docx, nodeListHandler: nodeListHandler2, insideTrackChange } = params2;
  if (nodes.length === 0 || nodes[0].name !== "w:sdt") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const sdtPr = node2.elements.find((el) => el.name === "w:sdtPr");
  const sdtContent = node2.elements.find((el) => el.name === "w:sdtContent");
  const docPartObj = sdtPr?.elements.find((el) => el.name === "w:docPartObj");
  if (docPartObj) {
    return handleDocPartObj({ nodes, docx, nodeListHandler: nodeListHandler2, insideTrackChange });
  }
  const alias = sdtPr?.elements.find((el) => el.name === "w:alias");
  const tag = sdtPr?.elements.find((el) => el.name === "w:tag");
  const tagValue = tag?.attributes["w:val"];
  const processAsJSON = tagValue?.startsWith("{") && tagValue?.endsWith("}");
  let attrs = {};
  if (processAsJSON) {
    const parsedAttrs = parseTagAttrsJSON(tagValue);
    const attrsFromJSON = {
      type: parsedAttrs.fieldTypeShort,
      fieldId: parsedAttrs.fieldId,
      displayLabel: parsedAttrs.displayLabel,
      defaultDisplayLabel: parsedAttrs.defaultDisplayLabel,
      fieldType: parsedAttrs.fieldType,
      fieldColor: parsedAttrs.fieldColor,
      multipleImage: parsedAttrs.fieldMultipleImage,
      fontFamily: parsedAttrs.fieldFontFamily,
      fontSize: parsedAttrs.fieldFontSize,
      textColor: parsedAttrs.fieldTextColor,
      textHighlight: parsedAttrs.fieldTextHighlight,
      hash: parsedAttrs.hash
    };
    attrs = attrsFromJSON;
  } else {
    const attrsFromElements = getAttrsFromElements({ sdtPr, tag, alias });
    attrs = attrsFromElements;
  }
  const { attrs: marksAsAttrs, marks } = parseAnnotationMarks(sdtContent);
  const allAttrs = { ...attrs, ...marksAsAttrs };
  if (!allAttrs.hash) allAttrs.hash = generateDocxRandomId(4);
  if (!attrs.fieldId || !attrs.type) {
    return { nodes: [], consumed: 0 };
  }
  let result = {
    type: "text",
    text: `{{${attrs.displayLabel}}}`,
    attrs: allAttrs,
    marks
  };
  if (params2.editor.options.annotations) {
    result = {
      type: "fieldAnnotation",
      attrs: allAttrs
    };
  }
  return {
    nodes: [result],
    consumed: 1
  };
};
const parseAnnotationMarks = (content = {}) => {
  let mainContent = content;
  const run2 = mainContent.elements?.find((el) => el.name === "w:r");
  const rPr = run2?.elements?.find((el) => el.name === "w:rPr");
  if (!rPr) return {};
  const unknownMarks = [];
  const marks = parseMarks(rPr, unknownMarks) || [];
  const marksWithFlatFontStyles = [];
  marks.forEach((mark) => {
    const { type: type2 } = mark;
    if (type2 === "textStyle") {
      const { attrs: attrs2 } = mark;
      Object.keys(attrs2).forEach((key) => {
        marksWithFlatFontStyles.push({ type: key, attrs: attrs2[key] });
      });
    } else {
      marksWithFlatFontStyles.push(mark);
    }
  });
  const attrs = {};
  marksWithFlatFontStyles?.forEach((mark) => {
    const { type: type2 } = mark;
    attrs[type2] = mark.attrs || true;
  });
  return {
    attrs,
    marks
  };
};
function getAttrsFromElements({ sdtPr, tag, alias }) {
  const type2 = sdtPr?.elements.find((el) => el.name === "w:fieldTypeShort")?.attributes["w:val"];
  const fieldType = sdtPr?.elements.find((el) => el.name === "w:fieldType")?.attributes["w:val"];
  const fieldColor = sdtPr?.elements.find((el) => el.name === "w:fieldColor")?.attributes["w:val"];
  const isMultipleImage = sdtPr?.elements.find((el) => el.name === "w:fieldMultipleImage")?.attributes["w:val"];
  const fontFamily2 = sdtPr?.elements.find((el) => el.name === "w:fieldFontFamily")?.attributes["w:val"];
  const fontSize2 = sdtPr?.elements.find((el) => el.name === "w:fieldFontSize")?.attributes["w:val"];
  const textColor = sdtPr?.elements.find((el) => el.name === "w:fieldTextColor")?.attributes["w:val"];
  const textHighlight = sdtPr?.elements.find((el) => el.name === "w:fieldTextHighlight")?.attributes["w:val"];
  const attrs = {
    type: type2,
    fieldId: tag?.attributes["w:val"],
    displayLabel: alias?.attributes["w:val"],
    fieldType,
    fieldColor,
    multipleImage: isMultipleImage === "true",
    fontFamily: fontFamily2 !== "null" ? fontFamily2 : null,
    fontSize: fontSize2 !== "null" ? fontSize2 : null,
    textColor: textColor !== "null" ? textColor : null,
    textHighlight: textHighlight !== "null" ? textHighlight : null
  };
  return attrs;
}
function parseTagAttrsJSON(json) {
  try {
    const attrs = JSON.parse(json);
    return attrs;
  } catch (err) {
    console.error(err);
    return {};
  }
}
const annotationNodeHandlerEntity = {
  handlerName: "annotationNodeHandler",
  handler: handleAnnotationNode
};
const handleSdtNode = (params2) => {
  const { nodes, nodeListHandler: nodeListHandler2 } = params2;
  if (nodes.length === 0 || nodes[0].name !== "w:sdt") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const sdtPr = node2.elements.find((el) => el.name === "w:sdtPr");
  const tag = sdtPr?.elements.find((el) => el.name === "w:tag");
  let tagValue = tag?.attributes?.["w:val"];
  try {
    tagValue = JSON.parse(tagValue);
    const { type: type2 } = tagValue;
    if (type2 === "documentSection") return handleDocumentSectionNode(params2, tagValue);
  } catch {
  }
  const sdtContent = node2.elements.find((el) => el.name === "w:sdtContent");
  const par = sdtContent?.elements?.find((el) => el.name === "w:p");
  const { marks } = parseAnnotationMarks(sdtContent);
  const translatedContent = nodeListHandler2.handler({ ...params2, nodes: sdtContent?.elements });
  let structuredContentType = "structuredContent";
  if (par) {
    structuredContentType = "structuredContentBlock";
  }
  let result = {
    type: structuredContentType,
    content: translatedContent,
    marks,
    attrs: {
      sdtPr
    }
  };
  return {
    nodes: [result],
    consumed: 1
  };
};
const handleDocumentSectionNode = (params2, tagValue) => {
  const { nodes, nodeListHandler: nodeListHandler2 } = params2;
  const node2 = nodes[0];
  const sdtPr = node2.elements.find((el) => el.name === "w:sdtPr");
  const idTag = sdtPr?.elements.find((el) => el.name === "w:id");
  const id = idTag?.attributes?.["w:val"] || tagValue.id || null;
  const titleTag = sdtPr?.elements.find((el) => el.name === "w:alias");
  const title = titleTag?.attributes?.["w:val"] || tagValue.title || null;
  const { description } = tagValue;
  const sdtContent = node2.elements.find((el) => el.name === "w:sdtContent");
  const translatedContent = nodeListHandler2.handler({ ...params2, nodes: sdtContent?.elements });
  const result = {
    type: "documentSection",
    content: translatedContent,
    attrs: {
      id,
      title,
      description
    }
  };
  return {
    nodes: [result],
    consumed: 1
  };
};
const sdtNodeHandlerEntity = {
  handlerName: "sdtNodeHandler",
  handler: handleSdtNode
};
const handleStandardNode = (params2) => {
  const { nodes, docx, nodeListHandler: nodeListHandler2 } = params2;
  if (!nodes || nodes.length === 0) {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const { name } = node2;
  const { attributes, elements, marks = [] } = parseProperties(node2);
  if (name === "w:sdt") {
    return { nodes: [], consumed: 0 };
  }
  if (isPropertiesElement(node2)) {
    return {
      nodes: [
        {
          type: getElementName(node2),
          attrs: { ...attributes },
          marks: []
        }
      ],
      consumed: 0
    };
  }
  if (!getElementName(node2)) {
    return {
      nodes: [
        {
          type: name,
          content: elements,
          attrs: { ...attributes },
          marks
        }
      ],
      consumed: 0,
      unhandled: true
    };
  }
  const content = [];
  const parentStyleId = getParentStyleId(node2);
  if (elements && elements.length) {
    const updatedElements = elements.map((el) => {
      if (!el.marks) el.marks = [];
      el.marks.push(...marks);
      return el;
    });
    const childParams = { ...params2, nodes: updatedElements, parentStyleId };
    const childContent = nodeListHandler2.handler(childParams);
    content.push(...childContent);
  }
  const resultNode = {
    type: getElementName(node2),
    content,
    attrs: { ...attributes },
    marks: []
  };
  return { nodes: [resultNode], consumed: 1 };
};
const getParentStyleId = (node2) => {
  const pPr = node2.elements?.find((el) => el.name === "w:pPr");
  const styleTag = pPr?.elements?.find((el) => el.name === "w:pStyle");
  return styleTag ? styleTag.attributes["w:val"] : null;
};
const standardNodeHandlerEntity = {
  handlerName: "standardNodeHandler",
  handler: handleStandardNode
};
const handleLineBreakNode = (params2) => {
  const { nodes } = params2;
  if (nodes.length === 0 || nodes[0].name !== "w:br") {
    return { nodes: [], consumed: 0 };
  }
  const lineBreakType = nodes[0].attributes?.["w:type"];
  const breakType = lineBreakType === "page" ? "hardBreak" : "lineBreak";
  return {
    nodes: [
      {
        type: breakType
      }
    ],
    consumed: 1
  };
};
const lineBreakNodeHandlerEntity = {
  handlerName: "lineBreakNodeHandler",
  handler: handleLineBreakNode
};
const handleBookmarkNode = (params2) => {
  const { nodes, nodeListHandler: nodeListHandler2, editor } = params2;
  if (nodes.length === 0 || nodes[0].name !== "w:bookmarkStart") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const handleStandardNode2 = nodeListHandler2.handlerEntities.find(
    (e) => e.handlerName === "standardNodeHandler"
  )?.handler;
  if (!handleStandardNode2) {
    console.error("Standard node handler not found");
    return { nodes: [], consumed: 0 };
  }
  const customMarks = editor?.extensionService?.extensions?.filter((e) => e.isExternal === true) || [];
  const bookmarkName = node2.attributes["w:name"]?.split(";")[0];
  const customMark = customMarks.find((mark) => mark.name === bookmarkName);
  if (customMark) {
    const bookmarkEndIndex = nodes.findIndex(
      (n) => n.name === "w:bookmarkEnd" && n.attributes["w:id"] === node2.attributes["w:id"]
    );
    const textNodes = nodes.slice(1, bookmarkEndIndex);
    const nodeListHandler3 = params2.nodeListHandler;
    const attrs = {};
    node2.attributes["w:name"].split(";").forEach((name) => {
      const [key, value] = name.split("=");
      if (key && value) {
        attrs[key] = value;
      }
    });
    const translatedText = nodeListHandler3.handler({ ...params2, nodes: textNodes });
    translatedText.forEach((n) => {
      n.marks.push({
        type: customMark.name,
        attrs
      });
    });
    return {
      nodes: translatedText,
      consumed: translatedText.length + 2
    };
  }
  const updatedParams = { ...params2, nodes: [node2] };
  const result = handleStandardNode2(updatedParams);
  if (result.nodes.length === 1) {
    result.nodes[0].attrs.name = node2.attributes["w:name"];
    result.nodes[0].attrs.id = node2.attributes["w:id"];
  }
  return result;
};
const bookmarkNodeHandlerEntity = {
  handlerName: "bookmarkNodeHandler",
  handler: handleBookmarkNode
};
const handleAlternateChoice = (params2) => {
  const skipHandlerResponse = { nodes: [], consumed: 0 };
  const { nodes, nodeListHandler: nodeListHandler2 } = params2;
  if (nodes.length === 0 || nodes[0].name !== "w:p") {
    return skipHandlerResponse;
  }
  const mainNode = nodes[0];
  const node2 = mainNode?.elements?.find((el) => el.name === "w:r");
  const hasAltChoice = node2?.elements?.some((el) => el.name === "mc:AlternateContent");
  if (!hasAltChoice) {
    return skipHandlerResponse;
  }
  const altChoiceNode = node2.elements.find((el) => el.name === "mc:AlternateContent");
  node2.elements.findIndex((el) => el.name === "mc:AlternateContent");
  const allowedNamespaces = ["wps", "wp14", "w14", "w15"];
  const wpsNode = altChoiceNode.elements.find(
    (el) => el.name === "mc:Choice" && allowedNamespaces.includes(el.attributes["Requires"])
  );
  if (!wpsNode) {
    return skipHandlerResponse;
  }
  const contents = wpsNode.elements;
  const result = nodeListHandler2.handler({
    ...params2,
    nodes: contents
  });
  return { nodes: result, consumed: 1 };
};
const alternateChoiceHandler = {
  handlerName: "alternateChoiceHandler",
  handler: handleAlternateChoice
};
const handleAutoPageNumber = (params2) => {
  const { nodes } = params2;
  if (nodes.length === 0 || nodes[0].name !== "sd:autoPageNumber") {
    return { nodes: [], consumed: 0 };
  }
  const rPr = nodes[0].elements?.find((el) => el.name === "w:rPr");
  const marks = parseMarks(rPr || { elements: [] });
  const processedNode = {
    type: "page-number",
    attrs: {
      marksAsAttrs: marks
    }
  };
  return { nodes: [processedNode], consumed: 1 };
};
const autoPageHandlerEntity = {
  handlerName: "autoPageNumberHandler",
  handler: handleAutoPageNumber
};
const handleAutoTotalPageNumber = (params2) => {
  const { nodes } = params2;
  if (nodes.length === 0 || nodes[0].name !== "sd:totalPageNumber") {
    return { nodes: [], consumed: 0 };
  }
  const rPr = nodes[0].elements?.find((el) => el.name === "w:rPr");
  const marks = parseMarks(rPr || { elements: [] });
  const processedNode = {
    type: "total-page-number",
    attrs: {
      marksAsAttrs: marks
    }
  };
  return { nodes: [processedNode], consumed: 1 };
};
const autoTotalPageCountEntity = {
  handlerName: "autoTotalPageCountEntity",
  handler: handleAutoTotalPageNumber
};
const handleTabNode = (params2) => {
  const { nodes, docx, parentStyleId } = params2;
  if (nodes.length === 0 || nodes[0].name !== "w:tab") {
    return { nodes: [], consumed: 0 };
  }
  const node2 = nodes[0];
  const styles = docx["word/styles.xml"];
  if (styles && styles.elements?.length) {
    const style2 = styles.elements[0]?.elements?.find((s) => s.attributes?.["w:styleId"] === parentStyleId);
    const pPr = style2?.elements?.find((s) => s.name === "w:pPr");
    const tabsDef = pPr?.elements?.find((s) => s.name === "w:tabs");
    const firstTab = tabsDef?.elements?.find((s) => s.name === "w:tab");
    twipsToPixels(firstTab?.attributes?.["w:pos"]);
  }
  const { attributes = {} } = node2;
  const processedNode = {
    type: "tab",
    attrs: {
      tabSize: attributes["w:val"] || 48
    },
    content: []
  };
  return { nodes: [processedNode], consumed: 1 };
};
const tabNodeEntityHandler = {
  handlerName: "tabNodeHandler",
  handler: handleTabNode
};
const handlePictNode = (params2) => {
  const { nodes } = params2;
  if (!nodes.length || nodes[0].name !== "w:p") {
    return { nodes: [], consumed: 0 };
  }
  const [pNode] = nodes;
  const run2 = pNode.elements?.find((el) => el.name === "w:r");
  const pict = run2?.elements?.find((el) => el.name === "w:pict");
  if (!pict) {
    return { nodes: [], consumed: 0 };
  }
  const node2 = pict;
  const shape = node2.elements?.find((el) => el.name === "v:shape");
  const group = node2.elements?.find((el) => el.name === "v:group");
  const rect = node2.elements?.find((el) => el.name === "v:rect");
  if (rect) {
    const result2 = handleVRectImport({
      pNode,
      rect
    });
    return { nodes: result2 ? [result2] : [], consumed: 1 };
  }
  if (!shape && !group) {
    return { nodes: [], consumed: 0 };
  }
  let result = null;
  const isGroup2 = group && !shape;
  if (isGroup2) {
    result = null;
  } else {
    const textbox = shape.elements?.find((el) => el.name === "v:textbox");
    if (textbox) {
      result = handleShapTextboxImport({
        shape,
        params: params2
      });
    }
  }
  return { nodes: result ? [result] : [], consumed: 1 };
};
function handleVRectImport({ rect, pNode }) {
  const schemaAttrs = {};
  const rectAttrs = rect.attributes || {};
  schemaAttrs.attributes = rectAttrs;
  if (rectAttrs.style) {
    const parsedStyle = parseInlineStyles(rectAttrs.style);
    const rectStyle = buildVRectStyles(parsedStyle);
    if (rectStyle) {
      schemaAttrs.style = rectStyle;
    }
    const size2 = {};
    if (parsedStyle.width !== void 0) {
      const inlineWidth = parsePointsToPixels(parsedStyle.width);
      size2.width = inlineWidth;
      if (rectAttrs["o:hr"] === "t" && !inlineWidth) {
        size2.width = "100%";
      }
    }
    if (parsedStyle.height !== void 0) {
      size2.height = parsePointsToPixels(parsedStyle.height);
    }
    if (Object.keys(size2).length > 0) {
      schemaAttrs.size = size2;
    }
  }
  if (rectAttrs.fillcolor) {
    schemaAttrs.background = rectAttrs.fillcolor;
  }
  const vmlAttrs = {};
  if (rectAttrs["o:hralign"]) vmlAttrs.hralign = rectAttrs["o:hralign"];
  if (rectAttrs["o:hrstd"]) vmlAttrs.hrstd = rectAttrs["o:hrstd"];
  if (rectAttrs["o:hr"]) vmlAttrs.hr = rectAttrs["o:hr"];
  if (rectAttrs.stroked) vmlAttrs.stroked = rectAttrs.stroked;
  if (Object.keys(vmlAttrs).length > 0) {
    schemaAttrs.vmlAttributes = vmlAttrs;
  }
  const isHorizontalRule = rectAttrs["o:hr"] === "t" || rectAttrs["o:hrstd"] === "t";
  if (isHorizontalRule) {
    schemaAttrs.horizontalRule = true;
  }
  const pPr = pNode.elements?.find((el) => el.name === "w:pPr");
  const spacingElement = pPr?.elements?.find((el) => el.name === "w:spacing");
  const spacingAttrs = spacingElement?.attributes || {};
  const inLineIndentTag = pPr?.elements?.find((el) => el.name === "w:ind");
  const inLineIndent = inLineIndentTag?.attributes || {};
  const spacing = {};
  if (spacingAttrs["w:after"]) spacing.lineSpaceAfter = twipsToPixels(spacingAttrs["w:after"]);
  if (spacingAttrs["w:before"]) spacing.lineSpaceBefore = twipsToPixels(spacingAttrs["w:before"]);
  if (spacingAttrs["w:line"]) spacing.line = twipsToLines(spacingAttrs["w:line"]);
  if (spacingAttrs["w:lineRule"]) spacing.lineRule = spacingAttrs["w:lineRule"];
  const indent = {
    left: 0,
    right: 0,
    firstLine: 0,
    hanging: 0
  };
  const leftIndent = inLineIndent?.["w:left"];
  const rightIndent = inLineIndent?.["w:right"];
  if (leftIndent) {
    indent.left = twipsToPixels(leftIndent);
  }
  if (rightIndent) {
    indent.right = twipsToPixels(rightIndent);
  }
  return {
    type: "paragraph",
    content: [
      {
        type: "contentBlock",
        attrs: schemaAttrs
      }
    ],
    attrs: {
      spacing: Object.keys(spacing).length > 0 ? spacing : void 0,
      rsidRDefault: pNode.attributes?.["w:rsidRDefault"],
      indent
    }
  };
}
function handleShapTextboxImport({ shape, params: params2 }) {
  const schemaAttrs = {};
  const schemaTextboxAttrs = {};
  const shapeAttrs = shape.attributes || {};
  schemaAttrs.attributes = shapeAttrs;
  if (shapeAttrs.fillcolor) {
    schemaAttrs.fillcolor = shapeAttrs.fillcolor;
  }
  const parsedStyle = parseInlineStyles(shapeAttrs.style);
  const shapeStyle = buildStyles(parsedStyle);
  if (shapeStyle) {
    schemaAttrs.style = shapeStyle;
  }
  const textbox = shape.elements?.find((el) => el.name === "v:textbox");
  const wrap2 = shape.elements?.find((el) => el.name === "w10:wrap");
  if (wrap2?.attributes) {
    schemaAttrs.wrapAttributes = wrap2.attributes;
  }
  if (textbox?.attributes) {
    schemaTextboxAttrs.attributes = textbox.attributes;
  }
  const textboxContent = textbox?.elements?.find((el) => el.name === "w:txbxContent");
  const textboxContentElems = textboxContent?.elements || [];
  const content = textboxContentElems.map(
    (elem) => handleParagraphNode({
      nodes: [elem],
      docx: params2.docx,
      nodeListHandler: defaultNodeListHandler()
    })
  );
  const contentNodes = content.reduce((acc, current) => [...acc, ...current.nodes], []);
  const shapeTextbox = {
    type: "shapeTextbox",
    attrs: schemaTextboxAttrs,
    content: contentNodes
  };
  const shapeContainer = {
    type: "shapeContainer",
    attrs: schemaAttrs,
    content: [shapeTextbox]
  };
  return shapeContainer;
}
function parseInlineStyles(styleString) {
  if (!styleString) return {};
  return styleString.split(";").filter((style2) => !!style2.trim()).reduce((acc, style2) => {
    const [prop, value] = style2.split(":").map((str) => str.trim());
    if (prop && value) acc[prop] = value;
    return acc;
  }, {});
}
function buildStyles(styleObject) {
  const allowed = [
    "width",
    "height"
    // these styles should probably work relative to the page,
    // since in the doc it is positioned absolutely.
    // 'margin-left',
    // 'margin-right',
    // causes pagination issues.
    // 'margin-top',
    // 'margin-bottom',
    // styleObject - also contains other word styles (mso-).
  ];
  let style2 = "";
  for (const [prop, value] of Object.entries(styleObject)) {
    if (allowed.includes(prop)) {
      style2 += `${prop}: ${value};`;
    }
  }
  return style2;
}
function buildVRectStyles(styleObject) {
  let style2 = "";
  for (const [prop, value] of Object.entries(styleObject)) {
    style2 += `${prop}: ${value};`;
  }
  return style2;
}
function parsePointsToPixels(value) {
  if (typeof value !== "string") return value;
  if (value.endsWith("pt")) {
    const val = value.replace("pt", "");
    if (isNaN(val)) {
      return 0;
    }
    const points = parseFloat(val);
    return Math.ceil(points * 1.33);
  }
  if (value.endsWith("px")) {
    const val = value.replace("px", "");
    if (isNaN(val)) {
      return 0;
    }
    return parseInt(val);
  }
  const numValue = parseFloat(value);
  return isNaN(numValue) ? 0 : numValue;
}
const pictNodeHandlerEntity = {
  handlerName: "handlePictNode",
  handler: handlePictNode
};
function importCommentData({ docx, editor, converter }) {
  const nodeListHandler2 = defaultNodeListHandler();
  const comments = docx["word/comments.xml"];
  if (!comments) return;
  const { elements } = comments;
  if (!elements || !elements.length) return;
  const { elements: allComments = [] } = elements[0];
  const extractedComments = allComments.map((el) => {
    const { attributes } = el;
    const importedId = attributes["w:id"];
    const authorName = attributes["w:author"];
    const authorEmail = attributes["w:email"];
    const initials = attributes["w:initials"];
    const createdDate = attributes["w:date"];
    const internalId = attributes["custom:internalId"];
    const trackedChange = attributes["custom:trackedChange"] === "true";
    const trackedChangeType = attributes["custom:trackedChangeType"];
    const trackedChangeText = attributes["custom:trackedChangeText"] !== "null" ? attributes["custom:trackedChangeText"] : null;
    const trackedDeletedText = attributes["custom:trackedDeletedText"] !== "null" ? attributes["custom:trackedDeletedText"] : null;
    const date = new Date(createdDate);
    const unixTimestampMs = date.getTime();
    const parsedComment = nodeListHandler2.handler({
      nodes: el.elements,
      nodeListHandler: nodeListHandler2,
      docx,
      editor,
      converter
    });
    const { attrs } = parsedComment[0];
    const paraId = attrs["w14:paraId"];
    return {
      commentId: internalId || v4(),
      importedId,
      creatorName: authorName,
      creatorEmail: authorEmail,
      createdTime: unixTimestampMs,
      textJson: parsedComment[0],
      initials,
      paraId,
      trackedChange,
      trackedChangeText,
      trackedChangeType,
      trackedDeletedText
    };
  });
  const extendedComments = generateCommentsWithExtendedData({ docx, comments: extractedComments });
  return extendedComments;
}
const generateCommentsWithExtendedData = ({ docx, comments }) => {
  const commentsExtended = docx["word/commentsExtended.xml"];
  if (!commentsExtended) return [];
  const { elements: initialElements } = commentsExtended;
  const { elements } = initialElements[0];
  const commentEx = elements.filter((el) => el.name === "w15:commentEx");
  return comments.map((comment) => {
    const extendedDef = commentEx.find((ce2) => ce2.attributes["w15:paraId"] === comment.paraId);
    if (!extendedDef) return { ...comment };
    const { isDone, paraIdParent } = getExtendedDetails(extendedDef);
    let parentComment;
    if (paraIdParent) parentComment = comments.find((c2) => c2.paraId === paraIdParent);
    const newComment = {
      ...comment,
      isDone,
      parentCommentId: parentComment?.commentId
    };
    return newComment;
  });
};
const getExtendedDetails = (commentEx) => {
  const { attributes } = commentEx;
  const paraId = attributes["w15:paraId"];
  const isDone = attributes["w15:done"] === "1" ? true : false;
  const paraIdParent = attributes["w15:paraIdParent"];
  return { paraId, isDone, paraIdParent };
};
const createDocumentJson = (docx, converter, editor) => {
  const json = carbonCopy(getInitialJSON(docx));
  if (!json) return null;
  if (converter?.telemetry) {
    const files = Object.keys(docx).map((filePath) => {
      const parts = filePath.split("/");
      return {
        filePath,
        fileDepth: parts.length,
        fileType: filePath.split(".").pop()
      };
    });
    converter.telemetry.trackFileStructure(
      {
        totalFiles: files.length,
        maxDepth: Math.max(...files.map((f) => f.fileDepth)),
        totalNodes: 0,
        files
      },
      converter.fileSource,
      converter.documentId,
      converter.documentInternalId
    );
  }
  const nodeListHandler2 = defaultNodeListHandler();
  const bodyNode = json.elements[0].elements.find((el) => el.name === "w:body");
  if (bodyNode) {
    const node2 = bodyNode;
    const ignoreNodes = ["w:sectPr"];
    const content = node2.elements?.filter((n) => !ignoreNodes.includes(n.name)) ?? [];
    const comments = importCommentData({ docx, converter, editor });
    const lists = {};
    const parsedContent = nodeListHandler2.handler({
      nodes: content,
      nodeListHandler: nodeListHandler2,
      docx,
      converter,
      editor,
      lists
    });
    const result = {
      type: "doc",
      content: parsedContent,
      attrs: {
        attributes: json.elements[0].attributes
      }
    };
    if (result.content.length > 1) {
      converter?.telemetry?.trackUsage("document_import", {
        documentType: "docx",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    }
    return {
      pmDoc: result,
      savedTagsToRestore: node2,
      pageStyles: getDocumentStyles(node2, docx, converter, editor),
      comments,
      linkedStyles: getStyleDefinitions(docx),
      numbering: getNumberingDefinitions(docx)
    };
  }
  return null;
};
const defaultNodeListHandler = () => {
  const entities = [
    alternateChoiceHandler,
    runNodeHandlerEntity,
    pictNodeHandlerEntity,
    listHandlerEntity,
    paragraphNodeHandlerEntity,
    textNodeHandlerEntity,
    lineBreakNodeHandlerEntity,
    annotationNodeHandlerEntity,
    sdtNodeHandlerEntity,
    bookmarkNodeHandlerEntity,
    hyperlinkNodeHandlerEntity,
    drawingNodeHandlerEntity,
    trackChangeNodeHandlerEntity,
    tableNodeHandlerEntity,
    tabNodeEntityHandler,
    autoPageHandlerEntity,
    autoTotalPageCountEntity,
    standardNodeHandlerEntity
    // This is the last one as it can handle everything
  ];
  const handler = createNodeListHandler(entities);
  return {
    handler,
    handlerEntities: entities
  };
};
const createNodeListHandler = (nodeHandlers) => {
  const getSafeElementContext = (elements, index2, processedNode, path) => {
    if (!elements || index2 < 0 || index2 >= elements.length) {
      return {
        elementIndex: index2,
        error: "index_out_of_bounds",
        arrayLength: elements?.length
      };
    }
    const element = elements[index2];
    return {
      elementName: element?.name,
      attributes: processedNode?.attrs,
      marks: processedNode?.marks,
      elementPath: path,
      type: processedNode?.type,
      content: processedNode?.content
    };
  };
  const nodeListHandlerFn = ({
    nodes: elements,
    docx,
    insideTrackChange,
    converter,
    editor,
    filename,
    parentStyleId,
    lists
  }) => {
    if (!elements || !elements.length) return [];
    const processedElements = [];
    try {
      for (let index2 = 0; index2 < elements.length; index2++) {
        try {
          const nodesToHandle = elements.slice(index2);
          if (!nodesToHandle || nodesToHandle.length === 0) {
            continue;
          }
          const { nodes, consumed, unhandled } = nodeHandlers.reduce(
            (res, handler) => {
              if (res.consumed > 0) return res;
              return handler.handler({
                nodes: nodesToHandle,
                docx,
                nodeListHandler: { handler: nodeListHandlerFn, handlerEntities: nodeHandlers },
                insideTrackChange,
                converter,
                editor,
                filename,
                parentStyleId,
                lists
              });
            },
            { nodes: [], consumed: 0 }
          );
          const context = getSafeElementContext(elements, index2, nodes[0], `/word/${filename || "document.xml"}`);
          if (unhandled) {
            if (!context.elementName) continue;
            converter?.telemetry?.trackStatistic("unknown", context);
            continue;
          } else {
            converter?.telemetry?.trackStatistic("node", context);
            if (context.type === "orderedList" || context.type === "bulletList") {
              context.content.forEach((item) => {
                const innerItemContext = getSafeElementContext([item], 0, item, `/word/${filename || "document.xml"}`);
                converter?.telemetry?.trackStatistic("attributes", innerItemContext);
              });
            }
            const hasHighlightMark = nodes[0]?.marks?.find((mark) => mark.type === "highlight");
            if (hasHighlightMark) {
              converter?.docHiglightColors.add(hasHighlightMark.attrs.color.toUpperCase());
            }
          }
          if (consumed > 0) {
            index2 += consumed - 1;
          }
          if (nodes) {
            nodes.forEach((node2) => {
              if (node2?.type && !["runProperties"].includes(node2.type)) {
                if (node2.type === "text" && Array.isArray(node2.content) && !node2.content.length) {
                  return;
                }
                processedElements.push(node2);
              }
            });
          }
        } catch (error) {
          console.debug("Import error", error);
          editor?.emit("exception", { error });
          converter?.telemetry?.trackStatistic("error", {
            type: "processing_error",
            message: error.message,
            name: error.name,
            stack: error.stack,
            fileName: `/word/${filename || "document.xml"}`
          });
        }
      }
      return processedElements;
    } catch (error) {
      console.debug("Error during import", error);
      editor?.emit("exception", { error });
      converter?.telemetry?.trackStatistic("error", {
        type: "fatal_error",
        message: error.message,
        name: error.name,
        stack: error.stack,
        fileName: `/word/${filename || "document.xml"}`
      });
      throw error;
    }
  };
  return nodeListHandlerFn;
};
function getDocumentStyles(node2, docx, converter, editor) {
  const sectPr = node2.elements?.find((n) => n.name === "w:sectPr");
  const styles = {};
  sectPr?.elements?.forEach((el) => {
    const { name, attributes } = el;
    switch (name) {
      case "w:pgSz":
        styles["pageSize"] = {
          width: twipsToInches(attributes["w:w"]),
          height: twipsToInches(attributes["w:h"])
        };
        break;
      case "w:pgMar":
        styles["pageMargins"] = {
          top: twipsToInches(attributes["w:top"]),
          right: twipsToInches(attributes["w:right"]),
          bottom: twipsToInches(attributes["w:bottom"]),
          left: twipsToInches(attributes["w:left"]),
          header: twipsToInches(attributes["w:header"]),
          footer: twipsToInches(attributes["w:footer"]),
          gutter: twipsToInches(attributes["w:gutter"])
        };
        break;
      case "w:cols":
        styles["columns"] = {
          space: twipsToInches(attributes["w:space"]),
          num: attributes["w:num"],
          equalWidth: attributes["w:equalWidth"]
        };
        break;
      case "w:docGrid":
        styles["docGrid"] = {
          linePitch: twipsToInches(attributes["w:linePitch"]),
          type: attributes["w:type"]
        };
        break;
      case "w:titlePg":
        converter.headerIds.titlePg = true;
    }
  });
  importHeadersFooters(docx, converter, editor);
  styles.alternateHeaders = isAlternatingHeadersOddEven(docx);
  return styles;
}
function getStyleDefinitions(docx) {
  const styles = docx["word/styles.xml"];
  if (!styles) return [];
  const { elements } = styles.elements[0];
  const styleDefinitions = elements.filter((el) => el.name === "w:style");
  const latentStyles = elements.find((el) => el.name === "w:latentStyles");
  latentStyles?.elements.forEach((el) => {
    const { attributes } = el;
    styleDefinitions.find((style2) => style2.attributes["w:styleId"] === attributes["w:name"]);
  });
  const allParsedStyles = [];
  styleDefinitions.forEach((style2) => {
    const id = style2.attributes["w:styleId"];
    const parsedStyle = getDefaultStyleDefinition(id, docx);
    const importedStyle = {
      id: style2.attributes["w:styleId"],
      type: style2.attributes["w:type"],
      definition: parsedStyle,
      attributes: {}
    };
    allParsedStyles.push(importedStyle);
  });
  return allParsedStyles;
}
function addDefaultStylesIfMissing(styles) {
  if (!styles) return null;
  const updatedStyles = carbonCopy(styles);
  const { elements } = updatedStyles.elements[0];
  Object.keys(DEFAULT_LINKED_STYLES).forEach((styleId) => {
    const existsOnDoc = elements.some((el) => el.attributes?.["w:styleId"] === styleId);
    if (!existsOnDoc) {
      const missingStyle = DEFAULT_LINKED_STYLES[styleId];
      updatedStyles.elements[0].elements.push(missingStyle);
    }
  });
  return updatedStyles;
}
const importHeadersFooters = (docx, converter, mainEditor) => {
  const rels = docx["word/_rels/document.xml.rels"];
  const relationships = rels.elements.find((el) => el.name === "Relationships");
  const { elements } = relationships;
  const headerType = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header";
  const footerType = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer";
  const headers = elements.filter((el) => el.attributes["Type"] === headerType);
  const footers = elements.filter((el) => el.attributes["Type"] === footerType);
  const sectPr = findSectPr(docx["word/document.xml"]) || [];
  const allSectPrElements = sectPr.flatMap((el) => el.elements);
  if (!mainEditor) return;
  const editor = { ...mainEditor };
  editor.options.annotations = true;
  headers.forEach((header) => {
    const { rId, referenceFile, currentFileName } = getHeaderFooterSectionData(header, docx);
    const sectPrHeader = allSectPrElements.find(
      (el) => el.name === "w:headerReference" && el.attributes["r:id"] === rId
    );
    let sectionType = sectPrHeader?.attributes["w:type"];
    if (converter.headerIds[sectionType]) sectionType = null;
    const nodeListHandler2 = defaultNodeListHandler();
    const schema = nodeListHandler2.handler({
      nodes: referenceFile.elements[0].elements,
      nodeListHandler: nodeListHandler2,
      docx,
      converter,
      editor,
      filename: currentFileName
    });
    if (!converter.headerIds.ids) converter.headerIds.ids = [];
    converter.headerIds.ids.push(rId);
    converter.headers[rId] = { type: "doc", content: [...schema] };
    sectionType && (converter.headerIds[sectionType] = rId);
  });
  const titlePg = allSectPrElements?.find((el) => el.name === "w:titlePg");
  if (titlePg) converter.headerIds.titlePg = true;
  footers.forEach((footer) => {
    const { rId, referenceFile, currentFileName } = getHeaderFooterSectionData(footer, docx);
    const sectPrFooter = allSectPrElements.find(
      (el) => el.name === "w:footerReference" && el.attributes["r:id"] === rId
    );
    const sectionType = sectPrFooter?.attributes["w:type"];
    const nodeListHandler2 = defaultNodeListHandler();
    const schema = nodeListHandler2.handler({
      nodes: referenceFile.elements[0].elements,
      nodeListHandler: nodeListHandler2,
      docx,
      converter,
      editor,
      filename: currentFileName
    });
    if (!converter.footerIds.ids) converter.footerIds.ids = [];
    converter.footerIds.ids.push(rId);
    converter.footers[rId] = { type: "doc", content: [...schema] };
    converter.footerIds[sectionType] = rId;
  });
};
const findSectPr = (obj, result = []) => {
  for (const key in obj) {
    if (obj[key] === "w:sectPr") {
      result.push(obj);
    } else if (typeof obj[key] === "object") {
      findSectPr(obj[key], result);
    }
  }
  return result;
};
const getHeaderFooterSectionData = (sectionData, docx) => {
  const rId = sectionData.attributes.Id;
  const target = sectionData.attributes.Target;
  const referenceFile = docx[`word/${target}`];
  const currentFileName = target;
  return {
    rId,
    referenceFile,
    currentFileName
  };
};
function getNumberingDefinitions(docx) {
  let numbering = docx["word/numbering.xml"];
  if (!numbering || !numbering.elements?.length || !numbering.elements[0].elements?.length) numbering = baseNumbering;
  const elements = numbering.elements[0].elements;
  const abstractDefs = elements.filter((el) => el.name === "w:abstractNum");
  const definitions = elements.filter((el) => el.name === "w:num");
  const abstractDefinitions = {};
  abstractDefs.forEach((el) => {
    const abstractId = Number(el.attributes["w:abstractNumId"]);
    abstractDefinitions[abstractId] = el;
  });
  let importListDefs = {};
  definitions.forEach((el) => {
    const numId = Number(el.attributes["w:numId"]);
    importListDefs[numId] = el;
  });
  const listDefsEntries = Object.entries(importListDefs);
  const foundByDurableId = listDefsEntries.filter(([, def]) => def.attributes?.["w16cid:durableId"] === "485517411");
  if (foundByDurableId.length > 1) {
    importListDefs = Object.fromEntries(
      listDefsEntries.filter(([, def]) => def.attributes?.["w16cid:durableId"] !== "485517411")
    );
  }
  return {
    abstracts: abstractDefinitions,
    definitions: importListDefs
  };
}
const isAlternatingHeadersOddEven = (docx) => {
  const settings = docx["word/settings.xml"];
  if (!settings || !settings.elements?.length) return false;
  const { elements = [] } = settings.elements[0];
  const evenOdd = elements.find((el) => el.name === "w:evenAndOddHeaders");
  return !!evenOdd;
};
const HYPERLINK_RELATIONSHIP_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink";
const HEADER_RELATIONSHIP_TYPE = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header";
const RELATIONSHIP_TYPES = (
  /** @type {const} */
  {
    image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
    hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink"
  }
);
const getDocumentRelationshipElements = (editor) => {
  const docx = editor.converter?.convertedXml;
  if (!docx) return [];
  const documentRels = docx["word/_rels/document.xml.rels"];
  const elements = documentRels?.elements;
  if (!Array.isArray(elements)) return [];
  const relationshipTag = elements.find((el) => el.name === "Relationships");
  return relationshipTag?.elements || [];
};
const getMaxRelationshipIdInt = (relationships) => {
  const ids = [];
  relationships.forEach((rel) => {
    const splitId = rel.attributes.Id.split("rId");
    const parsedInt = parseInt(splitId[1], 10);
    if (Number.isInteger(parsedInt)) {
      ids.push(parsedInt);
    }
  });
  if (ids.length === 0) return 0;
  return Math.max(...ids);
};
const findRelationshipIdFromTarget = (target, editor) => {
  if (!target) return null;
  if (target.startsWith("word/")) target = target.replace("word/", "");
  const relationships = getDocumentRelationshipElements(editor);
  const existingLinkRel = relationships?.find((rel) => rel.attributes.Target === target);
  if (existingLinkRel) {
    return existingLinkRel.attributes.Id;
  }
};
const insertNewRelationship = (target, type2, editor) => {
  if (!target || typeof target !== "string") {
    throw new Error("Target must be a non-empty string");
  }
  if (!type2 || typeof type2 !== "string") {
    throw new Error("Type must be a non-empty string");
  }
  if (!editor) {
    throw new Error("Editor instance is required");
  }
  const mappedType = RELATIONSHIP_TYPES[type2];
  if (!mappedType) {
    console.warn(
      `Unsupported relationship type: ${type2}. Available types: ${Object.keys(RELATIONSHIP_TYPES).join(", ")}`
    );
    return null;
  }
  const existingRelId = findRelationshipIdFromTarget(target, editor);
  if (existingRelId) {
    console.info(`Reusing existing relationship for target: ${target} (ID: ${existingRelId})`);
    return existingRelId;
  }
  const docx = editor.converter?.convertedXml;
  if (!docx) {
    console.error("No converted XML found in editor");
    return null;
  }
  const documentRels = docx["word/_rels/document.xml.rels"];
  if (!documentRels) {
    console.error("No document relationships found in the docx");
    return null;
  }
  const relationshipsTag = documentRels.elements?.find((el) => el.name === "Relationships");
  if (!relationshipsTag) {
    console.error("No Relationships tag found in document relationships");
    return null;
  }
  if (!relationshipsTag.elements) {
    relationshipsTag.elements = [];
  }
  const newId = getNewRelationshipId(editor);
  if (!newId) {
    console.error("Failed to generate new relationship ID");
    return null;
  }
  const newRel = {
    type: "element",
    name: "Relationship",
    attributes: {
      Id: newId,
      Type: mappedType,
      Target: target
    }
  };
  if (type2 === "hyperlink") {
    newRel.attributes.TargetMode = "External";
  }
  relationshipsTag.elements.push(newRel);
  return newId;
};
const getNewRelationshipId = (editor) => {
  const relationships = getDocumentRelationshipElements(editor);
  const maxIdInt = getMaxRelationshipIdInt(relationships);
  return `rId${maxIdInt + 1}`;
};
const DocxHelpers = {
  findRelationshipIdFromTarget,
  insertNewRelationship,
  getNewRelationshipId
};
const _SuperConverter = class _SuperConverter2 {
  constructor(params2 = null) {
    __privateAdd$2(this, _SuperConverter_instances);
    this.debug = params2?.debug || false;
    this.declaration = null;
    this.documentAttributes = null;
    this.convertedXml = {};
    this.docx = params2?.docx || [];
    this.media = params2?.media || {};
    this.fonts = params2?.fonts || {};
    this.addedMedia = {};
    this.comments = [];
    this.docHiglightColors = /* @__PURE__ */ new Set([]);
    this.xml = params2?.xml;
    this.declaration = null;
    this.numbering = {};
    this.numbering = null;
    this.pageStyles = null;
    this.initialJSON = null;
    this.headers = {};
    this.headerIds = { default: null, even: null, odd: null, first: null };
    this.headerEditors = [];
    this.footers = {};
    this.footerIds = { default: null, even: null, odd: null, first: null };
    this.footerEditors = [];
    this.linkedStyles = [];
    this.json = params2?.json;
    this.tagsNotInSchema = ["w:body"];
    this.savedTagsToRestore = [];
    this.telemetry = params2?.telemetry || null;
    this.documentInternalId = null;
    this.fileSource = params2?.fileSource || null;
    this.documentId = params2?.documentId || null;
    if (this.docx.length || this.xml) this.parseFromXml();
  }
  /**
   * Get the DocxHelpers object that contains utility functions for working with docx files.
   * @returns {import('./docx-helpers/docx-helpers.js').DocxHelpers} The DocxHelpers object.
   */
  get docxHelpers() {
    return DocxHelpers;
  }
  parseFromXml() {
    this.docx?.forEach((file) => {
      this.convertedXml[file.name] = this.parseXmlToJson(file.content);
      if (file.name === "word/document.xml") {
        this.documentAttributes = this.convertedXml[file.name].elements[0]?.attributes;
      }
      if (file.name === "word/styles.xml") {
        this.convertedXml[file.name] = addDefaultStylesIfMissing(this.convertedXml[file.name]);
      }
    });
    this.initialJSON = this.convertedXml["word/document.xml"];
    if (!this.initialJSON) this.initialJSON = this.parseXmlToJson(this.xml);
    this.declaration = this.initialJSON?.declaration;
  }
  parseXmlToJson(xml) {
    const newXml = xml.replace(/(<w:t xml:space="preserve">)(\s+)(<\/w:t>)/g, "$1[[sdspace]]$2[[sdspace]]$3");
    return JSON.parse(xmljs.xml2json(newXml, null, 2));
  }
  static getStoredSuperdocVersion(docx) {
    try {
      const customXml = docx.find((doc2) => doc2.name === "docProps/custom.xml");
      if (!customXml) return;
      const converter = new _SuperConverter2();
      const content = customXml.content;
      const contentJson = converter.parseXmlToJson(content);
      const properties = contentJson.elements.find((el) => el.name === "Properties");
      if (!properties.elements) return;
      const superdocVersion = properties.elements.find(
        (el) => el.name === "property" && el.attributes.name === "SuperdocVersion"
      );
      if (!superdocVersion) return;
      const version2 = superdocVersion.elements[0].elements[0].text;
      return version2;
    } catch (e) {
      console.warn("Error getting Superdoc version", e);
      return;
    }
  }
  static updateDocumentVersion(docx = this.convertedXml, version2 = "0.15.17-next.11") {
    const customLocation = "docProps/custom.xml";
    if (!docx[customLocation]) {
      docx[customLocation] = generateCustomXml();
    }
    const customXml = docx["docProps/custom.xml"];
    if (!customXml) return;
    const properties = customXml.elements.find((el) => el.name === "Properties");
    if (!properties.elements) properties.elements = [];
    const superdocVersion = properties.elements.find(
      (el) => el.name === "property" && el.attributes.name === "SuperdocVersion"
    );
    if (!superdocVersion) {
      const newCustomXml = generateSuperdocVersion();
      properties.elements.push(newCustomXml);
    } else {
      superdocVersion.elements[0].elements[0].elements[0].text = version2;
    }
    return docx;
  }
  getDocumentDefaultStyles() {
    const styles = this.convertedXml["word/styles.xml"];
    if (!styles) return {};
    const defaults = styles.elements[0].elements.find((el) => el.name === "w:docDefaults");
    const rDefault = defaults.elements.find((el) => el.name === "w:rPrDefault");
    if (!rDefault.elements) return {};
    const rElements = rDefault.elements[0].elements;
    const rFonts = rElements?.find((el) => el.name === "w:rFonts");
    if ("elements" in rDefault) {
      const fontThemeName = rElements.find((el) => el.name === "w:rFonts")?.attributes["w:asciiTheme"];
      let typeface, panose, fontSizeNormal;
      if (fontThemeName) {
        const fontInfo = this.getThemeInfo(fontThemeName);
        typeface = fontInfo.typeface;
        panose = fontInfo.panose;
      } else if (rFonts) {
        typeface = rFonts?.attributes["w:ascii"];
      }
      const paragraphDefaults = styles.elements[0].elements.filter((el) => {
        return el.name === "w:style" && el.attributes["w:styleId"] === "Normal";
      }) || [];
      paragraphDefaults.forEach((el) => {
        const rPr = el.elements.find((el2) => el2.name === "w:rPr");
        const fonts = rPr?.elements?.find((el2) => el2.name === "w:rFonts");
        typeface = fonts?.attributes["w:ascii"];
        fontSizeNormal = Number(rPr?.elements?.find((el2) => el2.name === "w:sz")?.attributes["w:val"]) / 2;
      });
      const rPrDefaults = defaults?.elements?.find((el) => el.name === "w:rPrDefault");
      if (rPrDefaults) {
        const rPr = rPrDefaults.elements?.find((el) => el.name === "w:rPr");
        const fonts = rPr?.elements?.find((el) => el.name === "w:rFonts");
        typeface = fonts?.attributes["w:ascii"];
        const fontSize2 = typeface ?? rPr?.elements?.find((el) => el.name === "w:sz")?.attributes["w:val"];
        fontSizeNormal = !fontSizeNormal && fontSize2 ? Number(fontSize2) / 2 : null;
      }
      const fontSizePt = fontSizeNormal || Number(rElements.find((el) => el.name === "w:sz")?.attributes["w:val"]) / 2 || 10;
      const kern = rElements.find((el) => el.name === "w:kern")?.attributes["w:val"];
      return { fontSizePt, kern, typeface, panose };
    }
  }
  getDocumentFonts() {
    const fontTable = this.convertedXml["word/fontTable.xml"];
    if (!fontTable || !Object.keys(this.fonts).length) return;
    const fonts = fontTable.elements.find((el) => el.name === "w:fonts");
    const embededFonts = fonts?.elements.filter(
      (el) => el.elements?.some((nested) => nested?.attributes && nested.attributes["r:id"] && nested.attributes["w:fontKey"])
    );
    const fontsToInclude = embededFonts?.reduce((acc, cur) => {
      const embedElements = cur.elements.filter((el) => el.name.startsWith("w:embed"))?.map((el) => ({ ...el, fontFamily: cur.attributes["w:name"] }));
      return [...acc, ...embedElements];
    }, []);
    const rels = this.convertedXml["word/_rels/fontTable.xml.rels"];
    const relationships = rels?.elements.find((el) => el.name === "Relationships") || {};
    const { elements } = relationships;
    let styleString = "";
    for (const font of fontsToInclude) {
      const filePath = elements.find((el) => el.attributes.Id === font.attributes["r:id"])?.attributes?.Target;
      if (!filePath) return;
      const fontUint8Array = this.fonts[`word/${filePath}`];
      const fontBuffer = fontUint8Array?.buffer;
      if (!fontBuffer) return;
      const ttfBuffer = deobfuscateFont(fontBuffer, font.attributes["w:fontKey"]);
      if (!ttfBuffer) return;
      const blob = new Blob([ttfBuffer], { type: "font/ttf" });
      const fontUrl = URL.createObjectURL(blob);
      const isNormal = font.name.includes("Regular");
      const isBold = font.name.includes("Bold");
      const isItalic = font.name.includes("Italic");
      const isLight = font.name.includes("Light");
      const fontWeight = isNormal ? "normal" : isBold ? "bold" : isLight ? "200" : "normal";
      styleString += `
        @font-face {
          font-style: ${isItalic ? "italic" : "normal"};
          font-weight: ${fontWeight};
          font-display: swap;
          font-family: ${font.fontFamily};
          src: url(${fontUrl}) format('truetype');
        }
      `;
    }
    return styleString;
  }
  getDocumentInternalId() {
    const settingsLocation = "word/settings.xml";
    if (!this.convertedXml[settingsLocation]) {
      this.convertedXml[settingsLocation] = SETTINGS_CUSTOM_XML;
    }
    const settings = Object.assign({}, this.convertedXml[settingsLocation]);
    if (!settings.elements[0]?.elements?.length) {
      const idElement = this.createDocumentIdElement(settings);
      settings.elements[0].elements = [idElement];
      if (!settings.elements[0].attributes["xmlns:w15"]) {
        settings.elements[0].attributes["xmlns:w15"] = "http://schemas.microsoft.com/office/word/2012/wordml";
      }
      this.convertedXml[settingsLocation] = settings;
      return;
    }
    const w15DocId = settings.elements[0].elements.find((el) => el.name === "w15:docId");
    this.documentInternalId = w15DocId?.attributes["w15:val"];
  }
  createDocumentIdElement() {
    const docId = v4().toUpperCase();
    this.documentInternalId = docId;
    return {
      type: "element",
      name: "w15:docId",
      attributes: {
        "w15:val": `{${docId}}`
      }
    };
  }
  getThemeInfo(themeName) {
    themeName = themeName.toLowerCase();
    const theme1 = this.convertedXml["word/theme/theme1.xml"];
    if (!theme1) return {};
    const themeData = theme1.elements.find((el) => el.name === "a:theme");
    const themeElements = themeData.elements.find((el) => el.name === "a:themeElements");
    const fontScheme = themeElements.elements.find((el) => el.name === "a:fontScheme");
    let fonts;
    if (themeName.startsWith("major")) {
      fonts = fontScheme.elements.find((el) => el.name === "a:majorFont").elements[0];
    } else if (themeName.startsWith("minor")) {
      fonts = fontScheme.elements.find((el) => el.name === "a:minorFont").elements[0];
    }
    const { typeface, panose } = fonts.attributes;
    return { typeface, panose };
  }
  getSchema(editor) {
    this.getDocumentInternalId();
    const result = createDocumentJson({ ...this.convertedXml, media: this.media }, this, editor);
    if (result) {
      this.savedTagsToRestore.push({ ...result.savedTagsToRestore });
      this.pageStyles = result.pageStyles;
      this.numbering = result.numbering;
      this.comments = result.comments;
      this.linkedStyles = result.linkedStyles;
      return result.pmDoc;
    } else {
      return null;
    }
  }
  schemaToXml(data, debug = false) {
    const exporter = new DocxExporter(this);
    return exporter.schemaToXml(data, debug);
  }
  async exportToDocx(jsonData, editorSchema, documentMedia, isFinalDoc = false, commentsExportType, comments = [], editor, exportJsonOnly = false, fieldsHighlightColor) {
    const commentsWithParaIds = comments.map((c2) => prepareCommentParaIds(c2));
    const commentDefinitions = commentsWithParaIds.map(
      (c2, index2) => getCommentDefinition(c2, index2, commentsWithParaIds, editor)
    );
    const { result, params: params2 } = this.exportToXmlJson({
      data: jsonData,
      editorSchema,
      comments,
      commentDefinitions,
      commentsExportType,
      isFinalDoc,
      editor,
      fieldsHighlightColor
    });
    if (exportJsonOnly) return result;
    const exporter = new DocxExporter(this);
    const xml = exporter.schemaToXml(result);
    await __privateMethod$2(this, _SuperConverter_instances, exportProcessMediaFiles_fn).call(this, {
      ...documentMedia,
      ...params2.media,
      ...this.media
    }, editor);
    let updatedXml = { ...this.convertedXml };
    let commentsRels = [];
    if (comments.length) {
      const { documentXml, relationships } = __privateMethod$2(this, _SuperConverter_instances, prepareCommentsXmlFilesForExport_fn).call(this, {
        defs: params2.exportedCommentDefs,
        exportType: commentsExportType,
        commentsWithParaIds
      });
      updatedXml = { ...documentXml };
      commentsRels = relationships;
    }
    this.convertedXml = { ...this.convertedXml, ...updatedXml };
    const headFootRels = __privateMethod$2(this, _SuperConverter_instances, exportProcessHeadersFooters_fn).call(this, { isFinalDoc });
    __privateMethod$2(this, _SuperConverter_instances, exportProcessNewRelationships_fn).call(this, [...params2.relationships, ...commentsRels, ...headFootRels]);
    storeSuperdocVersion(this.convertedXml);
    __privateMethod$2(this, _SuperConverter_instances, exportNumberingFile_fn).call(this, params2);
    return xml;
  }
  exportToXmlJson({
    data,
    editorSchema,
    comments,
    commentDefinitions,
    commentsExportType = "clean",
    isFinalDoc = false,
    editor,
    isHeaderFooter = false,
    fieldsHighlightColor = null
  }) {
    const bodyNode = this.savedTagsToRestore.find((el) => el.name === "w:body");
    const [result, params2] = exportSchemaToJson({
      node: data,
      bodyNode,
      relationships: [],
      documentMedia: {},
      media: {},
      isFinalDoc,
      editorSchema,
      converter: this,
      pageStyles: this.pageStyles,
      comments,
      commentsExportType,
      exportedCommentDefs: commentDefinitions,
      editor,
      isHeaderFooter,
      fieldsHighlightColor
    });
    return { result, params: params2 };
  }
};
_SuperConverter_instances = /* @__PURE__ */ new WeakSet();
exportNumberingFile_fn = function() {
  const numberingPath = "word/numbering.xml";
  let numberingXml = this.convertedXml[numberingPath];
  const newNumbering = this.numbering;
  if (!numberingXml) numberingXml = baseNumbering;
  const currentNumberingXml = numberingXml.elements[0];
  const newAbstracts = Object.values(newNumbering.abstracts).map((entry) => entry);
  const newNumDefs = Object.values(newNumbering.definitions).map((entry) => entry);
  currentNumberingXml.elements = [...newAbstracts, ...newNumDefs];
  this.convertedXml[numberingPath] = numberingXml;
};
prepareCommentsXmlFilesForExport_fn = function({ defs, exportType, commentsWithParaIds }) {
  const { documentXml, relationships } = prepareCommentsXmlFilesForExport({
    exportType,
    convertedXml: this.convertedXml,
    defs,
    commentsWithParaIds
  });
  return { documentXml, relationships };
};
exportProcessHeadersFooters_fn = function({ isFinalDoc = false }) {
  const relsData = this.convertedXml["word/_rels/document.xml.rels"];
  const relationships = relsData.elements.find((x) => x.name === "Relationships");
  const newDocRels = [];
  Object.entries(this.headers).forEach(([id, header], index2) => {
    const fileName = relationships.elements.find((el) => el.attributes.Id === id)?.attributes.Target || `header${index2 + 1}.xml`;
    const headerEditor = this.headerEditors.find((item) => item.id === id);
    if (!headerEditor) return;
    const { result, params: params2 } = this.exportToXmlJson({
      data: header,
      editor: headerEditor.editor,
      editorSchema: headerEditor.editor.schema,
      comments: [],
      commentDefinitions: [],
      isHeaderFooter: true,
      isFinalDoc
    });
    const bodyContent = result.elements[0].elements;
    const file = this.convertedXml[`word/${fileName}`];
    if (!file) {
      this.convertedXml[`word/${fileName}`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            attributes: DEFAULT_DOCX_DEFS,
            name: "w:hdr",
            type: "element",
            elements: []
          }
        ]
      };
      newDocRels.push({
        type: "element",
        name: "Relationship",
        attributes: {
          Id: id,
          Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/header",
          Target: fileName
        }
      });
    }
    this.convertedXml[`word/${fileName}`].elements[0].elements = bodyContent;
    if (params2.relationships.length) {
      const relationships2 = this.convertedXml[`word/_rels/${fileName}.rels`]?.elements?.find((x) => x.name === "Relationships")?.elements || [];
      this.convertedXml[`word/_rels/${fileName}.rels`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            name: "Relationships",
            attributes: {
              xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
            },
            elements: [...relationships2, ...params2.relationships]
          }
        ]
      };
    }
  });
  Object.entries(this.footers).forEach(([id, footer], index2) => {
    const fileName = relationships.elements.find((el) => el.attributes.Id === id)?.attributes.Target || `footer${index2 + 1}.xml`;
    const footerEditor = this.footerEditors.find((item) => item.id === id);
    if (!footerEditor) return;
    const { result, params: params2 } = this.exportToXmlJson({
      data: footer,
      editor: footerEditor.editor,
      editorSchema: footerEditor.editor.schema,
      comments: [],
      commentDefinitions: [],
      isHeaderFooter: true,
      isFinalDoc
    });
    const bodyContent = result.elements[0].elements;
    const file = this.convertedXml[`word/${fileName}`];
    if (!file) {
      this.convertedXml[`word/${fileName}`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            attributes: DEFAULT_DOCX_DEFS,
            name: "w:ftr",
            type: "element",
            elements: []
          }
        ]
      };
      newDocRels.push({
        type: "element",
        name: "Relationship",
        attributes: {
          Id: id,
          Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/footer",
          Target: fileName
        }
      });
    }
    this.convertedXml[`word/${fileName}`].elements[0].elements = bodyContent;
    if (params2.relationships.length) {
      const relationships2 = this.convertedXml[`word/_rels/${fileName}.rels`]?.elements?.find((x) => x.name === "Relationships")?.elements || [];
      this.convertedXml[`word/_rels/${fileName}.rels`] = {
        declaration: this.initialJSON?.declaration,
        elements: [
          {
            name: "Relationships",
            attributes: {
              xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
            },
            elements: [...relationships2, ...params2.relationships]
          }
        ]
      };
    }
  });
  return newDocRels;
};
exportProcessNewRelationships_fn = function(rels = []) {
  const relsData = this.convertedXml["word/_rels/document.xml.rels"];
  const relationships = relsData.elements.find((x) => x.name === "Relationships");
  const newRels = [];
  const regex = /rId|mi/g;
  let largestId = Math.max(...relationships.elements.map((el) => Number(el.attributes.Id.replace(regex, ""))));
  rels.forEach((rel) => {
    const existingId = rel.attributes.Id;
    const existingTarget = relationships.elements.find((el) => el.attributes.Target === rel.attributes.Target);
    const isNewMedia = rel.attributes.Target?.startsWith("media/") && existingId.length > 6;
    const isNewHyperlink = rel.attributes.Type === HYPERLINK_RELATIONSHIP_TYPE && existingId.length > 6;
    const isNewHeadFoot = rel.attributes.Type === HEADER_RELATIONSHIP_TYPE && existingId.length > 6;
    if (existingTarget && !isNewMedia && !isNewHyperlink && !isNewHeadFoot) {
      return;
    }
    rel.attributes.Target = rel.attributes?.Target?.replace(/&/g, "&amp;");
    rel.attributes.Id = existingId.length > 6 ? existingId : `rId${++largestId}`;
    newRels.push(rel);
  });
  relationships.elements = [...relationships.elements, ...newRels];
};
exportProcessMediaFiles_fn = async function(media, editor) {
  const processedData = {};
  for (const filePath in media) {
    if (typeof media[filePath] !== "string") continue;
    const name = filePath.split("/").pop();
    processedData[name] = await getArrayBufferFromUrl(media[filePath], editor.options.isHeadless);
  }
  this.convertedXml.media = {
    ...this.convertedXml.media,
    ...processedData
  };
  this.media = this.convertedXml.media;
  this.addedMedia = processedData;
};
__publicField$2(_SuperConverter, "allowedElements", Object.freeze({
  "w:document": "doc",
  "w:body": "body",
  "w:p": "paragraph",
  "w:r": "run",
  "w:t": "text",
  "w:delText": "text",
  "w:br": "lineBreak",
  "w:tbl": "table",
  "w:tr": "tableRow",
  "w:tc": "tableCell",
  "w:drawing": "drawing",
  "w:bookmarkStart": "bookmarkStart",
  // 'w:tab': 'tab',
  // Formatting only
  "w:sectPr": "sectionProperties",
  "w:rPr": "runProperties",
  // Comments
  "w:commentRangeStart": "commentRangeStart",
  "w:commentRangeEnd": "commentRangeEnd",
  "w:commentReference": "commentReference"
}));
__publicField$2(_SuperConverter, "markTypes", [
  { name: "w:b", type: "bold", property: "value" },
  // { name: 'w:bCs', type: 'bold' },
  { name: "w:i", type: "italic" },
  // { name: 'w:iCs', type: 'italic' },
  { name: "w:u", type: "underline", mark: "underline", property: "underlineType" },
  { name: "w:strike", type: "strike", mark: "strike" },
  { name: "w:color", type: "color", mark: "textStyle", property: "color" },
  { name: "w:sz", type: "fontSize", mark: "textStyle", property: "fontSize" },
  // { name: 'w:szCs', type: 'fontSize', mark: 'textStyle', property: 'fontSize' },
  { name: "w:rFonts", type: "fontFamily", mark: "textStyle", property: "fontFamily" },
  { name: "w:rStyle", type: "styleId", mark: "textStyle", property: "styleId" },
  { name: "w:jc", type: "textAlign", mark: "textStyle", property: "textAlign" },
  { name: "w:ind", type: "textIndent", mark: "textStyle", property: "textIndent" },
  { name: "w:spacing", type: "lineHeight", mark: "textStyle", property: "lineHeight" },
  { name: "w:spacing", type: "letterSpacing", mark: "textStyle", property: "letterSpacing" },
  { name: "link", type: "link", mark: "link", property: "href" },
  { name: "w:highlight", type: "highlight", mark: "highlight", property: "color" },
  { name: "w:shd", type: "highlight", mark: "highlight", property: "color" },
  { name: "w:caps", type: "textTransform", mark: "textStyle", property: "textTransform" }
]);
__publicField$2(_SuperConverter, "propertyTypes", Object.freeze({
  "w:pPr": "paragraphProperties",
  "w:rPr": "runProperties",
  "w:sectPr": "sectionProperties",
  "w:numPr": "numberingProperties",
  "w:tcPr": "tableCellProperties"
}));
__publicField$2(_SuperConverter, "elements", /* @__PURE__ */ new Set(["w:document", "w:body", "w:p", "w:r", "w:t", "w:delText"]));
let SuperConverter = _SuperConverter;
function storeSuperdocVersion(docx) {
  const customLocation = "docProps/custom.xml";
  if (!docx[customLocation]) docx[customLocation] = generateCustomXml();
  const customXml = docx[customLocation];
  const properties = customXml.elements.find((el) => el.name === "Properties");
  if (!properties.elements) properties.elements = [];
  const elements = properties.elements;
  const cleanProperties = elements.filter((prop) => typeof prop === "object" && prop !== null).filter((prop) => {
    const { attributes } = prop;
    return attributes.name !== "SuperdocVersion";
  });
  let pid = 2;
  try {
    pid = cleanProperties.length ? Math.max(...elements.map((el) => el.attributes.pid)) + 1 : 2;
  } catch {
  }
  cleanProperties.push(generateSuperdocVersion(pid));
  properties.elements = cleanProperties;
  return docx;
}
function generateCustomXml() {
  return DEFAULT_CUSTOM_XML;
}
function generateSuperdocVersion(pid = 2, version2 = "0.15.17-next.11") {
  return {
    type: "element",
    name: "property",
    attributes: {
      name: "SuperdocVersion",
      fmtid: "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
      pid
    },
    elements: [
      {
        type: "element",
        name: "vt:lpwstr",
        elements: [
          {
            type: "text",
            text: version2
          }
        ]
      }
    ]
  };
}
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jszip_min = { exports: {} };
var hasRequiredJszip_min;
function requireJszip_min() {
  if (hasRequiredJszip_min) return jszip_min.exports;
  hasRequiredJszip_min = 1;
  (function(module2, exports2) {
    !(function(e) {
      module2.exports = e();
    })(function() {
      return (function s(a, o, h2) {
        function u(r2, e2) {
          if (!o[r2]) {
            if (!a[r2]) {
              var t = "function" == typeof commonjsRequire && commonjsRequire;
              if (!e2 && t) return t(r2, true);
              if (l3) return l3(r2, true);
              var n = new Error("Cannot find module '" + r2 + "'");
              throw n.code = "MODULE_NOT_FOUND", n;
            }
            var i = o[r2] = { exports: {} };
            a[r2][0].call(i.exports, function(e3) {
              var t2 = a[r2][1][e3];
              return u(t2 || e3);
            }, i, i.exports, s, a, o, h2);
          }
          return o[r2].exports;
        }
        for (var l3 = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < h2.length; e++) u(h2[e]);
        return u;
      })({ 1: [function(e, t, r2) {
        var d2 = e("./utils"), c2 = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
        r2.encode = function(e2) {
          for (var t2, r22, n, i, s, a, o, h2 = [], u = 0, l3 = e2.length, f = l3, c22 = "string" !== d2.getTypeOf(e2); u < e2.length; ) f = l3 - u, n = c22 ? (t2 = e2[u++], r22 = u < l3 ? e2[u++] : 0, u < l3 ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r22 = u < l3 ? e2.charCodeAt(u++) : 0, u < l3 ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r22 >> 4, a = 1 < f ? (15 & r22) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h2.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
          return h2.join("");
        }, r2.decode = function(e2) {
          var t2, r22, n, i, s, a, o = 0, h2 = 0, u = "data:";
          if (e2.substr(0, u.length) === u) throw new Error("Invalid base64 input, it looks like a data url.");
          var l3, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
          if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0) throw new Error("Invalid base64 input, bad content length.");
          for (l3 = c2.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; ) t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r22 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l3[h2++] = t2, 64 !== s && (l3[h2++] = r22), 64 !== a && (l3[h2++] = n);
          return l3;
        };
      }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r2) {
        var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
        function o(e2, t2, r22, n2, i2) {
          this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r22, this.compression = n2, this.compressedContent = i2;
        }
        o.prototype = { getContentWorker: function() {
          var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
          return e2.on("end", function() {
            if (this.streamInfo.data_length !== t2.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch");
          }), e2;
        }, getCompressedWorker: function() {
          return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
        } }, o.createWorkerFrom = function(e2, t2, r22) {
          return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r22)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
        }, t.exports = o;
      }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r2) {
        var n = e("./stream/GenericWorker");
        r2.STORE = { magic: "\0\0", compressWorker: function() {
          return new n("STORE compression");
        }, uncompressWorker: function() {
          return new n("STORE decompression");
        } }, r2.DEFLATE = e("./flate");
      }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r2) {
        var n = e("./utils");
        var o = (function() {
          for (var e2, t2 = [], r22 = 0; r22 < 256; r22++) {
            e2 = r22;
            for (var n2 = 0; n2 < 8; n2++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r22] = e2;
          }
          return t2;
        })();
        t.exports = function(e2, t2) {
          return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? (function(e3, t3, r22, n2) {
            var i = o, s = n2 + r22;
            e3 ^= -1;
            for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
            return -1 ^ e3;
          })(0 | t2, e2, e2.length, 0) : (function(e3, t3, r22, n2) {
            var i = o, s = n2 + r22;
            e3 ^= -1;
            for (var a = n2; a < s; a++) e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
            return -1 ^ e3;
          })(0 | t2, e2, e2.length, 0) : 0;
        };
      }, { "./utils": 32 }], 5: [function(e, t, r2) {
        r2.base64 = false, r2.binary = false, r2.dir = false, r2.createFolders = true, r2.date = null, r2.compression = null, r2.compressionOptions = null, r2.comment = null, r2.unixPermissions = null, r2.dosPermissions = null;
      }, {}], 6: [function(e, t, r2) {
        var n = null;
        n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
      }, { lie: 37 }], 7: [function(e, t, r2) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
        function h2(e2, t2) {
          a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
        }
        r2.magic = "\b\0", s.inherits(h2, a), h2.prototype.processChunk = function(e2) {
          this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
        }, h2.prototype.flush = function() {
          a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
        }, h2.prototype.cleanUp = function() {
          a.prototype.cleanUp.call(this), this._pako = null;
        }, h2.prototype._createPako = function() {
          this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
          var t2 = this;
          this._pako.onData = function(e2) {
            t2.push({ data: e2, meta: t2.meta });
          };
        }, r2.compressWorker = function(e2) {
          return new h2("Deflate", e2);
        }, r2.uncompressWorker = function() {
          return new h2("Inflate", {});
        };
      }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r2) {
        function A(e2, t2) {
          var r22, n2 = "";
          for (r22 = 0; r22 < t2; r22++) n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
          return n2;
        }
        function n(e2, t2, r22, n2, i2, s2) {
          var a, o, h2 = e2.file, u = e2.compression, l3 = s2 !== O2.utf8encode, f = I2.transformTo("string", s2(h2.name)), c2 = I2.transformTo("string", O2.utf8encode(h2.name)), d2 = h2.comment, p = I2.transformTo("string", s2(d2)), m2 = I2.transformTo("string", O2.utf8encode(d2)), _2 = c2.length !== h2.name.length, g = m2.length !== d2.length, b2 = "", v2 = "", y2 = "", w2 = h2.dir, k = h2.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
          t2 && !r22 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
          var S2 = 0;
          t2 && (S2 |= 8), l3 || !_2 && !g || (S2 |= 2048);
          var z2 = 0, C2 = 0;
          w2 && (z2 |= 16), "UNIX" === i2 ? (C2 = 798, z2 |= (function(e3, t3) {
            var r3 = e3;
            return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
          })(h2.unixPermissions, w2)) : (C2 = 20, z2 |= (function(e3) {
            return 63 & (e3 || 0);
          })(h2.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _2 && (v2 = A(1, 1) + A(B2(f), 4) + c2, b2 += "up" + A(v2.length, 2) + v2), g && (y2 = A(1, 1) + A(B2(p), 4) + m2, b2 += "uc" + A(y2.length, 2) + y2);
          var E2 = "";
          return E2 += "\n\0", E2 += A(S2, 2), E2 += u.magic, E2 += A(a, 2), E2 += A(o, 2), E2 += A(x.crc32, 4), E2 += A(x.compressedSize, 4), E2 += A(x.uncompressedSize, 4), E2 += A(f.length, 2), E2 += A(b2.length, 2), { fileRecord: R2.LOCAL_FILE_HEADER + E2 + f + b2, dirRecord: R2.CENTRAL_FILE_HEADER + A(C2, 2) + E2 + A(p.length, 2) + "\0\0\0\0" + A(z2, 4) + A(n2, 4) + f + b2 + p };
        }
        var I2 = e("../utils"), i = e("../stream/GenericWorker"), O2 = e("../utf8"), B2 = e("../crc32"), R2 = e("../signature");
        function s(e2, t2, r22, n2) {
          i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r22, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
        }
        I2.inherits(s, i), s.prototype.push = function(e2) {
          var t2 = e2.meta.percent || 0, r22 = this.entriesCount, n2 = this._sources.length;
          this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r22 ? (t2 + 100 * (r22 - n2 - 1)) / r22 : 100 } }));
        }, s.prototype.openedSource = function(e2) {
          this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
          var t2 = this.streamFiles && !e2.file.dir;
          if (t2) {
            var r22 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
            this.push({ data: r22.fileRecord, meta: { percent: 0 } });
          } else this.accumulate = true;
        }, s.prototype.closedSource = function(e2) {
          this.accumulate = false;
          var t2 = this.streamFiles && !e2.file.dir, r22 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          if (this.dirRecords.push(r22.dirRecord), t2) this.push({ data: (function(e3) {
            return R2.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
          })(e2), meta: { percent: 100 } });
          else for (this.push({ data: r22.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; ) this.push(this.contentBuffer.shift());
          this.currentFile = null;
        }, s.prototype.flush = function() {
          for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++) this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
          var r22 = this.bytesWritten - e2, n2 = (function(e3, t3, r3, n3, i2) {
            var s2 = I2.transformTo("string", i2(n3));
            return R2.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
          })(this.dirRecords.length, r22, e2, this.zipComment, this.encodeFileName);
          this.push({ data: n2, meta: { percent: 100 } });
        }, s.prototype.prepareNextSource = function() {
          this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
        }, s.prototype.registerPrevious = function(e2) {
          this._sources.push(e2);
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
        }, s.prototype.error = function(e2) {
          var t2 = this._sources;
          if (!i.prototype.error.call(this, e2)) return false;
          for (var r22 = 0; r22 < t2.length; r22++) try {
            t2[r22].error(e2);
          } catch (e3) {
          }
          return true;
        }, s.prototype.lock = function() {
          i.prototype.lock.call(this);
          for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++) e2[t2].lock();
        }, t.exports = s;
      }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r2) {
        var u = e("../compressions"), n = e("./ZipFileWorker");
        r2.generateWorker = function(e2, a, t2) {
          var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h2 = 0;
          try {
            e2.forEach(function(e3, t3) {
              h2++;
              var r22 = (function(e4, t4) {
                var r3 = e4 || t4, n3 = u[r3];
                if (!n3) throw new Error(r3 + " is not a valid compression method !");
                return n3;
              })(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
              t3._compressWorker(r22, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
            }), o.entriesCount = h2;
          } catch (e3) {
            o.error(e3);
          }
          return o;
        };
      }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r2) {
        function n() {
          if (!(this instanceof n)) return new n();
          if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
          this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
            var e2 = new n();
            for (var t2 in this) "function" != typeof this[t2] && (e2[t2] = this[t2]);
            return e2;
          };
        }
        (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
          return new n().loadAsync(e2, t2);
        }, n.external = e("./external"), t.exports = n;
      }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r2) {
        var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l3 = e("./nodejsUtils");
        function f(n2) {
          return new i.Promise(function(e2, t2) {
            var r22 = n2.decompressed.getContentWorker().pipe(new a());
            r22.on("error", function(e3) {
              t2(e3);
            }).on("end", function() {
              r22.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
            }).resume();
          });
        }
        t.exports = function(e2, o) {
          var h2 = this;
          return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l3.isNode && l3.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
            var t2 = new s(o);
            return t2.load(e3), t2;
          }).then(function(e3) {
            var t2 = [i.Promise.resolve(e3)], r22 = e3.files;
            if (o.checkCRC32) for (var n2 = 0; n2 < r22.length; n2++) t2.push(f(r22[n2]));
            return i.Promise.all(t2);
          }).then(function(e3) {
            for (var t2 = e3.shift(), r22 = t2.files, n2 = 0; n2 < r22.length; n2++) {
              var i2 = r22[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
              h2.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h2.file(a2).unsafeOriginalName = s2);
            }
            return t2.zipComment.length && (h2.comment = t2.zipComment), h2;
          });
        };
      }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r2) {
        var n = e("../utils"), i = e("../stream/GenericWorker");
        function s(e2, t2) {
          i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
        }
        n.inherits(s, i), s.prototype._bindStream = function(e2) {
          var t2 = this;
          (this._stream = e2).pause(), e2.on("data", function(e3) {
            t2.push({ data: e3, meta: { percent: 0 } });
          }).on("error", function(e3) {
            t2.isPaused ? this.generatedError = e3 : t2.error(e3);
          }).on("end", function() {
            t2.isPaused ? t2._upstreamEnded = true : t2.end();
          });
        }, s.prototype.pause = function() {
          return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
        }, t.exports = s;
      }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r2) {
        var i = e("readable-stream").Readable;
        function n(e2, t2, r22) {
          i.call(this, t2), this._helper = e2;
          var n2 = this;
          e2.on("data", function(e3, t3) {
            n2.push(e3) || n2._helper.pause(), r22 && r22(t3);
          }).on("error", function(e3) {
            n2.emit("error", e3);
          }).on("end", function() {
            n2.push(null);
          });
        }
        e("../utils").inherits(n, i), n.prototype._read = function() {
          this._helper.resume();
        }, t.exports = n;
      }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r2) {
        t.exports = { isNode: "undefined" != typeof Buffer2, newBufferFrom: function(e2, t2) {
          if (Buffer2.from && Buffer2.from !== Uint8Array.from) return Buffer2.from(e2, t2);
          if ("number" == typeof e2) throw new Error('The "data" argument must not be a number');
          return new Buffer2(e2, t2);
        }, allocBuffer: function(e2) {
          if (Buffer2.alloc) return Buffer2.alloc(e2);
          var t2 = new Buffer2(e2);
          return t2.fill(0), t2;
        }, isBuffer: function(e2) {
          return Buffer2.isBuffer(e2);
        }, isStream: function(e2) {
          return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
        } };
      }, {}], 15: [function(e, t, r2) {
        function s(e2, t2, r22) {
          var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r22 || {}, f);
          s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _2(e2)) && b2.call(this, n2, true);
          var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
          r22 && void 0 !== r22.binary || (s2.binary = !a2), (t2 instanceof c2 && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
          var o2 = null;
          o2 = t2 instanceof c2 || t2 instanceof l3 ? t2 : p.isNode && p.isStream(t2) ? new m2(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
          var h22 = new d2(e2, o2, s2);
          this.files[e2] = h22;
        }
        var i = e("./utf8"), u = e("./utils"), l3 = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c2 = e("./compressedObject"), d2 = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m2 = e("./nodejs/NodejsStreamInputAdapter"), _2 = function(e2) {
          "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
          var t2 = e2.lastIndexOf("/");
          return 0 < t2 ? e2.substring(0, t2) : "";
        }, g = function(e2) {
          return "/" !== e2.slice(-1) && (e2 += "/"), e2;
        }, b2 = function(e2, t2) {
          return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
        };
        function h2(e2) {
          return "[object RegExp]" === Object.prototype.toString.call(e2);
        }
        var n = { load: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, forEach: function(e2) {
          var t2, r22, n2;
          for (t2 in this.files) n2 = this.files[t2], (r22 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r22, n2);
        }, filter: function(r22) {
          var n2 = [];
          return this.forEach(function(e2, t2) {
            r22(e2, t2) && n2.push(t2);
          }), n2;
        }, file: function(e2, t2, r22) {
          if (1 !== arguments.length) return e2 = this.root + e2, s.call(this, e2, t2, r22), this;
          if (h2(e2)) {
            var n2 = e2;
            return this.filter(function(e3, t3) {
              return !t3.dir && n2.test(e3);
            });
          }
          var i2 = this.files[this.root + e2];
          return i2 && !i2.dir ? i2 : null;
        }, folder: function(r22) {
          if (!r22) return this;
          if (h2(r22)) return this.filter(function(e3, t3) {
            return t3.dir && r22.test(e3);
          });
          var e2 = this.root + r22, t2 = b2.call(this, e2), n2 = this.clone();
          return n2.root = t2.name, n2;
        }, remove: function(r22) {
          r22 = this.root + r22;
          var e2 = this.files[r22];
          if (e2 || ("/" !== r22.slice(-1) && (r22 += "/"), e2 = this.files[r22]), e2 && !e2.dir) delete this.files[r22];
          else for (var t2 = this.filter(function(e3, t3) {
            return t3.name.slice(0, r22.length) === r22;
          }), n2 = 0; n2 < t2.length; n2++) delete this.files[t2[n2].name];
          return this;
        }, generate: function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, generateInternalStream: function(e2) {
          var t2, r22 = {};
          try {
            if ((r22 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r22.type.toLowerCase(), r22.compression = r22.compression.toUpperCase(), "binarystring" === r22.type && (r22.type = "string"), !r22.type) throw new Error("No output type specified.");
            u.checkSupport(r22.type), "darwin" !== r22.platform && "freebsd" !== r22.platform && "linux" !== r22.platform && "sunos" !== r22.platform || (r22.platform = "UNIX"), "win32" === r22.platform && (r22.platform = "DOS");
            var n2 = r22.comment || this.comment || "";
            t2 = o.generateWorker(this, r22, n2);
          } catch (e3) {
            (t2 = new l3("error")).error(e3);
          }
          return new a(t2, r22.type || "string", r22.mimeType);
        }, generateAsync: function(e2, t2) {
          return this.generateInternalStream(e2).accumulate(t2);
        }, generateNodeStream: function(e2, t2) {
          return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
        } };
        t.exports = n;
      }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r2) {
        t.exports = e("stream");
      }, { stream: void 0 }], 17: [function(e, t, r2) {
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
          for (var t2 = 0; t2 < this.data.length; t2++) e2[t2] = 255 & e2[t2];
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data[this.zero + e2];
        }, i.prototype.lastIndexOfSignature = function(e2) {
          for (var t2 = e2.charCodeAt(0), r22 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s) if (this.data[s] === t2 && this.data[s + 1] === r22 && this.data[s + 2] === n2 && this.data[s + 3] === i2) return s - this.zero;
          return -1;
        }, i.prototype.readAndCheckSignature = function(e2) {
          var t2 = e2.charCodeAt(0), r22 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
          return t2 === s[0] && r22 === s[1] && n2 === s[2] && i2 === s[3];
        }, i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2) return [];
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r2) {
        var n = e("../utils");
        function i(e2) {
          this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
        }
        i.prototype = { checkOffset: function(e2) {
          this.checkIndex(this.index + e2);
        }, checkIndex: function(e2) {
          if (this.length < this.zero + e2 || e2 < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
        }, setIndex: function(e2) {
          this.checkIndex(e2), this.index = e2;
        }, skip: function(e2) {
          this.setIndex(this.index + e2);
        }, byteAt: function() {
        }, readInt: function(e2) {
          var t2, r22 = 0;
          for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--) r22 = (r22 << 8) + this.byteAt(t2);
          return this.index += e2, r22;
        }, readString: function(e2) {
          return n.transformTo("string", this.readData(e2));
        }, readData: function() {
        }, lastIndexOfSignature: function() {
        }, readAndCheckSignature: function() {
        }, readDate: function() {
          var e2 = this.readInt(4);
          return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
        } }, t.exports = i;
      }, { "../utils": 32 }], 19: [function(e, t, r2) {
        var n = e("./Uint8ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r2) {
        var n = e("./DataReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
          return this.data.charCodeAt(this.zero + e2);
        }, i.prototype.lastIndexOfSignature = function(e2) {
          return this.data.lastIndexOf(e2) - this.zero;
        }, i.prototype.readAndCheckSignature = function(e2) {
          return e2 === this.readData(4);
        }, i.prototype.readData = function(e2) {
          this.checkOffset(e2);
          var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r2) {
        var n = e("./ArrayReader");
        function i(e2) {
          n.call(this, e2);
        }
        e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
          if (this.checkOffset(e2), 0 === e2) return new Uint8Array(0);
          var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
          return this.index += e2, t2;
        }, t.exports = i;
      }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r2) {
        var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h2 = e("./Uint8ArrayReader");
        t.exports = function(e2) {
          var t2 = n.getTypeOf(e2);
          return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h2(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
        };
      }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r2) {
        r2.LOCAL_FILE_HEADER = "PK", r2.CENTRAL_FILE_HEADER = "PK", r2.CENTRAL_DIRECTORY_END = "PK", r2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r2.ZIP64_CENTRAL_DIRECTORY_END = "PK", r2.DATA_DESCRIPTOR = "PK\x07\b";
      }, {}], 24: [function(e, t, r2) {
        var n = e("./GenericWorker"), i = e("../utils");
        function s(e2) {
          n.call(this, "ConvertWorker to " + e2), this.destType = e2;
        }
        i.inherits(s, n), s.prototype.processChunk = function(e2) {
          this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r2) {
        var n = e("./GenericWorker"), i = e("../crc32");
        function s() {
          n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
        }
        e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
          this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
        }, t.exports = s;
      }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r2) {
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
        }
        n.inherits(s, i), s.prototype.processChunk = function(e2) {
          if (e2) {
            var t2 = this.streamInfo[this.propName] || 0;
            this.streamInfo[this.propName] = t2 + e2.data.length;
          }
          i.prototype.processChunk.call(this, e2);
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r2) {
        var n = e("../utils"), i = e("./GenericWorker");
        function s(e2) {
          i.call(this, "DataWorker");
          var t2 = this;
          this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
            t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
          }, function(e3) {
            t2.error(e3);
          });
        }
        n.inherits(s, i), s.prototype.cleanUp = function() {
          i.prototype.cleanUp.call(this), this.data = null;
        }, s.prototype.resume = function() {
          return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
        }, s.prototype._tickAndRepeat = function() {
          this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
        }, s.prototype._tick = function() {
          if (this.isPaused || this.isFinished) return false;
          var e2 = null, t2 = Math.min(this.max, this.index + 16384);
          if (this.index >= this.max) return this.end();
          switch (this.type) {
            case "string":
              e2 = this.data.substring(this.index, t2);
              break;
            case "uint8array":
              e2 = this.data.subarray(this.index, t2);
              break;
            case "array":
            case "nodebuffer":
              e2 = this.data.slice(this.index, t2);
          }
          return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
        }, t.exports = s;
      }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r2) {
        function n(e2) {
          this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
        }
        n.prototype = { push: function(e2) {
          this.emit("data", e2);
        }, end: function() {
          if (this.isFinished) return false;
          this.flush();
          try {
            this.emit("end"), this.cleanUp(), this.isFinished = true;
          } catch (e2) {
            this.emit("error", e2);
          }
          return true;
        }, error: function(e2) {
          return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
        }, on: function(e2, t2) {
          return this._listeners[e2].push(t2), this;
        }, cleanUp: function() {
          this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
        }, emit: function(e2, t2) {
          if (this._listeners[e2]) for (var r22 = 0; r22 < this._listeners[e2].length; r22++) this._listeners[e2][r22].call(this, t2);
        }, pipe: function(e2) {
          return e2.registerPrevious(this);
        }, registerPrevious: function(e2) {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
          var t2 = this;
          return e2.on("data", function(e3) {
            t2.processChunk(e3);
          }), e2.on("end", function() {
            t2.end();
          }), e2.on("error", function(e3) {
            t2.error(e3);
          }), this;
        }, pause: function() {
          return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
        }, resume: function() {
          if (!this.isPaused || this.isFinished) return false;
          var e2 = this.isPaused = false;
          return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
        }, flush: function() {
        }, processChunk: function(e2) {
          this.push(e2);
        }, withStreamInfo: function(e2, t2) {
          return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
        }, mergeStreamInfo: function() {
          for (var e2 in this.extraStreamInfo) Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
        }, lock: function() {
          if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
          this.isLocked = true, this.previous && this.previous.lock();
        }, toString: function() {
          var e2 = "Worker " + this.name;
          return this.previous ? this.previous + " -> " + e2 : e2;
        } }, t.exports = n;
      }, {}], 29: [function(e, t, r2) {
        var h2 = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
        if (n.nodestream) try {
          o = e("../nodejs/NodejsStreamOutputAdapter");
        } catch (e2) {
        }
        function l3(e2, o2) {
          return new a.Promise(function(t2, r22) {
            var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
            e2.on("data", function(e3, t3) {
              n2.push(e3), o2 && o2(t3);
            }).on("error", function(e3) {
              n2 = [], r22(e3);
            }).on("end", function() {
              try {
                var e3 = (function(e4, t3, r3) {
                  switch (e4) {
                    case "blob":
                      return h2.newBlob(h2.transformTo("arraybuffer", t3), r3);
                    case "base64":
                      return u.encode(t3);
                    default:
                      return h2.transformTo(e4, t3);
                  }
                })(s2, (function(e4, t3) {
                  var r3, n3 = 0, i3 = null, s3 = 0;
                  for (r3 = 0; r3 < t3.length; r3++) s3 += t3[r3].length;
                  switch (e4) {
                    case "string":
                      return t3.join("");
                    case "array":
                      return Array.prototype.concat.apply([], t3);
                    case "uint8array":
                      for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++) i3.set(t3[r3], n3), n3 += t3[r3].length;
                      return i3;
                    case "nodebuffer":
                      return Buffer2.concat(t3);
                    default:
                      throw new Error("concat : unsupported type '" + e4 + "'");
                  }
                })(i2, n2), a2);
                t2(e3);
              } catch (e4) {
                r22(e4);
              }
              n2 = [];
            }).resume();
          });
        }
        function f(e2, t2, r22) {
          var n2 = t2;
          switch (t2) {
            case "blob":
            case "arraybuffer":
              n2 = "uint8array";
              break;
            case "base64":
              n2 = "string";
          }
          try {
            this._internalType = n2, this._outputType = t2, this._mimeType = r22, h2.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
          } catch (e3) {
            this._worker = new s("error"), this._worker.error(e3);
          }
        }
        f.prototype = { accumulate: function(e2) {
          return l3(this, e2);
        }, on: function(e2, t2) {
          var r22 = this;
          return "data" === e2 ? this._worker.on(e2, function(e3) {
            t2.call(r22, e3.data, e3.meta);
          }) : this._worker.on(e2, function() {
            h2.delay(t2, arguments, r22);
          }), this;
        }, resume: function() {
          return h2.delay(this._worker.resume, [], this._worker), this;
        }, pause: function() {
          return this._worker.pause(), this;
        }, toNodejsStream: function(e2) {
          if (h2.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
          return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
        } }, t.exports = f;
      }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r2) {
        if (r2.base64 = true, r2.array = true, r2.string = true, r2.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r2.nodebuffer = "undefined" != typeof Buffer2, r2.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) r2.blob = false;
        else {
          var n = new ArrayBuffer(0);
          try {
            r2.blob = 0 === new Blob([n], { type: "application/zip" }).size;
          } catch (e2) {
            try {
              var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              i.append(n), r2.blob = 0 === i.getBlob("application/zip").size;
            } catch (e3) {
              r2.blob = false;
            }
          }
        }
        try {
          r2.nodestream = !!e("readable-stream").Readable;
        } catch (e2) {
          r2.nodestream = false;
        }
      }, { "readable-stream": 16 }], 31: [function(e, t, s) {
        for (var o = e("./utils"), h2 = e("./support"), r2 = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++) u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
        u[254] = u[254] = 1;
        function a() {
          n.call(this, "utf-8 decode"), this.leftOver = null;
        }
        function l3() {
          n.call(this, "utf-8 encode");
        }
        s.utf8encode = function(e2) {
          return h2.nodebuffer ? r2.newBufferFrom(e2, "utf-8") : (function(e3) {
            var t2, r22, n2, i2, s2, a2 = e3.length, o2 = 0;
            for (i2 = 0; i2 < a2; i2++) 55296 == (64512 & (r22 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r22 = 65536 + (r22 - 55296 << 10) + (n2 - 56320), i2++), o2 += r22 < 128 ? 1 : r22 < 2048 ? 2 : r22 < 65536 ? 3 : 4;
            for (t2 = h2.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++) 55296 == (64512 & (r22 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r22 = 65536 + (r22 - 55296 << 10) + (n2 - 56320), i2++), r22 < 128 ? t2[s2++] = r22 : (r22 < 2048 ? t2[s2++] = 192 | r22 >>> 6 : (r22 < 65536 ? t2[s2++] = 224 | r22 >>> 12 : (t2[s2++] = 240 | r22 >>> 18, t2[s2++] = 128 | r22 >>> 12 & 63), t2[s2++] = 128 | r22 >>> 6 & 63), t2[s2++] = 128 | 63 & r22);
            return t2;
          })(e2);
        }, s.utf8decode = function(e2) {
          return h2.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : (function(e3) {
            var t2, r22, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
            for (t2 = r22 = 0; t2 < s2; ) if ((n2 = e3[t2++]) < 128) a2[r22++] = n2;
            else if (4 < (i2 = u[n2])) a2[r22++] = 65533, t2 += i2 - 1;
            else {
              for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; ) n2 = n2 << 6 | 63 & e3[t2++], i2--;
              1 < i2 ? a2[r22++] = 65533 : n2 < 65536 ? a2[r22++] = n2 : (n2 -= 65536, a2[r22++] = 55296 | n2 >> 10 & 1023, a2[r22++] = 56320 | 1023 & n2);
            }
            return a2.length !== r22 && (a2.subarray ? a2 = a2.subarray(0, r22) : a2.length = r22), o.applyFromCharCode(a2);
          })(e2 = o.transformTo(h2.uint8array ? "uint8array" : "array", e2));
        }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
          var t2 = o.transformTo(h2.uint8array ? "uint8array" : "array", e2.data);
          if (this.leftOver && this.leftOver.length) {
            if (h2.uint8array) {
              var r22 = t2;
              (t2 = new Uint8Array(r22.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r22, this.leftOver.length);
            } else t2 = this.leftOver.concat(t2);
            this.leftOver = null;
          }
          var n2 = (function(e3, t3) {
            var r3;
            for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); ) r3--;
            return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
          })(t2), i2 = t2;
          n2 !== t2.length && (h2.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
        }, a.prototype.flush = function() {
          this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
        }, s.Utf8DecodeWorker = a, o.inherits(l3, n), l3.prototype.processChunk = function(e2) {
          this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
        }, s.Utf8EncodeWorker = l3;
      }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
        var o = e("./support"), h2 = e("./base64"), r2 = e("./nodejsUtils"), u = e("./external");
        function n(e2) {
          return e2;
        }
        function l3(e2, t2) {
          for (var r22 = 0; r22 < e2.length; ++r22) t2[r22] = 255 & e2.charCodeAt(r22);
          return t2;
        }
        e("setimmediate"), a.newBlob = function(t2, r22) {
          a.checkSupport("blob");
          try {
            return new Blob([t2], { type: r22 });
          } catch (e2) {
            try {
              var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
              return n2.append(t2), n2.getBlob(r22);
            } catch (e3) {
              throw new Error("Bug : can't construct the Blob.");
            }
          }
        };
        var i = { stringifyByChunk: function(e2, t2, r22) {
          var n2 = [], i2 = 0, s2 = e2.length;
          if (s2 <= r22) return String.fromCharCode.apply(null, e2);
          for (; i2 < s2; ) "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r22, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r22, s2)))), i2 += r22;
          return n2.join("");
        }, stringifyByChar: function(e2) {
          for (var t2 = "", r22 = 0; r22 < e2.length; r22++) t2 += String.fromCharCode(e2[r22]);
          return t2;
        }, applyCanBeUsed: { uint8array: (function() {
          try {
            return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
          } catch (e2) {
            return false;
          }
        })(), nodebuffer: (function() {
          try {
            return o.nodebuffer && 1 === String.fromCharCode.apply(null, r2.allocBuffer(1)).length;
          } catch (e2) {
            return false;
          }
        })() } };
        function s(e2) {
          var t2 = 65536, r22 = a.getTypeOf(e2), n2 = true;
          if ("uint8array" === r22 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r22 && (n2 = i.applyCanBeUsed.nodebuffer), n2) for (; 1 < t2; ) try {
            return i.stringifyByChunk(e2, r22, t2);
          } catch (e3) {
            t2 = Math.floor(t2 / 2);
          }
          return i.stringifyByChar(e2);
        }
        function f(e2, t2) {
          for (var r22 = 0; r22 < e2.length; r22++) t2[r22] = e2[r22];
          return t2;
        }
        a.applyFromCharCode = s;
        var c2 = {};
        c2.string = { string: n, array: function(e2) {
          return l3(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c2.string.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return l3(e2, new Uint8Array(e2.length));
        }, nodebuffer: function(e2) {
          return l3(e2, r2.allocBuffer(e2.length));
        } }, c2.array = { string: s, array: n, arraybuffer: function(e2) {
          return new Uint8Array(e2).buffer;
        }, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r2.newBufferFrom(e2);
        } }, c2.arraybuffer = { string: function(e2) {
          return s(new Uint8Array(e2));
        }, array: function(e2) {
          return f(new Uint8Array(e2), new Array(e2.byteLength));
        }, arraybuffer: n, uint8array: function(e2) {
          return new Uint8Array(e2);
        }, nodebuffer: function(e2) {
          return r2.newBufferFrom(new Uint8Array(e2));
        } }, c2.uint8array = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return e2.buffer;
        }, uint8array: n, nodebuffer: function(e2) {
          return r2.newBufferFrom(e2);
        } }, c2.nodebuffer = { string: s, array: function(e2) {
          return f(e2, new Array(e2.length));
        }, arraybuffer: function(e2) {
          return c2.nodebuffer.uint8array(e2).buffer;
        }, uint8array: function(e2) {
          return f(e2, new Uint8Array(e2.length));
        }, nodebuffer: n }, a.transformTo = function(e2, t2) {
          if (t2 = t2 || "", !e2) return t2;
          a.checkSupport(e2);
          var r22 = a.getTypeOf(t2);
          return c2[r22][e2](t2);
        }, a.resolve = function(e2) {
          for (var t2 = e2.split("/"), r22 = [], n2 = 0; n2 < t2.length; n2++) {
            var i2 = t2[n2];
            "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r22.pop() : r22.push(i2));
          }
          return r22.join("/");
        }, a.getTypeOf = function(e2) {
          return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r2.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
        }, a.checkSupport = function(e2) {
          if (!o[e2.toLowerCase()]) throw new Error(e2 + " is not supported by this platform");
        }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
          var t2, r22, n2 = "";
          for (r22 = 0; r22 < (e2 || "").length; r22++) n2 += "\\x" + ((t2 = e2.charCodeAt(r22)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
          return n2;
        }, a.delay = function(e2, t2, r22) {
          setImmediate(function() {
            e2.apply(r22 || null, t2 || []);
          });
        }, a.inherits = function(e2, t2) {
          function r22() {
          }
          r22.prototype = t2.prototype, e2.prototype = new r22();
        }, a.extend = function() {
          var e2, t2, r22 = {};
          for (e2 = 0; e2 < arguments.length; e2++) for (t2 in arguments[e2]) Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r22[t2] && (r22[t2] = arguments[e2][t2]);
          return r22;
        }, a.prepareContent = function(r22, e2, n2, i2, s2) {
          return u.Promise.resolve(e2).then(function(n3) {
            return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
              var e3 = new FileReader();
              e3.onload = function(e4) {
                t2(e4.target.result);
              }, e3.onerror = function(e4) {
                r3(e4.target.error);
              }, e3.readAsArrayBuffer(n3);
            }) : n3;
          }).then(function(e3) {
            var t2 = a.getTypeOf(e3);
            return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h2.decode(e3) : n2 && true !== i2 && (e3 = (function(e4) {
              return l3(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
            })(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r22 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
          });
        };
      }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r2) {
        var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
        function h2(e2) {
          this.files = [], this.loadOptions = e2;
        }
        h2.prototype = { checkSignature: function(e2) {
          if (!this.reader.readAndCheckSignature(e2)) {
            this.reader.index -= 4;
            var t2 = this.reader.readString(4);
            throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
          }
        }, isSignature: function(e2, t2) {
          var r22 = this.reader.index;
          this.reader.setIndex(e2);
          var n2 = this.reader.readString(4) === t2;
          return this.reader.setIndex(r22), n2;
        }, readBlockEndOfCentral: function() {
          this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
          var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r22 = i.transformTo(t2, e2);
          this.zipComment = this.loadOptions.decodeFileName(r22);
        }, readBlockZip64EndOfCentral: function() {
          this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
          for (var e2, t2, r22, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; ) e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r22 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r22 };
        }, readBlockZip64EndOfCentralLocator: function() {
          if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount) throw new Error("Multi-volumes zip are not supported");
        }, readLocalFiles: function() {
          var e2, t2;
          for (e2 = 0; e2 < this.files.length; e2++) t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
        }, readCentralDir: function() {
          var e2;
          for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); ) (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
          if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }, readEndOfCentral: function() {
          var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
          if (e2 < 0) throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
          this.reader.setIndex(e2);
          var t2 = e2;
          if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
            if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
            if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
          }
          var r22 = this.centralDirOffset + this.centralDirSize;
          this.zip64 && (r22 += 20, r22 += 12 + this.zip64EndOfCentralSize);
          var n2 = t2 - r22;
          if (0 < n2) this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
          else if (n2 < 0) throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
        }, prepareReader: function(e2) {
          this.reader = n(e2);
        }, load: function(e2) {
          this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
        } }, t.exports = h2;
      }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r2) {
        var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h2 = e("./compressions"), u = e("./support");
        function l3(e2, t2) {
          this.options = e2, this.loadOptions = t2;
        }
        l3.prototype = { isEncrypted: function() {
          return 1 == (1 & this.bitFlag);
        }, useUTF8: function() {
          return 2048 == (2048 & this.bitFlag);
        }, readLocalPart: function(e2) {
          var t2, r22;
          if (e2.skip(22), this.fileNameLength = e2.readInt(2), r22 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r22), -1 === this.compressedSize || -1 === this.uncompressedSize) throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
          if (null === (t2 = (function(e3) {
            for (var t3 in h2) if (Object.prototype.hasOwnProperty.call(h2, t3) && h2[t3].magic === e3) return h2[t3];
            return null;
          })(this.compressionMethod))) throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
          this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
        }, readCentralPart: function(e2) {
          this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
          var t2 = e2.readInt(2);
          if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
          e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
        }, processAttributes: function() {
          this.unixPermissions = null, this.dosPermissions = null;
          var e2 = this.versionMadeBy >> 8;
          this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
        }, parseZIP64ExtraField: function() {
          if (this.extraFields[1]) {
            var e2 = n(this.extraFields[1].value);
            this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
          }
        }, readExtraFields: function(e2) {
          var t2, r22, n2, i2 = e2.index + this.extraFieldsLength;
          for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; ) t2 = e2.readInt(2), r22 = e2.readInt(2), n2 = e2.readData(r22), this.extraFields[t2] = { id: t2, length: r22, value: n2 };
          e2.setIndex(i2);
        }, handleUTF8: function() {
          var e2 = u.uint8array ? "uint8array" : "array";
          if (this.useUTF8()) this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
          else {
            var t2 = this.findExtraFieldUnicodePath();
            if (null !== t2) this.fileNameStr = t2;
            else {
              var r22 = s.transformTo(e2, this.fileName);
              this.fileNameStr = this.loadOptions.decodeFileName(r22);
            }
            var n2 = this.findExtraFieldUnicodeComment();
            if (null !== n2) this.fileCommentStr = n2;
            else {
              var i2 = s.transformTo(e2, this.fileComment);
              this.fileCommentStr = this.loadOptions.decodeFileName(i2);
            }
          }
        }, findExtraFieldUnicodePath: function() {
          var e2 = this.extraFields[28789];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        }, findExtraFieldUnicodeComment: function() {
          var e2 = this.extraFields[25461];
          if (e2) {
            var t2 = n(e2.value);
            return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
          }
          return null;
        } }, t.exports = l3;
      }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r2) {
        function n(e2, t2, r22) {
          this.name = e2, this.dir = r22.dir, this.date = r22.date, this.comment = r22.comment, this.unixPermissions = r22.unixPermissions, this.dosPermissions = r22.dosPermissions, this._data = t2, this._dataBinary = r22.binary, this.options = { compression: r22.compression, compressionOptions: r22.compressionOptions };
        }
        var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h2 = e("./stream/GenericWorker");
        n.prototype = { internalStream: function(e2) {
          var t2 = null, r22 = "string";
          try {
            if (!e2) throw new Error("No output type specified.");
            var n2 = "string" === (r22 = e2.toLowerCase()) || "text" === r22;
            "binarystring" !== r22 && "text" !== r22 || (r22 = "string"), t2 = this._decompressWorker();
            var i2 = !this._dataBinary;
            i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
          } catch (e3) {
            (t2 = new h2("error")).error(e3);
          }
          return new s(t2, r22, "");
        }, async: function(e2, t2) {
          return this.internalStream(e2).accumulate(t2);
        }, nodeStream: function(e2, t2) {
          return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
        }, _compressWorker: function(e2, t2) {
          if (this._data instanceof o && this._data.compression.magic === e2.magic) return this._data.getCompressedWorker();
          var r22 = this._decompressWorker();
          return this._dataBinary || (r22 = r22.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r22, e2, t2);
        }, _decompressWorker: function() {
          return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h2 ? this._data : new i(this._data);
        } };
        for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l3 = function() {
          throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
        }, f = 0; f < u.length; f++) n.prototype[u[f]] = l3;
        t.exports = n;
      }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l3, t) {
        (function(t2) {
          var r2, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
          if (e2) {
            var i = 0, s = new e2(u), a = t2.document.createTextNode("");
            s.observe(a, { characterData: true }), r2 = function() {
              a.data = i = ++i % 2;
            };
          } else if (t2.setImmediate || void 0 === t2.MessageChannel) r2 = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
            var e3 = t2.document.createElement("script");
            e3.onreadystatechange = function() {
              u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
            }, t2.document.documentElement.appendChild(e3);
          } : function() {
            setTimeout(u, 0);
          };
          else {
            var o = new t2.MessageChannel();
            o.port1.onmessage = u, r2 = function() {
              o.port2.postMessage(0);
            };
          }
          var h2 = [];
          function u() {
            var e3, t3;
            n = true;
            for (var r22 = h2.length; r22; ) {
              for (t3 = h2, h2 = [], e3 = -1; ++e3 < r22; ) t3[e3]();
              r22 = h2.length;
            }
            n = false;
          }
          l3.exports = function(e3) {
            1 !== h2.push(e3) || n || r2();
          };
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}], 37: [function(e, t, r2) {
        var i = e("immediate");
        function u() {
        }
        var l3 = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
        function o(e2) {
          if ("function" != typeof e2) throw new TypeError("resolver must be a function");
          this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d2(this, e2);
        }
        function h2(e2, t2, r22) {
          this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r22 && (this.onRejected = r22, this.callRejected = this.otherCallRejected);
        }
        function f(t2, r22, n2) {
          i(function() {
            var e2;
            try {
              e2 = r22(n2);
            } catch (e3) {
              return l3.reject(t2, e3);
            }
            e2 === t2 ? l3.reject(t2, new TypeError("Cannot resolve promise with itself")) : l3.resolve(t2, e2);
          });
        }
        function c2(e2) {
          var t2 = e2 && e2.then;
          if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2) return function() {
            t2.apply(e2, arguments);
          };
        }
        function d2(t2, e2) {
          var r22 = false;
          function n2(e3) {
            r22 || (r22 = true, l3.reject(t2, e3));
          }
          function i2(e3) {
            r22 || (r22 = true, l3.resolve(t2, e3));
          }
          var s2 = p(function() {
            e2(i2, n2);
          });
          "error" === s2.status && n2(s2.value);
        }
        function p(e2, t2) {
          var r22 = {};
          try {
            r22.value = e2(t2), r22.status = "success";
          } catch (e3) {
            r22.status = "error", r22.value = e3;
          }
          return r22;
        }
        (t.exports = o).prototype.finally = function(t2) {
          if ("function" != typeof t2) return this;
          var r22 = this.constructor;
          return this.then(function(e2) {
            return r22.resolve(t2()).then(function() {
              return e2;
            });
          }, function(e2) {
            return r22.resolve(t2()).then(function() {
              throw e2;
            });
          });
        }, o.prototype.catch = function(e2) {
          return this.then(null, e2);
        }, o.prototype.then = function(e2, t2) {
          if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s) return this;
          var r22 = new this.constructor(u);
          this.state !== n ? f(r22, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h2(r22, e2, t2));
          return r22;
        }, h2.prototype.callFulfilled = function(e2) {
          l3.resolve(this.promise, e2);
        }, h2.prototype.otherCallFulfilled = function(e2) {
          f(this.promise, this.onFulfilled, e2);
        }, h2.prototype.callRejected = function(e2) {
          l3.reject(this.promise, e2);
        }, h2.prototype.otherCallRejected = function(e2) {
          f(this.promise, this.onRejected, e2);
        }, l3.resolve = function(e2, t2) {
          var r22 = p(c2, t2);
          if ("error" === r22.status) return l3.reject(e2, r22.value);
          var n2 = r22.value;
          if (n2) d2(e2, n2);
          else {
            e2.state = a, e2.outcome = t2;
            for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; ) e2.queue[i2].callFulfilled(t2);
          }
          return e2;
        }, l3.reject = function(e2, t2) {
          e2.state = s, e2.outcome = t2;
          for (var r22 = -1, n2 = e2.queue.length; ++r22 < n2; ) e2.queue[r22].callRejected(t2);
          return e2;
        }, o.resolve = function(e2) {
          if (e2 instanceof this) return e2;
          return l3.resolve(new this(u), e2);
        }, o.reject = function(e2) {
          var t2 = new this(u);
          return l3.reject(t2, e2);
        }, o.all = function(e2) {
          var r22 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
          var n2 = e2.length, i2 = false;
          if (!n2) return this.resolve([]);
          var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
          for (; ++t2 < n2; ) h22(e2[t2], t2);
          return o2;
          function h22(e3, t3) {
            r22.resolve(e3).then(function(e4) {
              s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l3.resolve(o2, s2));
            }, function(e4) {
              i2 || (i2 = true, l3.reject(o2, e4));
            });
          }
        }, o.race = function(e2) {
          var t2 = this;
          if ("[object Array]" !== Object.prototype.toString.call(e2)) return this.reject(new TypeError("must be an array"));
          var r22 = e2.length, n2 = false;
          if (!r22) return this.resolve([]);
          var i2 = -1, s2 = new this(u);
          for (; ++i2 < r22; ) a2 = e2[i2], t2.resolve(a2).then(function(e3) {
            n2 || (n2 = true, l3.resolve(s2, e3));
          }, function(e3) {
            n2 || (n2 = true, l3.reject(s2, e3));
          });
          var a2;
          return s2;
        };
      }, { immediate: 36 }], 38: [function(e, t, r2) {
        var n = {};
        (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
      }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r2) {
        var a = e("./zlib/deflate"), o = e("./utils/common"), h2 = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l3 = 0, f = -1, c2 = 0, d2 = 8;
        function p(e2) {
          if (!(this instanceof p)) return new p(e2);
          this.options = o.assign({ level: f, method: d2, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c2, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
          var r22 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
          if (r22 !== l3) throw new Error(i[r22]);
          if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
            var n2;
            if (n2 = "string" == typeof t2.dictionary ? h2.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r22 = a.deflateSetDictionary(this.strm, n2)) !== l3) throw new Error(i[r22]);
            this._dict_set = true;
          }
        }
        function n(e2, t2) {
          var r22 = new p(t2);
          if (r22.push(e2, true), r22.err) throw r22.msg || i[r22.err];
          return r22.result;
        }
        p.prototype.push = function(e2, t2) {
          var r22, n2, i2 = this.strm, s2 = this.options.chunkSize;
          if (this.ended) return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h2.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
          do {
            if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r22 = a.deflate(i2, n2)) && r22 !== l3) return this.onEnd(r22), !(this.ended = true);
            0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h2.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
          } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r22);
          return 4 === n2 ? (r22 = a.deflateEnd(this.strm), this.onEnd(r22), this.ended = true, r22 === l3) : 2 !== n2 || (this.onEnd(l3), !(i2.avail_out = 0));
        }, p.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, p.prototype.onEnd = function(e2) {
          e2 === l3 && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r2.Deflate = p, r2.deflate = n, r2.deflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, n(e2, t2);
        }, r2.gzip = function(e2, t2) {
          return (t2 = t2 || {}).gzip = true, n(e2, t2);
        };
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r2) {
        var c2 = e("./zlib/inflate"), d2 = e("./utils/common"), p = e("./utils/strings"), m2 = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _2 = Object.prototype.toString;
        function a(e2) {
          if (!(this instanceof a)) return new a(e2);
          this.options = d2.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
          var t2 = this.options;
          t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
          var r22 = c2.inflateInit2(this.strm, t2.windowBits);
          if (r22 !== m2.Z_OK) throw new Error(n[r22]);
          this.header = new s(), c2.inflateGetHeader(this.strm, this.header);
        }
        function o(e2, t2) {
          var r22 = new a(t2);
          if (r22.push(e2, true), r22.err) throw r22.msg || n[r22.err];
          return r22.result;
        }
        a.prototype.push = function(e2, t2) {
          var r22, n2, i2, s2, a2, o2, h2 = this.strm, u = this.options.chunkSize, l3 = this.options.dictionary, f = false;
          if (this.ended) return false;
          n2 = t2 === ~~t2 ? t2 : true === t2 ? m2.Z_FINISH : m2.Z_NO_FLUSH, "string" == typeof e2 ? h2.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _2.call(e2) ? h2.input = new Uint8Array(e2) : h2.input = e2, h2.next_in = 0, h2.avail_in = h2.input.length;
          do {
            if (0 === h2.avail_out && (h2.output = new d2.Buf8(u), h2.next_out = 0, h2.avail_out = u), (r22 = c2.inflate(h2, m2.Z_NO_FLUSH)) === m2.Z_NEED_DICT && l3 && (o2 = "string" == typeof l3 ? p.string2buf(l3) : "[object ArrayBuffer]" === _2.call(l3) ? new Uint8Array(l3) : l3, r22 = c2.inflateSetDictionary(this.strm, o2)), r22 === m2.Z_BUF_ERROR && true === f && (r22 = m2.Z_OK, f = false), r22 !== m2.Z_STREAM_END && r22 !== m2.Z_OK) return this.onEnd(r22), !(this.ended = true);
            h2.next_out && (0 !== h2.avail_out && r22 !== m2.Z_STREAM_END && (0 !== h2.avail_in || n2 !== m2.Z_FINISH && n2 !== m2.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h2.output, h2.next_out), s2 = h2.next_out - i2, a2 = p.buf2string(h2.output, i2), h2.next_out = s2, h2.avail_out = u - s2, s2 && d2.arraySet(h2.output, h2.output, i2, s2, 0), this.onData(a2)) : this.onData(d2.shrinkBuf(h2.output, h2.next_out)))), 0 === h2.avail_in && 0 === h2.avail_out && (f = true);
          } while ((0 < h2.avail_in || 0 === h2.avail_out) && r22 !== m2.Z_STREAM_END);
          return r22 === m2.Z_STREAM_END && (n2 = m2.Z_FINISH), n2 === m2.Z_FINISH ? (r22 = c2.inflateEnd(this.strm), this.onEnd(r22), this.ended = true, r22 === m2.Z_OK) : n2 !== m2.Z_SYNC_FLUSH || (this.onEnd(m2.Z_OK), !(h2.avail_out = 0));
        }, a.prototype.onData = function(e2) {
          this.chunks.push(e2);
        }, a.prototype.onEnd = function(e2) {
          e2 === m2.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d2.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
        }, r2.Inflate = a, r2.inflate = o, r2.inflateRaw = function(e2, t2) {
          return (t2 = t2 || {}).raw = true, o(e2, t2);
        }, r2.ungzip = o;
      }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r2) {
        var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
        r2.assign = function(e2) {
          for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
            var r22 = t2.shift();
            if (r22) {
              if ("object" != typeof r22) throw new TypeError(r22 + "must be non-object");
              for (var n2 in r22) r22.hasOwnProperty(n2) && (e2[n2] = r22[n2]);
            }
          }
          return e2;
        }, r2.shrinkBuf = function(e2, t2) {
          return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
        };
        var i = { arraySet: function(e2, t2, r22, n2, i2) {
          if (t2.subarray && e2.subarray) e2.set(t2.subarray(r22, r22 + n2), i2);
          else for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r22 + s2];
        }, flattenChunks: function(e2) {
          var t2, r22, n2, i2, s2, a;
          for (t2 = n2 = 0, r22 = e2.length; t2 < r22; t2++) n2 += e2[t2].length;
          for (a = new Uint8Array(n2), t2 = i2 = 0, r22 = e2.length; t2 < r22; t2++) s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
          return a;
        } }, s = { arraySet: function(e2, t2, r22, n2, i2) {
          for (var s2 = 0; s2 < n2; s2++) e2[i2 + s2] = t2[r22 + s2];
        }, flattenChunks: function(e2) {
          return [].concat.apply([], e2);
        } };
        r2.setTyped = function(e2) {
          e2 ? (r2.Buf8 = Uint8Array, r2.Buf16 = Uint16Array, r2.Buf32 = Int32Array, r2.assign(r2, i)) : (r2.Buf8 = Array, r2.Buf16 = Array, r2.Buf32 = Array, r2.assign(r2, s));
        }, r2.setTyped(n);
      }, {}], 42: [function(e, t, r2) {
        var h2 = e("./common"), i = true, s = true;
        try {
          String.fromCharCode.apply(null, [0]);
        } catch (e2) {
          i = false;
        }
        try {
          String.fromCharCode.apply(null, new Uint8Array(1));
        } catch (e2) {
          s = false;
        }
        for (var u = new h2.Buf8(256), n = 0; n < 256; n++) u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
        function l3(e2, t2) {
          if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i)) return String.fromCharCode.apply(null, h2.shrinkBuf(e2, t2));
          for (var r22 = "", n2 = 0; n2 < t2; n2++) r22 += String.fromCharCode(e2[n2]);
          return r22;
        }
        u[254] = u[254] = 1, r2.string2buf = function(e2) {
          var t2, r22, n2, i2, s2, a = e2.length, o = 0;
          for (i2 = 0; i2 < a; i2++) 55296 == (64512 & (r22 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r22 = 65536 + (r22 - 55296 << 10) + (n2 - 56320), i2++), o += r22 < 128 ? 1 : r22 < 2048 ? 2 : r22 < 65536 ? 3 : 4;
          for (t2 = new h2.Buf8(o), i2 = s2 = 0; s2 < o; i2++) 55296 == (64512 & (r22 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r22 = 65536 + (r22 - 55296 << 10) + (n2 - 56320), i2++), r22 < 128 ? t2[s2++] = r22 : (r22 < 2048 ? t2[s2++] = 192 | r22 >>> 6 : (r22 < 65536 ? t2[s2++] = 224 | r22 >>> 12 : (t2[s2++] = 240 | r22 >>> 18, t2[s2++] = 128 | r22 >>> 12 & 63), t2[s2++] = 128 | r22 >>> 6 & 63), t2[s2++] = 128 | 63 & r22);
          return t2;
        }, r2.buf2binstring = function(e2) {
          return l3(e2, e2.length);
        }, r2.binstring2buf = function(e2) {
          for (var t2 = new h2.Buf8(e2.length), r22 = 0, n2 = t2.length; r22 < n2; r22++) t2[r22] = e2.charCodeAt(r22);
          return t2;
        }, r2.buf2string = function(e2, t2) {
          var r22, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
          for (r22 = n2 = 0; r22 < a; ) if ((i2 = e2[r22++]) < 128) o[n2++] = i2;
          else if (4 < (s2 = u[i2])) o[n2++] = 65533, r22 += s2 - 1;
          else {
            for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r22 < a; ) i2 = i2 << 6 | 63 & e2[r22++], s2--;
            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
          }
          return l3(o, n2);
        }, r2.utf8border = function(e2, t2) {
          var r22;
          for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r22 = t2 - 1; 0 <= r22 && 128 == (192 & e2[r22]); ) r22--;
          return r22 < 0 ? t2 : 0 === r22 ? t2 : r22 + u[e2[r22]] > t2 ? r22 : t2;
        };
      }, { "./common": 41 }], 43: [function(e, t, r2) {
        t.exports = function(e2, t2, r22, n) {
          for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r22; ) {
            for (r22 -= a = 2e3 < r22 ? 2e3 : r22; s = s + (i = i + t2[n++] | 0) | 0, --a; ) ;
            i %= 65521, s %= 65521;
          }
          return i | s << 16 | 0;
        };
      }, {}], 44: [function(e, t, r2) {
        t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
      }, {}], 45: [function(e, t, r2) {
        var o = (function() {
          for (var e2, t2 = [], r22 = 0; r22 < 256; r22++) {
            e2 = r22;
            for (var n = 0; n < 8; n++) e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
            t2[r22] = e2;
          }
          return t2;
        })();
        t.exports = function(e2, t2, r22, n) {
          var i = o, s = n + r22;
          e2 ^= -1;
          for (var a = n; a < s; a++) e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
          return -1 ^ e2;
        };
      }, {}], 46: [function(e, t, r2) {
        var h2, c2 = e("../utils/common"), u = e("./trees"), d2 = e("./adler32"), p = e("./crc32"), n = e("./messages"), l3 = 0, f = 4, m2 = 0, _2 = -2, g = -1, b2 = 4, i = 2, v2 = 8, y2 = 9, s = 286, a = 30, o = 19, w2 = 2 * s + 1, k = 15, x = 3, S2 = 258, z2 = S2 + x + 1, C2 = 42, E2 = 113, A = 1, I2 = 2, O2 = 3, B2 = 4;
        function R2(e2, t2) {
          return e2.msg = n[t2], t2;
        }
        function T(e2) {
          return (e2 << 1) - (4 < e2 ? 9 : 0);
        }
        function D2(e2) {
          for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
        }
        function F2(e2) {
          var t2 = e2.state, r22 = t2.pending;
          r22 > e2.avail_out && (r22 = e2.avail_out), 0 !== r22 && (c2.arraySet(e2.output, t2.pending_buf, t2.pending_out, r22, e2.next_out), e2.next_out += r22, t2.pending_out += r22, e2.total_out += r22, e2.avail_out -= r22, t2.pending -= r22, 0 === t2.pending && (t2.pending_out = 0));
        }
        function N2(e2, t2) {
          u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F2(e2.strm);
        }
        function U2(e2, t2) {
          e2.pending_buf[e2.pending++] = t2;
        }
        function P2(e2, t2) {
          e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
        }
        function L2(e2, t2) {
          var r22, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h22 = e2.strstart > e2.w_size - z2 ? e2.strstart - (e2.w_size - z2) : 0, u2 = e2.window, l22 = e2.w_mask, f2 = e2.prev, c22 = e2.strstart + S2, d22 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
          e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
          do {
            if (u2[(r22 = t2) + a2] === p2 && u2[r22 + a2 - 1] === d22 && u2[r22] === u2[s2] && u2[++r22] === u2[s2 + 1]) {
              s2 += 2, r22++;
              do {
              } while (u2[++s2] === u2[++r22] && u2[++s2] === u2[++r22] && u2[++s2] === u2[++r22] && u2[++s2] === u2[++r22] && u2[++s2] === u2[++r22] && u2[++s2] === u2[++r22] && u2[++s2] === u2[++r22] && u2[++s2] === u2[++r22] && s2 < c22);
              if (n2 = S2 - (c22 - s2), s2 = c22 - S2, a2 < n2) {
                if (e2.match_start = t2, o2 <= (a2 = n2)) break;
                d22 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
              }
            }
          } while ((t2 = f2[t2 & l22]) > h22 && 0 != --i2);
          return a2 <= e2.lookahead ? a2 : e2.lookahead;
        }
        function j2(e2) {
          var t2, r22, n2, i2, s2, a2, o2, h22, u2, l22, f2 = e2.w_size;
          do {
            if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z2)) {
              for (c2.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r22 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r22; ) ;
              for (t2 = r22 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r22; ) ;
              i2 += f2;
            }
            if (0 === e2.strm.avail_in) break;
            if (a2 = e2.strm, o2 = e2.window, h22 = e2.strstart + e2.lookahead, u2 = i2, l22 = void 0, l22 = a2.avail_in, u2 < l22 && (l22 = u2), r22 = 0 === l22 ? 0 : (a2.avail_in -= l22, c2.arraySet(o2, a2.input, a2.next_in, l22, h22), 1 === a2.state.wrap ? a2.adler = d2(a2.adler, o2, l22, h22) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l22, h22)), a2.next_in += l22, a2.total_in += l22, l22), e2.lookahead += r22, e2.lookahead + e2.insert >= x) for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); ) ;
          } while (e2.lookahead < z2 && 0 !== e2.strm.avail_in);
        }
        function Z(e2, t2) {
          for (var r22, n2; ; ) {
            if (e2.lookahead < z2) {
              if (j2(e2), e2.lookahead < z2 && t2 === l3) return A;
              if (0 === e2.lookahead) break;
            }
            if (r22 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r22 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r22 && e2.strstart - r22 <= e2.w_size - z2 && (e2.match_length = L2(e2, r22)), e2.match_length >= x) if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
              for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r22 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; ) ;
              e2.strstart++;
            } else e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
            else n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
            if (n2 && (N2(e2, false), 0 === e2.strm.avail_out)) return A;
          }
          return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N2(e2, true), 0 === e2.strm.avail_out ? O2 : B2) : e2.last_lit && (N2(e2, false), 0 === e2.strm.avail_out) ? A : I2;
        }
        function W2(e2, t2) {
          for (var r22, n2, i2; ; ) {
            if (e2.lookahead < z2) {
              if (j2(e2), e2.lookahead < z2 && t2 === l3) return A;
              if (0 === e2.lookahead) break;
            }
            if (r22 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r22 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r22 && e2.prev_length < e2.max_lazy_match && e2.strstart - r22 <= e2.w_size - z2 && (e2.match_length = L2(e2, r22), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
              for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r22 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; ) ;
              if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N2(e2, false), 0 === e2.strm.avail_out)) return A;
            } else if (e2.match_available) {
              if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N2(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out) return A;
            } else e2.match_available = 1, e2.strstart++, e2.lookahead--;
          }
          return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N2(e2, true), 0 === e2.strm.avail_out ? O2 : B2) : e2.last_lit && (N2(e2, false), 0 === e2.strm.avail_out) ? A : I2;
        }
        function M2(e2, t2, r22, n2, i2) {
          this.good_length = e2, this.max_lazy = t2, this.nice_length = r22, this.max_chain = n2, this.func = i2;
        }
        function H2() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v2, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c2.Buf16(2 * w2), this.dyn_dtree = new c2.Buf16(2 * (2 * a + 1)), this.bl_tree = new c2.Buf16(2 * (2 * o + 1)), D2(this.dyn_ltree), D2(this.dyn_dtree), D2(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c2.Buf16(k + 1), this.heap = new c2.Buf16(2 * s + 1), D2(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c2.Buf16(2 * s + 1), D2(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
        }
        function G(e2) {
          var t2;
          return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C2 : E2, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l3, u._tr_init(t2), m2) : R2(e2, _2);
        }
        function K2(e2) {
          var t2 = G(e2);
          return t2 === m2 && (function(e3) {
            e3.window_size = 2 * e3.w_size, D2(e3.head), e3.max_lazy_match = h2[e3.level].max_lazy, e3.good_match = h2[e3.level].good_length, e3.nice_match = h2[e3.level].nice_length, e3.max_chain_length = h2[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
          })(e2.state), t2;
        }
        function Y2(e2, t2, r22, n2, i2, s2) {
          if (!e2) return _2;
          var a2 = 1;
          if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y2 < i2 || r22 !== v2 || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b2 < s2) return R2(e2, _2);
          8 === n2 && (n2 = 9);
          var o2 = new H2();
          return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c2.Buf8(2 * o2.w_size), o2.head = new c2.Buf16(o2.hash_size), o2.prev = new c2.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c2.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r22, K2(e2);
        }
        h2 = [new M2(0, 0, 0, 0, function(e2, t2) {
          var r22 = 65535;
          for (r22 > e2.pending_buf_size - 5 && (r22 = e2.pending_buf_size - 5); ; ) {
            if (e2.lookahead <= 1) {
              if (j2(e2), 0 === e2.lookahead && t2 === l3) return A;
              if (0 === e2.lookahead) break;
            }
            e2.strstart += e2.lookahead, e2.lookahead = 0;
            var n2 = e2.block_start + r22;
            if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N2(e2, false), 0 === e2.strm.avail_out)) return A;
            if (e2.strstart - e2.block_start >= e2.w_size - z2 && (N2(e2, false), 0 === e2.strm.avail_out)) return A;
          }
          return e2.insert = 0, t2 === f ? (N2(e2, true), 0 === e2.strm.avail_out ? O2 : B2) : (e2.strstart > e2.block_start && (N2(e2, false), e2.strm.avail_out), A);
        }), new M2(4, 4, 8, 4, Z), new M2(4, 5, 16, 8, Z), new M2(4, 6, 32, 32, Z), new M2(4, 4, 16, 16, W2), new M2(8, 16, 32, 32, W2), new M2(8, 16, 128, 128, W2), new M2(8, 32, 128, 256, W2), new M2(32, 128, 258, 1024, W2), new M2(32, 258, 258, 4096, W2)], r2.deflateInit = function(e2, t2) {
          return Y2(e2, t2, v2, 15, 8, 0);
        }, r2.deflateInit2 = Y2, r2.deflateReset = K2, r2.deflateResetKeep = G, r2.deflateSetHeader = function(e2, t2) {
          return e2 && e2.state ? 2 !== e2.state.wrap ? _2 : (e2.state.gzhead = t2, m2) : _2;
        }, r2.deflate = function(e2, t2) {
          var r22, n2, i2, s2;
          if (!e2 || !e2.state || 5 < t2 || t2 < 0) return e2 ? R2(e2, _2) : _2;
          if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f) return R2(e2, 0 === e2.avail_out ? -5 : _2);
          if (n2.strm = e2, r22 = n2.last_flush, n2.last_flush = t2, n2.status === C2) if (2 === n2.wrap) e2.adler = 0, U2(n2, 31), U2(n2, 139), U2(n2, 8), n2.gzhead ? (U2(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U2(n2, 255 & n2.gzhead.time), U2(n2, n2.gzhead.time >> 8 & 255), U2(n2, n2.gzhead.time >> 16 & 255), U2(n2, n2.gzhead.time >> 24 & 255), U2(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U2(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U2(n2, 255 & n2.gzhead.extra.length), U2(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U2(n2, 0), U2(n2, 0), U2(n2, 0), U2(n2, 0), U2(n2, 0), U2(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U2(n2, 3), n2.status = E2);
          else {
            var a2 = v2 + (n2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E2, P2(n2, a2), 0 !== n2.strstart && (P2(n2, e2.adler >>> 16), P2(n2, 65535 & e2.adler)), e2.adler = 1;
          }
          if (69 === n2.status) if (n2.gzhead.extra) {
            for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); ) U2(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else n2.status = 73;
          if (73 === n2.status) if (n2.gzhead.name) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U2(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
          } else n2.status = 91;
          if (91 === n2.status) if (n2.gzhead.comment) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F2(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U2(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
          } else n2.status = 103;
          if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F2(e2), n2.pending + 2 <= n2.pending_buf_size && (U2(n2, 255 & e2.adler), U2(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E2)) : n2.status = E2), 0 !== n2.pending) {
            if (F2(e2), 0 === e2.avail_out) return n2.last_flush = -1, m2;
          } else if (0 === e2.avail_in && T(t2) <= T(r22) && t2 !== f) return R2(e2, -5);
          if (666 === n2.status && 0 !== e2.avail_in) return R2(e2, -5);
          if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l3 && 666 !== n2.status) {
            var o2 = 2 === n2.strategy ? (function(e3, t3) {
              for (var r3; ; ) {
                if (0 === e3.lookahead && (j2(e3), 0 === e3.lookahead)) {
                  if (t3 === l3) return A;
                  break;
                }
                if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N2(e3, false), 0 === e3.strm.avail_out)) return A;
              }
              return e3.insert = 0, t3 === f ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A : I2;
            })(n2, t2) : 3 === n2.strategy ? (function(e3, t3) {
              for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
                if (e3.lookahead <= S2) {
                  if (j2(e3), e3.lookahead <= S2 && t3 === l3) return A;
                  if (0 === e3.lookahead) break;
                }
                if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                  s3 = e3.strstart + S2;
                  do {
                  } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                  e3.match_length = S2 - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
                }
                if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N2(e3, false), 0 === e3.strm.avail_out)) return A;
              }
              return e3.insert = 0, t3 === f ? (N2(e3, true), 0 === e3.strm.avail_out ? O2 : B2) : e3.last_lit && (N2(e3, false), 0 === e3.strm.avail_out) ? A : I2;
            })(n2, t2) : h2[n2.level].func(n2, t2);
            if (o2 !== O2 && o2 !== B2 || (n2.status = 666), o2 === A || o2 === O2) return 0 === e2.avail_out && (n2.last_flush = -1), m2;
            if (o2 === I2 && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D2(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F2(e2), 0 === e2.avail_out)) return n2.last_flush = -1, m2;
          }
          return t2 !== f ? m2 : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U2(n2, 255 & e2.adler), U2(n2, e2.adler >> 8 & 255), U2(n2, e2.adler >> 16 & 255), U2(n2, e2.adler >> 24 & 255), U2(n2, 255 & e2.total_in), U2(n2, e2.total_in >> 8 & 255), U2(n2, e2.total_in >> 16 & 255), U2(n2, e2.total_in >> 24 & 255)) : (P2(n2, e2.adler >>> 16), P2(n2, 65535 & e2.adler)), F2(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m2 : 1);
        }, r2.deflateEnd = function(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state.status) !== C2 && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E2 && 666 !== t2 ? R2(e2, _2) : (e2.state = null, t2 === E2 ? R2(e2, -3) : m2) : _2;
        }, r2.deflateSetDictionary = function(e2, t2) {
          var r22, n2, i2, s2, a2, o2, h22, u2, l22 = t2.length;
          if (!e2 || !e2.state) return _2;
          if (2 === (s2 = (r22 = e2.state).wrap) || 1 === s2 && r22.status !== C2 || r22.lookahead) return _2;
          for (1 === s2 && (e2.adler = d2(e2.adler, t2, l22, 0)), r22.wrap = 0, l22 >= r22.w_size && (0 === s2 && (D2(r22.head), r22.strstart = 0, r22.block_start = 0, r22.insert = 0), u2 = new c2.Buf8(r22.w_size), c2.arraySet(u2, t2, l22 - r22.w_size, r22.w_size, 0), t2 = u2, l22 = r22.w_size), a2 = e2.avail_in, o2 = e2.next_in, h22 = e2.input, e2.avail_in = l22, e2.next_in = 0, e2.input = t2, j2(r22); r22.lookahead >= x; ) {
            for (n2 = r22.strstart, i2 = r22.lookahead - (x - 1); r22.ins_h = (r22.ins_h << r22.hash_shift ^ r22.window[n2 + x - 1]) & r22.hash_mask, r22.prev[n2 & r22.w_mask] = r22.head[r22.ins_h], r22.head[r22.ins_h] = n2, n2++, --i2; ) ;
            r22.strstart = n2, r22.lookahead = x - 1, j2(r22);
          }
          return r22.strstart += r22.lookahead, r22.block_start = r22.strstart, r22.insert = r22.lookahead, r22.lookahead = 0, r22.match_length = r22.prev_length = x - 1, r22.match_available = 0, e2.next_in = o2, e2.input = h22, e2.avail_in = a2, r22.wrap = s2, m2;
        }, r2.deflateInfo = "pako deflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r2) {
        t.exports = function() {
          this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
        };
      }, {}], 48: [function(e, t, r2) {
        t.exports = function(e2, t2) {
          var r22, n, i, s, a, o, h2, u, l3, f, c2, d2, p, m2, _2, g, b2, v2, y2, w2, k, x, S2, z2, C2;
          r22 = e2.state, n = e2.next_in, z2 = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C2 = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h2 = r22.dmax, u = r22.wsize, l3 = r22.whave, f = r22.wnext, c2 = r22.window, d2 = r22.hold, p = r22.bits, m2 = r22.lencode, _2 = r22.distcode, g = (1 << r22.lenbits) - 1, b2 = (1 << r22.distbits) - 1;
          e: do {
            p < 15 && (d2 += z2[n++] << p, p += 8, d2 += z2[n++] << p, p += 8), v2 = m2[d2 & g];
            t: for (; ; ) {
              if (d2 >>>= y2 = v2 >>> 24, p -= y2, 0 === (y2 = v2 >>> 16 & 255)) C2[s++] = 65535 & v2;
              else {
                if (!(16 & y2)) {
                  if (0 == (64 & y2)) {
                    v2 = m2[(65535 & v2) + (d2 & (1 << y2) - 1)];
                    continue t;
                  }
                  if (32 & y2) {
                    r22.mode = 12;
                    break e;
                  }
                  e2.msg = "invalid literal/length code", r22.mode = 30;
                  break e;
                }
                w2 = 65535 & v2, (y2 &= 15) && (p < y2 && (d2 += z2[n++] << p, p += 8), w2 += d2 & (1 << y2) - 1, d2 >>>= y2, p -= y2), p < 15 && (d2 += z2[n++] << p, p += 8, d2 += z2[n++] << p, p += 8), v2 = _2[d2 & b2];
                r: for (; ; ) {
                  if (d2 >>>= y2 = v2 >>> 24, p -= y2, !(16 & (y2 = v2 >>> 16 & 255))) {
                    if (0 == (64 & y2)) {
                      v2 = _2[(65535 & v2) + (d2 & (1 << y2) - 1)];
                      continue r;
                    }
                    e2.msg = "invalid distance code", r22.mode = 30;
                    break e;
                  }
                  if (k = 65535 & v2, p < (y2 &= 15) && (d2 += z2[n++] << p, (p += 8) < y2 && (d2 += z2[n++] << p, p += 8)), h2 < (k += d2 & (1 << y2) - 1)) {
                    e2.msg = "invalid distance too far back", r22.mode = 30;
                    break e;
                  }
                  if (d2 >>>= y2, p -= y2, (y2 = s - a) < k) {
                    if (l3 < (y2 = k - y2) && r22.sane) {
                      e2.msg = "invalid distance too far back", r22.mode = 30;
                      break e;
                    }
                    if (S2 = c2, (x = 0) === f) {
                      if (x += u - y2, y2 < w2) {
                        for (w2 -= y2; C2[s++] = c2[x++], --y2; ) ;
                        x = s - k, S2 = C2;
                      }
                    } else if (f < y2) {
                      if (x += u + f - y2, (y2 -= f) < w2) {
                        for (w2 -= y2; C2[s++] = c2[x++], --y2; ) ;
                        if (x = 0, f < w2) {
                          for (w2 -= y2 = f; C2[s++] = c2[x++], --y2; ) ;
                          x = s - k, S2 = C2;
                        }
                      }
                    } else if (x += f - y2, y2 < w2) {
                      for (w2 -= y2; C2[s++] = c2[x++], --y2; ) ;
                      x = s - k, S2 = C2;
                    }
                    for (; 2 < w2; ) C2[s++] = S2[x++], C2[s++] = S2[x++], C2[s++] = S2[x++], w2 -= 3;
                    w2 && (C2[s++] = S2[x++], 1 < w2 && (C2[s++] = S2[x++]));
                  } else {
                    for (x = s - k; C2[s++] = C2[x++], C2[s++] = C2[x++], C2[s++] = C2[x++], 2 < (w2 -= 3); ) ;
                    w2 && (C2[s++] = C2[x++], 1 < w2 && (C2[s++] = C2[x++]));
                  }
                  break;
                }
              }
              break;
            }
          } while (n < i && s < o);
          n -= w2 = p >> 3, d2 &= (1 << (p -= w2 << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r22.hold = d2, r22.bits = p;
        };
      }, {}], 49: [function(e, t, r2) {
        var I2 = e("../utils/common"), O2 = e("./adler32"), B2 = e("./crc32"), R2 = e("./inffast"), T = e("./inftrees"), D2 = 1, F2 = 2, N2 = 0, U2 = -2, P2 = 1, n = 852, i = 592;
        function L2(e2) {
          return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
        }
        function s() {
          this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I2.Buf16(320), this.work = new I2.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
        }
        function a(e2) {
          var t2;
          return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P2, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I2.Buf32(n), t2.distcode = t2.distdyn = new I2.Buf32(i), t2.sane = 1, t2.back = -1, N2) : U2;
        }
        function o(e2) {
          var t2;
          return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U2;
        }
        function h2(e2, t2) {
          var r22, n2;
          return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r22 = 0, t2 = -t2) : (r22 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U2 : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r22, n2.wbits = t2, o(e2))) : U2;
        }
        function u(e2, t2) {
          var r22, n2;
          return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r22 = h2(e2, t2)) !== N2 && (e2.state = null), r22) : U2;
        }
        var l3, f, c2 = true;
        function j2(e2) {
          if (c2) {
            var t2;
            for (l3 = new I2.Buf32(512), f = new I2.Buf32(32), t2 = 0; t2 < 144; ) e2.lens[t2++] = 8;
            for (; t2 < 256; ) e2.lens[t2++] = 9;
            for (; t2 < 280; ) e2.lens[t2++] = 7;
            for (; t2 < 288; ) e2.lens[t2++] = 8;
            for (T(D2, e2.lens, 0, 288, l3, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; ) e2.lens[t2++] = 5;
            T(F2, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c2 = false;
          }
          e2.lencode = l3, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
        }
        function Z(e2, t2, r22, n2) {
          var i2, s2 = e2.state;
          return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I2.Buf8(s2.wsize)), n2 >= s2.wsize ? (I2.arraySet(s2.window, t2, r22 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I2.arraySet(s2.window, t2, r22 - n2, i2, s2.wnext), (n2 -= i2) ? (I2.arraySet(s2.window, t2, r22 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
        }
        r2.inflateReset = o, r2.inflateReset2 = h2, r2.inflateResetKeep = a, r2.inflateInit = function(e2) {
          return u(e2, 15);
        }, r2.inflateInit2 = u, r2.inflate = function(e2, t2) {
          var r22, n2, i2, s2, a2, o2, h22, u2, l22, f2, c22, d2, p, m2, _2, g, b2, v2, y2, w2, k, x, S2, z2, C2 = 0, E2 = new I2.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in) return U2;
          12 === (r22 = e2.state).mode && (r22.mode = 13), a2 = e2.next_out, i2 = e2.output, h22 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r22.hold, l22 = r22.bits, f2 = o2, c22 = h22, x = N2;
          e: for (; ; ) switch (r22.mode) {
            case P2:
              if (0 === r22.wrap) {
                r22.mode = 13;
                break;
              }
              for (; l22 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l22, l22 += 8;
              }
              if (2 & r22.wrap && 35615 === u2) {
                E2[r22.check = 0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r22.check = B2(r22.check, E2, 2, 0), l22 = u2 = 0, r22.mode = 2;
                break;
              }
              if (r22.flags = 0, r22.head && (r22.head.done = false), !(1 & r22.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                e2.msg = "incorrect header check", r22.mode = 30;
                break;
              }
              if (8 != (15 & u2)) {
                e2.msg = "unknown compression method", r22.mode = 30;
                break;
              }
              if (l22 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r22.wbits) r22.wbits = k;
              else if (k > r22.wbits) {
                e2.msg = "invalid window size", r22.mode = 30;
                break;
              }
              r22.dmax = 1 << k, e2.adler = r22.check = 1, r22.mode = 512 & u2 ? 10 : 12, l22 = u2 = 0;
              break;
            case 2:
              for (; l22 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l22, l22 += 8;
              }
              if (r22.flags = u2, 8 != (255 & r22.flags)) {
                e2.msg = "unknown compression method", r22.mode = 30;
                break;
              }
              if (57344 & r22.flags) {
                e2.msg = "unknown header flags set", r22.mode = 30;
                break;
              }
              r22.head && (r22.head.text = u2 >> 8 & 1), 512 & r22.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r22.check = B2(r22.check, E2, 2, 0)), l22 = u2 = 0, r22.mode = 3;
            case 3:
              for (; l22 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l22, l22 += 8;
              }
              r22.head && (r22.head.time = u2), 512 & r22.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, E2[2] = u2 >>> 16 & 255, E2[3] = u2 >>> 24 & 255, r22.check = B2(r22.check, E2, 4, 0)), l22 = u2 = 0, r22.mode = 4;
            case 4:
              for (; l22 < 16; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l22, l22 += 8;
              }
              r22.head && (r22.head.xflags = 255 & u2, r22.head.os = u2 >> 8), 512 & r22.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r22.check = B2(r22.check, E2, 2, 0)), l22 = u2 = 0, r22.mode = 5;
            case 5:
              if (1024 & r22.flags) {
                for (; l22 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l22, l22 += 8;
                }
                r22.length = u2, r22.head && (r22.head.extra_len = u2), 512 & r22.flags && (E2[0] = 255 & u2, E2[1] = u2 >>> 8 & 255, r22.check = B2(r22.check, E2, 2, 0)), l22 = u2 = 0;
              } else r22.head && (r22.head.extra = null);
              r22.mode = 6;
            case 6:
              if (1024 & r22.flags && (o2 < (d2 = r22.length) && (d2 = o2), d2 && (r22.head && (k = r22.head.extra_len - r22.length, r22.head.extra || (r22.head.extra = new Array(r22.head.extra_len)), I2.arraySet(r22.head.extra, n2, s2, d2, k)), 512 & r22.flags && (r22.check = B2(r22.check, n2, d2, s2)), o2 -= d2, s2 += d2, r22.length -= d2), r22.length)) break e;
              r22.length = 0, r22.mode = 7;
            case 7:
              if (2048 & r22.flags) {
                if (0 === o2) break e;
                for (d2 = 0; k = n2[s2 + d2++], r22.head && k && r22.length < 65536 && (r22.head.name += String.fromCharCode(k)), k && d2 < o2; ) ;
                if (512 & r22.flags && (r22.check = B2(r22.check, n2, d2, s2)), o2 -= d2, s2 += d2, k) break e;
              } else r22.head && (r22.head.name = null);
              r22.length = 0, r22.mode = 8;
            case 8:
              if (4096 & r22.flags) {
                if (0 === o2) break e;
                for (d2 = 0; k = n2[s2 + d2++], r22.head && k && r22.length < 65536 && (r22.head.comment += String.fromCharCode(k)), k && d2 < o2; ) ;
                if (512 & r22.flags && (r22.check = B2(r22.check, n2, d2, s2)), o2 -= d2, s2 += d2, k) break e;
              } else r22.head && (r22.head.comment = null);
              r22.mode = 9;
            case 9:
              if (512 & r22.flags) {
                for (; l22 < 16; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l22, l22 += 8;
                }
                if (u2 !== (65535 & r22.check)) {
                  e2.msg = "header crc mismatch", r22.mode = 30;
                  break;
                }
                l22 = u2 = 0;
              }
              r22.head && (r22.head.hcrc = r22.flags >> 9 & 1, r22.head.done = true), e2.adler = r22.check = 0, r22.mode = 12;
              break;
            case 10:
              for (; l22 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l22, l22 += 8;
              }
              e2.adler = r22.check = L2(u2), l22 = u2 = 0, r22.mode = 11;
            case 11:
              if (0 === r22.havedict) return e2.next_out = a2, e2.avail_out = h22, e2.next_in = s2, e2.avail_in = o2, r22.hold = u2, r22.bits = l22, 2;
              e2.adler = r22.check = 1, r22.mode = 12;
            case 12:
              if (5 === t2 || 6 === t2) break e;
            case 13:
              if (r22.last) {
                u2 >>>= 7 & l22, l22 -= 7 & l22, r22.mode = 27;
                break;
              }
              for (; l22 < 3; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l22, l22 += 8;
              }
              switch (r22.last = 1 & u2, l22 -= 1, 3 & (u2 >>>= 1)) {
                case 0:
                  r22.mode = 14;
                  break;
                case 1:
                  if (j2(r22), r22.mode = 20, 6 !== t2) break;
                  u2 >>>= 2, l22 -= 2;
                  break e;
                case 2:
                  r22.mode = 17;
                  break;
                case 3:
                  e2.msg = "invalid block type", r22.mode = 30;
              }
              u2 >>>= 2, l22 -= 2;
              break;
            case 14:
              for (u2 >>>= 7 & l22, l22 -= 7 & l22; l22 < 32; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l22, l22 += 8;
              }
              if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                e2.msg = "invalid stored block lengths", r22.mode = 30;
                break;
              }
              if (r22.length = 65535 & u2, l22 = u2 = 0, r22.mode = 15, 6 === t2) break e;
            case 15:
              r22.mode = 16;
            case 16:
              if (d2 = r22.length) {
                if (o2 < d2 && (d2 = o2), h22 < d2 && (d2 = h22), 0 === d2) break e;
                I2.arraySet(i2, n2, s2, d2, a2), o2 -= d2, s2 += d2, h22 -= d2, a2 += d2, r22.length -= d2;
                break;
              }
              r22.mode = 12;
              break;
            case 17:
              for (; l22 < 14; ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l22, l22 += 8;
              }
              if (r22.nlen = 257 + (31 & u2), u2 >>>= 5, l22 -= 5, r22.ndist = 1 + (31 & u2), u2 >>>= 5, l22 -= 5, r22.ncode = 4 + (15 & u2), u2 >>>= 4, l22 -= 4, 286 < r22.nlen || 30 < r22.ndist) {
                e2.msg = "too many length or distance symbols", r22.mode = 30;
                break;
              }
              r22.have = 0, r22.mode = 18;
            case 18:
              for (; r22.have < r22.ncode; ) {
                for (; l22 < 3; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l22, l22 += 8;
                }
                r22.lens[A[r22.have++]] = 7 & u2, u2 >>>= 3, l22 -= 3;
              }
              for (; r22.have < 19; ) r22.lens[A[r22.have++]] = 0;
              if (r22.lencode = r22.lendyn, r22.lenbits = 7, S2 = { bits: r22.lenbits }, x = T(0, r22.lens, 0, 19, r22.lencode, 0, r22.work, S2), r22.lenbits = S2.bits, x) {
                e2.msg = "invalid code lengths set", r22.mode = 30;
                break;
              }
              r22.have = 0, r22.mode = 19;
            case 19:
              for (; r22.have < r22.nlen + r22.ndist; ) {
                for (; g = (C2 = r22.lencode[u2 & (1 << r22.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l22); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l22, l22 += 8;
                }
                if (b2 < 16) u2 >>>= _2, l22 -= _2, r22.lens[r22.have++] = b2;
                else {
                  if (16 === b2) {
                    for (z2 = _2 + 2; l22 < z2; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l22, l22 += 8;
                    }
                    if (u2 >>>= _2, l22 -= _2, 0 === r22.have) {
                      e2.msg = "invalid bit length repeat", r22.mode = 30;
                      break;
                    }
                    k = r22.lens[r22.have - 1], d2 = 3 + (3 & u2), u2 >>>= 2, l22 -= 2;
                  } else if (17 === b2) {
                    for (z2 = _2 + 3; l22 < z2; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l22, l22 += 8;
                    }
                    l22 -= _2, k = 0, d2 = 3 + (7 & (u2 >>>= _2)), u2 >>>= 3, l22 -= 3;
                  } else {
                    for (z2 = _2 + 7; l22 < z2; ) {
                      if (0 === o2) break e;
                      o2--, u2 += n2[s2++] << l22, l22 += 8;
                    }
                    l22 -= _2, k = 0, d2 = 11 + (127 & (u2 >>>= _2)), u2 >>>= 7, l22 -= 7;
                  }
                  if (r22.have + d2 > r22.nlen + r22.ndist) {
                    e2.msg = "invalid bit length repeat", r22.mode = 30;
                    break;
                  }
                  for (; d2--; ) r22.lens[r22.have++] = k;
                }
              }
              if (30 === r22.mode) break;
              if (0 === r22.lens[256]) {
                e2.msg = "invalid code -- missing end-of-block", r22.mode = 30;
                break;
              }
              if (r22.lenbits = 9, S2 = { bits: r22.lenbits }, x = T(D2, r22.lens, 0, r22.nlen, r22.lencode, 0, r22.work, S2), r22.lenbits = S2.bits, x) {
                e2.msg = "invalid literal/lengths set", r22.mode = 30;
                break;
              }
              if (r22.distbits = 6, r22.distcode = r22.distdyn, S2 = { bits: r22.distbits }, x = T(F2, r22.lens, r22.nlen, r22.ndist, r22.distcode, 0, r22.work, S2), r22.distbits = S2.bits, x) {
                e2.msg = "invalid distances set", r22.mode = 30;
                break;
              }
              if (r22.mode = 20, 6 === t2) break e;
            case 20:
              r22.mode = 21;
            case 21:
              if (6 <= o2 && 258 <= h22) {
                e2.next_out = a2, e2.avail_out = h22, e2.next_in = s2, e2.avail_in = o2, r22.hold = u2, r22.bits = l22, R2(e2, c22), a2 = e2.next_out, i2 = e2.output, h22 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r22.hold, l22 = r22.bits, 12 === r22.mode && (r22.back = -1);
                break;
              }
              for (r22.back = 0; g = (C2 = r22.lencode[u2 & (1 << r22.lenbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l22); ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l22, l22 += 8;
              }
              if (g && 0 == (240 & g)) {
                for (v2 = _2, y2 = g, w2 = b2; g = (C2 = r22.lencode[w2 + ((u2 & (1 << v2 + y2) - 1) >> v2)]) >>> 16 & 255, b2 = 65535 & C2, !(v2 + (_2 = C2 >>> 24) <= l22); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l22, l22 += 8;
                }
                u2 >>>= v2, l22 -= v2, r22.back += v2;
              }
              if (u2 >>>= _2, l22 -= _2, r22.back += _2, r22.length = b2, 0 === g) {
                r22.mode = 26;
                break;
              }
              if (32 & g) {
                r22.back = -1, r22.mode = 12;
                break;
              }
              if (64 & g) {
                e2.msg = "invalid literal/length code", r22.mode = 30;
                break;
              }
              r22.extra = 15 & g, r22.mode = 22;
            case 22:
              if (r22.extra) {
                for (z2 = r22.extra; l22 < z2; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l22, l22 += 8;
                }
                r22.length += u2 & (1 << r22.extra) - 1, u2 >>>= r22.extra, l22 -= r22.extra, r22.back += r22.extra;
              }
              r22.was = r22.length, r22.mode = 23;
            case 23:
              for (; g = (C2 = r22.distcode[u2 & (1 << r22.distbits) - 1]) >>> 16 & 255, b2 = 65535 & C2, !((_2 = C2 >>> 24) <= l22); ) {
                if (0 === o2) break e;
                o2--, u2 += n2[s2++] << l22, l22 += 8;
              }
              if (0 == (240 & g)) {
                for (v2 = _2, y2 = g, w2 = b2; g = (C2 = r22.distcode[w2 + ((u2 & (1 << v2 + y2) - 1) >> v2)]) >>> 16 & 255, b2 = 65535 & C2, !(v2 + (_2 = C2 >>> 24) <= l22); ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l22, l22 += 8;
                }
                u2 >>>= v2, l22 -= v2, r22.back += v2;
              }
              if (u2 >>>= _2, l22 -= _2, r22.back += _2, 64 & g) {
                e2.msg = "invalid distance code", r22.mode = 30;
                break;
              }
              r22.offset = b2, r22.extra = 15 & g, r22.mode = 24;
            case 24:
              if (r22.extra) {
                for (z2 = r22.extra; l22 < z2; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l22, l22 += 8;
                }
                r22.offset += u2 & (1 << r22.extra) - 1, u2 >>>= r22.extra, l22 -= r22.extra, r22.back += r22.extra;
              }
              if (r22.offset > r22.dmax) {
                e2.msg = "invalid distance too far back", r22.mode = 30;
                break;
              }
              r22.mode = 25;
            case 25:
              if (0 === h22) break e;
              if (d2 = c22 - h22, r22.offset > d2) {
                if ((d2 = r22.offset - d2) > r22.whave && r22.sane) {
                  e2.msg = "invalid distance too far back", r22.mode = 30;
                  break;
                }
                p = d2 > r22.wnext ? (d2 -= r22.wnext, r22.wsize - d2) : r22.wnext - d2, d2 > r22.length && (d2 = r22.length), m2 = r22.window;
              } else m2 = i2, p = a2 - r22.offset, d2 = r22.length;
              for (h22 < d2 && (d2 = h22), h22 -= d2, r22.length -= d2; i2[a2++] = m2[p++], --d2; ) ;
              0 === r22.length && (r22.mode = 21);
              break;
            case 26:
              if (0 === h22) break e;
              i2[a2++] = r22.length, h22--, r22.mode = 21;
              break;
            case 27:
              if (r22.wrap) {
                for (; l22 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 |= n2[s2++] << l22, l22 += 8;
                }
                if (c22 -= h22, e2.total_out += c22, r22.total += c22, c22 && (e2.adler = r22.check = r22.flags ? B2(r22.check, i2, c22, a2 - c22) : O2(r22.check, i2, c22, a2 - c22)), c22 = h22, (r22.flags ? u2 : L2(u2)) !== r22.check) {
                  e2.msg = "incorrect data check", r22.mode = 30;
                  break;
                }
                l22 = u2 = 0;
              }
              r22.mode = 28;
            case 28:
              if (r22.wrap && r22.flags) {
                for (; l22 < 32; ) {
                  if (0 === o2) break e;
                  o2--, u2 += n2[s2++] << l22, l22 += 8;
                }
                if (u2 !== (4294967295 & r22.total)) {
                  e2.msg = "incorrect length check", r22.mode = 30;
                  break;
                }
                l22 = u2 = 0;
              }
              r22.mode = 29;
            case 29:
              x = 1;
              break e;
            case 30:
              x = -3;
              break e;
            case 31:
              return -4;
            case 32:
            default:
              return U2;
          }
          return e2.next_out = a2, e2.avail_out = h22, e2.next_in = s2, e2.avail_in = o2, r22.hold = u2, r22.bits = l22, (r22.wsize || c22 !== e2.avail_out && r22.mode < 30 && (r22.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c22 - e2.avail_out) ? (r22.mode = 31, -4) : (f2 -= e2.avail_in, c22 -= e2.avail_out, e2.total_in += f2, e2.total_out += c22, r22.total += c22, r22.wrap && c22 && (e2.adler = r22.check = r22.flags ? B2(r22.check, i2, c22, e2.next_out - c22) : O2(r22.check, i2, c22, e2.next_out - c22)), e2.data_type = r22.bits + (r22.last ? 64 : 0) + (12 === r22.mode ? 128 : 0) + (20 === r22.mode || 15 === r22.mode ? 256 : 0), (0 == f2 && 0 === c22 || 4 === t2) && x === N2 && (x = -5), x);
        }, r2.inflateEnd = function(e2) {
          if (!e2 || !e2.state) return U2;
          var t2 = e2.state;
          return t2.window && (t2.window = null), e2.state = null, N2;
        }, r2.inflateGetHeader = function(e2, t2) {
          var r22;
          return e2 && e2.state ? 0 == (2 & (r22 = e2.state).wrap) ? U2 : ((r22.head = t2).done = false, N2) : U2;
        }, r2.inflateSetDictionary = function(e2, t2) {
          var r22, n2 = t2.length;
          return e2 && e2.state ? 0 !== (r22 = e2.state).wrap && 11 !== r22.mode ? U2 : 11 === r22.mode && O2(1, t2, n2, 0) !== r22.check ? -3 : Z(e2, t2, n2, n2) ? (r22.mode = 31, -4) : (r22.havedict = 1, N2) : U2;
        }, r2.inflateInfo = "pako inflate (from Nodeca project)";
      }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r2) {
        var D2 = e("../utils/common"), F2 = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N2 = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U2 = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P2 = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(e2, t2, r22, n, i, s, a, o) {
          var h2, u, l3, f, c2, d2, p, m2, _2, g = o.bits, b2 = 0, v2 = 0, y2 = 0, w2 = 0, k = 0, x = 0, S2 = 0, z2 = 0, C2 = 0, E2 = 0, A = null, I2 = 0, O2 = new D2.Buf16(16), B2 = new D2.Buf16(16), R2 = null, T = 0;
          for (b2 = 0; b2 <= 15; b2++) O2[b2] = 0;
          for (v2 = 0; v2 < n; v2++) O2[t2[r22 + v2]]++;
          for (k = g, w2 = 15; 1 <= w2 && 0 === O2[w2]; w2--) ;
          if (w2 < k && (k = w2), 0 === w2) return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
          for (y2 = 1; y2 < w2 && 0 === O2[y2]; y2++) ;
          for (k < y2 && (k = y2), b2 = z2 = 1; b2 <= 15; b2++) if (z2 <<= 1, (z2 -= O2[b2]) < 0) return -1;
          if (0 < z2 && (0 === e2 || 1 !== w2)) return -1;
          for (B2[1] = 0, b2 = 1; b2 < 15; b2++) B2[b2 + 1] = B2[b2] + O2[b2];
          for (v2 = 0; v2 < n; v2++) 0 !== t2[r22 + v2] && (a[B2[t2[r22 + v2]]++] = v2);
          if (d2 = 0 === e2 ? (A = R2 = a, 19) : 1 === e2 ? (A = F2, I2 -= 257, R2 = N2, T -= 257, 256) : (A = U2, R2 = P2, -1), b2 = y2, c2 = s, S2 = v2 = E2 = 0, l3 = -1, f = (C2 = 1 << (x = k)) - 1, 1 === e2 && 852 < C2 || 2 === e2 && 592 < C2) return 1;
          for (; ; ) {
            for (p = b2 - S2, _2 = a[v2] < d2 ? (m2 = 0, a[v2]) : a[v2] > d2 ? (m2 = R2[T + a[v2]], A[I2 + a[v2]]) : (m2 = 96, 0), h2 = 1 << b2 - S2, y2 = u = 1 << x; i[c2 + (E2 >> S2) + (u -= h2)] = p << 24 | m2 << 16 | _2 | 0, 0 !== u; ) ;
            for (h2 = 1 << b2 - 1; E2 & h2; ) h2 >>= 1;
            if (0 !== h2 ? (E2 &= h2 - 1, E2 += h2) : E2 = 0, v2++, 0 == --O2[b2]) {
              if (b2 === w2) break;
              b2 = t2[r22 + a[v2]];
            }
            if (k < b2 && (E2 & f) !== l3) {
              for (0 === S2 && (S2 = k), c2 += y2, z2 = 1 << (x = b2 - S2); x + S2 < w2 && !((z2 -= O2[x + S2]) <= 0); ) x++, z2 <<= 1;
              if (C2 += 1 << x, 1 === e2 && 852 < C2 || 2 === e2 && 592 < C2) return 1;
              i[l3 = E2 & f] = k << 24 | x << 16 | c2 - s | 0;
            }
          }
          return 0 !== E2 && (i[c2 + E2] = b2 - S2 << 24 | 64 << 16 | 0), o.bits = k, 0;
        };
      }, { "../utils/common": 41 }], 51: [function(e, t, r2) {
        t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
      }, {}], 52: [function(e, t, r2) {
        var i = e("../utils/common"), o = 0, h2 = 1;
        function n(e2) {
          for (var t2 = e2.length; 0 <= --t2; ) e2[t2] = 0;
        }
        var s = 0, a = 29, u = 256, l3 = u + 1 + a, f = 30, c2 = 19, _2 = 2 * l3 + 1, g = 15, d2 = 16, p = 7, m2 = 256, b2 = 16, v2 = 17, y2 = 18, w2 = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S2 = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z2 = new Array(2 * (l3 + 2));
        n(z2);
        var C2 = new Array(2 * f);
        n(C2);
        var E2 = new Array(512);
        n(E2);
        var A = new Array(256);
        n(A);
        var I2 = new Array(a);
        n(I2);
        var O2, B2, R2, T = new Array(f);
        function D2(e2, t2, r22, n2, i2) {
          this.static_tree = e2, this.extra_bits = t2, this.extra_base = r22, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
        }
        function F2(e2, t2) {
          this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
        }
        function N2(e2) {
          return e2 < 256 ? E2[e2] : E2[256 + (e2 >>> 7)];
        }
        function U2(e2, t2) {
          e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
        }
        function P2(e2, t2, r22) {
          e2.bi_valid > d2 - r22 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U2(e2, e2.bi_buf), e2.bi_buf = t2 >> d2 - e2.bi_valid, e2.bi_valid += r22 - d2) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r22);
        }
        function L2(e2, t2, r22) {
          P2(e2, r22[2 * t2], r22[2 * t2 + 1]);
        }
        function j2(e2, t2) {
          for (var r22 = 0; r22 |= 1 & e2, e2 >>>= 1, r22 <<= 1, 0 < --t2; ) ;
          return r22 >>> 1;
        }
        function Z(e2, t2, r22) {
          var n2, i2, s2 = new Array(g + 1), a2 = 0;
          for (n2 = 1; n2 <= g; n2++) s2[n2] = a2 = a2 + r22[n2 - 1] << 1;
          for (i2 = 0; i2 <= t2; i2++) {
            var o2 = e2[2 * i2 + 1];
            0 !== o2 && (e2[2 * i2] = j2(s2[o2]++, o2));
          }
        }
        function W2(e2) {
          var t2;
          for (t2 = 0; t2 < l3; t2++) e2.dyn_ltree[2 * t2] = 0;
          for (t2 = 0; t2 < f; t2++) e2.dyn_dtree[2 * t2] = 0;
          for (t2 = 0; t2 < c2; t2++) e2.bl_tree[2 * t2] = 0;
          e2.dyn_ltree[2 * m2] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
        }
        function M2(e2) {
          8 < e2.bi_valid ? U2(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
        }
        function H2(e2, t2, r22, n2) {
          var i2 = 2 * t2, s2 = 2 * r22;
          return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r22];
        }
        function G(e2, t2, r22) {
          for (var n2 = e2.heap[r22], i2 = r22 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H2(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H2(t2, n2, e2.heap[i2], e2.depth)); ) e2.heap[r22] = e2.heap[i2], r22 = i2, i2 <<= 1;
          e2.heap[r22] = n2;
        }
        function K2(e2, t2, r22) {
          var n2, i2, s2, a2, o2 = 0;
          if (0 !== e2.last_lit) for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L2(e2, i2, t2) : (L2(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w2[s2]) && P2(e2, i2 -= I2[s2], a2), L2(e2, s2 = N2(--n2), r22), 0 !== (a2 = k[s2]) && P2(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; ) ;
          L2(e2, m2, t2);
        }
        function Y2(e2, t2) {
          var r22, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h22 = t2.stat_desc.elems, u2 = -1;
          for (e2.heap_len = 0, e2.heap_max = _2, r22 = 0; r22 < h22; r22++) 0 !== s2[2 * r22] ? (e2.heap[++e2.heap_len] = u2 = r22, e2.depth[r22] = 0) : s2[2 * r22 + 1] = 0;
          for (; e2.heap_len < 2; ) s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
          for (t2.max_code = u2, r22 = e2.heap_len >> 1; 1 <= r22; r22--) G(e2, s2, r22);
          for (i2 = h22; r22 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r22, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r22] + s2[2 * n2], e2.depth[i2] = (e2.depth[r22] >= e2.depth[n2] ? e2.depth[r22] : e2.depth[n2]) + 1, s2[2 * r22 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; ) ;
          e2.heap[--e2.heap_max] = e2.heap[1], (function(e3, t3) {
            var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l22 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c22 = t3.stat_desc.extra_bits, d22 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m22 = 0;
            for (s3 = 0; s3 <= g; s3++) e3.bl_count[s3] = 0;
            for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _2; r3++) p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m22++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d22 <= n3 && (a3 = c22[n3 - d22]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l22[2 * n3 + 1] + a3)));
            if (0 !== m22) {
              do {
                for (s3 = p2 - 1; 0 === e3.bl_count[s3]; ) s3--;
                e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m22 -= 2;
              } while (0 < m22);
              for (s3 = p2; 0 !== s3; s3--) for (n3 = e3.bl_count[s3]; 0 !== n3; ) u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
            }
          })(e2, t2), Z(s2, u2, e2.bl_count);
        }
        function X2(e2, t2, r22) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h22 = 7, u2 = 4;
          for (0 === a2 && (h22 = 138, u2 = 3), t2[2 * (r22 + 1) + 1] = 65535, n2 = 0; n2 <= r22; n2++) i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h22 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b2]++) : o2 <= 10 ? e2.bl_tree[2 * v2]++ : e2.bl_tree[2 * y2]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h22 = 138, 3) : i2 === a2 ? (h22 = 6, 3) : (h22 = 7, 4));
        }
        function V2(e2, t2, r22) {
          var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h22 = 7, u2 = 4;
          for (0 === a2 && (h22 = 138, u2 = 3), n2 = 0; n2 <= r22; n2++) if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h22 && i2 === a2)) {
            if (o2 < u2) for (; L2(e2, i2, e2.bl_tree), 0 != --o2; ) ;
            else 0 !== i2 ? (i2 !== s2 && (L2(e2, i2, e2.bl_tree), o2--), L2(e2, b2, e2.bl_tree), P2(e2, o2 - 3, 2)) : o2 <= 10 ? (L2(e2, v2, e2.bl_tree), P2(e2, o2 - 3, 3)) : (L2(e2, y2, e2.bl_tree), P2(e2, o2 - 11, 7));
            s2 = i2, u2 = (o2 = 0) === a2 ? (h22 = 138, 3) : i2 === a2 ? (h22 = 6, 3) : (h22 = 7, 4);
          }
        }
        n(T);
        var q2 = false;
        function J2(e2, t2, r22, n2) {
          P2(e2, (s << 1) + (n2 ? 1 : 0), 3), (function(e3, t3, r3, n3) {
            M2(e3), U2(e3, r3), U2(e3, ~r3), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
          })(e2, t2, r22);
        }
        r2._tr_init = function(e2) {
          q2 || ((function() {
            var e3, t2, r22, n2, i2, s2 = new Array(g + 1);
            for (n2 = r22 = 0; n2 < a - 1; n2++) for (I2[n2] = r22, e3 = 0; e3 < 1 << w2[n2]; e3++) A[r22++] = n2;
            for (A[r22 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++) for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++) E2[i2++] = n2;
            for (i2 >>= 7; n2 < f; n2++) for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++) E2[256 + i2++] = n2;
            for (t2 = 0; t2 <= g; t2++) s2[t2] = 0;
            for (e3 = 0; e3 <= 143; ) z2[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (; e3 <= 255; ) z2[2 * e3 + 1] = 9, e3++, s2[9]++;
            for (; e3 <= 279; ) z2[2 * e3 + 1] = 7, e3++, s2[7]++;
            for (; e3 <= 287; ) z2[2 * e3 + 1] = 8, e3++, s2[8]++;
            for (Z(z2, l3 + 1, s2), e3 = 0; e3 < f; e3++) C2[2 * e3 + 1] = 5, C2[2 * e3] = j2(e3, 5);
            O2 = new D2(z2, w2, u + 1, l3, g), B2 = new D2(C2, k, 0, f, g), R2 = new D2(new Array(0), x, 0, c2, p);
          })(), q2 = true), e2.l_desc = new F2(e2.dyn_ltree, O2), e2.d_desc = new F2(e2.dyn_dtree, B2), e2.bl_desc = new F2(e2.bl_tree, R2), e2.bi_buf = 0, e2.bi_valid = 0, W2(e2);
        }, r2._tr_stored_block = J2, r2._tr_flush_block = function(e2, t2, r22, n2) {
          var i2, s2, a2 = 0;
          0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = (function(e3) {
            var t3, r3 = 4093624447;
            for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1) if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3]) return o;
            if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26]) return h2;
            for (t3 = 32; t3 < u; t3++) if (0 !== e3.dyn_ltree[2 * t3]) return h2;
            return o;
          })(e2)), Y2(e2, e2.l_desc), Y2(e2, e2.d_desc), a2 = (function(e3) {
            var t3;
            for (X2(e3, e3.dyn_ltree, e3.l_desc.max_code), X2(e3, e3.dyn_dtree, e3.d_desc.max_code), Y2(e3, e3.bl_desc), t3 = c2 - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S2[t3] + 1]; t3--) ;
            return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
          })(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r22 + 5, r22 + 4 <= i2 && -1 !== t2 ? J2(e2, t2, r22, n2) : 4 === e2.strategy || s2 === i2 ? (P2(e2, 2 + (n2 ? 1 : 0), 3), K2(e2, z2, C2)) : (P2(e2, 4 + (n2 ? 1 : 0), 3), (function(e3, t3, r3, n3) {
            var i3;
            for (P2(e3, t3 - 257, 5), P2(e3, r3 - 1, 5), P2(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++) P2(e3, e3.bl_tree[2 * S2[i3] + 1], 3);
            V2(e3, e3.dyn_ltree, t3 - 1), V2(e3, e3.dyn_dtree, r3 - 1);
          })(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K2(e2, e2.dyn_ltree, e2.dyn_dtree)), W2(e2), n2 && M2(e2);
        }, r2._tr_tally = function(e2, t2, r22) {
          return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r22, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r22]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r22] + u + 1)]++, e2.dyn_dtree[2 * N2(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
        }, r2._tr_align = function(e2) {
          P2(e2, 2, 3), L2(e2, m2, z2), (function(e3) {
            16 === e3.bi_valid ? (U2(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
          })(e2);
        };
      }, { "../utils/common": 41 }], 53: [function(e, t, r2) {
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
        };
      }, {}], 54: [function(e, t, r2) {
        (function(e2) {
          !(function(r22, n) {
            if (!r22.setImmediate) {
              var i, s, t2, a, o = 1, h2 = {}, u = false, l3 = r22.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r22);
              e3 = e3 && e3.setTimeout ? e3 : r22, i = "[object process]" === {}.toString.call(r22.process) ? function(e4) {
                process$1$1.nextTick(function() {
                  c2(e4);
                });
              } : (function() {
                if (r22.postMessage && !r22.importScripts) {
                  var e4 = true, t3 = r22.onmessage;
                  return r22.onmessage = function() {
                    e4 = false;
                  }, r22.postMessage("", "*"), r22.onmessage = t3, e4;
                }
              })() ? (a = "setImmediate$" + Math.random() + "$", r22.addEventListener ? r22.addEventListener("message", d2, false) : r22.attachEvent("onmessage", d2), function(e4) {
                r22.postMessage(a + e4, "*");
              }) : r22.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
                c2(e4.data);
              }, function(e4) {
                t2.port2.postMessage(e4);
              }) : l3 && "onreadystatechange" in l3.createElement("script") ? (s = l3.documentElement, function(e4) {
                var t3 = l3.createElement("script");
                t3.onreadystatechange = function() {
                  c2(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
                }, s.appendChild(t3);
              }) : function(e4) {
                setTimeout(c2, 0, e4);
              }, e3.setImmediate = function(e4) {
                "function" != typeof e4 && (e4 = new Function("" + e4));
                for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++) t3[r3] = arguments[r3 + 1];
                var n2 = { callback: e4, args: t3 };
                return h2[o] = n2, i(o), o++;
              }, e3.clearImmediate = f;
            }
            function f(e4) {
              delete h2[e4];
            }
            function c2(e4) {
              if (u) setTimeout(c2, 0, e4);
              else {
                var t3 = h2[e4];
                if (t3) {
                  u = true;
                  try {
                    !(function(e5) {
                      var t4 = e5.callback, r3 = e5.args;
                      switch (r3.length) {
                        case 0:
                          t4();
                          break;
                        case 1:
                          t4(r3[0]);
                          break;
                        case 2:
                          t4(r3[0], r3[1]);
                          break;
                        case 3:
                          t4(r3[0], r3[1], r3[2]);
                          break;
                        default:
                          t4.apply(n, r3);
                      }
                    })(t3);
                  } finally {
                    f(e4), u = false;
                  }
                }
              }
            }
            function d2(e4) {
              e4.source === r22 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c2(+e4.data.slice(a.length));
            }
          })("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
        }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}] }, {}, [10])(10);
    });
  })(jszip_min);
  return jszip_min.exports;
}
var jszip_minExports = requireJszip_min();
const JSZip = /* @__PURE__ */ getDefaultExportFromCjs$1(jszip_minExports);
class DocxZipper {
  constructor(params2 = {}) {
    this.debug = params2.debug || false;
    this.zip = new JSZip();
    this.files = [];
    this.media = {};
    this.mediaFiles = {};
    this.fonts = {};
  }
  /**
   * Get all docx data from the zipped docx
   *
   * [ContentTypes].xml
   * _rels/.rels
   * word/document.xml
   * word/_rels/document.xml.rels
   * word/footnotes.xml
   * word/endnotes.xml
   * word/header1.xml
   * word/theme/theme1.xml
   * word/settings.xml
   * word/styles.xml
   * word/webSettings.xml
   * word/fontTable.xml
   * docProps/core.xml
   * docProps/app.xml
   * */
  async getDocxData(file, isNode2 = false) {
    const extractedFiles = await this.unzip(file);
    const files = Object.entries(extractedFiles.files);
    const mediaObjects = {};
    const validTypes = ["xml", "rels"];
    for (const file2 of files) {
      const [, zipEntry] = file2;
      if (validTypes.some((validType) => zipEntry.name.endsWith(validType))) {
        const content = await zipEntry.async("string");
        this.files.push({
          name: zipEntry.name,
          content
        });
      } else if (zipEntry.name.startsWith("word/media") && zipEntry.name !== "word/media/") {
        if (isNode2) {
          const buffer2 = await zipEntry.async("nodebuffer");
          const fileBase64 = buffer2.toString("base64");
          mediaObjects[zipEntry.name] = fileBase64;
        } else {
          const blob = await zipEntry.async("blob");
          const extension = this.getFileExtension(zipEntry.name);
          const fileBase64 = await zipEntry.async("base64");
          this.mediaFiles[zipEntry.name] = `data:image/${extension};base64,${fileBase64}`;
          const file3 = new File([blob], zipEntry.name, { type: blob.type });
          const imageUrl = URL.createObjectURL(file3);
          this.media[zipEntry.name] = imageUrl;
        }
      } else if (zipEntry.name.startsWith("word/fonts") && zipEntry.name !== "word/fonts/") {
        const uint8array = await zipEntry.async("uint8array");
        this.fonts[zipEntry.name] = uint8array;
      }
    }
    return this.files;
  }
  getFileExtension(fileName) {
    const fileSplit = fileName.split(".");
    if (fileSplit.length < 2) return null;
    return fileSplit[fileSplit.length - 1];
  }
  /**
   * Update [Content_Types].xml with extensions of new Image annotations
   */
  async updateContentTypes(docx, media, fromJson) {
    const newMediaTypes = Object.keys(media).map((name) => {
      return this.getFileExtension(name);
    }).filter(Boolean);
    const contentTypesPath = "[Content_Types].xml";
    let contentTypesXml;
    if (fromJson) {
      contentTypesXml = docx.files.find((file) => file.name === contentTypesPath)?.content || "";
    } else contentTypesXml = await docx.file(contentTypesPath).async("string");
    let typesString = "";
    const defaultMediaTypes = getContentTypesFromXml(contentTypesXml);
    const seenTypes = /* @__PURE__ */ new Set();
    for (let type2 of newMediaTypes) {
      if (defaultMediaTypes.includes(type2)) continue;
      if (seenTypes.has(type2)) continue;
      const newContentType = `<Default Extension="${type2}" ContentType="image/${type2}"/>`;
      typesString += newContentType;
      seenTypes.add(type2);
    }
    const xmlJson = JSON.parse(xmljs.xml2json(contentTypesXml, null, 2));
    const types2 = xmlJson.elements?.find((el) => el.name === "Types") || {};
    const hasComments = types2.elements?.some(
      (el) => el.name === "Override" && el.attributes.PartName === "/word/comments.xml"
    );
    const hasCommentsExtended = types2.elements?.some(
      (el) => el.name === "Override" && el.attributes.PartName === "/word/commentsExtended.xml"
    );
    const hasCommentsIds = types2.elements?.some(
      (el) => el.name === "Override" && el.attributes.PartName === "/word/commentsIds.xml"
    );
    const hasCommentsExtensible = types2.elements?.some(
      (el) => el.name === "Override" && el.attributes.PartName === "/word/commentsExtensible.xml"
    );
    if (docx.files["word/comments.xml"]) {
      const commentsDef = `<Override PartName="/word/comments.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml" />`;
      if (!hasComments) typesString += commentsDef;
    }
    if (docx.files["word/commentsExtended.xml"]) {
      const commentsExtendedDef = `<Override PartName="/word/commentsExtended.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtended+xml" />`;
      if (!hasCommentsExtended) typesString += commentsExtendedDef;
    }
    if (docx.files["word/commentsIds.xml"]) {
      const commentsIdsDef = `<Override PartName="/word/commentsIds.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.commentsIds+xml" />`;
      if (!hasCommentsIds) typesString += commentsIdsDef;
    }
    if (docx.files["word/commentsExtensible.xml"]) {
      const commentsExtendedDef = `<Override PartName="/word/commentsExtensible.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.commentsExtensible+xml" />`;
      if (!hasCommentsExtensible) typesString += commentsExtendedDef;
    }
    Object.keys(docx.files).forEach((name) => {
      if (name.includes(".rels") || !name.includes("header") && !name.includes("footer")) return;
      const hasExtensible = types2.elements?.some(
        (el) => el.name === "Override" && el.attributes.PartName === `/${name}`
      );
      const type2 = name.includes("header") ? "header" : "footer";
      const extendedDef = `<Override PartName="/${name}" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.${type2}+xml"/>`;
      if (!hasExtensible) {
        typesString += extendedDef;
      }
    });
    const beginningString = '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">';
    const updatedContentTypesXml = contentTypesXml.replace(beginningString, `${beginningString}${typesString}`);
    if (fromJson) return updatedContentTypesXml;
    docx.file(contentTypesPath, updatedContentTypesXml);
  }
  async unzip(file) {
    const zip = await this.zip.loadAsync(file);
    return zip;
  }
  async updateZip({ docx, updatedDocs, originalDocxFile, media, fonts, isHeadless }) {
    let zip;
    if (originalDocxFile) {
      zip = await this.exportFromOriginalFile(originalDocxFile, updatedDocs, media);
    } else {
      zip = await this.exportFromCollaborativeDocx(docx, updatedDocs, media, fonts);
    }
    const exportType = isHeadless ? "nodebuffer" : "blob";
    return await zip.generateAsync({ type: exportType });
  }
  /**
   * Export the Editor content to a docx file, updating changed docs
   * @param {Object} docx An object containing the unzipped docx files (keys are relative file names)
   * @param {Object} updatedDocs An object containing the updated docs (keys are relative file names)
   * @returns {Promise<JSZip>} The unzipped but updated docx file ready for zipping
   */
  async exportFromCollaborativeDocx(docx, updatedDocs, media, fonts) {
    const zip = new JSZip();
    for (const file of docx) {
      const content = file.content;
      zip.file(file.name, content);
    }
    Object.keys(updatedDocs).forEach((key) => {
      const content = updatedDocs[key];
      zip.file(key, content);
    });
    Object.keys(media).forEach((name) => {
      const binaryData = Buffer2.from(media[name], "base64");
      zip.file(`word/media/${name}`, binaryData);
    });
    for (const [fontName, fontUintArray] of Object.entries(fonts)) {
      zip.file(fontName, fontUintArray);
    }
    await this.updateContentTypes(zip, media);
    return zip;
  }
  /**
   * Export the Editor content to a docx file, updating changed docs
   * Requires the original docx file
   * @param {File} originalDocxFile The original docx file
   * @param {Object} updatedDocs An object containing the updated docs (keys are relative file names)
   * @returns {Promise<JSZip>} The unzipped but updated docx file ready for zipping
   */
  async exportFromOriginalFile(originalDocxFile, updatedDocs, media) {
    const unzippedOriginalDocx = await this.unzip(originalDocxFile);
    const filePromises = [];
    unzippedOriginalDocx.forEach((relativePath, zipEntry) => {
      const promise = zipEntry.async("string").then((content) => {
        unzippedOriginalDocx.file(zipEntry.name, content);
      });
      filePromises.push(promise);
    });
    await Promise.all(filePromises);
    Object.keys(updatedDocs).forEach((key) => {
      unzippedOriginalDocx.file(key, updatedDocs[key]);
    });
    Object.keys(media).forEach((name) => {
      unzippedOriginalDocx.file(`word/media/${name}`, media[name]);
    });
    await this.updateContentTypes(unzippedOriginalDocx, media);
    return unzippedOriginalDocx;
  }
}
var __defProp$1 = Object.defineProperty;
var __typeError$1 = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField$1 = (obj, key, value) => __defNormalProp$1(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck$1 = (obj, member, msg2) => member.has(obj) || __typeError$1("Cannot " + msg2);
var __privateGet$1 = (obj, member, getter) => (__accessCheck$1(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd$1 = (obj, member, value) => member.has(obj) ? __typeError$1("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck$1(obj, member, "write to private field"), member.set(obj, value), value);
var __privateMethod$1 = (obj, member, method) => (__accessCheck$1(obj, member, "access private method"), method);
var _Attribute_static, getGlobalAttributes_fn, getNodeAndMarksAttributes_fn, _Schema_static, createNodesSchema_fn, createMarksSchema_fn, _events, _ExtensionService_instances, setupExtensions_fn, attachEditorEvents_fn, _editor, _stateValidators, _requiredNodeTypes, _requiredMarkTypes, _SuperValidator_instances, initializeValidators_fn, collectValidatorRequirements_fn, analyzeDocument_fn, _commandService, _Editor_instances, initContainerElement_fn, init_fn, initRichText_fn, onFocus_fn, checkHeadless_fn, insertNewFileData_fn, registerPluginByNameIfNotExists_fn, createExtensionService_fn, createCommandService_fn, createConverter_fn, initMedia_fn, initFonts_fn, createSchema_fn, generatePmData_fn, createView_fn, onCollaborationReady_fn, initComments_fn, initPagination_fn, dispatchTransaction_fn, handleNodeSelection_fn, prepareDocumentForImport_fn, prepareDocumentForExport_fn, endCollaboration_fn, validateDocumentInit_fn, _ListItemNodeView_instances, init_fn2, _FieldAnnotationView_instances, createAnnotation_fn, _AutoPageNumberNodeView_instances, renderDom_fn, scheduleUpdateNodeStyle_fn, _DocumentSectionView_instances, init_fn3, addToolTip_fn;
var GOOD_LEAF_SIZE = 200;
var RopeSequence = function RopeSequence2() {
};
RopeSequence.prototype.append = function append(other) {
  if (!other.length) {
    return this;
  }
  other = RopeSequence.from(other);
  return !this.length && other || other.length < GOOD_LEAF_SIZE && this.leafAppend(other) || this.length < GOOD_LEAF_SIZE && other.leafPrepend(this) || this.appendInner(other);
};
RopeSequence.prototype.prepend = function prepend(other) {
  if (!other.length) {
    return this;
  }
  return RopeSequence.from(other).append(this);
};
RopeSequence.prototype.appendInner = function appendInner(other) {
  return new Append(this, other);
};
RopeSequence.prototype.slice = function slice(from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 >= to) {
    return RopeSequence.empty;
  }
  return this.sliceInner(Math.max(0, from2), Math.min(this.length, to));
};
RopeSequence.prototype.get = function get(i) {
  if (i < 0 || i >= this.length) {
    return void 0;
  }
  return this.getInner(i);
};
RopeSequence.prototype.forEach = function forEach2(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  if (from2 <= to) {
    this.forEachInner(f, from2, to, 0);
  } else {
    this.forEachInvertedInner(f, from2, to, 0);
  }
};
RopeSequence.prototype.map = function map(f, from2, to) {
  if (from2 === void 0) from2 = 0;
  if (to === void 0) to = this.length;
  var result = [];
  this.forEach(function(elt, i) {
    return result.push(f(elt, i));
  }, from2, to);
  return result;
};
RopeSequence.from = function from(values) {
  if (values instanceof RopeSequence) {
    return values;
  }
  return values && values.length ? new Leaf(values) : RopeSequence.empty;
};
var Leaf = /* @__PURE__ */ (function(RopeSequence3) {
  function Leaf2(values) {
    RopeSequence3.call(this);
    this.values = values;
  }
  if (RopeSequence3) Leaf2.__proto__ = RopeSequence3;
  Leaf2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Leaf2.prototype.constructor = Leaf2;
  var prototypeAccessors = { length: { configurable: true }, depth: { configurable: true } };
  Leaf2.prototype.flatten = function flatten2() {
    return this.values;
  };
  Leaf2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    return new Leaf2(this.values.slice(from2, to));
  };
  Leaf2.prototype.getInner = function getInner(i) {
    return this.values[i];
  };
  Leaf2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    for (var i = from2; i < to; i++) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    for (var i = from2 - 1; i >= to; i--) {
      if (f(this.values[i], start2 + i) === false) {
        return false;
      }
    }
  };
  Leaf2.prototype.leafAppend = function leafAppend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(this.values.concat(other.flatten()));
    }
  };
  Leaf2.prototype.leafPrepend = function leafPrepend(other) {
    if (this.length + other.length <= GOOD_LEAF_SIZE) {
      return new Leaf2(other.flatten().concat(this.values));
    }
  };
  prototypeAccessors.length.get = function() {
    return this.values.length;
  };
  prototypeAccessors.depth.get = function() {
    return 0;
  };
  Object.defineProperties(Leaf2.prototype, prototypeAccessors);
  return Leaf2;
})(RopeSequence);
RopeSequence.empty = new Leaf([]);
var Append = /* @__PURE__ */ (function(RopeSequence3) {
  function Append2(left2, right2) {
    RopeSequence3.call(this);
    this.left = left2;
    this.right = right2;
    this.length = left2.length + right2.length;
    this.depth = Math.max(left2.depth, right2.depth) + 1;
  }
  if (RopeSequence3) Append2.__proto__ = RopeSequence3;
  Append2.prototype = Object.create(RopeSequence3 && RopeSequence3.prototype);
  Append2.prototype.constructor = Append2;
  Append2.prototype.flatten = function flatten2() {
    return this.left.flatten().concat(this.right.flatten());
  };
  Append2.prototype.getInner = function getInner(i) {
    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length);
  };
  Append2.prototype.forEachInner = function forEachInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 < leftLen && this.left.forEachInner(f, from2, Math.min(to, leftLen), start2) === false) {
      return false;
    }
    if (to > leftLen && this.right.forEachInner(f, Math.max(from2 - leftLen, 0), Math.min(this.length, to) - leftLen, start2 + leftLen) === false) {
      return false;
    }
  };
  Append2.prototype.forEachInvertedInner = function forEachInvertedInner(f, from2, to, start2) {
    var leftLen = this.left.length;
    if (from2 > leftLen && this.right.forEachInvertedInner(f, from2 - leftLen, Math.max(to, leftLen) - leftLen, start2 + leftLen) === false) {
      return false;
    }
    if (to < leftLen && this.left.forEachInvertedInner(f, Math.min(from2, leftLen), to, start2) === false) {
      return false;
    }
  };
  Append2.prototype.sliceInner = function sliceInner(from2, to) {
    if (from2 == 0 && to == this.length) {
      return this;
    }
    var leftLen = this.left.length;
    if (to <= leftLen) {
      return this.left.slice(from2, to);
    }
    if (from2 >= leftLen) {
      return this.right.slice(from2 - leftLen, to - leftLen);
    }
    return this.left.slice(from2, leftLen).append(this.right.slice(0, to - leftLen));
  };
  Append2.prototype.leafAppend = function leafAppend(other) {
    var inner = this.right.leafAppend(other);
    if (inner) {
      return new Append2(this.left, inner);
    }
  };
  Append2.prototype.leafPrepend = function leafPrepend(other) {
    var inner = this.left.leafPrepend(other);
    if (inner) {
      return new Append2(inner, this.right);
    }
  };
  Append2.prototype.appendInner = function appendInner2(other) {
    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1) {
      return new Append2(this.left, new Append2(this.right, other));
    }
    return new Append2(this, other);
  };
  return Append2;
})(RopeSequence);
const max_empty_items = 500;
class Branch {
  constructor(items, eventCount) {
    this.items = items;
    this.eventCount = eventCount;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(state2, preserveItems) {
    if (this.eventCount == 0)
      return null;
    let end2 = this.items.length;
    for (; ; end2--) {
      let next = this.items.get(end2 - 1);
      if (next.selection) {
        --end2;
        break;
      }
    }
    let remap, mapFrom;
    if (preserveItems) {
      remap = this.remapping(end2, this.items.length);
      mapFrom = remap.maps.length;
    }
    let transform = state2.tr;
    let selection, remaining;
    let addAfter = [], addBefore = [];
    this.items.forEach((item, i) => {
      if (!item.step) {
        if (!remap) {
          remap = this.remapping(end2, i + 1);
          mapFrom = remap.maps.length;
        }
        mapFrom--;
        addBefore.push(item);
        return;
      }
      if (remap) {
        addBefore.push(new Item(item.map));
        let step = item.step.map(remap.slice(mapFrom)), map22;
        if (step && transform.maybeStep(step).doc) {
          map22 = transform.mapping.maps[transform.mapping.maps.length - 1];
          addAfter.push(new Item(map22, void 0, void 0, addAfter.length + addBefore.length));
        }
        mapFrom--;
        if (map22)
          remap.appendMap(map22, mapFrom);
      } else {
        transform.maybeStep(item.step);
      }
      if (item.selection) {
        selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;
        remaining = new Branch(this.items.slice(0, end2).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);
        return false;
      }
    }, this.items.length, 0);
    return { remaining, transform, selection };
  }
  // Create a new branch with the given transform added.
  addTransform(transform, selection, histOptions, preserveItems) {
    let newItems = [], eventCount = this.eventCount;
    let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;
    for (let i = 0; i < transform.steps.length; i++) {
      let step = transform.steps[i].invert(transform.docs[i]);
      let item = new Item(transform.mapping.maps[i], step, selection), merged;
      if (merged = lastItem && lastItem.merge(item)) {
        item = merged;
        if (i)
          newItems.pop();
        else
          oldItems = oldItems.slice(0, oldItems.length - 1);
      }
      newItems.push(item);
      if (selection) {
        eventCount++;
        selection = void 0;
      }
      if (!preserveItems)
        lastItem = item;
    }
    let overflow = eventCount - histOptions.depth;
    if (overflow > DEPTH_OVERFLOW) {
      oldItems = cutOffEvents(oldItems, overflow);
      eventCount -= overflow;
    }
    return new Branch(oldItems.append(newItems), eventCount);
  }
  remapping(from2, to) {
    let maps = new Mapping();
    this.items.forEach((item, i) => {
      let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from2 ? maps.maps.length - item.mirrorOffset : void 0;
      maps.appendMap(item.map, mirrorPos);
    }, from2, to);
    return maps;
  }
  addMaps(array) {
    if (this.eventCount == 0)
      return this;
    return new Branch(this.items.append(array.map((map22) => new Item(map22))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(rebasedTransform, rebasedCount) {
    if (!this.eventCount)
      return this;
    let rebasedItems = [], start2 = Math.max(0, this.items.length - rebasedCount);
    let mapping = rebasedTransform.mapping;
    let newUntil = rebasedTransform.steps.length;
    let eventCount = this.eventCount;
    this.items.forEach((item) => {
      if (item.selection)
        eventCount--;
    }, start2);
    let iRebased = rebasedCount;
    this.items.forEach((item) => {
      let pos = mapping.getMirror(--iRebased);
      if (pos == null)
        return;
      newUntil = Math.min(newUntil, pos);
      let map22 = mapping.maps[pos];
      if (item.step) {
        let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);
        let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));
        if (selection)
          eventCount++;
        rebasedItems.push(new Item(map22, step, selection));
      } else {
        rebasedItems.push(new Item(map22));
      }
    }, start2);
    let newMaps = [];
    for (let i = rebasedCount; i < newUntil; i++)
      newMaps.push(new Item(mapping.maps[i]));
    let items = this.items.slice(0, start2).append(newMaps).append(rebasedItems);
    let branch = new Branch(items, eventCount);
    if (branch.emptyItemCount() > max_empty_items)
      branch = branch.compress(this.items.length - rebasedItems.length);
    return branch;
  }
  emptyItemCount() {
    let count = 0;
    this.items.forEach((item) => {
      if (!item.step)
        count++;
    });
    return count;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(upto = this.items.length) {
    let remap = this.remapping(0, upto), mapFrom = remap.maps.length;
    let items = [], events2 = 0;
    this.items.forEach((item, i) => {
      if (i >= upto) {
        items.push(item);
        if (item.selection)
          events2++;
      } else if (item.step) {
        let step = item.step.map(remap.slice(mapFrom)), map22 = step && step.getMap();
        mapFrom--;
        if (map22)
          remap.appendMap(map22, mapFrom);
        if (step) {
          let selection = item.selection && item.selection.map(remap.slice(mapFrom));
          if (selection)
            events2++;
          let newItem = new Item(map22.invert(), step, selection), merged, last = items.length - 1;
          if (merged = items.length && items[last].merge(newItem))
            items[last] = merged;
          else
            items.push(newItem);
        }
      } else if (item.map) {
        mapFrom--;
      }
    }, this.items.length, 0);
    return new Branch(RopeSequence.from(items.reverse()), events2);
  }
}
Branch.empty = new Branch(RopeSequence.empty, 0);
function cutOffEvents(items, n) {
  let cutPoint;
  items.forEach((item, i) => {
    if (item.selection && n-- == 0) {
      cutPoint = i;
      return false;
    }
  });
  return items.slice(cutPoint);
}
class Item {
  constructor(map22, step, selection, mirrorOffset) {
    this.map = map22;
    this.step = step;
    this.selection = selection;
    this.mirrorOffset = mirrorOffset;
  }
  merge(other) {
    if (this.step && other.step && !other.selection) {
      let step = other.step.merge(this.step);
      if (step)
        return new Item(step.getMap().invert(), step, this.selection);
    }
  }
}
class HistoryState {
  constructor(done, undone, prevRanges, prevTime, prevComposition) {
    this.done = done;
    this.undone = undone;
    this.prevRanges = prevRanges;
    this.prevTime = prevTime;
    this.prevComposition = prevComposition;
  }
}
const DEPTH_OVERFLOW = 20;
function applyTransaction(history2, state2, tr, options) {
  let historyTr = tr.getMeta(historyKey), rebased;
  if (historyTr)
    return historyTr.historyState;
  if (tr.getMeta(closeHistoryKey))
    history2 = new HistoryState(history2.done, history2.undone, null, 0, -1);
  let appended = tr.getMeta("appendedTransaction");
  if (tr.steps.length == 0) {
    return history2;
  } else if (appended && appended.getMeta(historyKey)) {
    if (appended.getMeta(historyKey).redo)
      return new HistoryState(history2.done.addTransform(tr, void 0, options, mustPreserveItems(state2)), history2.undone, rangesFor(tr.mapping.maps), history2.prevTime, history2.prevComposition);
    else
      return new HistoryState(history2.done, history2.undone.addTransform(tr, void 0, options, mustPreserveItems(state2)), null, history2.prevTime, history2.prevComposition);
  } else if (tr.getMeta("addToHistory") !== false && !(appended && appended.getMeta("addToHistory") === false)) {
    let composition = tr.getMeta("composition");
    let newGroup = history2.prevTime == 0 || !appended && history2.prevComposition != composition && (history2.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history2.prevRanges));
    let prevRanges = appended ? mapRanges(history2.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);
    return new HistoryState(history2.done.addTransform(tr, newGroup ? state2.selection.getBookmark() : void 0, options, mustPreserveItems(state2)), Branch.empty, prevRanges, tr.time, composition == null ? history2.prevComposition : composition);
  } else if (rebased = tr.getMeta("rebased")) {
    return new HistoryState(history2.done.rebased(tr, rebased), history2.undone.rebased(tr, rebased), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
  } else {
    return new HistoryState(history2.done.addMaps(tr.mapping.maps), history2.undone.addMaps(tr.mapping.maps), mapRanges(history2.prevRanges, tr.mapping), history2.prevTime, history2.prevComposition);
  }
}
function isAdjacentTo(transform, prevRanges) {
  if (!prevRanges)
    return false;
  if (!transform.docChanged)
    return true;
  let adjacent = false;
  transform.mapping.maps[0].forEach((start2, end2) => {
    for (let i = 0; i < prevRanges.length; i += 2)
      if (start2 <= prevRanges[i + 1] && end2 >= prevRanges[i])
        adjacent = true;
  });
  return adjacent;
}
function rangesFor(maps) {
  let result = [];
  for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)
    maps[i].forEach((_from, _to, from2, to) => result.push(from2, to));
  return result;
}
function mapRanges(ranges, mapping) {
  if (!ranges)
    return null;
  let result = [];
  for (let i = 0; i < ranges.length; i += 2) {
    let from2 = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);
    if (from2 <= to)
      result.push(from2, to);
  }
  return result;
}
function histTransaction(history2, state2, redo2) {
  let preserveItems = mustPreserveItems(state2);
  let histOptions = historyKey.get(state2).spec.config;
  let pop = (redo2 ? history2.undone : history2.done).popEvent(state2, preserveItems);
  if (!pop)
    return null;
  let selection = pop.selection.resolve(pop.transform.doc);
  let added = (redo2 ? history2.done : history2.undone).addTransform(pop.transform, state2.selection.getBookmark(), histOptions, preserveItems);
  let newHist = new HistoryState(redo2 ? added : pop.remaining, redo2 ? pop.remaining : added, null, 0, -1);
  return pop.transform.setSelection(selection).setMeta(historyKey, { redo: redo2, historyState: newHist });
}
let cachedPreserveItems = false, cachedPreserveItemsPlugins = null;
function mustPreserveItems(state2) {
  let plugins = state2.plugins;
  if (cachedPreserveItemsPlugins != plugins) {
    cachedPreserveItems = false;
    cachedPreserveItemsPlugins = plugins;
    for (let i = 0; i < plugins.length; i++)
      if (plugins[i].spec.historyPreserveItems) {
        cachedPreserveItems = true;
        break;
      }
  }
  return cachedPreserveItems;
}
const historyKey = new PluginKey("history");
const closeHistoryKey = new PluginKey("closeHistory");
function history(config = {}) {
  config = {
    depth: config.depth || 100,
    newGroupDelay: config.newGroupDelay || 500
  };
  return new Plugin({
    key: historyKey,
    state: {
      init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);
      },
      apply(tr, hist, state2) {
        return applyTransaction(hist, state2, tr, config);
      }
    },
    config,
    props: {
      handleDOMEvents: {
        beforeinput(view, e) {
          let inputType = e.inputType;
          let command2 = inputType == "historyUndo" ? undo$1 : inputType == "historyRedo" ? redo$1 : null;
          if (!command2)
            return false;
          e.preventDefault();
          return command2(view.state, view.dispatch);
        }
      }
    }
  });
}
function buildCommand(redo2, scroll) {
  return (state2, dispatch) => {
    let hist = historyKey.getState(state2);
    if (!hist || (redo2 ? hist.undone : hist.done).eventCount == 0)
      return false;
    if (dispatch) {
      let tr = histTransaction(hist, state2, redo2);
      if (tr)
        dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
const undo$1 = buildCommand(false);
const redo$1 = buildCommand(true);
function undoDepth(state2) {
  let hist = historyKey.getState(state2);
  return hist ? hist.done.eventCount : 0;
}
function redoDepth(state2) {
  let hist = historyKey.getState(state2);
  return hist ? hist.undone.eventCount : 0;
}
class Extension {
  constructor(config) {
    __publicField$1(this, "type", "extension");
    __publicField$1(this, "name", "extension");
    __publicField$1(this, "options");
    __publicField$1(this, "storage");
    __publicField$1(this, "config", {
      name: this.name
    });
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, "addOptions", {
          name: this.name
        })
      );
    }
    this.storage = callOrGet(
      getExtensionConfigField(this, "addStorage", {
        name: this.name,
        options: this.options
      })
    ) || {};
  }
  /**
   * Static method for creating an extension.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new Extension(...args);
  }
}
const History = Extension.create({
  name: "history",
  addOptions() {
    return {
      /**
       * @typedef {Object} HistoryOptions
       * @category Options
       * @property {number} [depth=100] - Maximum undo/redo steps to remember
       * @property {number} [newGroupDelay=500] - Milliseconds to wait before starting a new history group
       */
      depth: 100,
      newGroupDelay: 500
    };
  },
  addPmPlugins() {
    const historyPlugin = history(this.options);
    return [historyPlugin];
  },
  //prettier-ignore
  addCommands() {
    return {
      /**
       * Undo the last action
       * @category Command
       * @returns {Function} Command function
       * @example
       * undo()
       * @note Groups changes within the newGroupDelay window
       */
      undo: () => ({ state: state2, dispatch, tr }) => {
        tr.setMeta("inputType", "historyUndo");
        return undo$1(state2, dispatch);
      },
      /**
       * Redo the last undone action
       * @category Command
       * @returns {Function} Command function
       * @example
       * redo()
       * @note Only available after an undo action
       */
      redo: () => ({ state: state2, dispatch, tr }) => {
        tr.setMeta("inputType", "historyRedo");
        return redo$1(state2, dispatch);
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-Shift-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo()
    };
  }
});
let Node$1 = class Node22 {
  constructor(config) {
    __publicField$1(this, "type", "node");
    __publicField$1(this, "name", "node");
    __publicField$1(this, "options");
    __publicField$1(this, "storage");
    __publicField$1(this, "config", {
      name: this.name
    });
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, "addOptions", {
          name: this.name
        })
      );
    }
    this.storage = callOrGet(
      getExtensionConfigField(this, "addStorage", {
        name: this.name,
        options: this.options
      })
    ) || {};
  }
  /**
   * Static method for creating Node extension.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new Node22(...args);
  }
};
class Mark2 {
  constructor(config) {
    __publicField$1(this, "type", "mark");
    __publicField$1(this, "name", "mark");
    __publicField$1(this, "options");
    __publicField$1(this, "storage");
    __publicField$1(this, "isExternal");
    __publicField$1(this, "config", {
      name: this.name
    });
    this.config = {
      ...this.config,
      ...config
    };
    this.name = this.config.name;
    this.isExternal = Boolean(this.config.isExternal);
    if (this.config.addOptions) {
      this.options = callOrGet(
        getExtensionConfigField(this, "addOptions", {
          name: this.name
        })
      );
    }
    this.storage = callOrGet(
      getExtensionConfigField(this, "addStorage", {
        name: this.name,
        options: this.options
      })
    ) || {};
  }
  /**
   * Static method for creating Mark extension.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new Mark2(...args);
  }
}
class Attribute2 {
  /**
   * Get a list of all attributes defined in the extensions.
   * @param extensions List of all extensions.
   * @returns Extension attributes.
   */
  static getAttributesFromExtensions(extensions) {
    const extensionAttributes = [];
    const defaultAttribute = {
      default: null,
      rendered: true,
      renderDOM: null,
      parseDOM: null,
      keepOnSplit: true
    };
    const globalAttributes = __privateMethod$1(this, _Attribute_static, getGlobalAttributes_fn).call(this, extensions, defaultAttribute);
    const nodeAndMarksAttributes = __privateMethod$1(this, _Attribute_static, getNodeAndMarksAttributes_fn).call(this, extensions, defaultAttribute);
    extensionAttributes.push(...globalAttributes, ...nodeAndMarksAttributes);
    return extensionAttributes;
  }
  /**
   * Inserts extension attributes into parseRule attributes.
   * @param parseRule PM ParseRule.
   * @param extensionAttrs List of attributes to insert.
   */
  static insertExtensionAttrsToParseRule(parseRule, extensionAttrs) {
    if ("style" in parseRule) {
      return parseRule;
    }
    return {
      ...parseRule,
      getAttrs: (node2) => {
        const oldAttrs = parseRule.getAttrs ? parseRule.getAttrs(node2) : parseRule.attrs;
        if (oldAttrs === false) return false;
        const parseFromString = (value) => {
          if (typeof value !== "string") return value;
          if (value.match(/^[+-]?(\d*\.)?\d+$/)) return Number(value);
          if (value === "true") return true;
          if (value === "false") return false;
          return value;
        };
        let newAttrs = {};
        for (const item of extensionAttrs) {
          const value = item.attribute.parseDOM ? item.attribute.parseDOM(node2) : parseFromString(node2.getAttribute(item.name));
          if (value === null || value === void 0) continue;
          newAttrs = {
            ...newAttrs,
            [item.name]: value
          };
        }
        return { ...oldAttrs, ...newAttrs };
      }
    };
  }
  /**
   * Get attributes to render.
   * @param nodeOrMark Node or Mark.
   * @param extensionAttrs Extension attributes.
   */
  static getAttributesToRender(nodeOrMark, extensionAttrs) {
    const attributes = extensionAttrs.filter((item) => item.attribute.rendered).map((item) => {
      if (!item.attribute.renderDOM) {
        return { [item.name]: nodeOrMark.attrs[item.name] };
      }
      return item.attribute.renderDOM(nodeOrMark.attrs) || {};
    });
    let mergedAttrs = {};
    for (const attribute of attributes) {
      mergedAttrs = this.mergeAttributes(mergedAttrs, attribute);
    }
    return mergedAttrs;
  }
  /**
   * Merges attributes.
   * @param objects Objects with attributes.
   * @returns Object with merged attributes.
   */
  static mergeAttributes(...objects) {
    const items = objects.filter((item) => !!item);
    let attrs = {};
    for (const item of items) {
      const mergedAttributes = { ...attrs };
      for (const [key, value] of Object.entries(item)) {
        const exists2 = mergedAttributes[key];
        if (!exists2) {
          mergedAttributes[key] = value;
          continue;
        }
        if (key === "class") {
          const valueClasses = value ? value.split(" ") : [];
          const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(" ") : [];
          const insertClasses = valueClasses.filter((value2) => !existingClasses.includes(value2));
          mergedAttributes[key] = [...existingClasses, ...insertClasses].join(" ");
        } else if (key === "style") {
          mergedAttributes[key] = [mergedAttributes[key], value].join("; ");
        } else {
          mergedAttributes[key] = value;
        }
      }
      attrs = mergedAttributes;
    }
    return attrs;
  }
  /**
   * Get extension attributes that should be splitted by keepOnSplit flag.
   * @param extensionAttrs Array of attributes.
   * @param typeName The type of the extension.
   * @param attributes The extension attributes.
   * @returns The splitted attributes.
   */
  static getSplittedAttributes(extensionAttrs, typeName, attributes) {
    const entries = Object.entries(attributes).filter(([name]) => {
      const extensionAttr = extensionAttrs.find((item) => {
        return item.type === typeName && item.name === name;
      });
      if (!extensionAttr) return false;
      return extensionAttr.attribute.keepOnSplit;
    });
    return Object.fromEntries(entries);
  }
  /**
   * Get mark attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The mark type or name.
   * @returns The mark attrs.
   */
  static getMarkAttributes(state2, typeOrName) {
    const type2 = getMarkType(typeOrName, state2.schema);
    const marks = getMarksFromSelection(state2);
    const mark = marks.find((markItem) => markItem.type.name === type2.name);
    if (!mark) return {};
    return { ...mark.attrs };
  }
  /**
   * Get node attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The node type or name.
   * @returns The node attrs.
   */
  static getNodeAttributes(state2, typeOrName) {
    const type2 = getNodeType(typeOrName, state2.schema);
    const { from: from2, to } = state2.selection;
    const nodes = [];
    state2.doc.nodesBetween(from2, to, (node22) => {
      nodes.push(node22);
    });
    const node2 = nodes.reverse().find((nodeItem) => nodeItem.type.name === type2.name);
    if (!node2) return {};
    return { ...node2.attrs };
  }
  /**
   * Get node or mark attrs on the current editor state.
   * @param state The current editor state.
   * @param typeOrName The node/mark type or name.
   * @returns The attrs of the node/mark or an empty object.
   */
  static getAttributes(state2, typeOrName) {
    const schemaType = getSchemaTypeNameByName(
      typeof typeOrName === "string" ? typeOrName : typeOrName.name,
      state2.schema
    );
    if (schemaType === "node") {
      return this.getNodeAttributes(state2, typeOrName);
    }
    if (schemaType === "mark") {
      return this.getMarkAttributes(state2, typeOrName);
    }
    return {};
  }
}
_Attribute_static = /* @__PURE__ */ new WeakSet();
getGlobalAttributes_fn = function(extensions, defaultAttribute) {
  const extensionAttributes = [];
  const collectAttribute = (globalAttr) => {
    for (const type2 of globalAttr.types) {
      const entries = Object.entries(globalAttr.attributes);
      for (const [name, attribute] of entries) {
        extensionAttributes.push({
          type: type2,
          name,
          attribute: {
            ...defaultAttribute,
            ...attribute
          }
        });
      }
    }
  };
  for (const extension of extensions) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addGlobalAttributes = getExtensionConfigField(extension, "addGlobalAttributes", context);
    if (!addGlobalAttributes) continue;
    const globalAttributes = addGlobalAttributes();
    for (const globalAttr of globalAttributes) {
      collectAttribute(globalAttr);
    }
  }
  return extensionAttributes;
};
getNodeAndMarksAttributes_fn = function(extensions, defaultAttribute) {
  const extensionAttributes = [];
  const nodeAndMarkExtensions = extensions.filter((e) => {
    return e.type === "node" || e.type === "mark";
  });
  for (const extension of nodeAndMarkExtensions) {
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage
    };
    const addAttributes = getExtensionConfigField(extension, "addAttributes", context);
    if (!addAttributes) continue;
    const attributes = addAttributes();
    for (const [name, attribute] of Object.entries(attributes)) {
      const merged = {
        ...defaultAttribute,
        ...attribute
      };
      if (typeof merged.default === "function") {
        merged.default = merged.default();
      }
      extensionAttributes.push({
        type: extension.name,
        name,
        attribute: merged
      });
    }
  }
  return extensionAttributes;
};
__privateAdd$1(Attribute2, _Attribute_static);
const _Schema = class _Schema2 {
  /**
   * Creates PM schema by resolved extensions.
   * @param extensions List of extensions.
   * @param editor Editor instance.
   * @returns PM schema
   */
  static createSchemaByExtensions(extensions, editor) {
    var _a2, _b;
    const nodeExtensions = extensions.filter((e) => e.type === "node");
    const markExtensions = extensions.filter((e) => e.type === "mark");
    const topNode = nodeExtensions.find((e) => getExtensionConfigField(e, "topNode"))?.name;
    const attributes = Attribute2.getAttributesFromExtensions(extensions);
    const nodes = __privateMethod$1(_a2 = _Schema2, _Schema_static, createNodesSchema_fn).call(_a2, nodeExtensions, attributes, editor);
    const marks = __privateMethod$1(_b = _Schema2, _Schema_static, createMarksSchema_fn).call(_b, markExtensions, attributes, editor);
    return new Schema$1({ topNode, nodes, marks });
  }
};
_Schema_static = /* @__PURE__ */ new WeakSet();
createNodesSchema_fn = function(nodeExtensions, attributes, editor) {
  const nodeEntries = nodeExtensions.map((extension) => {
    const extensionAttributes = attributes.filter((a) => a.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const attrs = Object.fromEntries(
      extensionAttributes.map((attr) => {
        return [attr.name, { default: attr?.attribute?.default }];
      })
    );
    const additionalNodeFields = nodeExtensions.reduce((fields, e) => {
      const extendNodeSchema = getExtensionConfigField(e, "extendNodeSchema", context);
      return {
        ...fields,
        ...extendNodeSchema ? extendNodeSchema(extension) : {}
      };
    }, {});
    const schema = cleanSchemaItem({
      content: callOrGet(getExtensionConfigField(extension, "content", context)),
      group: callOrGet(getExtensionConfigField(extension, "group", context)),
      marks: callOrGet(getExtensionConfigField(extension, "marks", context)),
      inline: callOrGet(getExtensionConfigField(extension, "inline", context)),
      atom: callOrGet(getExtensionConfigField(extension, "atom", context)),
      selectable: callOrGet(getExtensionConfigField(extension, "selectable", context)),
      draggable: callOrGet(getExtensionConfigField(extension, "draggable", context)),
      code: callOrGet(getExtensionConfigField(extension, "code", context)),
      defining: callOrGet(getExtensionConfigField(extension, "defining", context)),
      isolating: callOrGet(getExtensionConfigField(extension, "isolating", context)),
      attrs,
      ...additionalNodeFields
    });
    const parseDOM = callOrGet(getExtensionConfigField(extension, "parseDOM", context));
    if (parseDOM) {
      schema.parseDOM = parseDOM.map((parseRule) => {
        return Attribute2.insertExtensionAttrsToParseRule(parseRule, extensionAttributes);
      });
    }
    const renderDOM = getExtensionConfigField(extension, "renderDOM", context);
    if (renderDOM) {
      schema.toDOM = (node2) => renderDOM({
        node: node2,
        htmlAttributes: Attribute2.getAttributesToRender(node2, extensionAttributes)
      });
    }
    const renderText = getExtensionConfigField(extension, "renderText", context);
    if (renderText) {
      schema.toText = renderText;
    }
    return [extension.name, schema];
  });
  return Object.fromEntries(nodeEntries);
};
createMarksSchema_fn = function(markExtensions, attributes, editor) {
  const markEntries = markExtensions.map((extension) => {
    const extensionAttributes = attributes.filter((a) => a.type === extension.name);
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor
    };
    const attrs = Object.fromEntries(
      extensionAttributes.map((attr) => {
        return [attr.name, { default: attr?.attribute?.default }];
      })
    );
    const schema = cleanSchemaItem({
      group: callOrGet(getExtensionConfigField(extension, "group", context)),
      inclusive: callOrGet(getExtensionConfigField(extension, "inclusive", context)),
      excludes: callOrGet(getExtensionConfigField(extension, "excludes", context)),
      spanning: callOrGet(getExtensionConfigField(extension, "spanning", context)),
      code: callOrGet(getExtensionConfigField(extension, "code", context)),
      attrs
    });
    const parseDOM = callOrGet(getExtensionConfigField(extension, "parseDOM", context));
    if (parseDOM) {
      schema.parseDOM = parseDOM.map((parseRule) => {
        return Attribute2.insertExtensionAttrsToParseRule(parseRule, extensionAttributes);
      });
    }
    const renderDOM = getExtensionConfigField(extension, "renderDOM", context);
    if (renderDOM) {
      schema.toDOM = (mark) => renderDOM({
        mark,
        htmlAttributes: Attribute2.getAttributesToRender(mark, extensionAttributes)
      });
    }
    return [extension.name, schema];
  });
  return Object.fromEntries(markEntries);
};
__privateAdd$1(_Schema, _Schema_static);
let Schema2 = _Schema;
const first = (commands2) => (props) => {
  const items = typeof commands2 === "function" ? commands2(props) : commands2;
  for (let i = 0; i < items.length; i += 1) {
    if (items[i](props)) return true;
  }
  return false;
};
const command = (fn2) => (props) => fn2(props);
const insertTabChar = () => ({ tr }) => {
  tr.insertText("	", tr.selection.from, tr.selection.to);
  return true;
};
const insertTabCharacter = ({ tr, state: state2, dispatch }) => {
  const { from: from2 } = tr.selection;
  const tabText = state2.schema.text("	");
  tr = tr.replaceSelectionWith(tabText);
  tr = tr.setSelection(TextSelection$1.create(tr.doc, from2 + 1));
  if (dispatch) dispatch(tr);
  return true;
};
const insertTabNode = () => ({ tr, state: state2, dispatch }) => {
  const newPos = tr.selection.from;
  const tabNode = state2.schema?.nodes?.tab?.create();
  if (!tabNode) return insertTabCharacter({ tr, state: state2, dispatch });
  tr.insert(newPos, tabNode);
  if (dispatch) dispatch(tr);
  return true;
};
const setMeta$1 = (key, value) => ({ tr }) => {
  tr.setMeta(key, value);
  return true;
};
const ensureMarks = (state2, splittableMarks) => {
  const marks = state2.storedMarks || state2.selection.$to.parentOffset && state2.selection.$from.marks();
  if (marks) {
    const filtered = marks.filter((m2) => splittableMarks?.includes(m2.type.name));
    state2.tr.ensureMarks(filtered);
  }
};
const splitBlock$1 = ({ keepMarks = true } = {}) => (props) => {
  const { tr, state: state2, dispatch, editor } = props;
  const { selection, doc: doc2 } = tr;
  const { $from, $to } = selection;
  const extensionAttrs = editor.extensionService.attributes;
  const newAttrs = Attribute2.getSplittedAttributes(extensionAttrs, $from.node().type.name, $from.node().attrs);
  if (selection instanceof NodeSelection && selection.node.isBlock) {
    if (!$from.parentOffset || !canSplit(doc2, $from.pos)) return false;
    if (dispatch) {
      if (keepMarks) ensureMarks(state2, editor.extensionService.splittableMarks);
      tr.split($from.pos).scrollIntoView();
    }
    return true;
  }
  if (!$from.parent.isBlock) return false;
  if (dispatch) {
    const atEnd = $to.parentOffset === $to.parent.content.size;
    if (selection instanceof TextSelection$1) tr.deleteSelection();
    const deflt = $from.depth === 0 ? null : defaultBlockAt$1($from.node(-1).contentMatchAt($from.indexAfter(-1)));
    let types2 = atEnd && deflt ? [{ type: deflt, attrs: newAttrs }] : void 0;
    let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types2);
    if (!types2 && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : void 0)) {
      can = true;
      types2 = deflt ? [{ type: deflt, attrs: newAttrs }] : void 0;
    }
    if (can) {
      tr.split(tr.mapping.map($from.pos), 1, types2);
      if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {
        const first2 = tr.mapping.map($from.before());
        const $first = tr.doc.resolve(first2);
        if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {
          tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);
        }
      }
    }
    if (keepMarks) ensureMarks(state2, editor.extensionService.splittableMarks);
    tr.scrollIntoView();
  }
  return true;
};
const deleteSelection$1 = (state2, dispatch) => {
  if (state2.selection.empty)
    return false;
  if (dispatch)
    dispatch(state2.tr.deleteSelection().scrollIntoView());
  return true;
};
function atBlockStart(state2, view) {
  let { $cursor } = state2.selection;
  if (!$cursor || (view ? !view.endOfTextblock("backward", state2) : $cursor.parentOffset > 0))
    return null;
  return $cursor;
}
const joinBackward$1 = (state2, dispatch, view) => {
  let $cursor = atBlockStart(state2, view);
  if (!$cursor)
    return false;
  let $cut = findCutBefore($cursor);
  if (!$cut) {
    let range2 = $cursor.blockRange(), target = range2 && liftTarget(range2);
    if (target == null)
      return false;
    if (dispatch)
      dispatch(state2.tr.lift(range2, target).scrollIntoView());
    return true;
  }
  let before = $cut.nodeBefore;
  if (deleteBarrier(state2, $cut, dispatch, -1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(before, "end") || NodeSelection.isSelectable(before))) {
    for (let depth = $cursor.depth; ; depth--) {
      let delStep = replaceStep$1(state2.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);
      if (delStep && delStep.slice.size < delStep.to - delStep.from) {
        if (dispatch) {
          let tr = state2.tr.step(delStep);
          tr.setSelection(textblockAt(before, "end") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1) : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));
          dispatch(tr.scrollIntoView());
        }
        return true;
      }
      if (depth == 1 || $cursor.node(depth - 1).childCount > 1)
        break;
    }
  }
  if (before.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state2.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());
    return true;
  }
  return false;
};
function textblockAt(node2, side, only = false) {
  for (let scan = node2; scan; scan = side == "start" ? scan.firstChild : scan.lastChild) {
    if (scan.isTextblock)
      return true;
    if (only && scan.childCount != 1)
      return false;
  }
  return false;
}
const selectNodeBackward$1 = (state2, dispatch, view) => {
  let { $head, empty: empty2 } = state2.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("backward", state2) : $head.parentOffset > 0)
      return false;
    $cut = findCutBefore($head);
  }
  let node2 = $cut && $cut.nodeBefore;
  if (!node2 || !NodeSelection.isSelectable(node2))
    return false;
  if (dispatch)
    dispatch(state2.tr.setSelection(NodeSelection.create(state2.doc, $cut.pos - node2.nodeSize)).scrollIntoView());
  return true;
};
function findCutBefore($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      if ($pos.index(i) > 0)
        return $pos.doc.resolve($pos.before(i + 1));
      if ($pos.node(i).type.spec.isolating)
        break;
    }
  return null;
}
function atBlockEnd(state2, view) {
  let { $cursor } = state2.selection;
  if (!$cursor || (view ? !view.endOfTextblock("forward", state2) : $cursor.parentOffset < $cursor.parent.content.size))
    return null;
  return $cursor;
}
const joinForward$1 = (state2, dispatch, view) => {
  let $cursor = atBlockEnd(state2, view);
  if (!$cursor)
    return false;
  let $cut = findCutAfter($cursor);
  if (!$cut)
    return false;
  let after = $cut.nodeAfter;
  if (deleteBarrier(state2, $cut, dispatch, 1))
    return true;
  if ($cursor.parent.content.size == 0 && (textblockAt(after, "start") || NodeSelection.isSelectable(after))) {
    let delStep = replaceStep$1(state2.doc, $cursor.before(), $cursor.after(), Slice.empty);
    if (delStep && delStep.slice.size < delStep.to - delStep.from) {
      if (dispatch) {
        let tr = state2.tr.step(delStep);
        tr.setSelection(textblockAt(after, "start") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1) : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  if (after.isAtom && $cut.depth == $cursor.depth - 1) {
    if (dispatch)
      dispatch(state2.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());
    return true;
  }
  return false;
};
const selectNodeForward$1 = (state2, dispatch, view) => {
  let { $head, empty: empty2 } = state2.selection, $cut = $head;
  if (!empty2)
    return false;
  if ($head.parent.isTextblock) {
    if (view ? !view.endOfTextblock("forward", state2) : $head.parentOffset < $head.parent.content.size)
      return false;
    $cut = findCutAfter($head);
  }
  let node2 = $cut && $cut.nodeAfter;
  if (!node2 || !NodeSelection.isSelectable(node2))
    return false;
  if (dispatch)
    dispatch(state2.tr.setSelection(NodeSelection.create(state2.doc, $cut.pos)).scrollIntoView());
  return true;
};
function findCutAfter($pos) {
  if (!$pos.parent.type.spec.isolating)
    for (let i = $pos.depth - 1; i >= 0; i--) {
      let parent = $pos.node(i);
      if ($pos.index(i) + 1 < parent.childCount)
        return $pos.doc.resolve($pos.after(i + 1));
      if (parent.type.spec.isolating)
        break;
    }
  return null;
}
const joinUp$1 = (state2, dispatch) => {
  let sel = state2.selection, nodeSel = sel instanceof NodeSelection, point;
  if (nodeSel) {
    if (sel.node.isTextblock || !canJoin(state2.doc, sel.from))
      return false;
    point = sel.from;
  } else {
    point = joinPoint(state2.doc, sel.from, -1);
    if (point == null)
      return false;
  }
  if (dispatch) {
    let tr = state2.tr.join(point);
    if (nodeSel)
      tr.setSelection(NodeSelection.create(tr.doc, point - state2.doc.resolve(point).nodeBefore.nodeSize));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const joinDown$1 = (state2, dispatch) => {
  let sel = state2.selection, point;
  if (sel instanceof NodeSelection) {
    if (sel.node.isTextblock || !canJoin(state2.doc, sel.to))
      return false;
    point = sel.to;
  } else {
    point = joinPoint(state2.doc, sel.to, 1);
    if (point == null)
      return false;
  }
  if (dispatch)
    dispatch(state2.tr.join(point).scrollIntoView());
  return true;
};
const newlineInCode$1 = (state2, dispatch) => {
  let { $head, $anchor } = state2.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  if (dispatch)
    dispatch(state2.tr.insertText("\n").scrollIntoView());
  return true;
};
function defaultBlockAt(match) {
  for (let i = 0; i < match.edgeCount; i++) {
    let { type: type2 } = match.edge(i);
    if (type2.isTextblock && !type2.hasRequiredAttrs())
      return type2;
  }
  return null;
}
const exitCode$1 = (state2, dispatch) => {
  let { $head, $anchor } = state2.selection;
  if (!$head.parent.type.spec.code || !$head.sameParent($anchor))
    return false;
  let above = $head.node(-1), after = $head.indexAfter(-1), type2 = defaultBlockAt(above.contentMatchAt(after));
  if (!type2 || !above.canReplaceWith(after, after, type2))
    return false;
  if (dispatch) {
    let pos = $head.after(), tr = state2.tr.replaceWith(pos, pos, type2.createAndFill());
    tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const createParagraphNear$1 = (state2, dispatch) => {
  let sel = state2.selection, { $from, $to } = sel;
  if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)
    return false;
  let type2 = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));
  if (!type2 || !type2.isTextblock)
    return false;
  if (dispatch) {
    let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;
    let tr = state2.tr.insert(side, type2.createAndFill());
    tr.setSelection(TextSelection$1.create(tr.doc, side + 1));
    dispatch(tr.scrollIntoView());
  }
  return true;
};
const liftEmptyBlock$1 = (state2, dispatch) => {
  let { $cursor } = state2.selection;
  if (!$cursor || $cursor.parent.content.size)
    return false;
  if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {
    let before = $cursor.before();
    if (canSplit(state2.doc, before)) {
      if (dispatch)
        dispatch(state2.tr.split(before).scrollIntoView());
      return true;
    }
  }
  let range2 = $cursor.blockRange(), target = range2 && liftTarget(range2);
  if (target == null)
    return false;
  if (dispatch)
    dispatch(state2.tr.lift(range2, target).scrollIntoView());
  return true;
};
function splitBlockAs(splitNode) {
  return (state2, dispatch) => {
    let { $from, $to } = state2.selection;
    if (state2.selection instanceof NodeSelection && state2.selection.node.isBlock) {
      if (!$from.parentOffset || !canSplit(state2.doc, $from.pos))
        return false;
      if (dispatch)
        dispatch(state2.tr.split($from.pos).scrollIntoView());
      return true;
    }
    if (!$from.depth)
      return false;
    let types2 = [];
    let splitDepth, deflt, atEnd = false, atStart = false;
    for (let d2 = $from.depth; ; d2--) {
      let node2 = $from.node(d2);
      if (node2.isBlock) {
        atEnd = $from.end(d2) == $from.pos + ($from.depth - d2);
        atStart = $from.start(d2) == $from.pos - ($from.depth - d2);
        deflt = defaultBlockAt($from.node(d2 - 1).contentMatchAt($from.indexAfter(d2 - 1)));
        types2.unshift(atEnd && deflt ? { type: deflt } : null);
        splitDepth = d2;
        break;
      } else {
        if (d2 == 1)
          return false;
        types2.unshift(null);
      }
    }
    let tr = state2.tr;
    if (state2.selection instanceof TextSelection$1 || state2.selection instanceof AllSelection)
      tr.deleteSelection();
    let splitPos = tr.mapping.map($from.pos);
    let can = canSplit(tr.doc, splitPos, types2.length, types2);
    if (!can) {
      types2[0] = deflt ? { type: deflt } : null;
      can = canSplit(tr.doc, splitPos, types2.length, types2);
    }
    if (!can)
      return false;
    tr.split(splitPos, types2.length, types2);
    if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {
      let first2 = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first2);
      if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))
        tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);
    }
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
const splitBlock = splitBlockAs();
const selectAll$1 = (state2, dispatch) => {
  if (dispatch)
    dispatch(state2.tr.setSelection(new AllSelection(state2.doc)));
  return true;
};
function joinMaybeClear(state2, $pos, dispatch) {
  let before = $pos.nodeBefore, after = $pos.nodeAfter, index2 = $pos.index();
  if (!before || !after || !before.type.compatibleContent(after.type))
    return false;
  if (!before.content.size && $pos.parent.canReplace(index2 - 1, index2)) {
    if (dispatch)
      dispatch(state2.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());
    return true;
  }
  if (!$pos.parent.canReplace(index2, index2 + 1) || !(after.isTextblock || canJoin(state2.doc, $pos.pos)))
    return false;
  if (dispatch)
    dispatch(state2.tr.join($pos.pos).scrollIntoView());
  return true;
}
function deleteBarrier(state2, $cut, dispatch, dir) {
  let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;
  let isolated = before.type.spec.isolating || after.type.spec.isolating;
  if (!isolated && joinMaybeClear(state2, $cut, dispatch))
    return true;
  let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);
  if (canDelAfter && (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) && match.matchType(conn[0] || after.type).validEnd) {
    if (dispatch) {
      let end2 = $cut.pos + after.nodeSize, wrap2 = Fragment.empty;
      for (let i = conn.length - 1; i >= 0; i--)
        wrap2 = Fragment.from(conn[i].create(null, wrap2));
      wrap2 = Fragment.from(before.copy(wrap2));
      let tr = state2.tr.step(new ReplaceAroundStep$1($cut.pos - 1, end2, $cut.pos, end2, new Slice(wrap2, 1, 0), conn.length, true));
      let $joinAt = tr.doc.resolve(end2 + 2 * conn.length);
      if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type && canJoin(tr.doc, $joinAt.pos))
        tr.join($joinAt.pos);
      dispatch(tr.scrollIntoView());
    }
    return true;
  }
  let selAfter = after.type.spec.isolating || dir > 0 && isolated ? null : Selection.findFrom($cut, 1);
  let range2 = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range2 && liftTarget(range2);
  if (target != null && target >= $cut.depth) {
    if (dispatch)
      dispatch(state2.tr.lift(range2, target).scrollIntoView());
    return true;
  }
  if (canDelAfter && textblockAt(after, "start", true) && textblockAt(before, "end")) {
    let at = before, wrap2 = [];
    for (; ; ) {
      wrap2.push(at);
      if (at.isTextblock)
        break;
      at = at.lastChild;
    }
    let afterText = after, afterDepth = 1;
    for (; !afterText.isTextblock; afterText = afterText.firstChild)
      afterDepth++;
    if (at.canReplace(at.childCount, at.childCount, afterText.content)) {
      if (dispatch) {
        let end2 = Fragment.empty;
        for (let i = wrap2.length - 1; i >= 0; i--)
          end2 = Fragment.from(wrap2[i].copy(end2));
        let tr = state2.tr.step(new ReplaceAroundStep$1($cut.pos - wrap2.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end2, wrap2.length, 0), 0, true));
        dispatch(tr.scrollIntoView());
      }
      return true;
    }
  }
  return false;
}
function selectTextblockSide(side) {
  return function(state2, dispatch) {
    let sel = state2.selection, $pos = side < 0 ? sel.$from : sel.$to;
    let depth = $pos.depth;
    while ($pos.node(depth).isInline) {
      if (!depth)
        return false;
      depth--;
    }
    if (!$pos.node(depth).isTextblock)
      return false;
    if (dispatch)
      dispatch(state2.tr.setSelection(TextSelection$1.create(state2.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));
    return true;
  };
}
const selectTextblockStart$1 = selectTextblockSide(-1);
const selectTextblockEnd$1 = selectTextblockSide(1);
function setBlockType(nodeType, attrs = null) {
  return function(state2, dispatch) {
    let applicable = false;
    for (let i = 0; i < state2.selection.ranges.length && !applicable; i++) {
      let { $from: { pos: from2 }, $to: { pos: to } } = state2.selection.ranges[i];
      state2.doc.nodesBetween(from2, to, (node2, pos) => {
        if (applicable)
          return false;
        if (!node2.isTextblock || node2.hasMarkup(nodeType, attrs))
          return;
        if (node2.type == nodeType) {
          applicable = true;
        } else {
          let $pos = state2.doc.resolve(pos), index2 = $pos.index();
          applicable = $pos.parent.canReplaceWith(index2, index2 + 1, nodeType);
        }
      });
    }
    if (!applicable)
      return false;
    if (dispatch) {
      let tr = state2.tr;
      for (let i = 0; i < state2.selection.ranges.length; i++) {
        let { $from: { pos: from2 }, $to: { pos: to } } = state2.selection.ranges[i];
        tr.setBlockType(from2, to, nodeType, attrs);
      }
      dispatch(tr.scrollIntoView());
    }
    return true;
  };
}
function chainCommands(...commands2) {
  return function(state2, dispatch, view) {
    for (let i = 0; i < commands2.length; i++)
      if (commands2[i](state2, dispatch, view))
        return true;
    return false;
  };
}
chainCommands(deleteSelection$1, joinBackward$1, selectNodeBackward$1);
chainCommands(deleteSelection$1, joinForward$1, selectNodeForward$1);
({
  "Enter": chainCommands(newlineInCode$1, createParagraphNear$1, liftEmptyBlock$1, splitBlock)
});
typeof navigator != "undefined" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os != "undefined" && os.platform ? os.platform() == "darwin" : false;
const liftEmptyBlock = () => ({ state: state2, dispatch }) => liftEmptyBlock$1(state2, dispatch);
const createParagraphNear = () => ({ state: state2, dispatch }) => {
  return createParagraphNear$1(state2, dispatch);
};
const newlineInCode = () => ({ state: state2, dispatch }) => newlineInCode$1(state2, dispatch);
const exitCode = () => ({ state: state2, dispatch }) => {
  return exitCode$1(state2, dispatch);
};
function canSetMark(editor, state2, tr, newMarkType) {
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  let cursor = null;
  if (isTextSelection()) {
    cursor = selection.$cursor;
  }
  if (cursor) {
    const currentMarks = state2.storedMarks ?? cursor.marks();
    return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark) => mark.type.excludes(newMarkType));
  }
  return selection.ranges.some(({ $from, $to }) => {
    let someNodeSupportsMark = $from.depth === 0 ? state2.doc.inlineContent && state2.doc.type.allowsMarkType(newMarkType) : false;
    state2.doc.nodesBetween($from.pos, $to.pos, (node2, _pos, parent) => {
      if (someNodeSupportsMark) return false;
      if (node2.isInline) {
        const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);
        const currentMarksAllowMarkType = !!newMarkType.isInSet(node2.marks) || !node2.marks.some((otherMark) => otherMark.type.excludes(newMarkType));
        someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;
      }
      return !someNodeSupportsMark;
    });
    return someNodeSupportsMark;
  });
}
const setMark = (typeOrName, attributes = {}) => ({ tr, state: state2, dispatch, editor }) => {
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  const { empty: empty2, ranges } = selection;
  const type2 = getMarkType(typeOrName, state2.schema);
  if (dispatch) {
    if (empty2) {
      const oldAttributes = Attribute2.getMarkAttributes(state2, type2);
      tr.addStoredMark(
        type2.create({
          ...oldAttributes,
          ...attributes
        })
      );
    } else {
      ranges.forEach((range2) => {
        const from2 = range2.$from.pos;
        const to = range2.$to.pos;
        state2.doc.nodesBetween(from2, to, (node2, pos) => {
          const trimmedFrom = Math.max(pos, from2);
          const trimmedTo = Math.min(pos + node2.nodeSize, to);
          const someHasMark = node2.marks.find((mark) => mark.type === type2);
          if (someHasMark) {
            node2.marks.forEach((mark) => {
              if (type2 === mark.type) {
                tr.addMark(
                  trimmedFrom,
                  trimmedTo,
                  type2.create({
                    ...mark.attrs,
                    ...attributes
                  })
                );
              }
            });
          } else {
            tr.addMark(trimmedFrom, trimmedTo, type2.create(attributes));
          }
        });
      });
    }
  }
  return canSetMark(editor, state2, tr, type2);
};
const unsetMark = (typeOrName, options = {}) => ({ tr, state: state2, dispatch, editor }) => {
  const { extendEmptyMarkRange = false } = options;
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  const type2 = getMarkType(typeOrName, state2.schema);
  const { $from, empty: empty2, ranges } = selection;
  if (!dispatch) return true;
  if (empty2 && extendEmptyMarkRange) {
    let { from: from2, to } = selection;
    const attrs = $from.marks().find((mark) => mark.type === type2)?.attrs;
    const range2 = getMarkRange($from, type2, attrs);
    if (range2) {
      from2 = range2.from;
      to = range2.to;
    }
    tr.removeMark(from2, to, type2);
  } else {
    ranges.forEach((range2) => {
      tr.removeMark(range2.$from.pos, range2.$to.pos, type2);
    });
  }
  tr.removeStoredMark(type2);
  return true;
};
const unsetAllMarks = () => ({ tr, dispatch, editor }) => {
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  const { empty: empty2, ranges } = selection;
  if (empty2) return true;
  if (dispatch) {
    ranges.forEach((range2) => {
      tr.removeMark(range2.$from.pos, range2.$to.pos);
    });
  }
  return true;
};
const toggleMark = (typeOrName, attrs = {}, options = {}) => ({ state: state2, commands: commands2 }) => {
  const { extendEmptyMarkRange = false } = options;
  const type2 = getMarkType(typeOrName, state2.schema);
  const isActive2 = isMarkActive(state2, type2, attrs);
  if (isActive2) return commands2.unsetMark(type2, { extendEmptyMarkRange });
  return commands2.setMark(type2, attrs);
};
const clearNodes = () => ({ state: state2, tr, dispatch }) => {
  const { selection } = tr;
  const { ranges } = selection;
  if (!dispatch) return true;
  ranges.forEach(({ $from, $to }) => {
    state2.doc.nodesBetween($from.pos, $to.pos, (node2, pos) => {
      if (node2.type.isText) return;
      const { doc: doc2, mapping } = tr;
      const $mappedFrom = doc2.resolve(mapping.map(pos));
      const $mappedTo = doc2.resolve(mapping.map(pos + node2.nodeSize));
      const nodeRange = $mappedFrom.blockRange($mappedTo);
      if (!nodeRange) return;
      const targetLiftDepth = liftTarget(nodeRange);
      if (node2.type.isTextblock) {
        const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());
        tr.setNodeMarkup(nodeRange.start, defaultType);
      }
      if (targetLiftDepth || targetLiftDepth === 0) {
        tr.lift(nodeRange, targetLiftDepth);
      }
    });
  });
  return true;
};
const setNode = (typeOrName, attrs = {}) => ({ state: state2, dispatch, chain }) => {
  const type2 = getNodeType(typeOrName, state2.schema);
  if (!type2.isTextblock) return false;
  return chain().command(({ commands: commands2 }) => {
    const canSetBlock = setBlockType(type2, attrs)(state2);
    if (canSetBlock) return true;
    return commands2.clearNodes();
  }).command(({ state: updatedState }) => {
    return setBlockType(type2, attrs)(updatedState, dispatch);
  }).run();
};
const toggleNode = (typeOrName, toggleTypeOrName, attrs = {}) => ({ state: state2, commands: commands2 }) => {
  const type2 = getNodeType(typeOrName, state2.schema);
  const toggleType = getNodeType(toggleTypeOrName, state2.schema);
  const isActive2 = isNodeActive(state2, type2, attrs);
  if (isActive2) return commands2.setNode(toggleType);
  return commands2.setNode(type2, attrs);
};
const selectAll = () => ({ state: state2, dispatch }) => selectAll$1(state2, dispatch);
const deleteSelection = () => ({ state: state2, tr, dispatch }) => {
  const { from: from2, to, empty: empty2 } = state2.selection;
  if (empty2) {
    return deleteSelection$1(state2, dispatch);
  }
  let hasListContent = false;
  state2.doc.nodesBetween(from2, to, (node2) => {
    if (node2.type.name === "orderedList" || node2.type.name === "bulletList" || node2.type.name === "listItem") {
      hasListContent = true;
      return false;
    }
  });
  if (hasListContent) {
    const transaction = tr || state2.tr;
    transaction.deleteRange(from2, to);
    if (dispatch) {
      dispatch(transaction);
    }
    return true;
  }
  return deleteSelection$1(state2, dispatch);
};
const findNodePosition = (doc2, targetNode) => {
  let nodePos = null;
  doc2.descendants((node2, pos) => {
    if (node2 === targetNode) {
      nodePos = pos;
      return false;
    }
  });
  return nodePos;
};
const isList = (n) => n.type.name === "orderedList" || n.type.name === "bulletList";
const handleBackspaceNextToList = () => ({ state: state2, dispatch }) => {
  const { selection, doc: doc2 } = state2;
  const { $from } = selection;
  if (!selection.empty) return false;
  if ($from.parent.type.name !== "paragraph") return false;
  if ($from.parentOffset !== 0) return false;
  const parentDepth = $from.depth - 1;
  if (parentDepth < 0) return false;
  const container = $from.node(parentDepth);
  const idx = $from.index(parentDepth);
  if (idx === 0) return false;
  const beforeNode = container.child(idx - 1);
  if (!beforeNode || !isList(beforeNode)) return false;
  const listItem = beforeNode.lastChild;
  if (!listItem || listItem.type.name !== "listItem") return false;
  const targetPara = listItem.lastChild;
  if (!targetPara || targetPara.type.name !== "paragraph") return false;
  const paraStartPos = findNodePosition(doc2, targetPara);
  if (paraStartPos == null) return false;
  const inlineContent = Fragment.from($from.parent.content);
  const tr = state2.tr;
  tr.setMeta("updateListSync", true);
  const oldParaPos = $from.before();
  tr.delete(oldParaPos, oldParaPos + $from.parent.nodeSize);
  const insertPos = paraStartPos + 1 + targetPara.content.size;
  tr.insert(insertPos, inlineContent);
  tr.setSelection(TextSelection$1.near(tr.doc.resolve(insertPos), 1));
  dispatch(tr);
  return true;
};
const handleDeleteNextToList = () => ({ state: state2, dispatch }) => {
  const { selection, doc: doc2 } = state2;
  const { $from } = selection;
  if (!selection.empty) return false;
  if ($from.parent.type.name !== "paragraph") return false;
  if ($from.parentOffset !== $from.parent.content.size) return false;
  let currentDepth = $from.depth;
  let listItemDepth = -1;
  while (currentDepth > 0) {
    const node2 = $from.node(currentDepth - 1);
    if (node2.type.name === "listItem") {
      listItemDepth = currentDepth - 1;
      break;
    }
    currentDepth--;
  }
  if (listItemDepth !== -1) {
    const listDepth = listItemDepth - 1;
    const list = $from.node(listDepth);
    const listItemIdx = $from.index(listDepth);
    const listContainer = $from.node(listDepth - 1);
    const listIdx = $from.index(listDepth - 1);
    if (listItemIdx < list.childCount - 1) {
      return true;
    }
    if (listIdx >= listContainer.childCount - 1) return false;
    const nextNode = listContainer.child(listIdx + 1);
    if (!isList(nextNode)) return false;
    const nextListItem = nextNode.firstChild;
    if (!nextListItem || nextListItem.type.name !== "listItem") return false;
    const nextPara = nextListItem.firstChild;
    if (!nextPara || nextPara.type.name !== "paragraph") return false;
    const nextListStartPos = findNodePosition(doc2, nextNode);
    if (nextListStartPos == null) return false;
    const targetInlineContent = Fragment.from(nextPara.content);
    const tr = state2.tr;
    tr.setMeta("updateListSync", true);
    tr.delete(nextListStartPos, nextListStartPos + nextNode.nodeSize);
    const insertPos = tr.mapping.map($from.pos);
    tr.insert(insertPos, targetInlineContent);
    tr.setSelection(TextSelection$1.near(tr.doc.resolve(insertPos), 1));
    dispatch(tr);
    return true;
  } else {
    const parentDepth = $from.depth - 1;
    if (parentDepth < 0) return false;
    const container = $from.node(parentDepth);
    const idx = $from.index(parentDepth);
    if (idx >= container.childCount - 1) return false;
    const afterNode = container.child(idx + 1);
    if (!afterNode || !isList(afterNode)) return false;
    const listItem = afterNode.firstChild;
    if (!listItem || listItem.type.name !== "listItem") return false;
    const targetPara = listItem.firstChild;
    if (!targetPara || targetPara.type.name !== "paragraph") return false;
    const listStartPos = findNodePosition(doc2, afterNode);
    if (listStartPos == null) return false;
    const targetInlineContent = Fragment.from(targetPara.content);
    const tr = state2.tr;
    tr.setMeta("updateListSync", true);
    tr.delete(listStartPos, listStartPos + afterNode.nodeSize);
    const insertPos = tr.mapping.map($from.pos);
    tr.insert(insertPos, targetInlineContent);
    tr.setSelection(TextSelection$1.near(tr.doc.resolve(insertPos), 1));
    dispatch(tr);
    return true;
  }
};
const updateAttributes = (typeOrName, attrs = {}) => ({ tr, state: state2, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state2.schema
  );
  if (!schemaType) return false;
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state2.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state2.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range2) => {
      const from2 = range2.$from.pos;
      const to = range2.$to.pos;
      state2.doc.nodesBetween(from2, to, (node2, pos) => {
        if (nodeType && nodeType === node2.type) {
          tr.setNodeMarkup(pos, void 0, { ...node2.attrs, ...attrs });
        }
        if (markType && node2.marks.length) {
          node2.marks.forEach((mark) => {
            if (markType === mark.type) {
              const trimmedFrom = Math.max(pos, from2);
              const trimmedTo = Math.min(pos + node2.nodeSize, to);
              tr.addMark(trimmedFrom, trimmedTo, markType.create({ ...mark.attrs, ...attrs }));
            }
          });
        }
      });
    });
  }
  return true;
};
const resetAttributes = (typeOrName, attrs) => ({ tr, state: state2, dispatch }) => {
  let nodeType = null;
  let markType = null;
  const schemaType = getSchemaTypeNameByName(
    typeof typeOrName === "string" ? typeOrName : typeOrName.name,
    state2.schema
  );
  if (!schemaType) return false;
  if (schemaType === "node") {
    nodeType = getNodeType(typeOrName, state2.schema);
  }
  if (schemaType === "mark") {
    markType = getMarkType(typeOrName, state2.schema);
  }
  if (dispatch) {
    tr.selection.ranges.forEach((range2) => {
      state2.doc.nodesBetween(range2.$from.pos, range2.$to.pos, (node2, pos) => {
        if (nodeType && nodeType === node2.type) {
          tr.setNodeMarkup(pos, void 0, deleteProps(node2.attrs, attrs));
        }
        if (markType && node2.marks.length) {
          node2.marks.forEach((mark) => {
            if (markType === mark.type) {
              tr.addMark(pos, pos + node2.nodeSize, markType.create(deleteProps(mark.attrs, attrs)));
            }
          });
        }
      });
    });
  }
  return true;
};
const joinUp = () => ({ state: state2, dispatch }) => joinUp$1(state2, dispatch);
const joinDown = () => ({ state: state2, dispatch }) => joinDown$1(state2, dispatch);
const joinBackward = () => ({ state: state2, dispatch }) => {
  const { selection, doc: doc2 } = state2;
  const { $from } = selection;
  if (!$from.parent.isTextblock || $from.parentOffset > 0) {
    return joinBackward$1(state2, dispatch);
  }
  const beforePos = $from.before();
  const nodeBefore = doc2.resolve(beforePos).nodeBefore;
  const nodeAfter = doc2.resolve(beforePos).nodeAfter;
  const isList2 = (node2) => node2?.type.name === "orderedList" || node2?.type.name === "bulletList";
  if (isList2(nodeBefore) || isList2(nodeAfter)) {
    return false;
  }
  return joinBackward$1(state2, dispatch);
};
const joinForward = () => ({ state: state2, dispatch }) => {
  const { selection, doc: doc2 } = state2;
  const { $from } = selection;
  if (!$from.parent.isTextblock || $from.parentOffset > 0) {
    return joinForward$1(state2, dispatch);
  }
  const beforePos = $from.before();
  const nodeBefore = doc2.resolve(beforePos).nodeBefore;
  const nodeAfter = doc2.resolve(beforePos).nodeAfter;
  const isList2 = (node2) => node2?.type.name === "orderedList" || node2?.type.name === "bulletList";
  if (isList2(nodeBefore) || isList2(nodeAfter)) {
    return false;
  }
  return joinForward$1(state2, dispatch);
};
const selectNodeBackward = () => ({ state: state2, dispatch }) => {
  return selectNodeBackward$1(state2, dispatch);
};
const selectNodeForward = () => ({ state: state2, dispatch }) => selectNodeForward$1(state2, dispatch);
const selectTextblockStart = () => ({ state: state2, dispatch }) => selectTextblockStart$1(state2, dispatch);
const selectTextblockEnd = () => ({ state: state2, dispatch }) => selectTextblockEnd$1(state2, dispatch);
const insertContent = (value, options) => ({ tr, commands: commands2 }) => {
  return commands2.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);
};
const removeWhitespaces = (node2) => {
  const children = node2.childNodes;
  for (let i = children.length - 1; i >= 0; i -= 1) {
    const child = children[i];
    if (child.nodeType === 3 && child.nodeValue && /^(\n\s\s|\n)$/.test(child.nodeValue)) {
      node2.removeChild(child);
    } else if (child.nodeType === 1) {
      removeWhitespaces(child);
    }
  }
  return node2;
};
function elementFromString(value) {
  const wrappedValue = `<body>${value}</body>`;
  const html = new window.DOMParser().parseFromString(wrappedValue, "text/html").body;
  return removeWhitespaces(html);
}
function createNodeFromContent(content, schema, options) {
  options = {
    slice: true,
    parseOptions: {},
    ...options
  };
  const isJSONContent = typeof content === "object" && content !== null;
  const isTextContent = typeof content === "string";
  if (isJSONContent) {
    try {
      const isArrayContent = Array.isArray(content) && content.length > 0;
      if (isArrayContent) {
        return Fragment.fromArray(content.map((item) => schema.nodeFromJSON(item)));
      }
      const node2 = schema.nodeFromJSON(content);
      if (options.errorOnInvalidContent) {
        node2.check();
      }
      return node2;
    } catch (error) {
      if (options.errorOnInvalidContent) {
        throw new Error("[super-editor error]: Invalid JSON content", { cause: error });
      }
      console.warn("[super-editor warn]: Invalid content.", "Passed value:", content, "Error:", error);
      return createNodeFromContent("", schema, options);
    }
  }
  if (isTextContent) {
    if (options.errorOnInvalidContent) {
      let hasInvalidContent = false;
      let invalidContent = "";
      const contentCheckSchema = new Schema$1({
        topNode: schema.spec.topNode,
        marks: schema.spec.marks,
        // Prosemirror's schemas are executed such that: the last to execute, matches last
        // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle
        nodes: schema.spec.nodes.append({
          __supereditor__private__unknown__catch__all__node: {
            content: "inline*",
            group: "block",
            parseDOM: [
              {
                tag: "*",
                getAttrs: (e) => {
                  hasInvalidContent = true;
                  invalidContent = typeof e === "string" ? e : e.outerHTML;
                  return null;
                }
              }
            ]
          }
        })
      });
      if (options.slice) {
        DOMParser$1.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);
      } else {
        DOMParser$1.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);
      }
      if (options.errorOnInvalidContent && hasInvalidContent) {
        throw new Error("[super-editor error]: Invalid HTML content", {
          cause: new Error(`Invalid element found: ${invalidContent}`)
        });
      }
    }
    const parser = DOMParser$1.fromSchema(schema);
    if (options.slice) {
      return parser.parseSlice(elementFromString(content), options.parseOptions).content;
    }
    return parser.parse(elementFromString(content), options.parseOptions);
  }
  return createNodeFromContent("", schema, options);
}
function selectionToInsertionEnd(tr, startLen, bias) {
  const last = tr.steps.length - 1;
  if (last < startLen) {
    return;
  }
  const step = tr.steps[last];
  if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep$1)) {
    return;
  }
  const map22 = tr.mapping.maps[last];
  let end2 = 0;
  map22.forEach((_from, _to, _newFrom, newTo) => {
    if (end2 === 0) {
      end2 = newTo;
    }
  });
  tr.setSelection(Selection.near(tr.doc.resolve(end2), bias));
}
const isFragment = (nodeOrFragment) => {
  return !("type" in nodeOrFragment);
};
const insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {
  if (dispatch) {
    options = {
      parseOptions: {},
      updateSelection: true,
      applyInputRules: false,
      applyPasteRules: false,
      ...options
    };
    let content;
    try {
      content = createNodeFromContent(value, editor.schema, {
        parseOptions: {
          preserveWhitespace: "full",
          ...options.parseOptions
        },
        errorOnInvalidContent: options.errorOnInvalidContent ?? editor.options.enableContentCheck
      });
    } catch (e) {
      editor.emit("contentError", {
        editor,
        error: e,
        disableCollaboration: () => {
          console.error("[super-editor error]: Unable to disable collaboration at this point in time");
        }
      });
      return false;
    }
    let { from: from2, to } = typeof position === "number" ? { from: position, to: position } : { from: position.from, to: position.to };
    let isOnlyTextContent = true;
    let isOnlyBlockContent = true;
    const nodes = isFragment(content) ? content : [content];
    nodes.forEach((node2) => {
      node2.check();
      isOnlyTextContent = isOnlyTextContent ? node2.isText && node2.marks.length === 0 : false;
      isOnlyBlockContent = isOnlyBlockContent ? node2.isBlock : false;
    });
    if (from2 === to && isOnlyBlockContent) {
      const { parent } = tr.doc.resolve(from2);
      const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;
      if (isEmptyTextBlock) {
        from2 -= 1;
        to += 1;
      }
    }
    let newContent;
    if (isOnlyTextContent) {
      if (Array.isArray(value)) {
        newContent = value.map((v2) => v2.text || "").join("");
      } else if (typeof value === "object" && !!value && !!value.text) {
        newContent = value.text;
      } else {
        newContent = value;
      }
      tr.insertText(newContent, from2, to);
    } else {
      newContent = content;
      tr.replaceWith(from2, to, newContent);
    }
    if (options.updateSelection) {
      selectionToInsertionEnd(tr, tr.steps.length - 1, -1);
    }
    if (options.applyInputRules) {
      tr.setMeta("applyInputRules", { from: from2, text: newContent });
    }
    if (options.applyPasteRules) {
      tr.setMeta("applyPasteRules", { from: from2, text: newContent });
    }
  }
  return true;
};
const undoInputRule = () => ({ state: state2, dispatch }) => {
  const plugins = state2.plugins;
  for (let i = 0; i < plugins.length; i += 1) {
    const plugin2 = plugins[i];
    let undoable;
    if (plugin2.spec.isInputRules && (undoable = plugin2.getState(state2))) {
      if (dispatch) {
        const tr = state2.tr;
        const toUndo = undoable.transform;
        for (let j2 = toUndo.steps.length - 1; j2 >= 0; j2 -= 1) {
          tr.step(toUndo.steps[j2].invert(toUndo.docs[j2]));
        }
        if (undoable.text) {
          const marks = tr.doc.resolve(undoable.from).marks();
          tr.replaceWith(undoable.from, undoable.to, state2.schema.text(undoable.text, marks));
        } else {
          tr.delete(undoable.from, undoable.to);
        }
      }
      return true;
    }
  }
  return false;
};
function wrapInList$1(listType, attrs = null) {
  return function(state2, dispatch) {
    let { $from, $to } = state2.selection;
    let range2 = $from.blockRange($to);
    if (!range2)
      return false;
    let tr = dispatch ? state2.tr : null;
    if (!wrapRangeInList(tr, range2, listType, attrs))
      return false;
    if (dispatch)
      dispatch(tr.scrollIntoView());
    return true;
  };
}
function wrapRangeInList(tr, range2, listType, attrs = null) {
  let doJoin = false, outerRange = range2, doc2 = range2.$from.doc;
  if (range2.depth >= 2 && range2.$from.node(range2.depth - 1).type.compatibleContent(listType) && range2.startIndex == 0) {
    if (range2.$from.index(range2.depth - 1) == 0)
      return false;
    let $insert = doc2.resolve(range2.start - 2);
    outerRange = new NodeRange($insert, $insert, range2.depth);
    if (range2.endIndex < range2.parent.childCount)
      range2 = new NodeRange(range2.$from, doc2.resolve(range2.$to.end(range2.depth)), range2.depth);
    doJoin = true;
  }
  let wrap2 = findWrapping(outerRange, listType, attrs, range2);
  if (!wrap2)
    return false;
  if (tr)
    doWrapInList(tr, range2, wrap2, doJoin, listType);
  return true;
}
function doWrapInList(tr, range2, wrappers, joinBefore, listType) {
  let content = Fragment.empty;
  for (let i = wrappers.length - 1; i >= 0; i--)
    content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));
  tr.step(new ReplaceAroundStep$1(range2.start - (joinBefore ? 2 : 0), range2.end, range2.start, range2.end, new Slice(content, 0, 0), wrappers.length, true));
  let found2 = 0;
  for (let i = 0; i < wrappers.length; i++)
    if (wrappers[i].type == listType)
      found2 = i + 1;
  let splitDepth = wrappers.length - found2;
  let splitPos = range2.start + wrappers.length - (joinBefore ? 2 : 0), parent = range2.parent;
  for (let i = range2.startIndex, e = range2.endIndex, first2 = true; i < e; i++, first2 = false) {
    if (!first2 && canSplit(tr.doc, splitPos, splitDepth)) {
      tr.split(splitPos, splitDepth);
      splitPos += 2 * splitDepth;
    }
    splitPos += parent.child(i).nodeSize;
  }
  return tr;
}
function liftListItem$1(itemType) {
  return function(state2, dispatch) {
    let { $from, $to } = state2.selection;
    let range2 = $from.blockRange($to, (node2) => node2.childCount > 0 && node2.firstChild.type == itemType);
    if (!range2)
      return false;
    if (!dispatch)
      return true;
    if ($from.node(range2.depth - 1).type == itemType)
      return liftToOuterList(state2, dispatch, itemType, range2);
    else
      return liftOutOfList(state2, dispatch, range2);
  };
}
function liftToOuterList(state2, dispatch, itemType, range2) {
  let tr = state2.tr, end2 = range2.end, endOfList = range2.$to.end(range2.depth);
  if (end2 < endOfList) {
    tr.step(new ReplaceAroundStep$1(end2 - 1, endOfList, end2, endOfList, new Slice(Fragment.from(itemType.create(null, range2.parent.copy())), 1, 0), 1, true));
    range2 = new NodeRange(tr.doc.resolve(range2.$from.pos), tr.doc.resolve(endOfList), range2.depth);
  }
  const target = liftTarget(range2);
  if (target == null)
    return false;
  tr.lift(range2, target);
  let $after = tr.doc.resolve(tr.mapping.map(end2, -1) - 1);
  if (canJoin(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)
    tr.join($after.pos);
  dispatch(tr.scrollIntoView());
  return true;
}
function liftOutOfList(state2, dispatch, range2) {
  let tr = state2.tr, list = range2.parent;
  for (let pos = range2.end, i = range2.endIndex - 1, e = range2.startIndex; i > e; i--) {
    pos -= list.child(i).nodeSize;
    tr.delete(pos - 1, pos + 1);
  }
  let $start = tr.doc.resolve(range2.start), item = $start.nodeAfter;
  if (tr.mapping.map(range2.end) != range2.start + $start.nodeAfter.nodeSize)
    return false;
  let atStart = range2.startIndex == 0, atEnd = range2.endIndex == list.childCount;
  let parent = $start.node(-1), indexBefore = $start.index(-1);
  if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))
    return false;
  let start2 = $start.pos, end2 = start2 + item.nodeSize;
  tr.step(new ReplaceAroundStep$1(start2 - (atStart ? 1 : 0), end2 + (atEnd ? 1 : 0), start2 + 1, end2 - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))).append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));
  dispatch(tr.scrollIntoView());
  return true;
}
function sinkListItem$1(itemType) {
  return function(state2, dispatch) {
    let { $from, $to } = state2.selection;
    let range2 = $from.blockRange($to, (node2) => node2.childCount > 0 && node2.firstChild.type == itemType);
    if (!range2)
      return false;
    let startIndex = range2.startIndex;
    if (startIndex == 0)
      return false;
    let parent = range2.parent, nodeBefore = parent.child(startIndex - 1);
    if (nodeBefore.type != itemType)
      return false;
    if (dispatch) {
      let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;
      let inner = Fragment.from(nestedBefore ? itemType.create() : null);
      let slice2 = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);
      let before = range2.start, after = range2.end;
      dispatch(state2.tr.step(new ReplaceAroundStep$1(before - (nestedBefore ? 3 : 1), after, before, after, slice2, 1, true)).scrollIntoView());
    }
    return true;
  };
}
const wrapInList = (typeOrName, attrs = {}) => ({ state: state2, dispatch }) => {
  const type2 = getNodeType(typeOrName, state2.schema);
  return wrapInList$1(type2, attrs)(state2, dispatch);
};
const toggleList = (listType) => ({ editor, state: state2, tr }) => {
  const { selection } = state2;
  const { from: from2, to } = selection;
  const isList2 = findParentNode((node2) => node2.type === listType)(tr.selection);
  if (!isList2) {
    if (!selection.empty && from2 !== to) {
      const paragraphsToConvert = [];
      state2.doc.nodesBetween(from2, to, (node2, pos) => {
        if (node2.type.name === "paragraph") {
          const nodeFrom = pos;
          const nodeTo = pos + node2.nodeSize;
          if (nodeFrom < to && nodeTo > from2) {
            paragraphsToConvert.push({
              node: node2,
              pos,
              from: Math.max(nodeFrom, from2),
              to: Math.min(nodeTo, to)
            });
          }
        }
        return false;
      });
      if (paragraphsToConvert.length > 1) {
        const numId = ListHelpers.getNewListId(editor);
        if (typeof listType === "string") listType = editor.schema.nodes[listType];
        ListHelpers.generateNewListDefinition({ numId, listType, editor });
        paragraphsToConvert.reverse().forEach(({ node: node2, pos }) => {
          const level = 0;
          const listLevel = [1];
          const listNode = ListHelpers.createSchemaOrderedListNode({
            level,
            numId,
            listType,
            editor,
            listLevel,
            contentNode: node2.toJSON()
          });
          const replaceFrom = pos;
          const replaceTo = pos + node2.nodeSize;
          ListHelpers.insertNewList(tr, replaceFrom, replaceTo, listNode);
        });
        return true;
      }
    }
    return ListHelpers.createNewList({ listType, tr, editor });
  }
  return false;
};
const decreaseListIndent = () => ({ editor, tr }) => {
  const { state: state2 } = editor;
  const currentNode = ListHelpers.getCurrentListItem(state2);
  if (!currentNode) return false;
  const parentList = ListHelpers.getParentOrderedList(state2);
  if (!parentList) return false;
  const currentLevel = currentNode.node.attrs.level;
  const newLevel = currentLevel - 1;
  if (newLevel < 0) {
    return false;
  }
  const numId = currentNode.node.attrs.numId;
  tr.setNodeMarkup(currentNode.pos, null, {
    ...currentNode.node.attrs,
    level: newLevel,
    numId
  });
  return true;
};
const splitListItem = () => (props) => {
  const { tr, state: state2, editor } = props;
  const type2 = getNodeType("listItem", state2.schema);
  const { $from, $to } = state2.selection;
  tr.setMeta("updateListSync", true);
  const currentListItem = findParentNode((node2) => node2.type.name === "listItem")(state2.selection);
  if (!currentListItem) return false;
  if (state2.selection.node && state2.selection.node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {
    return false;
  }
  if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {
    return handleSplitInEmptyBlock(props, currentListItem);
  }
  const matchedListItem = findParentNode((node2) => node2.type === type2)(state2.selection);
  const { node: listItemNode } = matchedListItem || {};
  if (listItemNode.type !== type2) return false;
  const listTypes = ["orderedList", "bulletList"];
  const matchedParentList = findParentNode((node2) => listTypes.includes(node2.type.name))(state2.selection);
  const { node: parentListNode } = matchedParentList || {};
  if ($from.pos !== $to.pos) tr.delete($from.pos, $to.pos);
  const paragraphNode = $from.node();
  const paraOffset = $from.parentOffset;
  const beforeCursor = paragraphNode.content.cut(0, paraOffset);
  const afterCursor = paragraphNode.content.cut(paraOffset);
  let firstList, secondList;
  const marks = state2.storedMarks || $from.marks() || [];
  const listItemHasMultipleParagraphs = listItemNode.childCount > 1;
  if (listItemHasMultipleParagraphs) {
    const paragraphIndex = $from.index(-1);
    let contentBeforeCurrentPara = [];
    for (let i = 0; i < paragraphIndex; i++) {
      contentBeforeCurrentPara.push(listItemNode.child(i));
    }
    let contentAfterCurrentPara = [];
    for (let i = paragraphIndex + 1; i < listItemNode.childCount; i++) {
      contentAfterCurrentPara.push(listItemNode.child(i));
    }
    let firstListContent = [...contentBeforeCurrentPara];
    if (beforeCursor.size > 0) {
      const modifiedFirstParagraph = editor.schema.nodes.paragraph.create(paragraphNode.attrs, beforeCursor);
      firstListContent.push(modifiedFirstParagraph);
    }
    let secondListContent = [];
    if (afterCursor && afterCursor.size > 0) {
      const modifiedSecondParagraph = editor.schema.nodes.paragraph.create(paragraphNode.attrs, afterCursor);
      secondListContent.push(modifiedSecondParagraph);
    } else {
      const emptyParagraph = editor.schema.nodes.paragraph.create(paragraphNode.attrs);
      secondListContent.push(emptyParagraph);
    }
    secondListContent = secondListContent.concat(contentAfterCurrentPara);
    if (firstListContent.length === 0) {
      const emptyParagraph = editor.schema.nodes.paragraph.create();
      firstListContent = [emptyParagraph];
    }
    if (secondListContent.length === 0) {
      const emptyParagraph = editor.schema.nodes.paragraph.create();
      secondListContent = [emptyParagraph];
    }
    const firstListItem = editor.schema.nodes.listItem.create(
      { ...listItemNode.attrs },
      Fragment.from(firstListContent)
    );
    firstList = editor.schema.nodes.orderedList.createAndFill(parentListNode.attrs, Fragment.from(firstListItem));
    const secondListItem = editor.schema.nodes.listItem.create(
      { ...listItemNode.attrs },
      Fragment.from(secondListContent)
    );
    secondList = editor.schema.nodes.orderedList.createAndFill(parentListNode.attrs, Fragment.from(secondListItem));
  } else {
    let firstParagraphContent = beforeCursor;
    if (beforeCursor.size === 0) {
      firstParagraphContent = editor.schema.text(" ", marks);
    }
    const firstParagraph = editor.schema.nodes.paragraph.create(paragraphNode.attrs, firstParagraphContent);
    const firstListItem = editor.schema.nodes.listItem.create({ ...listItemNode.attrs }, firstParagraph);
    firstList = editor.schema.nodes.orderedList.createAndFill(parentListNode.attrs, Fragment.from(firstListItem));
    let secondParagraphContent = afterCursor;
    if (afterCursor.size === 0) {
      secondParagraphContent = editor.schema.text(" ", marks);
    }
    const secondParagraph = editor.schema.nodes.paragraph.create(paragraphNode.attrs, secondParagraphContent);
    const secondListItem = editor.schema.nodes.listItem.create({ ...listItemNode.attrs }, secondParagraph);
    secondList = editor.schema.nodes.orderedList.createAndFill(parentListNode.attrs, Fragment.from(secondListItem));
  }
  if (!firstList || !secondList) return false;
  const listStart = matchedParentList.pos;
  const listEnd = matchedParentList.pos + parentListNode.nodeSize;
  tr.replaceWith(listStart, listEnd, firstList);
  const insertPosition = listStart + firstList.nodeSize;
  tr.insert(insertPosition, secondList);
  const secondListStart = insertPosition + 2;
  tr.setSelection(TextSelection$1.near(tr.doc.resolve(secondListStart)));
  tr.scrollIntoView();
  if (marks?.length) {
    tr.ensureMarks(marks);
  }
  tr.setMeta("splitListItem", true);
  return true;
};
const handleSplitInEmptyBlock = (props, currentListItem) => {
  const { state: state2, editor, tr } = props;
  const { schema } = state2;
  const { $from } = state2.selection;
  const extensionAttrs = editor.extensionService.attributes;
  const listItemNode = currentListItem.node;
  const isEmptyParagraph = $from.parent.content.size === 0;
  const listItemHasOtherContent = listItemNode.content.size > $from.parent.nodeSize;
  const isAtEndOfListItem = $from.indexAfter(-1) === $from.node(-1).childCount;
  if (isEmptyParagraph && listItemHasOtherContent && isAtEndOfListItem) {
    try {
      const listTypes = ["orderedList", "bulletList"];
      const parentList = findParentNode((node2) => listTypes.includes(node2.type.name))(state2.selection);
      if (!parentList) return false;
      const newParagraphAttrs = Attribute2.getSplittedAttributes(extensionAttrs, "paragraph", {});
      const newParagraph = schema.nodes.paragraph.create(newParagraphAttrs);
      const newListItem = schema.nodes.listItem.create({ ...listItemNode.attrs }, newParagraph);
      const newList = schema.nodes.orderedList.createAndFill(parentList.node.attrs, Fragment.from(newListItem));
      if (!newList) return false;
      const insertPos = parentList.pos + parentList.node.nodeSize;
      tr.insert(insertPos, newList);
      const newPos = insertPos + 2;
      tr.setSelection(TextSelection$1.near(tr.doc.resolve(newPos)));
      tr.scrollIntoView();
      return true;
    } catch (error) {
      console.error("Error creating new list item:", error);
      return false;
    }
  }
  if (isEmptyParagraph && listItemHasOtherContent && !isAtEndOfListItem) {
    return false;
  }
  const isListItemEmpty = () => {
    if (listItemNode.childCount === 0) return true;
    for (let i = 0; i < listItemNode.childCount; i++) {
      const child = listItemNode.child(i);
      if (child.type.name === "paragraph" && child.content.size === 0) {
        continue;
      } else if (child.type.name === "paragraph" && child.content.size > 0) {
        return false;
      } else {
        return false;
      }
    }
    return true;
  };
  if (isListItemEmpty()) {
    const didOutdent = decreaseListIndent()({ editor, tr });
    if (didOutdent) return true;
    try {
      const listTypes = ["orderedList", "bulletList"];
      const parentList = findParentNode((node2) => listTypes.includes(node2.type.name))(state2.selection);
      if (!parentList) {
        console.error("No parent list found");
        return false;
      }
      const newParagraphAttrs = Attribute2.getSplittedAttributes(extensionAttrs, "paragraph", {});
      const paragraphType = schema.nodes.paragraph;
      let newParagraph = paragraphType.createAndFill(newParagraphAttrs);
      if (!newParagraph) {
        newParagraph = paragraphType.create();
      }
      const listStart = parentList.pos;
      const listEnd = parentList.pos + parentList.node.nodeSize;
      tr.replaceWith(listStart, listEnd, newParagraph);
      const newPos = listStart + 1;
      tr.setSelection(TextSelection$1.near(tr.doc.resolve(newPos)));
      tr.scrollIntoView();
      return true;
    } catch (error) {
      console.error("Error destroying list:", error);
      return false;
    }
  }
  return false;
};
const sinkListItem = (typeOrName) => ({ state: state2, dispatch }) => {
  const type2 = getNodeType(typeOrName, state2.schema);
  return sinkListItem$1(type2)(state2, dispatch);
};
const liftListItem = (typeOrName) => ({ state: state2, dispatch }) => {
  const type2 = getNodeType(typeOrName, state2.schema);
  return liftListItem$1(type2)(state2, dispatch);
};
const deleteListItem = () => (props) => {
  const { tr, state: state2 } = props;
  const { selection } = state2;
  tr.setMeta("updateListSync", true);
  if (!selection.empty) {
    const { from: from2, to } = selection;
    const fullySelectedBlocks = [];
    state2.doc.nodesBetween(from2, to, (node2, pos) => {
      if (node2.isBlock && pos >= from2 && pos + node2.nodeSize <= to) {
        fullySelectedBlocks.push({ pos, size: node2.nodeSize });
      }
    });
    if (fullySelectedBlocks.length) {
      fullySelectedBlocks.sort((a, b2) => b2.pos - a.pos).forEach(({ pos, size: size2 }) => {
        tr.delete(pos, pos + size2);
      });
      const $new = tr.doc.resolve(from2);
      tr.setSelection(TextSelection$1.near($new));
      return true;
    }
    return false;
  }
  const { $from } = state2.selection;
  if ($from.parentOffset !== 0) return false;
  const currentListItem = findParentNode((n) => n.type.name === "listItem")(state2.selection);
  if (!currentListItem) return false;
  const listTypes = ["orderedList", "bulletList"];
  const parentList = findParentNode((n) => listTypes.includes(n.type.name))(state2.selection);
  if (!parentList) return false;
  const currentParagraphNode = findParentNode((n) => n.type.name === "paragraph")(state2.selection);
  const paragraphNode = currentListItem.node.content.firstChild;
  if (paragraphNode !== currentParagraphNode.node) return false;
  const listFrom = parentList.pos;
  const listTo = listFrom + parentList.node.nodeSize;
  if (currentListItem.node.content.size === 0) {
    tr.delete(listFrom, listTo);
    return true;
  }
  const listItemContent = currentListItem.node.content;
  const nodes = [];
  listItemContent.forEach((child) => {
    nodes.push(child);
  });
  tr.replaceWith(listFrom, listTo, nodes);
  const $pos = tr.doc.resolve(listFrom + 1);
  tr.setSelection(TextSelection$1.near($pos));
  return true;
};
const increaseListIndent = () => ({ editor, tr }) => {
  const { state: state2 } = editor;
  const currentNode = ListHelpers.getCurrentListItem(state2);
  if (!currentNode) return false;
  const parentList = ListHelpers.getParentOrderedList(state2);
  if (!parentList) return false;
  const newLevel = currentNode.node.attrs.level + 1;
  const numId = currentNode.node.attrs.numId;
  tr.setNodeMarkup(currentNode.pos, null, {
    ...currentNode.node.attrs,
    level: newLevel,
    numId
  });
  return true;
};
const restoreSelection = () => ({ editor, state: state2, tr }) => {
  if (editor.options.lastSelection) {
    const selectionTr = tr.setSelection(
      TextSelection$1.create(state2.doc, editor.options.lastSelection.from, editor.options.lastSelection.to)
    );
    editor.view.dispatch(selectionTr);
  }
};
const commands$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clearNodes,
  command,
  createParagraphNear,
  decreaseListIndent,
  deleteListItem,
  deleteSelection,
  exitCode,
  first,
  handleBackspaceNextToList,
  handleDeleteNextToList,
  increaseListIndent,
  insertContent,
  insertContentAt,
  insertTabChar,
  insertTabCharacter,
  insertTabNode,
  joinBackward,
  joinDown,
  joinForward,
  joinUp,
  liftEmptyBlock,
  liftListItem,
  newlineInCode,
  resetAttributes,
  restoreSelection,
  selectAll,
  selectNodeBackward,
  selectNodeForward,
  selectTextblockEnd,
  selectTextblockStart,
  setMark,
  setMeta: setMeta$1,
  setNode,
  sinkListItem,
  splitBlock: splitBlock$1,
  splitListItem,
  toggleList,
  toggleMark,
  toggleNode,
  undoInputRule,
  unsetAllMarks,
  unsetMark,
  updateAttributes,
  wrapInList
}, Symbol.toStringTag, { value: "Module" }));
const Commands = Extension.create({
  name: "commands",
  addCommands() {
    return { ...commands$1 };
  }
});
const handleEnter = (editor) => {
  return editor.commands.first(({ commands: commands2 }) => [
    () => commands2.newlineInCode(),
    () => commands2.createParagraphNear(),
    () => commands2.liftEmptyBlock(),
    () => commands2.splitBlock()
  ]);
};
const handleBackspace = (editor) => {
  return editor.commands.first(({ commands: commands2, tr }) => [
    () => commands2.undoInputRule(),
    () => {
      tr.setMeta("inputType", "deleteContentBackward");
      return false;
    },
    () => commands2.deleteSelection(),
    () => commands2.handleBackspaceNextToList(),
    () => commands2.deleteListItem(),
    () => commands2.joinBackward(),
    () => commands2.selectNodeBackward()
  ]);
};
const handleDelete = (editor) => {
  return editor.commands.first(({ commands: commands2 }) => [
    () => commands2.deleteSelection(),
    () => commands2.handleDeleteNextToList(),
    () => commands2.joinForward(),
    () => commands2.selectNodeForward()
  ]);
};
const Keymap = Extension.create({
  name: "keymap",
  addShortcuts() {
    const baseKeymap = {
      Enter: () => handleEnter(this.editor),
      "Mod-Enter": () => this.editor.commands.exitCode(),
      Backspace: () => handleBackspace(this.editor),
      "Mod-Backspace": () => handleBackspace(this.editor),
      "Shift-Backspace": () => handleBackspace(this.editor),
      Delete: () => handleDelete(this.editor),
      "Mod-Delete": () => handleDelete(this.editor),
      "Mod-a": () => this.editor.commands.selectAll(),
      Tab: () => this.editor.commands.insertTabNode()
    };
    const pcBaseKeymap = {
      ...baseKeymap
    };
    const macBaseKeymap = {
      ...baseKeymap,
      "Ctrl-h": () => handleBackspace(this.editor),
      "Alt-Backspace": () => handleBackspace(this.editor),
      "Ctrl-d": () => handleDelete(this.editor),
      "Ctrl-Alt-Backspace": () => handleDelete(this.editor),
      "Alt-Delete": () => handleDelete(this.editor),
      "Alt-d": () => handleDelete(this.editor),
      "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
      "Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
      "Ctrl-t": () => this.editor.commands.insertTabChar()
    };
    if (isMacOS() || isIOS()) {
      return macBaseKeymap;
    }
    return pcBaseKeymap;
  }
});
const Editable = Extension.create({
  name: "editable",
  addPmPlugins() {
    const editablePlugin = new Plugin({
      key: new PluginKey("editable"),
      props: {
        editable: () => {
          return this.editor.options.editable;
        }
      }
    });
    return [editablePlugin];
  }
});
const EditorFocus = Extension.create({
  name: "editorFocus",
  addPmPlugins() {
    const editor = this.editor;
    const editorFocusPlugin = new Plugin({
      key: new PluginKey("editorFocus"),
      props: {
        handleDOMEvents: {
          focus: (view, event) => {
            editor.isFocused = true;
            const tr = editor.state.tr.setMeta("focus", { event }).setMeta("addToHistory", false);
            view.dispatch(tr);
            return false;
          },
          blur: (view, event) => {
            editor.isFocused = false;
            const tr = editor.state.tr.setMeta("blur", { event }).setMeta("addToHistory", false);
            view.dispatch(tr);
            return false;
          }
        }
      }
    });
    return [editorFocusPlugin];
  }
});
const global$1 = globalThis || void 0 || self;
const domIndex = function(node2) {
  for (var index2 = 0; ; index2++) {
    node2 = node2.previousSibling;
    if (!node2)
      return index2;
  }
};
const parentNode = function(node2) {
  let parent = node2.assignedSlot || node2.parentNode;
  return parent && parent.nodeType == 11 ? parent.host : parent;
};
let reusedRange = null;
const textRange = function(node2, from2, to) {
  let range2 = reusedRange || (reusedRange = document.createRange());
  range2.setEnd(node2, to == null ? node2.nodeValue.length : to);
  range2.setStart(node2, from2 || 0);
  return range2;
};
const clearReusedRange = function() {
  reusedRange = null;
};
const isEquivalentPosition = function(node2, off2, targetNode, targetOff) {
  return targetNode && (scanFor(node2, off2, targetNode, targetOff, -1) || scanFor(node2, off2, targetNode, targetOff, 1));
};
const atomElements = /^(img|br|input|textarea|hr)$/i;
function scanFor(node2, off2, targetNode, targetOff, dir) {
  var _a2;
  for (; ; ) {
    if (node2 == targetNode && off2 == targetOff)
      return true;
    if (off2 == (dir < 0 ? 0 : nodeSize(node2))) {
      let parent = node2.parentNode;
      if (!parent || parent.nodeType != 1 || hasBlockDesc(node2) || atomElements.test(node2.nodeName) || node2.contentEditable == "false")
        return false;
      off2 = domIndex(node2) + (dir < 0 ? 0 : 1);
      node2 = parent;
    } else if (node2.nodeType == 1) {
      let child = node2.childNodes[off2 + (dir < 0 ? -1 : 0)];
      if (child.nodeType == 1 && child.contentEditable == "false") {
        if ((_a2 = child.pmViewDesc) === null || _a2 === void 0 ? void 0 : _a2.ignoreForSelection)
          off2 += dir;
        else
          return false;
      } else {
        node2 = child;
        off2 = dir < 0 ? nodeSize(node2) : 0;
      }
    } else {
      return false;
    }
  }
}
function nodeSize(node2) {
  return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
}
function textNodeBefore$1(node2, offset2) {
  for (; ; ) {
    if (node2.nodeType == 3 && offset2)
      return node2;
    if (node2.nodeType == 1 && offset2 > 0) {
      if (node2.contentEditable == "false")
        return null;
      node2 = node2.childNodes[offset2 - 1];
      offset2 = nodeSize(node2);
    } else if (node2.parentNode && !hasBlockDesc(node2)) {
      offset2 = domIndex(node2);
      node2 = node2.parentNode;
    } else {
      return null;
    }
  }
}
function textNodeAfter$1(node2, offset2) {
  for (; ; ) {
    if (node2.nodeType == 3 && offset2 < node2.nodeValue.length)
      return node2;
    if (node2.nodeType == 1 && offset2 < node2.childNodes.length) {
      if (node2.contentEditable == "false")
        return null;
      node2 = node2.childNodes[offset2];
      offset2 = 0;
    } else if (node2.parentNode && !hasBlockDesc(node2)) {
      offset2 = domIndex(node2) + 1;
      node2 = node2.parentNode;
    } else {
      return null;
    }
  }
}
function isOnEdge(node2, offset2, parent) {
  for (let atStart = offset2 == 0, atEnd = offset2 == nodeSize(node2); atStart || atEnd; ) {
    if (node2 == parent)
      return true;
    let index2 = domIndex(node2);
    node2 = node2.parentNode;
    if (!node2)
      return false;
    atStart = atStart && index2 == 0;
    atEnd = atEnd && index2 == nodeSize(node2);
  }
}
function hasBlockDesc(dom) {
  let desc;
  for (let cur = dom; cur; cur = cur.parentNode)
    if (desc = cur.pmViewDesc)
      break;
  return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);
}
const selectionCollapsed = function(domSel) {
  return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);
};
function keyEvent(keyCode, key) {
  let event = document.createEvent("Event");
  event.initEvent("keydown", true, true);
  event.keyCode = keyCode;
  event.key = event.code = key;
  return event;
}
function deepActiveElement(doc2) {
  let elt = doc2.activeElement;
  while (elt && elt.shadowRoot)
    elt = elt.shadowRoot.activeElement;
  return elt;
}
function caretFromPoint(doc2, x, y2) {
  if (doc2.caretPositionFromPoint) {
    try {
      let pos = doc2.caretPositionFromPoint(x, y2);
      if (pos)
        return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };
    } catch (_2) {
    }
  }
  if (doc2.caretRangeFromPoint) {
    let range2 = doc2.caretRangeFromPoint(x, y2);
    if (range2)
      return { node: range2.startContainer, offset: Math.min(nodeSize(range2.startContainer), range2.startOffset) };
  }
}
const nav = typeof navigator != "undefined" ? navigator : null;
const doc$1 = typeof document != "undefined" ? document : null;
const agent = nav && nav.userAgent || "";
const ie_edge = /Edge\/(\d+)/.exec(agent);
const ie_upto10 = /MSIE \d/.exec(agent);
const ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(agent);
const ie$1 = !!(ie_upto10 || ie_11up || ie_edge);
const ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;
const gecko = !ie$1 && /gecko\/(\d+)/i.test(agent);
gecko && +(/Firefox\/(\d+)/.exec(agent) || [0, 0])[1];
const _chrome = !ie$1 && /Chrome\/(\d+)/.exec(agent);
const chrome = !!_chrome;
const chrome_version = _chrome ? +_chrome[1] : 0;
const safari = !ie$1 && !!nav && /Apple Computer/.test(nav.vendor);
const ios = safari && (/Mobile\/\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);
const mac$2 = ios || (nav ? /Mac/.test(nav.platform) : false);
const windows$1 = nav ? /Win/.test(nav.platform) : false;
const android = /Android \d/.test(agent);
const webkit = !!doc$1 && "webkitFontSmoothing" in doc$1.documentElement.style;
const webkit_version = webkit ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function windowRect(doc2) {
  let vp = doc2.defaultView && doc2.defaultView.visualViewport;
  if (vp)
    return {
      left: 0,
      right: vp.width,
      top: 0,
      bottom: vp.height
    };
  return {
    left: 0,
    right: doc2.documentElement.clientWidth,
    top: 0,
    bottom: doc2.documentElement.clientHeight
  };
}
function getSide$1(value, side) {
  return typeof value == "number" ? value : value[side];
}
function clientRect(node2) {
  let rect = node2.getBoundingClientRect();
  let scaleX = rect.width / node2.offsetWidth || 1;
  let scaleY = rect.height / node2.offsetHeight || 1;
  return {
    left: rect.left,
    right: rect.left + node2.clientWidth * scaleX,
    top: rect.top,
    bottom: rect.top + node2.clientHeight * scaleY
  };
}
function scrollRectIntoView(view, rect, startDOM) {
  let scrollThreshold = view.someProp("scrollThreshold") || 0, scrollMargin = view.someProp("scrollMargin") || 5;
  let doc2 = view.dom.ownerDocument;
  for (let parent = startDOM || view.dom; ; ) {
    if (!parent)
      break;
    if (parent.nodeType != 1) {
      parent = parentNode(parent);
      continue;
    }
    let elt = parent;
    let atTop = elt == doc2.body;
    let bounding = atTop ? windowRect(doc2) : clientRect(elt);
    let moveX = 0, moveY = 0;
    if (rect.top < bounding.top + getSide$1(scrollThreshold, "top"))
      moveY = -(bounding.top - rect.top + getSide$1(scrollMargin, "top"));
    else if (rect.bottom > bounding.bottom - getSide$1(scrollThreshold, "bottom"))
      moveY = rect.bottom - rect.top > bounding.bottom - bounding.top ? rect.top + getSide$1(scrollMargin, "top") - bounding.top : rect.bottom - bounding.bottom + getSide$1(scrollMargin, "bottom");
    if (rect.left < bounding.left + getSide$1(scrollThreshold, "left"))
      moveX = -(bounding.left - rect.left + getSide$1(scrollMargin, "left"));
    else if (rect.right > bounding.right - getSide$1(scrollThreshold, "right"))
      moveX = rect.right - bounding.right + getSide$1(scrollMargin, "right");
    if (moveX || moveY) {
      if (atTop) {
        doc2.defaultView.scrollBy(moveX, moveY);
      } else {
        let startX = elt.scrollLeft, startY = elt.scrollTop;
        if (moveY)
          elt.scrollTop += moveY;
        if (moveX)
          elt.scrollLeft += moveX;
        let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;
        rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };
      }
    }
    let pos = atTop ? "fixed" : getComputedStyle(parent).position;
    if (/^(fixed|sticky)$/.test(pos))
      break;
    parent = pos == "absolute" ? parent.offsetParent : parentNode(parent);
  }
}
function storeScrollPos(view) {
  let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);
  let refDOM, refTop;
  for (let x = (rect.left + rect.right) / 2, y2 = startY + 1; y2 < Math.min(innerHeight, rect.bottom); y2 += 5) {
    let dom = view.root.elementFromPoint(x, y2);
    if (!dom || dom == view.dom || !view.dom.contains(dom))
      continue;
    let localRect = dom.getBoundingClientRect();
    if (localRect.top >= startY - 20) {
      refDOM = dom;
      refTop = localRect.top;
      break;
    }
  }
  return { refDOM, refTop, stack: scrollStack(view.dom) };
}
function scrollStack(dom) {
  let stack2 = [], doc2 = dom.ownerDocument;
  for (let cur = dom; cur; cur = parentNode(cur)) {
    stack2.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });
    if (dom == doc2)
      break;
  }
  return stack2;
}
function resetScrollPos({ refDOM, refTop, stack: stack2 }) {
  let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;
  restoreScrollStack(stack2, newRefTop == 0 ? 0 : newRefTop - refTop);
}
function restoreScrollStack(stack2, dTop) {
  for (let i = 0; i < stack2.length; i++) {
    let { dom, top: top2, left: left2 } = stack2[i];
    if (dom.scrollTop != top2 + dTop)
      dom.scrollTop = top2 + dTop;
    if (dom.scrollLeft != left2)
      dom.scrollLeft = left2;
  }
}
let preventScrollSupported = null;
function focusPreventScroll(dom) {
  if (dom.setActive)
    return dom.setActive();
  if (preventScrollSupported)
    return dom.focus(preventScrollSupported);
  let stored = scrollStack(dom);
  dom.focus(preventScrollSupported == null ? {
    get preventScroll() {
      preventScrollSupported = { preventScroll: true };
      return true;
    }
  } : void 0);
  if (!preventScrollSupported) {
    preventScrollSupported = false;
    restoreScrollStack(stored, 0);
  }
}
function findOffsetInNode(node2, coords) {
  let closest, dxClosest = 2e8, coordsClosest, offset2 = 0;
  let rowBot = coords.top, rowTop = coords.top;
  let firstBelow, coordsBelow;
  for (let child = node2.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {
    let rects;
    if (child.nodeType == 1)
      rects = child.getClientRects();
    else if (child.nodeType == 3)
      rects = textRange(child).getClientRects();
    else
      continue;
    for (let i = 0; i < rects.length; i++) {
      let rect = rects[i];
      if (rect.top <= rowBot && rect.bottom >= rowTop) {
        rowBot = Math.max(rect.bottom, rowBot);
        rowTop = Math.min(rect.top, rowTop);
        let dx = rect.left > coords.left ? rect.left - coords.left : rect.right < coords.left ? coords.left - rect.right : 0;
        if (dx < dxClosest) {
          closest = child;
          dxClosest = dx;
          coordsClosest = dx && closest.nodeType == 3 ? {
            left: rect.right < coords.left ? rect.right : rect.left,
            top: coords.top
          } : coords;
          if (child.nodeType == 1 && dx)
            offset2 = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);
          continue;
        }
      } else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {
        firstBelow = child;
        coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };
      }
      if (!closest && (coords.left >= rect.right && coords.top >= rect.top || coords.left >= rect.left && coords.top >= rect.bottom))
        offset2 = childIndex + 1;
    }
  }
  if (!closest && firstBelow) {
    closest = firstBelow;
    coordsClosest = coordsBelow;
    dxClosest = 0;
  }
  if (closest && closest.nodeType == 3)
    return findOffsetInText(closest, coordsClosest);
  if (!closest || dxClosest && closest.nodeType == 1)
    return { node: node2, offset: offset2 };
  return findOffsetInNode(closest, coordsClosest);
}
function findOffsetInText(node2, coords) {
  let len = node2.nodeValue.length;
  let range2 = document.createRange();
  for (let i = 0; i < len; i++) {
    range2.setEnd(node2, i + 1);
    range2.setStart(node2, i);
    let rect = singleRect(range2, 1);
    if (rect.top == rect.bottom)
      continue;
    if (inRect(coords, rect))
      return { node: node2, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };
  }
  return { node: node2, offset: 0 };
}
function inRect(coords, rect) {
  return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 && coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;
}
function targetKludge(dom, coords) {
  let parent = dom.parentNode;
  if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)
    return parent;
  return dom;
}
function posFromElement(view, elt, coords) {
  let { node: node2, offset: offset2 } = findOffsetInNode(elt, coords), bias = -1;
  if (node2.nodeType == 1 && !node2.firstChild) {
    let rect = node2.getBoundingClientRect();
    bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;
  }
  return view.docView.posFromDOM(node2, offset2, bias);
}
function posFromCaret(view, node2, offset2, coords) {
  let outsideBlock = -1;
  for (let cur = node2, sawBlock = false; ; ) {
    if (cur == view.dom)
      break;
    let desc = view.docView.nearestDesc(cur, true), rect;
    if (!desc)
      return null;
    if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) && // Ignore elements with zero-size bounding rectangles
    ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {
      if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {
        if (!sawBlock && rect.left > coords.left || rect.top > coords.top)
          outsideBlock = desc.posBefore;
        else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)
          outsideBlock = desc.posAfter;
        sawBlock = true;
      }
      if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {
        let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2 : coords.left < (rect.left + rect.right) / 2;
        return before ? desc.posBefore : desc.posAfter;
      }
    }
    cur = desc.dom.parentNode;
  }
  return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node2, offset2, -1);
}
function elementFromPoint(element, coords, box) {
  let len = element.childNodes.length;
  if (len && box.top < box.bottom) {
    for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI; ; ) {
      let child = element.childNodes[i];
      if (child.nodeType == 1) {
        let rects = child.getClientRects();
        for (let j2 = 0; j2 < rects.length; j2++) {
          let rect = rects[j2];
          if (inRect(coords, rect))
            return elementFromPoint(child, coords, rect);
        }
      }
      if ((i = (i + 1) % len) == startI)
        break;
    }
  }
  return element;
}
function posAtCoords(view, coords) {
  let doc2 = view.dom.ownerDocument, node2, offset2 = 0;
  let caret = caretFromPoint(doc2, coords.left, coords.top);
  if (caret)
    ({ node: node2, offset: offset2 } = caret);
  let elt = (view.root.elementFromPoint ? view.root : doc2).elementFromPoint(coords.left, coords.top);
  let pos;
  if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {
    let box = view.dom.getBoundingClientRect();
    if (!inRect(coords, box))
      return null;
    elt = elementFromPoint(view.dom, coords, box);
    if (!elt)
      return null;
  }
  if (safari) {
    for (let p = elt; node2 && p; p = parentNode(p))
      if (p.draggable)
        node2 = void 0;
  }
  elt = targetKludge(elt, coords);
  if (node2) {
    if (gecko && node2.nodeType == 1) {
      offset2 = Math.min(offset2, node2.childNodes.length);
      if (offset2 < node2.childNodes.length) {
        let next = node2.childNodes[offset2], box;
        if (next.nodeName == "IMG" && (box = next.getBoundingClientRect()).right <= coords.left && box.bottom > coords.top)
          offset2++;
      }
    }
    let prev;
    if (webkit && offset2 && node2.nodeType == 1 && (prev = node2.childNodes[offset2 - 1]).nodeType == 1 && prev.contentEditable == "false" && prev.getBoundingClientRect().top >= coords.top)
      offset2--;
    if (node2 == view.dom && offset2 == node2.childNodes.length - 1 && node2.lastChild.nodeType == 1 && coords.top > node2.lastChild.getBoundingClientRect().bottom)
      pos = view.state.doc.content.size;
    else if (offset2 == 0 || node2.nodeType != 1 || node2.childNodes[offset2 - 1].nodeName != "BR")
      pos = posFromCaret(view, node2, offset2, coords);
  }
  if (pos == null)
    pos = posFromElement(view, elt, coords);
  let desc = view.docView.nearestDesc(elt, true);
  return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };
}
function nonZero(rect) {
  return rect.top < rect.bottom || rect.left < rect.right;
}
function singleRect(target, bias) {
  let rects = target.getClientRects();
  if (rects.length) {
    let first2 = rects[bias < 0 ? 0 : rects.length - 1];
    if (nonZero(first2))
      return first2;
  }
  return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();
}
const BIDI = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function coordsAtPos(view, pos, side) {
  let { node: node2, offset: offset2, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);
  let supportEmptyRange = webkit || gecko;
  if (node2.nodeType == 3) {
    if (supportEmptyRange && (BIDI.test(node2.nodeValue) || (side < 0 ? !offset2 : offset2 == node2.nodeValue.length))) {
      let rect = singleRect(textRange(node2, offset2, offset2), side);
      if (gecko && offset2 && /\s/.test(node2.nodeValue[offset2 - 1]) && offset2 < node2.nodeValue.length) {
        let rectBefore = singleRect(textRange(node2, offset2 - 1, offset2 - 1), -1);
        if (rectBefore.top == rect.top) {
          let rectAfter = singleRect(textRange(node2, offset2, offset2 + 1), -1);
          if (rectAfter.top != rect.top)
            return flattenV(rectAfter, rectAfter.left < rectBefore.left);
        }
      }
      return rect;
    } else {
      let from2 = offset2, to = offset2, takeSide = side < 0 ? 1 : -1;
      if (side < 0 && !offset2) {
        to++;
        takeSide = -1;
      } else if (side >= 0 && offset2 == node2.nodeValue.length) {
        from2--;
        takeSide = 1;
      } else if (side < 0) {
        from2--;
      } else {
        to++;
      }
      return flattenV(singleRect(textRange(node2, from2, to), takeSide), takeSide < 0);
    }
  }
  let $dom = view.state.doc.resolve(pos - (atom || 0));
  if (!$dom.parent.inlineContent) {
    if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node2))) {
      let before = node2.childNodes[offset2 - 1];
      if (before.nodeType == 1)
        return flattenH(before.getBoundingClientRect(), false);
    }
    if (atom == null && offset2 < nodeSize(node2)) {
      let after = node2.childNodes[offset2];
      if (after.nodeType == 1)
        return flattenH(after.getBoundingClientRect(), true);
    }
    return flattenH(node2.getBoundingClientRect(), side >= 0);
  }
  if (atom == null && offset2 && (side < 0 || offset2 == nodeSize(node2))) {
    let before = node2.childNodes[offset2 - 1];
    let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1)) : before.nodeType == 1 && (before.nodeName != "BR" || !before.nextSibling) ? before : null;
    if (target)
      return flattenV(singleRect(target, 1), false);
  }
  if (atom == null && offset2 < nodeSize(node2)) {
    let after = node2.childNodes[offset2];
    while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)
      after = after.nextSibling;
    let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, supportEmptyRange ? 0 : 1) : after.nodeType == 1 ? after : null;
    if (target)
      return flattenV(singleRect(target, -1), true);
  }
  return flattenV(singleRect(node2.nodeType == 3 ? textRange(node2) : node2, -side), side >= 0);
}
function flattenV(rect, left2) {
  if (rect.width == 0)
    return rect;
  let x = left2 ? rect.left : rect.right;
  return { top: rect.top, bottom: rect.bottom, left: x, right: x };
}
function flattenH(rect, top2) {
  if (rect.height == 0)
    return rect;
  let y2 = top2 ? rect.top : rect.bottom;
  return { top: y2, bottom: y2, left: rect.left, right: rect.right };
}
function withFlushedState(view, state2, f) {
  let viewState = view.state, active = view.root.activeElement;
  if (viewState != state2)
    view.updateState(state2);
  if (active != view.dom)
    view.focus();
  try {
    return f();
  } finally {
    if (viewState != state2)
      view.updateState(viewState);
    if (active != view.dom && active)
      active.focus();
  }
}
function endOfTextblockVertical(view, state2, dir) {
  let sel = state2.selection;
  let $pos = dir == "up" ? sel.$from : sel.$to;
  return withFlushedState(view, state2, () => {
    let { node: dom } = view.docView.domFromPos($pos.pos, dir == "up" ? -1 : 1);
    for (; ; ) {
      let nearest = view.docView.nearestDesc(dom, true);
      if (!nearest)
        break;
      if (nearest.node.isBlock) {
        dom = nearest.contentDOM || nearest.dom;
        break;
      }
      dom = nearest.dom.parentNode;
    }
    let coords = coordsAtPos(view, $pos.pos, 1);
    for (let child = dom.firstChild; child; child = child.nextSibling) {
      let boxes;
      if (child.nodeType == 1)
        boxes = child.getClientRects();
      else if (child.nodeType == 3)
        boxes = textRange(child, 0, child.nodeValue.length).getClientRects();
      else
        continue;
      for (let i = 0; i < boxes.length; i++) {
        let box = boxes[i];
        if (box.bottom > box.top + 1 && (dir == "up" ? coords.top - box.top > (box.bottom - coords.top) * 2 : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))
          return false;
      }
    }
    return true;
  });
}
const maybeRTL = /[\u0590-\u08ac]/;
function endOfTextblockHorizontal(view, state2, dir) {
  let { $head } = state2.selection;
  if (!$head.parent.isTextblock)
    return false;
  let offset2 = $head.parentOffset, atStart = !offset2, atEnd = offset2 == $head.parent.content.size;
  let sel = view.domSelection();
  if (!sel)
    return $head.pos == $head.start() || $head.pos == $head.end();
  if (!maybeRTL.test($head.parent.textContent) || !sel.modify)
    return dir == "left" || dir == "backward" ? atStart : atEnd;
  return withFlushedState(view, state2, () => {
    let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();
    let oldBidiLevel = sel.caretBidiLevel;
    sel.modify("move", dir, "character");
    let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;
    let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();
    let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) || oldNode == newNode && oldOff == newOff;
    try {
      sel.collapse(anchorNode, anchorOffset);
      if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)
        sel.extend(oldNode, oldOff);
    } catch (_2) {
    }
    if (oldBidiLevel != null)
      sel.caretBidiLevel = oldBidiLevel;
    return result;
  });
}
let cachedState = null;
let cachedDir = null;
let cachedResult = false;
function endOfTextblock(view, state2, dir) {
  if (cachedState == state2 && cachedDir == dir)
    return cachedResult;
  cachedState = state2;
  cachedDir = dir;
  return cachedResult = dir == "up" || dir == "down" ? endOfTextblockVertical(view, state2, dir) : endOfTextblockHorizontal(view, state2, dir);
}
const NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;
class ViewDesc {
  constructor(parent, children, dom, contentDOM) {
    this.parent = parent;
    this.children = children;
    this.dom = dom;
    this.contentDOM = contentDOM;
    this.dirty = NOT_DIRTY;
    dom.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(widget) {
    return false;
  }
  matchesMark(mark) {
    return false;
  }
  matchesNode(node2, outerDeco, innerDeco) {
    return false;
  }
  matchesHack(nodeName) {
    return false;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(event) {
    return false;
  }
  // The size of the content represented by this desc.
  get size() {
    let size2 = 0;
    for (let i = 0; i < this.children.length; i++)
      size2 += this.children[i].size;
    return size2;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0;
    if (this.dom.pmViewDesc == this)
      this.dom.pmViewDesc = void 0;
    for (let i = 0; i < this.children.length; i++)
      this.children[i].destroy();
  }
  posBeforeChild(child) {
    for (let i = 0, pos = this.posAtStart; ; i++) {
      let cur = this.children[i];
      if (cur == child)
        return pos;
      pos += cur.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(dom, offset2, bias) {
    if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {
      if (bias < 0) {
        let domBefore, desc;
        if (dom == this.contentDOM) {
          domBefore = dom.childNodes[offset2 - 1];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domBefore = dom.previousSibling;
        }
        while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))
          domBefore = domBefore.previousSibling;
        return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;
      } else {
        let domAfter, desc;
        if (dom == this.contentDOM) {
          domAfter = dom.childNodes[offset2];
        } else {
          while (dom.parentNode != this.contentDOM)
            dom = dom.parentNode;
          domAfter = dom.nextSibling;
        }
        while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))
          domAfter = domAfter.nextSibling;
        return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;
      }
    }
    let atEnd;
    if (dom == this.dom && this.contentDOM) {
      atEnd = offset2 > domIndex(this.contentDOM);
    } else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {
      atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;
    } else if (this.dom.firstChild) {
      if (offset2 == 0)
        for (let search2 = dom; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = false;
            break;
          }
          if (search2.previousSibling)
            break;
        }
      if (atEnd == null && offset2 == dom.childNodes.length)
        for (let search2 = dom; ; search2 = search2.parentNode) {
          if (search2 == this.dom) {
            atEnd = true;
            break;
          }
          if (search2.nextSibling)
            break;
        }
    }
    return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(dom, onlyNodes = false) {
    for (let first2 = true, cur = dom; cur; cur = cur.parentNode) {
      let desc = this.getDesc(cur), nodeDOM;
      if (desc && (!onlyNodes || desc.node)) {
        if (first2 && (nodeDOM = desc.nodeDOM) && !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))
          first2 = false;
        else
          return desc;
      }
    }
  }
  getDesc(dom) {
    let desc = dom.pmViewDesc;
    for (let cur = desc; cur; cur = cur.parent)
      if (cur == this)
        return desc;
  }
  posFromDOM(dom, offset2, bias) {
    for (let scan = dom; scan; scan = scan.parentNode) {
      let desc = this.getDesc(scan);
      if (desc)
        return desc.localPosFromDOM(dom, offset2, bias);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(pos) {
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == pos && end2 != offset2) {
        while (!child.border && child.children.length) {
          for (let i2 = 0; i2 < child.children.length; i2++) {
            let inner = child.children[i2];
            if (inner.size) {
              child = inner;
              break;
            }
          }
        }
        return child;
      }
      if (pos < end2)
        return child.descAt(pos - offset2 - child.border);
      offset2 = end2;
    }
  }
  domFromPos(pos, side) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: pos + 1 };
    let i = 0, offset2 = 0;
    for (let curPos = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = curPos + child.size;
      if (end2 > pos || child instanceof TrailingHackViewDesc) {
        offset2 = pos - curPos;
        break;
      }
      curPos = end2;
    }
    if (offset2)
      return this.children[i].domFromPos(offset2 - this.children[i].border, side);
    for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) {
    }
    if (side <= 0) {
      let prev, enter = true;
      for (; ; i--, enter = false) {
        prev = i ? this.children[i - 1] : null;
        if (!prev || prev.dom.parentNode == this.contentDOM)
          break;
      }
      if (prev && side && enter && !prev.border && !prev.domAtom)
        return prev.domFromPos(prev.size, side);
      return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };
    } else {
      let next, enter = true;
      for (; ; i++, enter = false) {
        next = i < this.children.length ? this.children[i] : null;
        if (!next || next.dom.parentNode == this.contentDOM)
          break;
      }
      if (next && enter && !next.border && !next.domAtom)
        return next.domFromPos(0, side);
      return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(from2, to, base2 = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: from2, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let fromOffset = -1, toOffset = -1;
    for (let offset2 = base2, i = 0; ; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (fromOffset == -1 && from2 <= end2) {
        let childBase = offset2 + child.border;
        if (from2 >= childBase && to <= end2 - child.border && child.node && child.contentDOM && this.contentDOM.contains(child.contentDOM))
          return child.parseRange(from2, to, childBase);
        from2 = offset2;
        for (let j2 = i; j2 > 0; j2--) {
          let prev = this.children[j2 - 1];
          if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {
            fromOffset = domIndex(prev.dom) + 1;
            break;
          }
          from2 -= prev.size;
        }
        if (fromOffset == -1)
          fromOffset = 0;
      }
      if (fromOffset > -1 && (end2 > to || i == this.children.length - 1)) {
        to = end2;
        for (let j2 = i + 1; j2 < this.children.length; j2++) {
          let next = this.children[j2];
          if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {
            toOffset = domIndex(next.dom);
            break;
          }
          to += next.size;
        }
        if (toOffset == -1)
          toOffset = this.contentDOM.childNodes.length;
        break;
      }
      offset2 = end2;
    }
    return { node: this.contentDOM, from: from2, to, fromOffset, toOffset };
  }
  emptyChildAt(side) {
    if (this.border || !this.contentDOM || !this.children.length)
      return false;
    let child = this.children[side < 0 ? 0 : this.children.length - 1];
    return child.size == 0 || child.emptyChildAt(side);
  }
  domAfterPos(pos) {
    let { node: node2, offset: offset2 } = this.domFromPos(pos, 0);
    if (node2.nodeType != 1 || offset2 == node2.childNodes.length)
      throw new RangeError("No node after pos " + pos);
    return node2.childNodes[offset2];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(anchor, head, view, force = false) {
    let from2 = Math.min(anchor, head), to = Math.max(anchor, head);
    for (let i = 0, offset2 = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (from2 > offset2 && to < end2)
        return child.setSelection(anchor - offset2 - child.border, head - offset2 - child.border, view, force);
      offset2 = end2;
    }
    let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);
    let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);
    let domSel = view.root.getSelection();
    let selRange = view.domSelectionRange();
    let brKludge = false;
    if ((gecko || safari) && anchor == head) {
      let { node: node2, offset: offset2 } = anchorDOM;
      if (node2.nodeType == 3) {
        brKludge = !!(offset2 && node2.nodeValue[offset2 - 1] == "\n");
        if (brKludge && offset2 == node2.nodeValue.length) {
          for (let scan = node2, after; scan; scan = scan.parentNode) {
            if (after = scan.nextSibling) {
              if (after.nodeName == "BR")
                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };
              break;
            }
            let desc = scan.pmViewDesc;
            if (desc && desc.node && desc.node.isBlock)
              break;
          }
        }
      } else {
        let prev = node2.childNodes[offset2 - 1];
        brKludge = prev && (prev.nodeName == "BR" || prev.contentEditable == "false");
      }
    }
    if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {
      let after = selRange.focusNode.childNodes[selRange.focusOffset];
      if (after && after.contentEditable == "false")
        force = true;
    }
    if (!(force || brKludge && safari) && isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) && isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))
      return;
    let domSelExtended = false;
    if ((domSel.extend || anchor == head) && !brKludge) {
      domSel.collapse(anchorDOM.node, anchorDOM.offset);
      try {
        if (anchor != head)
          domSel.extend(headDOM.node, headDOM.offset);
        domSelExtended = true;
      } catch (_2) {
      }
    }
    if (!domSelExtended) {
      if (anchor > head) {
        let tmp = anchorDOM;
        anchorDOM = headDOM;
        headDOM = tmp;
      }
      let range2 = document.createRange();
      range2.setEnd(headDOM.node, headDOM.offset);
      range2.setStart(anchorDOM.node, anchorDOM.offset);
      domSel.removeAllRanges();
      domSel.addRange(range2);
    }
  }
  ignoreMutation(mutation) {
    return !this.contentDOM && mutation.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(from2, to) {
    for (let offset2 = 0, i = 0; i < this.children.length; i++) {
      let child = this.children[i], end2 = offset2 + child.size;
      if (offset2 == end2 ? from2 <= end2 && to >= offset2 : from2 < end2 && to > offset2) {
        let startInside = offset2 + child.border, endInside = end2 - child.border;
        if (from2 >= startInside && to <= endInside) {
          this.dirty = from2 == offset2 || to == end2 ? CONTENT_DIRTY : CHILD_DIRTY;
          if (from2 == startInside && to == endInside && (child.contentLost || child.dom.parentNode != this.contentDOM))
            child.dirty = NODE_DIRTY;
          else
            child.markDirty(from2 - startInside, to - startInside);
          return;
        } else {
          child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length ? CONTENT_DIRTY : NODE_DIRTY;
        }
      }
      offset2 = end2;
    }
    this.dirty = CONTENT_DIRTY;
  }
  markParentsDirty() {
    let level = 1;
    for (let node2 = this.parent; node2; node2 = node2.parent, level++) {
      let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;
      if (node2.dirty < dirty)
        node2.dirty = dirty;
    }
  }
  get domAtom() {
    return false;
  }
  get ignoreForCoords() {
    return false;
  }
  get ignoreForSelection() {
    return false;
  }
  isText(text) {
    return false;
  }
}
class WidgetViewDesc extends ViewDesc {
  constructor(parent, widget, view, pos) {
    let self2, dom = widget.type.toDOM;
    if (typeof dom == "function")
      dom = dom(view, () => {
        if (!self2)
          return pos;
        if (self2.parent)
          return self2.parent.posBeforeChild(self2);
      });
    if (!widget.type.spec.raw) {
      if (dom.nodeType != 1) {
        let wrap2 = document.createElement("span");
        wrap2.appendChild(dom);
        dom = wrap2;
      }
      dom.contentEditable = "false";
      dom.classList.add("ProseMirror-widget");
    }
    super(parent, [], dom, null);
    this.widget = widget;
    this.widget = widget;
    self2 = this;
  }
  matchesWidget(widget) {
    return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: true };
  }
  stopEvent(event) {
    let stop = this.widget.spec.stopEvent;
    return stop ? stop(event) : false;
  }
  ignoreMutation(mutation) {
    return mutation.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom);
    super.destroy();
  }
  get domAtom() {
    return true;
  }
  get ignoreForSelection() {
    return !!this.widget.type.spec.relaxedSide;
  }
  get side() {
    return this.widget.type.side;
  }
}
class CompositionViewDesc extends ViewDesc {
  constructor(parent, dom, textDOM, text) {
    super(parent, [], dom, null);
    this.textDOM = textDOM;
    this.text = text;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(dom, offset2) {
    if (dom != this.textDOM)
      return this.posAtStart + (offset2 ? this.size : 0);
    return this.posAtStart + offset2;
  }
  domFromPos(pos) {
    return { node: this.textDOM, offset: pos };
  }
  ignoreMutation(mut) {
    return mut.type === "characterData" && mut.target.nodeValue == mut.oldValue;
  }
}
class MarkViewDesc extends ViewDesc {
  constructor(parent, mark, dom, contentDOM, spec) {
    super(parent, [], dom, contentDOM);
    this.mark = mark;
    this.spec = spec;
  }
  static create(parent, mark, inline, view) {
    let custom = view.nodeViews[mark.type.name];
    let spec = custom && custom(mark, view, inline);
    if (!spec || !spec.dom)
      spec = DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);
    return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);
  }
  parseRule() {
    if (this.dirty & NODE_DIRTY || this.mark.type.spec.reparseInView)
      return null;
    return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(mark) {
    return this.dirty != NODE_DIRTY && this.mark.eq(mark);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dirty != NOT_DIRTY) {
      let parent = this.parent;
      while (!parent.node)
        parent = parent.parent;
      if (parent.dirty < this.dirty)
        parent.dirty = this.dirty;
      this.dirty = NOT_DIRTY;
    }
  }
  slice(from2, to, view) {
    let copy2 = MarkViewDesc.create(this.parent, this.mark, true, view);
    let nodes = this.children, size2 = this.size;
    if (to < size2)
      nodes = replaceNodes(nodes, to, size2, view);
    if (from2 > 0)
      nodes = replaceNodes(nodes, 0, from2, view);
    for (let i = 0; i < nodes.length; i++)
      nodes[i].parent = copy2;
    copy2.children = nodes;
    return copy2;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
}
class NodeViewDesc extends ViewDesc {
  constructor(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {
    super(parent, [], dom, contentDOM);
    this.node = node2;
    this.outerDeco = outerDeco;
    this.innerDeco = innerDeco;
    this.nodeDOM = nodeDOM;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(parent, node2, outerDeco, innerDeco, view, pos) {
    let custom = view.nodeViews[node2.type.name], descObj;
    let spec = custom && custom(node2, view, () => {
      if (!descObj)
        return pos;
      if (descObj.parent)
        return descObj.parent.posBeforeChild(descObj);
    }, outerDeco, innerDeco);
    let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;
    if (node2.isText) {
      if (!dom)
        dom = document.createTextNode(node2.text);
      else if (dom.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else if (!dom) {
      let spec2 = DOMSerializer.renderSpec(document, node2.type.spec.toDOM(node2), null, node2.attrs);
      ({ dom, contentDOM } = spec2);
    }
    if (!contentDOM && !node2.isText && dom.nodeName != "BR") {
      if (!dom.hasAttribute("contenteditable"))
        dom.contentEditable = "false";
      if (node2.type.spec.draggable)
        dom.draggable = true;
    }
    let nodeDOM = dom;
    dom = applyOuterDeco(dom, outerDeco, node2);
    if (spec)
      return descObj = new CustomNodeViewDesc(parent, node2, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);
    else if (node2.isText)
      return new TextViewDesc(parent, node2, outerDeco, innerDeco, dom, nodeDOM, view);
    else
      return new NodeViewDesc(parent, node2, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let rule = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre")
      rule.preserveWhitespace = "full";
    if (!this.contentDOM) {
      rule.getContent = () => this.node.content;
    } else if (!this.contentLost) {
      rule.contentElement = this.contentDOM;
    } else {
      for (let i = this.children.length - 1; i >= 0; i--) {
        let child = this.children[i];
        if (this.dom.contains(child.dom.parentNode)) {
          rule.contentElement = child.dom.parentNode;
          break;
        }
      }
      if (!rule.contentElement)
        rule.getContent = () => Fragment.empty;
    }
    return rule;
  }
  matchesNode(node2, outerDeco, innerDeco) {
    return this.dirty == NOT_DIRTY && node2.eq(this.node) && sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(view, pos) {
    let inline = this.node.inlineContent, off2 = pos;
    let composition = view.composing ? this.localCompositionInfo(view, pos) : null;
    let localComposition = composition && composition.pos > -1 ? composition : null;
    let compositionInChild = composition && composition.pos < 0;
    let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);
    iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {
      if (widget.spec.marks)
        updater.syncToMarks(widget.spec.marks, inline, view);
      else if (widget.type.side >= 0 && !insideNode)
        updater.syncToMarks(i == this.node.childCount ? Mark$1.none : this.node.child(i).marks, inline, view);
      updater.placeWidget(widget, view, off2);
    }, (child, outerDeco, innerDeco, i) => {
      updater.syncToMarks(child.marks, inline, view);
      let compIndex;
      if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;
      else if (compositionInChild && view.state.selection.from > off2 && view.state.selection.to < off2 + child.nodeSize && (compIndex = updater.findIndexWithChild(composition.node)) > -1 && updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;
      else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off2)) ;
      else {
        updater.addNode(child, outerDeco, innerDeco, view, off2);
      }
      off2 += child.nodeSize;
    });
    updater.syncToMarks([], inline, view);
    if (this.node.isTextblock)
      updater.addTextblockHacks();
    updater.destroyRest();
    if (updater.changed || this.dirty == CONTENT_DIRTY) {
      if (localComposition)
        this.protectLocalComposition(view, localComposition);
      renderDescs(this.contentDOM, this.children, view);
      if (ios)
        iosHacks(this.dom);
    }
  }
  localCompositionInfo(view, pos) {
    let { from: from2, to } = view.state.selection;
    if (!(view.state.selection instanceof TextSelection$1) || from2 < pos || to > pos + this.node.content.size)
      return null;
    let textNode = view.input.compositionNode;
    if (!textNode || !this.dom.contains(textNode.parentNode))
      return null;
    if (this.node.inlineContent) {
      let text = textNode.nodeValue;
      let textPos = findTextInFragment(this.node.content, text, from2 - pos, to - pos);
      return textPos < 0 ? null : { node: textNode, pos: textPos, text };
    } else {
      return { node: textNode, pos: -1, text: "" };
    }
  }
  protectLocalComposition(view, { node: node2, pos, text }) {
    if (this.getDesc(node2))
      return;
    let topNode = node2;
    for (; ; topNode = topNode.parentNode) {
      if (topNode.parentNode == this.contentDOM)
        break;
      while (topNode.previousSibling)
        topNode.parentNode.removeChild(topNode.previousSibling);
      while (topNode.nextSibling)
        topNode.parentNode.removeChild(topNode.nextSibling);
      if (topNode.pmViewDesc)
        topNode.pmViewDesc = void 0;
    }
    let desc = new CompositionViewDesc(this, topNode, node2, text);
    view.input.compositionNodes.push(desc);
    this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(node2, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || !node2.sameMarkup(this.node))
      return false;
    this.updateInner(node2, outerDeco, innerDeco, view);
    return true;
  }
  updateInner(node2, outerDeco, innerDeco, view) {
    this.updateOuterDeco(outerDeco);
    this.node = node2;
    this.innerDeco = innerDeco;
    if (this.contentDOM)
      this.updateChildren(view, this.posAtStart);
    this.dirty = NOT_DIRTY;
  }
  updateOuterDeco(outerDeco) {
    if (sameOuterDeco(outerDeco, this.outerDeco))
      return;
    let needsWrap = this.nodeDOM.nodeType != 1;
    let oldDOM = this.dom;
    this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));
    if (this.dom != oldDOM) {
      oldDOM.pmViewDesc = void 0;
      this.dom.pmViewDesc = this;
    }
    this.outerDeco = outerDeco;
  }
  // Mark this node as being the selected node.
  selectNode() {
    if (this.nodeDOM.nodeType == 1)
      this.nodeDOM.classList.add("ProseMirror-selectednode");
    if (this.contentDOM || !this.node.type.spec.draggable)
      this.dom.draggable = true;
  }
  // Remove selected node marking from this node.
  deselectNode() {
    if (this.nodeDOM.nodeType == 1) {
      this.nodeDOM.classList.remove("ProseMirror-selectednode");
      if (this.contentDOM || !this.node.type.spec.draggable)
        this.dom.removeAttribute("draggable");
    }
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function docViewDesc(doc2, outerDeco, innerDeco, dom, view) {
  applyOuterDeco(dom, outerDeco, doc2);
  let docView = new NodeViewDesc(void 0, doc2, outerDeco, innerDeco, dom, dom, dom, view, 0);
  if (docView.contentDOM)
    docView.updateChildren(view, 0);
  return docView;
}
class TextViewDesc extends NodeViewDesc {
  constructor(parent, node2, outerDeco, innerDeco, dom, nodeDOM, view) {
    super(parent, node2, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);
  }
  parseRule() {
    let skip = this.nodeDOM.parentNode;
    while (skip && skip != this.dom && !skip.pmIsDeco)
      skip = skip.parentNode;
    return { skip: skip || true };
  }
  update(node2, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY || this.dirty != NOT_DIRTY && !this.inParent() || !node2.sameMarkup(this.node))
      return false;
    this.updateOuterDeco(outerDeco);
    if ((this.dirty != NOT_DIRTY || node2.text != this.node.text) && node2.text != this.nodeDOM.nodeValue) {
      this.nodeDOM.nodeValue = node2.text;
      if (view.trackWrites == this.nodeDOM)
        view.trackWrites = null;
    }
    this.node = node2;
    this.dirty = NOT_DIRTY;
    return true;
  }
  inParent() {
    let parentDOM = this.parent.contentDOM;
    for (let n = this.nodeDOM; n; n = n.parentNode)
      if (n == parentDOM)
        return true;
    return false;
  }
  domFromPos(pos) {
    return { node: this.nodeDOM, offset: pos };
  }
  localPosFromDOM(dom, offset2, bias) {
    if (dom == this.nodeDOM)
      return this.posAtStart + Math.min(offset2, this.node.text.length);
    return super.localPosFromDOM(dom, offset2, bias);
  }
  ignoreMutation(mutation) {
    return mutation.type != "characterData" && mutation.type != "selection";
  }
  slice(from2, to, view) {
    let node2 = this.node.cut(from2, to), dom = document.createTextNode(node2.text);
    return new TextViewDesc(this.parent, node2, this.outerDeco, this.innerDeco, dom, dom, view);
  }
  markDirty(from2, to) {
    super.markDirty(from2, to);
    if (this.dom != this.nodeDOM && (from2 == 0 || to == this.nodeDOM.nodeValue.length))
      this.dirty = NODE_DIRTY;
  }
  get domAtom() {
    return false;
  }
  isText(text) {
    return this.node.text == text;
  }
}
class TrailingHackViewDesc extends ViewDesc {
  parseRule() {
    return { ignore: true };
  }
  matchesHack(nodeName) {
    return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName;
  }
  get domAtom() {
    return true;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class CustomNodeViewDesc extends NodeViewDesc {
  constructor(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {
    super(parent, node2, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);
    this.spec = spec;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(node2, outerDeco, innerDeco, view) {
    if (this.dirty == NODE_DIRTY)
      return false;
    if (this.spec.update && (this.node.type == node2.type || this.spec.multiType)) {
      let result = this.spec.update(node2, outerDeco, innerDeco);
      if (result)
        this.updateInner(node2, outerDeco, innerDeco, view);
      return result;
    } else if (!this.contentDOM && !node2.isLeaf) {
      return false;
    } else {
      return super.update(node2, outerDeco, innerDeco, view);
    }
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(anchor, head, view, force) {
    this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root) : super.setSelection(anchor, head, view, force);
  }
  destroy() {
    if (this.spec.destroy)
      this.spec.destroy();
    super.destroy();
  }
  stopEvent(event) {
    return this.spec.stopEvent ? this.spec.stopEvent(event) : false;
  }
  ignoreMutation(mutation) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);
  }
}
function renderDescs(parentDOM, descs, view) {
  let dom = parentDOM.firstChild, written = false;
  for (let i = 0; i < descs.length; i++) {
    let desc = descs[i], childDOM = desc.dom;
    if (childDOM.parentNode == parentDOM) {
      while (childDOM != dom) {
        dom = rm(dom);
        written = true;
      }
      dom = dom.nextSibling;
    } else {
      written = true;
      parentDOM.insertBefore(childDOM, dom);
    }
    if (desc instanceof MarkViewDesc) {
      let pos = dom ? dom.previousSibling : parentDOM.lastChild;
      renderDescs(desc.contentDOM, desc.children, view);
      dom = pos ? pos.nextSibling : parentDOM.firstChild;
    }
  }
  while (dom) {
    dom = rm(dom);
    written = true;
  }
  if (written && view.trackWrites == parentDOM)
    view.trackWrites = null;
}
const OuterDecoLevel = function(nodeName) {
  if (nodeName)
    this.nodeName = nodeName;
};
OuterDecoLevel.prototype = /* @__PURE__ */ Object.create(null);
const noDeco = [new OuterDecoLevel()];
function computeOuterDeco(outerDeco, node2, needsWrap) {
  if (outerDeco.length == 0)
    return noDeco;
  let top2 = needsWrap ? noDeco[0] : new OuterDecoLevel(), result = [top2];
  for (let i = 0; i < outerDeco.length; i++) {
    let attrs = outerDeco[i].type.attrs;
    if (!attrs)
      continue;
    if (attrs.nodeName)
      result.push(top2 = new OuterDecoLevel(attrs.nodeName));
    for (let name in attrs) {
      let val = attrs[name];
      if (val == null)
        continue;
      if (needsWrap && result.length == 1)
        result.push(top2 = new OuterDecoLevel(node2.isInline ? "span" : "div"));
      if (name == "class")
        top2.class = (top2.class ? top2.class + " " : "") + val;
      else if (name == "style")
        top2.style = (top2.style ? top2.style + ";" : "") + val;
      else if (name != "nodeName")
        top2[name] = val;
    }
  }
  return result;
}
function patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {
  if (prevComputed == noDeco && curComputed == noDeco)
    return nodeDOM;
  let curDOM = nodeDOM;
  for (let i = 0; i < curComputed.length; i++) {
    let deco = curComputed[i], prev = prevComputed[i];
    if (i) {
      let parent;
      if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM && (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {
        curDOM = parent;
      } else {
        parent = document.createElement(deco.nodeName);
        parent.pmIsDeco = true;
        parent.appendChild(curDOM);
        prev = noDeco[0];
        curDOM = parent;
      }
    }
    patchAttributes(curDOM, prev || noDeco[0], deco);
  }
  return curDOM;
}
function patchAttributes(dom, prev, cur) {
  for (let name in prev)
    if (name != "class" && name != "style" && name != "nodeName" && !(name in cur))
      dom.removeAttribute(name);
  for (let name in cur)
    if (name != "class" && name != "style" && name != "nodeName" && cur[name] != prev[name])
      dom.setAttribute(name, cur[name]);
  if (prev.class != cur.class) {
    let prevList = prev.class ? prev.class.split(" ").filter(Boolean) : [];
    let curList = cur.class ? cur.class.split(" ").filter(Boolean) : [];
    for (let i = 0; i < prevList.length; i++)
      if (curList.indexOf(prevList[i]) == -1)
        dom.classList.remove(prevList[i]);
    for (let i = 0; i < curList.length; i++)
      if (prevList.indexOf(curList[i]) == -1)
        dom.classList.add(curList[i]);
    if (dom.classList.length == 0)
      dom.removeAttribute("class");
  }
  if (prev.style != cur.style) {
    if (prev.style) {
      let prop = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, m2;
      while (m2 = prop.exec(prev.style))
        dom.style.removeProperty(m2[1]);
    }
    if (cur.style)
      dom.style.cssText += cur.style;
  }
}
function applyOuterDeco(dom, deco, node2) {
  return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node2, dom.nodeType != 1));
}
function sameOuterDeco(a, b2) {
  if (a.length != b2.length)
    return false;
  for (let i = 0; i < a.length; i++)
    if (!a[i].type.eq(b2[i].type))
      return false;
  return true;
}
function rm(dom) {
  let next = dom.nextSibling;
  dom.parentNode.removeChild(dom);
  return next;
}
class ViewTreeUpdater {
  constructor(top2, lock, view) {
    this.lock = lock;
    this.view = view;
    this.index = 0;
    this.stack = [];
    this.changed = false;
    this.top = top2;
    this.preMatch = preMatch(top2.node.content, top2);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(start2, end2) {
    if (start2 == end2)
      return;
    for (let i = start2; i < end2; i++)
      this.top.children[i].destroy();
    this.top.children.splice(start2, end2 - start2);
    this.changed = true;
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(marks, inline, view) {
    let keep2 = 0, depth = this.stack.length >> 1;
    let maxKeep = Math.min(depth, marks.length);
    while (keep2 < maxKeep && (keep2 == depth - 1 ? this.top : this.stack[keep2 + 1 << 1]).matchesMark(marks[keep2]) && marks[keep2].type.spec.spanning !== false)
      keep2++;
    while (keep2 < depth) {
      this.destroyRest();
      this.top.dirty = NOT_DIRTY;
      this.index = this.stack.pop();
      this.top = this.stack.pop();
      depth--;
    }
    while (depth < marks.length) {
      this.stack.push(this.top, this.index + 1);
      let found2 = -1;
      for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {
        let next = this.top.children[i];
        if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {
          found2 = i;
          break;
        }
      }
      if (found2 > -1) {
        if (found2 > this.index) {
          this.changed = true;
          this.destroyBetween(this.index, found2);
        }
        this.top = this.top.children[this.index];
      } else {
        let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);
        this.top.children.splice(this.index, 0, markDesc);
        this.top = markDesc;
        this.changed = true;
      }
      this.index = 0;
      depth++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(node2, outerDeco, innerDeco, index2) {
    let found2 = -1, targetDesc;
    if (index2 >= this.preMatch.index && (targetDesc = this.preMatch.matches[index2 - this.preMatch.index]).parent == this.top && targetDesc.matchesNode(node2, outerDeco, innerDeco)) {
      found2 = this.top.children.indexOf(targetDesc, this.index);
    } else {
      for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {
        let child = this.top.children[i];
        if (child.matchesNode(node2, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {
          found2 = i;
          break;
        }
      }
    }
    if (found2 < 0)
      return false;
    this.destroyBetween(this.index, found2);
    this.index++;
    return true;
  }
  updateNodeAt(node2, outerDeco, innerDeco, index2, view) {
    let child = this.top.children[index2];
    if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)
      child.dirty = CONTENT_DIRTY;
    if (!child.update(node2, outerDeco, innerDeco, view))
      return false;
    this.destroyBetween(this.index, index2);
    this.index++;
    return true;
  }
  findIndexWithChild(domNode) {
    for (; ; ) {
      let parent = domNode.parentNode;
      if (!parent)
        return -1;
      if (parent == this.top.contentDOM) {
        let desc = domNode.pmViewDesc;
        if (desc)
          for (let i = this.index; i < this.top.children.length; i++) {
            if (this.top.children[i] == desc)
              return i;
          }
        return -1;
      }
      domNode = parent;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(node2, outerDeco, innerDeco, view, index2, pos) {
    for (let i = this.index; i < this.top.children.length; i++) {
      let next = this.top.children[i];
      if (next instanceof NodeViewDesc) {
        let preMatch2 = this.preMatch.matched.get(next);
        if (preMatch2 != null && preMatch2 != index2)
          return false;
        let nextDOM = next.dom, updated;
        let locked = this.isLocked(nextDOM) && !(node2.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node2.text && next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));
        if (!locked && next.update(node2, outerDeco, innerDeco, view)) {
          this.destroyBetween(this.index, i);
          if (next.dom != nextDOM)
            this.changed = true;
          this.index++;
          return true;
        } else if (!locked && (updated = this.recreateWrapper(next, node2, outerDeco, innerDeco, view, pos))) {
          this.destroyBetween(this.index, i);
          this.top.children[this.index] = updated;
          if (updated.contentDOM) {
            updated.dirty = CONTENT_DIRTY;
            updated.updateChildren(view, pos + 1);
            updated.dirty = NOT_DIRTY;
          }
          this.changed = true;
          this.index++;
          return true;
        }
        break;
      }
    }
    return false;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(next, node2, outerDeco, innerDeco, view, pos) {
    if (next.dirty || node2.isAtom || !next.children.length || !next.node.content.eq(node2.content) || !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))
      return null;
    let wrapper = NodeViewDesc.create(this.top, node2, outerDeco, innerDeco, view, pos);
    if (wrapper.contentDOM) {
      wrapper.children = next.children;
      next.children = [];
      for (let ch of wrapper.children)
        ch.parent = wrapper;
    }
    next.destroy();
    return wrapper;
  }
  // Insert the node as a newly created node desc.
  addNode(node2, outerDeco, innerDeco, view, pos) {
    let desc = NodeViewDesc.create(this.top, node2, outerDeco, innerDeco, view, pos);
    if (desc.contentDOM)
      desc.updateChildren(view, pos + 1);
    this.top.children.splice(this.index++, 0, desc);
    this.changed = true;
  }
  placeWidget(widget, view, pos) {
    let next = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (next && next.matchesWidget(widget) && (widget == next.widget || !next.widget.type.toDOM.parentNode)) {
      this.index++;
    } else {
      let desc = new WidgetViewDesc(this.top, widget, view, pos);
      this.top.children.splice(this.index++, 0, desc);
      this.changed = true;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let lastChild = this.top.children[this.index - 1], parent = this.top;
    while (lastChild instanceof MarkViewDesc) {
      parent = lastChild;
      lastChild = parent.children[parent.children.length - 1];
    }
    if (!lastChild || // Empty textblock
    !(lastChild instanceof TextViewDesc) || /\n$/.test(lastChild.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(lastChild.node.text)) {
      if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == "false")
        this.addHackNode("IMG", parent);
      this.addHackNode("BR", this.top);
    }
  }
  addHackNode(nodeName, parent) {
    if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {
      this.index++;
    } else {
      let dom = document.createElement(nodeName);
      if (nodeName == "IMG") {
        dom.className = "ProseMirror-separator";
        dom.alt = "";
      }
      if (nodeName == "BR")
        dom.className = "ProseMirror-trailingBreak";
      let hack = new TrailingHackViewDesc(this.top, [], dom, null);
      if (parent != this.top)
        parent.children.push(hack);
      else
        parent.children.splice(this.index++, 0, hack);
      this.changed = true;
    }
  }
  isLocked(node2) {
    return this.lock && (node2 == this.lock || node2.nodeType == 1 && node2.contains(this.lock.parentNode));
  }
}
function preMatch(frag, parentDesc) {
  let curDesc = parentDesc, descI = curDesc.children.length;
  let fI = frag.childCount, matched = /* @__PURE__ */ new Map(), matches2 = [];
  outer: while (fI > 0) {
    let desc;
    for (; ; ) {
      if (descI) {
        let next = curDesc.children[descI - 1];
        if (next instanceof MarkViewDesc) {
          curDesc = next;
          descI = next.children.length;
        } else {
          desc = next;
          descI--;
          break;
        }
      } else if (curDesc == parentDesc) {
        break outer;
      } else {
        descI = curDesc.parent.children.indexOf(curDesc);
        curDesc = curDesc.parent;
      }
    }
    let node2 = desc.node;
    if (!node2)
      continue;
    if (node2 != frag.child(fI - 1))
      break;
    --fI;
    matched.set(desc, fI);
    matches2.push(desc);
  }
  return { index: fI, matched, matches: matches2.reverse() };
}
function compareSide(a, b2) {
  return a.type.side - b2.type.side;
}
function iterDeco(parent, deco, onWidget, onNode) {
  let locals = deco.locals(parent), offset2 = 0;
  if (locals.length == 0) {
    for (let i = 0; i < parent.childCount; i++) {
      let child = parent.child(i);
      onNode(child, locals, deco.forChild(offset2, child), i);
      offset2 += child.nodeSize;
    }
    return;
  }
  let decoIndex = 0, active = [], restNode = null;
  for (let parentIndex = 0; ; ) {
    let widget, widgets;
    while (decoIndex < locals.length && locals[decoIndex].to == offset2) {
      let next = locals[decoIndex++];
      if (next.widget) {
        if (!widget)
          widget = next;
        else
          (widgets || (widgets = [widget])).push(next);
      }
    }
    if (widget) {
      if (widgets) {
        widgets.sort(compareSide);
        for (let i = 0; i < widgets.length; i++)
          onWidget(widgets[i], parentIndex, !!restNode);
      } else {
        onWidget(widget, parentIndex, !!restNode);
      }
    }
    let child, index2;
    if (restNode) {
      index2 = -1;
      child = restNode;
      restNode = null;
    } else if (parentIndex < parent.childCount) {
      index2 = parentIndex;
      child = parent.child(parentIndex++);
    } else {
      break;
    }
    for (let i = 0; i < active.length; i++)
      if (active[i].to <= offset2)
        active.splice(i--, 1);
    while (decoIndex < locals.length && locals[decoIndex].from <= offset2 && locals[decoIndex].to > offset2)
      active.push(locals[decoIndex++]);
    let end2 = offset2 + child.nodeSize;
    if (child.isText) {
      let cutAt = end2;
      if (decoIndex < locals.length && locals[decoIndex].from < cutAt)
        cutAt = locals[decoIndex].from;
      for (let i = 0; i < active.length; i++)
        if (active[i].to < cutAt)
          cutAt = active[i].to;
      if (cutAt < end2) {
        restNode = child.cut(cutAt - offset2);
        child = child.cut(0, cutAt - offset2);
        end2 = cutAt;
        index2 = -1;
      }
    } else {
      while (decoIndex < locals.length && locals[decoIndex].to < end2)
        decoIndex++;
    }
    let outerDeco = child.isInline && !child.isLeaf ? active.filter((d2) => !d2.inline) : active.slice();
    onNode(child, outerDeco, deco.forChild(offset2, child), index2);
    offset2 = end2;
  }
}
function iosHacks(dom) {
  if (dom.nodeName == "UL" || dom.nodeName == "OL") {
    let oldCSS = dom.style.cssText;
    dom.style.cssText = oldCSS + "; list-style: square !important";
    window.getComputedStyle(dom).listStyle;
    dom.style.cssText = oldCSS;
  }
}
function findTextInFragment(frag, text, from2, to) {
  for (let i = 0, pos = 0; i < frag.childCount && pos <= to; ) {
    let child = frag.child(i++), childStart = pos;
    pos += child.nodeSize;
    if (!child.isText)
      continue;
    let str = child.text;
    while (i < frag.childCount) {
      let next = frag.child(i++);
      pos += next.nodeSize;
      if (!next.isText)
        break;
      str += next.text;
    }
    if (pos >= from2) {
      if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)
        return to - text.length;
      let found2 = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;
      if (found2 >= 0 && found2 + text.length + childStart >= from2)
        return childStart + found2;
      if (from2 == to && str.length >= to + text.length - childStart && str.slice(to - childStart, to - childStart + text.length) == text)
        return to;
    }
  }
  return -1;
}
function replaceNodes(nodes, from2, to, view, replacement) {
  let result = [];
  for (let i = 0, off2 = 0; i < nodes.length; i++) {
    let child = nodes[i], start2 = off2, end2 = off2 += child.size;
    if (start2 >= to || end2 <= from2) {
      result.push(child);
    } else {
      if (start2 < from2)
        result.push(child.slice(0, from2 - start2, view));
      if (replacement) {
        result.push(replacement);
        replacement = void 0;
      }
      if (end2 > to)
        result.push(child.slice(to - start2, child.size, view));
    }
  }
  return result;
}
function selectionFromDOM(view, origin = null) {
  let domSel = view.domSelectionRange(), doc2 = view.state.doc;
  if (!domSel.focusNode)
    return null;
  let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;
  let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);
  if (head < 0)
    return null;
  let $head = doc2.resolve(head), anchor, selection;
  if (selectionCollapsed(domSel)) {
    anchor = head;
    while (nearestDesc && !nearestDesc.node)
      nearestDesc = nearestDesc.parent;
    let nearestDescNode = nearestDesc.node;
    if (nearestDesc && nearestDescNode.isAtom && NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {
      let pos = nearestDesc.posBefore;
      selection = new NodeSelection(head == pos ? $head : doc2.resolve(pos));
    }
  } else {
    if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {
      let min2 = head, max2 = head;
      for (let i = 0; i < domSel.rangeCount; i++) {
        let range2 = domSel.getRangeAt(i);
        min2 = Math.min(min2, view.docView.posFromDOM(range2.startContainer, range2.startOffset, 1));
        max2 = Math.max(max2, view.docView.posFromDOM(range2.endContainer, range2.endOffset, -1));
      }
      if (min2 < 0)
        return null;
      [anchor, head] = max2 == view.state.selection.anchor ? [max2, min2] : [min2, max2];
      $head = doc2.resolve(head);
    } else {
      anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);
    }
    if (anchor < 0)
      return null;
  }
  let $anchor = doc2.resolve(anchor);
  if (!selection) {
    let bias = origin == "pointer" || view.state.selection.head < $head.pos && !inWidget ? 1 : -1;
    selection = selectionBetween(view, $anchor, $head, bias);
  }
  return selection;
}
function editorOwnsSelection(view) {
  return view.editable ? view.hasFocus() : hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);
}
function selectionToDOM(view, force = false) {
  let sel = view.state.selection;
  syncNodeSelection(view, sel);
  if (!editorOwnsSelection(view))
    return;
  if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {
    let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;
    if (domSel.anchorNode && curSel.anchorNode && isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {
      view.input.mouseDown.delayedSelectionSync = true;
      view.domObserver.setCurSelection();
      return;
    }
  }
  view.domObserver.disconnectSelection();
  if (view.cursorWrapper) {
    selectCursorWrapper(view);
  } else {
    let { anchor, head } = sel, resetEditableFrom, resetEditableTo;
    if (brokenSelectBetweenUneditable && !(sel instanceof TextSelection$1)) {
      if (!sel.$from.parent.inlineContent)
        resetEditableFrom = temporarilyEditableNear(view, sel.from);
      if (!sel.empty && !sel.$from.parent.inlineContent)
        resetEditableTo = temporarilyEditableNear(view, sel.to);
    }
    view.docView.setSelection(anchor, head, view, force);
    if (brokenSelectBetweenUneditable) {
      if (resetEditableFrom)
        resetEditable(resetEditableFrom);
      if (resetEditableTo)
        resetEditable(resetEditableTo);
    }
    if (sel.visible) {
      view.dom.classList.remove("ProseMirror-hideselection");
    } else {
      view.dom.classList.add("ProseMirror-hideselection");
      if ("onselectionchange" in document)
        removeClassOnSelectionChange(view);
    }
  }
  view.domObserver.setCurSelection();
  view.domObserver.connectSelection();
}
const brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;
function temporarilyEditableNear(view, pos) {
  let { node: node2, offset: offset2 } = view.docView.domFromPos(pos, 0);
  let after = offset2 < node2.childNodes.length ? node2.childNodes[offset2] : null;
  let before = offset2 ? node2.childNodes[offset2 - 1] : null;
  if (safari && after && after.contentEditable == "false")
    return setEditable(after);
  if ((!after || after.contentEditable == "false") && (!before || before.contentEditable == "false")) {
    if (after)
      return setEditable(after);
    else if (before)
      return setEditable(before);
  }
}
function setEditable(element) {
  element.contentEditable = "true";
  if (safari && element.draggable) {
    element.draggable = false;
    element.wasDraggable = true;
  }
  return element;
}
function resetEditable(element) {
  element.contentEditable = "false";
  if (element.wasDraggable) {
    element.draggable = true;
    element.wasDraggable = null;
  }
}
function removeClassOnSelectionChange(view) {
  let doc2 = view.dom.ownerDocument;
  doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
  let domSel = view.domSelectionRange();
  let node2 = domSel.anchorNode, offset2 = domSel.anchorOffset;
  doc2.addEventListener("selectionchange", view.input.hideSelectionGuard = () => {
    if (domSel.anchorNode != node2 || domSel.anchorOffset != offset2) {
      doc2.removeEventListener("selectionchange", view.input.hideSelectionGuard);
      setTimeout(() => {
        if (!editorOwnsSelection(view) || view.state.selection.visible)
          view.dom.classList.remove("ProseMirror-hideselection");
      }, 20);
    }
  });
}
function selectCursorWrapper(view) {
  let domSel = view.domSelection(), range2 = document.createRange();
  if (!domSel)
    return;
  let node2 = view.cursorWrapper.dom, img = node2.nodeName == "IMG";
  if (img)
    range2.setStart(node2.parentNode, domIndex(node2) + 1);
  else
    range2.setStart(node2, 0);
  range2.collapse(true);
  domSel.removeAllRanges();
  domSel.addRange(range2);
  if (!img && !view.state.selection.visible && ie$1 && ie_version <= 11) {
    node2.disabled = true;
    node2.disabled = false;
  }
}
function syncNodeSelection(view, sel) {
  if (sel instanceof NodeSelection) {
    let desc = view.docView.descAt(sel.from);
    if (desc != view.lastSelectedViewDesc) {
      clearNodeSelection(view);
      if (desc)
        desc.selectNode();
      view.lastSelectedViewDesc = desc;
    }
  } else {
    clearNodeSelection(view);
  }
}
function clearNodeSelection(view) {
  if (view.lastSelectedViewDesc) {
    if (view.lastSelectedViewDesc.parent)
      view.lastSelectedViewDesc.deselectNode();
    view.lastSelectedViewDesc = void 0;
  }
}
function selectionBetween(view, $anchor, $head, bias) {
  return view.someProp("createSelectionBetween", (f) => f(view, $anchor, $head)) || TextSelection$1.between($anchor, $head, bias);
}
function hasFocusAndSelection(view) {
  if (view.editable && !view.hasFocus())
    return false;
  return hasSelection(view);
}
function hasSelection(view) {
  let sel = view.domSelectionRange();
  if (!sel.anchorNode)
    return false;
  try {
    return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) && (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));
  } catch (_2) {
    return false;
  }
}
function anchorInRightPlace(view) {
  let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);
  let domSel = view.domSelectionRange();
  return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);
}
function moveSelectionBlock(state2, dir) {
  let { $anchor, $head } = state2.selection;
  let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);
  let $start = !$side.parent.inlineContent ? $side : $side.depth ? state2.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;
  return $start && Selection.findFrom($start, dir);
}
function apply$1(view, sel) {
  view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());
  return true;
}
function selectHorizontally(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection$1) {
    if (mods.indexOf("s") > -1) {
      let { $head } = sel, node2 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;
      if (!node2 || node2.isText || !node2.isLeaf)
        return false;
      let $newHead = view.state.doc.resolve($head.pos + node2.nodeSize * (dir < 0 ? -1 : 1));
      return apply$1(view, new TextSelection$1(sel.$anchor, $newHead));
    } else if (!sel.empty) {
      return false;
    } else if (view.endOfTextblock(dir > 0 ? "forward" : "backward")) {
      let next = moveSelectionBlock(view.state, dir);
      if (next && next instanceof NodeSelection)
        return apply$1(view, next);
      return false;
    } else if (!(mac$2 && mods.indexOf("m") > -1)) {
      let $head = sel.$head, node2 = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;
      if (!node2 || node2.isText)
        return false;
      let nodePos = dir < 0 ? $head.pos - node2.nodeSize : $head.pos;
      if (!(node2.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))
        return false;
      if (NodeSelection.isSelectable(node2)) {
        return apply$1(view, new NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node2.nodeSize) : $head));
      } else if (webkit) {
        return apply$1(view, new TextSelection$1(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node2.nodeSize)));
      } else {
        return false;
      }
    }
  } else if (sel instanceof NodeSelection && sel.node.isInline) {
    return apply$1(view, new TextSelection$1(dir > 0 ? sel.$to : sel.$from));
  } else {
    let next = moveSelectionBlock(view.state, dir);
    if (next)
      return apply$1(view, next);
    return false;
  }
}
function nodeLen(node2) {
  return node2.nodeType == 3 ? node2.nodeValue.length : node2.childNodes.length;
}
function isIgnorable(dom, dir) {
  let desc = dom.pmViewDesc;
  return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != "BR");
}
function skipIgnoredNodes(view, dir) {
  return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);
}
function skipIgnoredNodesBefore(view) {
  let sel = view.domSelectionRange();
  let node2 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node2)
    return;
  let moveNode, moveOffset, force = false;
  if (gecko && node2.nodeType == 1 && offset2 < nodeLen(node2) && isIgnorable(node2.childNodes[offset2], -1))
    force = true;
  for (; ; ) {
    if (offset2 > 0) {
      if (node2.nodeType != 1) {
        break;
      } else {
        let before = node2.childNodes[offset2 - 1];
        if (isIgnorable(before, -1)) {
          moveNode = node2;
          moveOffset = --offset2;
        } else if (before.nodeType == 3) {
          node2 = before;
          offset2 = node2.nodeValue.length;
        } else
          break;
      }
    } else if (isBlockNode(node2)) {
      break;
    } else {
      let prev = node2.previousSibling;
      while (prev && isIgnorable(prev, -1)) {
        moveNode = node2.parentNode;
        moveOffset = domIndex(prev);
        prev = prev.previousSibling;
      }
      if (!prev) {
        node2 = node2.parentNode;
        if (node2 == view.dom)
          break;
        offset2 = 0;
      } else {
        node2 = prev;
        offset2 = nodeLen(node2);
      }
    }
  }
  if (force)
    setSelFocus(view, node2, offset2);
  else if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function skipIgnoredNodesAfter(view) {
  let sel = view.domSelectionRange();
  let node2 = sel.focusNode, offset2 = sel.focusOffset;
  if (!node2)
    return;
  let len = nodeLen(node2);
  let moveNode, moveOffset;
  for (; ; ) {
    if (offset2 < len) {
      if (node2.nodeType != 1)
        break;
      let after = node2.childNodes[offset2];
      if (isIgnorable(after, 1)) {
        moveNode = node2;
        moveOffset = ++offset2;
      } else
        break;
    } else if (isBlockNode(node2)) {
      break;
    } else {
      let next = node2.nextSibling;
      while (next && isIgnorable(next, 1)) {
        moveNode = next.parentNode;
        moveOffset = domIndex(next) + 1;
        next = next.nextSibling;
      }
      if (!next) {
        node2 = node2.parentNode;
        if (node2 == view.dom)
          break;
        offset2 = len = 0;
      } else {
        node2 = next;
        offset2 = 0;
        len = nodeLen(node2);
      }
    }
  }
  if (moveNode)
    setSelFocus(view, moveNode, moveOffset);
}
function isBlockNode(dom) {
  let desc = dom.pmViewDesc;
  return desc && desc.node && desc.node.isBlock;
}
function textNodeAfter(node2, offset2) {
  while (node2 && offset2 == node2.childNodes.length && !hasBlockDesc(node2)) {
    offset2 = domIndex(node2) + 1;
    node2 = node2.parentNode;
  }
  while (node2 && offset2 < node2.childNodes.length) {
    let next = node2.childNodes[offset2];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node2 = next;
    offset2 = 0;
  }
}
function textNodeBefore(node2, offset2) {
  while (node2 && !offset2 && !hasBlockDesc(node2)) {
    offset2 = domIndex(node2);
    node2 = node2.parentNode;
  }
  while (node2 && offset2) {
    let next = node2.childNodes[offset2 - 1];
    if (next.nodeType == 3)
      return next;
    if (next.nodeType == 1 && next.contentEditable == "false")
      break;
    node2 = next;
    offset2 = node2.childNodes.length;
  }
}
function setSelFocus(view, node2, offset2) {
  if (node2.nodeType != 3) {
    let before, after;
    if (after = textNodeAfter(node2, offset2)) {
      node2 = after;
      offset2 = 0;
    } else if (before = textNodeBefore(node2, offset2)) {
      node2 = before;
      offset2 = before.nodeValue.length;
    }
  }
  let sel = view.domSelection();
  if (!sel)
    return;
  if (selectionCollapsed(sel)) {
    let range2 = document.createRange();
    range2.setEnd(node2, offset2);
    range2.setStart(node2, offset2);
    sel.removeAllRanges();
    sel.addRange(range2);
  } else if (sel.extend) {
    sel.extend(node2, offset2);
  }
  view.domObserver.setCurSelection();
  let { state: state2 } = view;
  setTimeout(() => {
    if (view.state == state2)
      selectionToDOM(view);
  }, 50);
}
function findDirection(view, pos) {
  let $pos = view.state.doc.resolve(pos);
  if (!(chrome || windows$1) && $pos.parent.inlineContent) {
    let coords = view.coordsAtPos(pos);
    if (pos > $pos.start()) {
      let before = view.coordsAtPos(pos - 1);
      let mid = (before.top + before.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)
        return before.left < coords.left ? "ltr" : "rtl";
    }
    if (pos < $pos.end()) {
      let after = view.coordsAtPos(pos + 1);
      let mid = (after.top + after.bottom) / 2;
      if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)
        return after.left > coords.left ? "ltr" : "rtl";
    }
  }
  let computed2 = getComputedStyle(view.dom).direction;
  return computed2 == "rtl" ? "rtl" : "ltr";
}
function selectVertically(view, dir, mods) {
  let sel = view.state.selection;
  if (sel instanceof TextSelection$1 && !sel.empty || mods.indexOf("s") > -1)
    return false;
  if (mac$2 && mods.indexOf("m") > -1)
    return false;
  let { $from, $to } = sel;
  if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? "up" : "down")) {
    let next = moveSelectionBlock(view.state, dir);
    if (next && next instanceof NodeSelection)
      return apply$1(view, next);
  }
  if (!$from.parent.inlineContent) {
    let side = dir < 0 ? $from : $to;
    let beyond = sel instanceof AllSelection ? Selection.near(side, dir) : Selection.findFrom(side, dir);
    return beyond ? apply$1(view, beyond) : false;
  }
  return false;
}
function stopNativeHorizontalDelete(view, dir) {
  if (!(view.state.selection instanceof TextSelection$1))
    return true;
  let { $head, $anchor, empty: empty2 } = view.state.selection;
  if (!$head.sameParent($anchor))
    return true;
  if (!empty2)
    return false;
  if (view.endOfTextblock(dir > 0 ? "forward" : "backward"))
    return true;
  let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);
  if (nextNode && !nextNode.isText) {
    let tr = view.state.tr;
    if (dir < 0)
      tr.delete($head.pos - nextNode.nodeSize, $head.pos);
    else
      tr.delete($head.pos, $head.pos + nextNode.nodeSize);
    view.dispatch(tr);
    return true;
  }
  return false;
}
function switchEditable(view, node2, state2) {
  view.domObserver.stop();
  node2.contentEditable = state2;
  view.domObserver.start();
}
function safariDownArrowBug(view) {
  if (!safari || view.state.selection.$head.parentOffset > 0)
    return false;
  let { focusNode, focusOffset } = view.domSelectionRange();
  if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 && focusNode.firstChild && focusNode.firstChild.contentEditable == "false") {
    let child = focusNode.firstChild;
    switchEditable(view, child, "true");
    setTimeout(() => switchEditable(view, child, "false"), 20);
  }
  return false;
}
function getMods(event) {
  let result = "";
  if (event.ctrlKey)
    result += "c";
  if (event.metaKey)
    result += "m";
  if (event.altKey)
    result += "a";
  if (event.shiftKey)
    result += "s";
  return result;
}
function captureKeyDown(view, event) {
  let code = event.keyCode, mods = getMods(event);
  if (code == 8 || mac$2 && code == 72 && mods == "c") {
    return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);
  } else if (code == 46 && !event.shiftKey || mac$2 && code == 68 && mods == "c") {
    return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);
  } else if (code == 13 || code == 27) {
    return true;
  } else if (code == 37 || mac$2 && code == 66 && mods == "c") {
    let dir = code == 37 ? findDirection(view, view.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 39 || mac$2 && code == 70 && mods == "c") {
    let dir = code == 39 ? findDirection(view, view.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);
  } else if (code == 38 || mac$2 && code == 80 && mods == "c") {
    return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);
  } else if (code == 40 || mac$2 && code == 78 && mods == "c") {
    return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);
  } else if (mods == (mac$2 ? "m" : "c") && (code == 66 || code == 73 || code == 89 || code == 90)) {
    return true;
  }
  return false;
}
function serializeForClipboard(view, slice2) {
  view.someProp("transformCopied", (f) => {
    slice2 = f(slice2, view);
  });
  let context = [], { content, openStart, openEnd } = slice2;
  while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {
    openStart--;
    openEnd--;
    let node2 = content.firstChild;
    context.push(node2.type.name, node2.attrs != node2.type.defaultAttrs ? node2.attrs : null);
    content = node2.content;
  }
  let serializer = view.someProp("clipboardSerializer") || DOMSerializer.fromSchema(view.state.schema);
  let doc2 = detachedDoc(), wrap2 = doc2.createElement("div");
  wrap2.appendChild(serializer.serializeFragment(content, { document: doc2 }));
  let firstChild = wrap2.firstChild, needsWrap, wrappers = 0;
  while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {
    for (let i = needsWrap.length - 1; i >= 0; i--) {
      let wrapper = doc2.createElement(needsWrap[i]);
      while (wrap2.firstChild)
        wrapper.appendChild(wrap2.firstChild);
      wrap2.appendChild(wrapper);
      wrappers++;
    }
    firstChild = wrap2.firstChild;
  }
  if (firstChild && firstChild.nodeType == 1)
    firstChild.setAttribute("data-pm-slice", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : ""} ${JSON.stringify(context)}`);
  let text = view.someProp("clipboardTextSerializer", (f) => f(slice2, view)) || slice2.content.textBetween(0, slice2.content.size, "\n\n");
  return { dom: wrap2, text, slice: slice2 };
}
function parseFromClipboard(view, text, html, plainText, $context) {
  let inCode = $context.parent.type.spec.code;
  let dom, slice2;
  if (!html && !text)
    return null;
  let asText = text && (plainText || inCode || !html);
  if (asText) {
    view.someProp("transformPastedText", (f) => {
      text = f(text, inCode || plainText, view);
    });
    if (inCode)
      return text ? new Slice(Fragment.from(view.state.schema.text(text.replace(/\r\n?/g, "\n"))), 0, 0) : Slice.empty;
    let parsed = view.someProp("clipboardTextParser", (f) => f(text, $context, plainText, view));
    if (parsed) {
      slice2 = parsed;
    } else {
      let marks = $context.marks();
      let { schema } = view.state, serializer = DOMSerializer.fromSchema(schema);
      dom = document.createElement("div");
      text.split(/(?:\r\n?|\n)+/).forEach((block) => {
        let p = dom.appendChild(document.createElement("p"));
        if (block)
          p.appendChild(serializer.serializeNode(schema.text(block, marks)));
      });
    }
  } else {
    view.someProp("transformPastedHTML", (f) => {
      html = f(html, view);
    });
    dom = readHTML(html);
    if (webkit)
      restoreReplacedSpaces(dom);
  }
  let contextNode = dom && dom.querySelector("[data-pm-slice]");
  let sliceData = contextNode && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(contextNode.getAttribute("data-pm-slice") || "");
  if (sliceData && sliceData[3])
    for (let i = +sliceData[3]; i > 0; i--) {
      let child = dom.firstChild;
      while (child && child.nodeType != 1)
        child = child.nextSibling;
      if (!child)
        break;
      dom = child;
    }
  if (!slice2) {
    let parser = view.someProp("clipboardParser") || view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
    slice2 = parser.parseSlice(dom, {
      preserveWhitespace: !!(asText || sliceData),
      context: $context,
      ruleFromNode(dom2) {
        if (dom2.nodeName == "BR" && !dom2.nextSibling && dom2.parentNode && !inlineParents.test(dom2.parentNode.nodeName))
          return { ignore: true };
        return null;
      }
    });
  }
  if (sliceData) {
    slice2 = addContext(closeSlice(slice2, +sliceData[1], +sliceData[2]), sliceData[4]);
  } else {
    slice2 = Slice.maxOpen(normalizeSiblings(slice2.content, $context), true);
    if (slice2.openStart || slice2.openEnd) {
      let openStart = 0, openEnd = 0;
      for (let node2 = slice2.content.firstChild; openStart < slice2.openStart && !node2.type.spec.isolating; openStart++, node2 = node2.firstChild) {
      }
      for (let node2 = slice2.content.lastChild; openEnd < slice2.openEnd && !node2.type.spec.isolating; openEnd++, node2 = node2.lastChild) {
      }
      slice2 = closeSlice(slice2, openStart, openEnd);
    }
  }
  view.someProp("transformPasted", (f) => {
    slice2 = f(slice2, view);
  });
  return slice2;
}
const inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function normalizeSiblings(fragment, $context) {
  if (fragment.childCount < 2)
    return fragment;
  for (let d2 = $context.depth; d2 >= 0; d2--) {
    let parent = $context.node(d2);
    let match = parent.contentMatchAt($context.index(d2));
    let lastWrap, result = [];
    fragment.forEach((node2) => {
      if (!result)
        return;
      let wrap2 = match.findWrapping(node2.type), inLast;
      if (!wrap2)
        return result = null;
      if (inLast = result.length && lastWrap.length && addToSibling(wrap2, lastWrap, node2, result[result.length - 1], 0)) {
        result[result.length - 1] = inLast;
      } else {
        if (result.length)
          result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);
        let wrapped = withWrappers(node2, wrap2);
        result.push(wrapped);
        match = match.matchType(wrapped.type);
        lastWrap = wrap2;
      }
    });
    if (result)
      return Fragment.from(result);
  }
  return fragment;
}
function withWrappers(node2, wrap2, from2 = 0) {
  for (let i = wrap2.length - 1; i >= from2; i--)
    node2 = wrap2[i].create(null, Fragment.from(node2));
  return node2;
}
function addToSibling(wrap2, lastWrap, node2, sibling, depth) {
  if (depth < wrap2.length && depth < lastWrap.length && wrap2[depth] == lastWrap[depth]) {
    let inner = addToSibling(wrap2, lastWrap, node2, sibling.lastChild, depth + 1);
    if (inner)
      return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));
    let match = sibling.contentMatchAt(sibling.childCount);
    if (match.matchType(depth == wrap2.length - 1 ? node2.type : wrap2[depth + 1]))
      return sibling.copy(sibling.content.append(Fragment.from(withWrappers(node2, wrap2, depth + 1))));
  }
}
function closeRight(node2, depth) {
  if (depth == 0)
    return node2;
  let fragment = node2.content.replaceChild(node2.childCount - 1, closeRight(node2.lastChild, depth - 1));
  let fill = node2.contentMatchAt(node2.childCount).fillBefore(Fragment.empty, true);
  return node2.copy(fragment.append(fill));
}
function closeRange(fragment, side, from2, to, depth, openEnd) {
  let node2 = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node2.content;
  if (fragment.childCount > 1)
    openEnd = 0;
  if (depth < to - 1)
    inner = closeRange(inner, side, from2, to, depth + 1, openEnd);
  if (depth >= from2)
    inner = side < 0 ? node2.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner) : inner.append(node2.contentMatchAt(node2.childCount).fillBefore(Fragment.empty, true));
  return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node2.copy(inner));
}
function closeSlice(slice2, openStart, openEnd) {
  if (openStart < slice2.openStart)
    slice2 = new Slice(closeRange(slice2.content, -1, openStart, slice2.openStart, 0, slice2.openEnd), openStart, slice2.openEnd);
  if (openEnd < slice2.openEnd)
    slice2 = new Slice(closeRange(slice2.content, 1, openEnd, slice2.openEnd, 0, 0), slice2.openStart, openEnd);
  return slice2;
}
const wrapMap = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let _detachedDoc = null;
function detachedDoc() {
  return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument("title"));
}
let _policy = null;
function maybeWrapTrusted(html) {
  let trustedTypes = window.trustedTypes;
  if (!trustedTypes)
    return html;
  if (!_policy)
    _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy("ProseMirrorClipboard", { createHTML: (s) => s });
  return _policy.createHTML(html);
}
function readHTML(html) {
  let metas = /^(\s*<meta [^>]*>)*/.exec(html);
  if (metas)
    html = html.slice(metas[0].length);
  let elt = detachedDoc().createElement("div");
  let firstTag = /<([a-z][^>\s]+)/i.exec(html), wrap2;
  if (wrap2 = firstTag && wrapMap[firstTag[1].toLowerCase()])
    html = wrap2.map((n) => "<" + n + ">").join("") + html + wrap2.map((n) => "</" + n + ">").reverse().join("");
  elt.innerHTML = maybeWrapTrusted(html);
  if (wrap2)
    for (let i = 0; i < wrap2.length; i++)
      elt = elt.querySelector(wrap2[i]) || elt;
  return elt;
}
function restoreReplacedSpaces(dom) {
  let nodes = dom.querySelectorAll(chrome ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let i = 0; i < nodes.length; i++) {
    let node2 = nodes[i];
    if (node2.childNodes.length == 1 && node2.textContent == " " && node2.parentNode)
      node2.parentNode.replaceChild(dom.ownerDocument.createTextNode(" "), node2);
  }
}
function addContext(slice2, context) {
  if (!slice2.size)
    return slice2;
  let schema = slice2.content.firstChild.type.schema, array;
  try {
    array = JSON.parse(context);
  } catch (e) {
    return slice2;
  }
  let { content, openStart, openEnd } = slice2;
  for (let i = array.length - 2; i >= 0; i -= 2) {
    let type2 = schema.nodes[array[i]];
    if (!type2 || type2.hasRequiredAttrs())
      break;
    content = Fragment.from(type2.create(array[i + 1], content));
    openStart++;
    openEnd++;
  }
  return new Slice(content, openStart, openEnd);
}
const handlers = {};
const editHandlers = {};
const passiveHandlers = { touchstart: true, touchmove: true };
class InputState {
  constructor() {
    this.shiftKey = false;
    this.mouseDown = null;
    this.lastKeyCode = null;
    this.lastKeyCodeTime = 0;
    this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 };
    this.lastSelectionOrigin = null;
    this.lastSelectionTime = 0;
    this.lastIOSEnter = 0;
    this.lastIOSEnterFallbackTimeout = -1;
    this.lastFocus = 0;
    this.lastTouch = 0;
    this.lastChromeDelete = 0;
    this.composing = false;
    this.compositionNode = null;
    this.composingTimeout = -1;
    this.compositionNodes = [];
    this.compositionEndedAt = -2e8;
    this.compositionID = 1;
    this.compositionPendingChanges = 0;
    this.domChangeCount = 0;
    this.eventHandlers = /* @__PURE__ */ Object.create(null);
    this.hideSelectionGuard = null;
  }
}
function initInput(view) {
  for (let event in handlers) {
    let handler = handlers[event];
    view.dom.addEventListener(event, view.input.eventHandlers[event] = (event2) => {
      if (eventBelongsToView(view, event2) && !runCustomHandler(view, event2) && (view.editable || !(event2.type in editHandlers)))
        handler(view, event2);
    }, passiveHandlers[event] ? { passive: true } : void 0);
  }
  if (safari)
    view.dom.addEventListener("input", () => null);
  ensureListeners(view);
}
function setSelectionOrigin(view, origin) {
  view.input.lastSelectionOrigin = origin;
  view.input.lastSelectionTime = Date.now();
}
function destroyInput(view) {
  view.domObserver.stop();
  for (let type2 in view.input.eventHandlers)
    view.dom.removeEventListener(type2, view.input.eventHandlers[type2]);
  clearTimeout(view.input.composingTimeout);
  clearTimeout(view.input.lastIOSEnterFallbackTimeout);
}
function ensureListeners(view) {
  view.someProp("handleDOMEvents", (currentHandlers) => {
    for (let type2 in currentHandlers)
      if (!view.input.eventHandlers[type2])
        view.dom.addEventListener(type2, view.input.eventHandlers[type2] = (event) => runCustomHandler(view, event));
  });
}
function runCustomHandler(view, event) {
  return view.someProp("handleDOMEvents", (handlers2) => {
    let handler = handlers2[event.type];
    return handler ? handler(view, event) || event.defaultPrevented : false;
  });
}
function eventBelongsToView(view, event) {
  if (!event.bubbles)
    return true;
  if (event.defaultPrevented)
    return false;
  for (let node2 = event.target; node2 != view.dom; node2 = node2.parentNode)
    if (!node2 || node2.nodeType == 11 || node2.pmViewDesc && node2.pmViewDesc.stopEvent(event))
      return false;
  return true;
}
function dispatchEvent(view, event) {
  if (!runCustomHandler(view, event) && handlers[event.type] && (view.editable || !(event.type in editHandlers)))
    handlers[event.type](view, event);
}
editHandlers.keydown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.keyCode == 16 || event.shiftKey;
  if (inOrNearComposition(view, event))
    return;
  view.input.lastKeyCode = event.keyCode;
  view.input.lastKeyCodeTime = Date.now();
  if (android && chrome && event.keyCode == 13)
    return;
  if (event.keyCode != 229)
    view.domObserver.forceFlush();
  if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {
    let now = Date.now();
    view.input.lastIOSEnter = now;
    view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
      if (view.input.lastIOSEnter == now) {
        view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")));
        view.input.lastIOSEnter = 0;
      }
    }, 200);
  } else if (view.someProp("handleKeyDown", (f) => f(view, event)) || captureKeyDown(view, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "key");
  }
};
editHandlers.keyup = (view, event) => {
  if (event.keyCode == 16)
    view.input.shiftKey = false;
};
editHandlers.keypress = (view, _event) => {
  let event = _event;
  if (inOrNearComposition(view, event) || !event.charCode || event.ctrlKey && !event.altKey || mac$2 && event.metaKey)
    return;
  if (view.someProp("handleKeyPress", (f) => f(view, event))) {
    event.preventDefault();
    return;
  }
  let sel = view.state.selection;
  if (!(sel instanceof TextSelection$1) || !sel.$from.sameParent(sel.$to)) {
    let text = String.fromCharCode(event.charCode);
    let deflt = () => view.state.tr.insertText(text).scrollIntoView();
    if (!/[\r\n]/.test(text) && !view.someProp("handleTextInput", (f) => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))
      view.dispatch(deflt());
    event.preventDefault();
  }
};
function eventCoords(event) {
  return { left: event.clientX, top: event.clientY };
}
function isNear(event, click) {
  let dx = click.x - event.clientX, dy = click.y - event.clientY;
  return dx * dx + dy * dy < 100;
}
function runHandlerOnContext(view, propName, pos, inside, event) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    if (view.someProp(propName, (f) => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true) : f(view, pos, $pos.node(i), $pos.before(i), event, false)))
      return true;
  }
  return false;
}
function updateSelection(view, selection, origin) {
  if (!view.focused)
    view.focus();
  if (view.state.selection.eq(selection))
    return;
  let tr = view.state.tr.setSelection(selection);
  tr.setMeta("pointer", true);
  view.dispatch(tr);
}
function selectClickedLeaf(view, inside) {
  if (inside == -1)
    return false;
  let $pos = view.state.doc.resolve(inside), node2 = $pos.nodeAfter;
  if (node2 && node2.isAtom && NodeSelection.isSelectable(node2)) {
    updateSelection(view, new NodeSelection($pos));
    return true;
  }
  return false;
}
function selectClickedNode(view, inside) {
  if (inside == -1)
    return false;
  let sel = view.state.selection, selectedNode, selectAt;
  if (sel instanceof NodeSelection)
    selectedNode = sel.node;
  let $pos = view.state.doc.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node2 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    if (NodeSelection.isSelectable(node2)) {
      if (selectedNode && sel.$from.depth > 0 && i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)
        selectAt = $pos.before(sel.$from.depth);
      else
        selectAt = $pos.before(i);
      break;
    }
  }
  if (selectAt != null) {
    updateSelection(view, NodeSelection.create(view.state.doc, selectAt));
    return true;
  } else {
    return false;
  }
}
function handleSingleClick(view, pos, inside, event, selectNode) {
  return runHandlerOnContext(view, "handleClickOn", pos, inside, event) || view.someProp("handleClick", (f) => f(view, pos, event)) || (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));
}
function handleDoubleClick(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleDoubleClickOn", pos, inside, event) || view.someProp("handleDoubleClick", (f) => f(view, pos, event));
}
function handleTripleClick$1(view, pos, inside, event) {
  return runHandlerOnContext(view, "handleTripleClickOn", pos, inside, event) || view.someProp("handleTripleClick", (f) => f(view, pos, event)) || defaultTripleClick(view, inside, event);
}
function defaultTripleClick(view, inside, event) {
  if (event.button != 0)
    return false;
  let doc2 = view.state.doc;
  if (inside == -1) {
    if (doc2.inlineContent) {
      updateSelection(view, TextSelection$1.create(doc2, 0, doc2.content.size));
      return true;
    }
    return false;
  }
  let $pos = doc2.resolve(inside);
  for (let i = $pos.depth + 1; i > 0; i--) {
    let node2 = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);
    let nodePos = $pos.before(i);
    if (node2.inlineContent)
      updateSelection(view, TextSelection$1.create(doc2, nodePos + 1, nodePos + 1 + node2.content.size));
    else if (NodeSelection.isSelectable(node2))
      updateSelection(view, NodeSelection.create(doc2, nodePos));
    else
      continue;
    return true;
  }
}
function forceDOMFlush(view) {
  return endComposition(view);
}
const selectNodeModifier = mac$2 ? "metaKey" : "ctrlKey";
handlers.mousedown = (view, _event) => {
  let event = _event;
  view.input.shiftKey = event.shiftKey;
  let flushed = forceDOMFlush(view);
  let now = Date.now(), type2 = "singleClick";
  if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] && view.input.lastClick.button == event.button) {
    if (view.input.lastClick.type == "singleClick")
      type2 = "doubleClick";
    else if (view.input.lastClick.type == "doubleClick")
      type2 = "tripleClick";
  }
  view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type: type2, button: event.button };
  let pos = view.posAtCoords(eventCoords(event));
  if (!pos)
    return;
  if (type2 == "singleClick") {
    if (view.input.mouseDown)
      view.input.mouseDown.done();
    view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);
  } else if ((type2 == "doubleClick" ? handleDoubleClick : handleTripleClick$1)(view, pos.pos, pos.inside, event)) {
    event.preventDefault();
  } else {
    setSelectionOrigin(view, "pointer");
  }
};
class MouseDown {
  constructor(view, pos, event, flushed) {
    this.view = view;
    this.pos = pos;
    this.event = event;
    this.flushed = flushed;
    this.delayedSelectionSync = false;
    this.mightDrag = null;
    this.startDoc = view.state.doc;
    this.selectNode = !!event[selectNodeModifier];
    this.allowDefault = event.shiftKey;
    let targetNode, targetPos;
    if (pos.inside > -1) {
      targetNode = view.state.doc.nodeAt(pos.inside);
      targetPos = pos.inside;
    } else {
      let $pos = view.state.doc.resolve(pos.pos);
      targetNode = $pos.parent;
      targetPos = $pos.depth ? $pos.before() : 0;
    }
    const target = flushed ? null : event.target;
    const targetDesc = target ? view.docView.nearestDesc(target, true) : null;
    this.target = targetDesc && targetDesc.dom.nodeType == 1 ? targetDesc.dom : null;
    let { selection } = view.state;
    if (event.button == 0 && targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false || selection instanceof NodeSelection && selection.from <= targetPos && selection.to > targetPos)
      this.mightDrag = {
        node: targetNode,
        pos: targetPos,
        addAttr: !!(this.target && !this.target.draggable),
        setUneditable: !!(this.target && gecko && !this.target.hasAttribute("contentEditable"))
      };
    if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.draggable = true;
      if (this.mightDrag.setUneditable)
        setTimeout(() => {
          if (this.view.input.mouseDown == this)
            this.target.setAttribute("contentEditable", "false");
        }, 20);
      this.view.domObserver.start();
    }
    view.root.addEventListener("mouseup", this.up = this.up.bind(this));
    view.root.addEventListener("mousemove", this.move = this.move.bind(this));
    setSelectionOrigin(view, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up);
    this.view.root.removeEventListener("mousemove", this.move);
    if (this.mightDrag && this.target) {
      this.view.domObserver.stop();
      if (this.mightDrag.addAttr)
        this.target.removeAttribute("draggable");
      if (this.mightDrag.setUneditable)
        this.target.removeAttribute("contentEditable");
      this.view.domObserver.start();
    }
    if (this.delayedSelectionSync)
      setTimeout(() => selectionToDOM(this.view));
    this.view.input.mouseDown = null;
  }
  up(event) {
    this.done();
    if (!this.view.dom.contains(event.target))
      return;
    let pos = this.pos;
    if (this.view.state.doc != this.startDoc)
      pos = this.view.posAtCoords(eventCoords(event));
    this.updateAllowDefault(event);
    if (this.allowDefault || !pos) {
      setSelectionOrigin(this.view, "pointer");
    } else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {
      event.preventDefault();
    } else if (event.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    safari && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    chrome && !this.view.state.selection.visible && Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2)) {
      updateSelection(this.view, Selection.near(this.view.state.doc.resolve(pos.pos)));
      event.preventDefault();
    } else {
      setSelectionOrigin(this.view, "pointer");
    }
  }
  move(event) {
    this.updateAllowDefault(event);
    setSelectionOrigin(this.view, "pointer");
    if (event.buttons == 0)
      this.done();
  }
  updateAllowDefault(event) {
    if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 || Math.abs(this.event.y - event.clientY) > 4))
      this.allowDefault = true;
  }
}
handlers.touchstart = (view) => {
  view.input.lastTouch = Date.now();
  forceDOMFlush(view);
  setSelectionOrigin(view, "pointer");
};
handlers.touchmove = (view) => {
  view.input.lastTouch = Date.now();
  setSelectionOrigin(view, "pointer");
};
handlers.contextmenu = (view) => forceDOMFlush(view);
function inOrNearComposition(view, event) {
  if (view.composing)
    return true;
  if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {
    view.input.compositionEndedAt = -2e8;
    return true;
  }
  return false;
}
const timeoutComposition = android ? 5e3 : -1;
editHandlers.compositionstart = editHandlers.compositionupdate = (view) => {
  if (!view.composing) {
    view.domObserver.flush();
    let { state: state2 } = view, $pos = state2.selection.$to;
    if (state2.selection instanceof TextSelection$1 && (state2.storedMarks || !$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some((m2) => m2.type.spec.inclusive === false))) {
      view.markCursor = view.state.storedMarks || $pos.marks();
      endComposition(view, true);
      view.markCursor = null;
    } else {
      endComposition(view, !state2.selection.empty);
      if (gecko && state2.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {
        let sel = view.domSelectionRange();
        for (let node2 = sel.focusNode, offset2 = sel.focusOffset; node2 && node2.nodeType == 1 && offset2 != 0; ) {
          let before = offset2 < 0 ? node2.lastChild : node2.childNodes[offset2 - 1];
          if (!before)
            break;
          if (before.nodeType == 3) {
            let sel2 = view.domSelection();
            if (sel2)
              sel2.collapse(before, before.nodeValue.length);
            break;
          } else {
            node2 = before;
            offset2 = -1;
          }
        }
      }
    }
    view.input.composing = true;
  }
  scheduleComposeEnd(view, timeoutComposition);
};
editHandlers.compositionend = (view, event) => {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = event.timeStamp;
    view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;
    view.input.compositionNode = null;
    if (view.input.compositionPendingChanges)
      Promise.resolve().then(() => view.domObserver.flush());
    view.input.compositionID++;
    scheduleComposeEnd(view, 20);
  }
};
function scheduleComposeEnd(view, delay) {
  clearTimeout(view.input.composingTimeout);
  if (delay > -1)
    view.input.composingTimeout = setTimeout(() => endComposition(view), delay);
}
function clearComposition(view) {
  if (view.composing) {
    view.input.composing = false;
    view.input.compositionEndedAt = timestampFromCustomEvent();
  }
  while (view.input.compositionNodes.length > 0)
    view.input.compositionNodes.pop().markParentsDirty();
}
function findCompositionNode(view) {
  let sel = view.domSelectionRange();
  if (!sel.focusNode)
    return null;
  let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);
  let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);
  if (textBefore && textAfter && textBefore != textAfter) {
    let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;
    if (textBefore == lastChanged || textAfter == lastChanged)
      return lastChanged;
    if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {
      return textAfter;
    } else if (view.input.compositionNode == textAfter) {
      let descBefore = textBefore.pmViewDesc;
      if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))
        return textAfter;
    }
  }
  return textBefore || textAfter;
}
function timestampFromCustomEvent() {
  let event = document.createEvent("Event");
  event.initEvent("event", true, true);
  return event.timeStamp;
}
function endComposition(view, restarting = false) {
  if (android && view.domObserver.flushingSoon >= 0)
    return;
  view.domObserver.forceFlush();
  clearComposition(view);
  if (restarting || view.docView && view.docView.dirty) {
    let sel = selectionFromDOM(view), cur = view.state.selection;
    if (sel && !sel.eq(cur))
      view.dispatch(view.state.tr.setSelection(sel));
    else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)
      view.dispatch(view.state.tr.deleteSelection());
    else
      view.updateState(view.state);
    return true;
  }
  return false;
}
function captureCopy(view, dom) {
  if (!view.dom.parentNode)
    return;
  let wrap2 = view.dom.parentNode.appendChild(document.createElement("div"));
  wrap2.appendChild(dom);
  wrap2.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let sel = getSelection(), range2 = document.createRange();
  range2.selectNodeContents(dom);
  view.dom.blur();
  sel.removeAllRanges();
  sel.addRange(range2);
  setTimeout(() => {
    if (wrap2.parentNode)
      wrap2.parentNode.removeChild(wrap2);
    view.focus();
  }, 50);
}
const brokenClipboardAPI = ie$1 && ie_version < 15 || ios && webkit_version < 604;
handlers.copy = editHandlers.cut = (view, _event) => {
  let event = _event;
  let sel = view.state.selection, cut = event.type == "cut";
  if (sel.empty)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let slice2 = sel.content(), { dom, text } = serializeForClipboard(view, slice2);
  if (data) {
    event.preventDefault();
    data.clearData();
    data.setData("text/html", dom.innerHTML);
    data.setData("text/plain", text);
  } else {
    captureCopy(view, dom);
  }
  if (cut)
    view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function sliceSingleNode(slice2) {
  return slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1 ? slice2.content.firstChild : null;
}
function capturePaste(view, event) {
  if (!view.dom.parentNode)
    return;
  let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;
  let target = view.dom.parentNode.appendChild(document.createElement(plainText ? "textarea" : "div"));
  if (!plainText)
    target.contentEditable = "true";
  target.style.cssText = "position: fixed; left: -10000px; top: 10px";
  target.focus();
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  setTimeout(() => {
    view.focus();
    if (target.parentNode)
      target.parentNode.removeChild(target);
    if (plainText)
      doPaste(view, target.value, null, plain, event);
    else
      doPaste(view, target.textContent, target.innerHTML, plain, event);
  }, 50);
}
function doPaste(view, text, html, preferPlain, event) {
  let slice2 = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);
  if (view.someProp("handlePaste", (f) => f(view, event, slice2 || Slice.empty)))
    return true;
  if (!slice2)
    return false;
  let singleNode = sliceSingleNode(slice2);
  let tr = singleNode ? view.state.tr.replaceSelectionWith(singleNode, preferPlain) : view.state.tr.replaceSelection(slice2);
  view.dispatch(tr.scrollIntoView().setMeta("paste", true).setMeta("uiEvent", "paste"));
  return true;
}
function getText(clipboardData) {
  let text = clipboardData.getData("text/plain") || clipboardData.getData("Text");
  if (text)
    return text;
  let uris = clipboardData.getData("text/uri-list");
  return uris ? uris.replace(/\r?\n/g, " ") : "";
}
editHandlers.paste = (view, _event) => {
  let event = _event;
  if (view.composing && !android)
    return;
  let data = brokenClipboardAPI ? null : event.clipboardData;
  let plain = view.input.shiftKey && view.input.lastKeyCode != 45;
  if (data && doPaste(view, getText(data), data.getData("text/html"), plain, event))
    event.preventDefault();
  else
    capturePaste(view, event);
};
class Dragging {
  constructor(slice2, move2, node2) {
    this.slice = slice2;
    this.move = move2;
    this.node = node2;
  }
}
const dragCopyModifier = mac$2 ? "altKey" : "ctrlKey";
function dragMoves(view, event) {
  let moves = view.someProp("dragCopies", (test) => !test(event));
  return moves != null ? moves : !event[dragCopyModifier];
}
handlers.dragstart = (view, _event) => {
  let event = _event;
  let mouseDown = view.input.mouseDown;
  if (mouseDown)
    mouseDown.done();
  if (!event.dataTransfer)
    return;
  let sel = view.state.selection;
  let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));
  let node2;
  if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof NodeSelection ? sel.to - 1 : sel.to)) ;
  else if (mouseDown && mouseDown.mightDrag) {
    node2 = NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);
  } else if (event.target && event.target.nodeType == 1) {
    let desc = view.docView.nearestDesc(event.target, true);
    if (desc && desc.node.type.spec.draggable && desc != view.docView)
      node2 = NodeSelection.create(view.state.doc, desc.posBefore);
  }
  let draggedSlice = (node2 || view.state.selection).content();
  let { dom, text, slice: slice2 } = serializeForClipboard(view, draggedSlice);
  if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)
    event.dataTransfer.clearData();
  event.dataTransfer.setData(brokenClipboardAPI ? "Text" : "text/html", dom.innerHTML);
  event.dataTransfer.effectAllowed = "copyMove";
  if (!brokenClipboardAPI)
    event.dataTransfer.setData("text/plain", text);
  view.dragging = new Dragging(slice2, dragMoves(view, event), node2);
};
handlers.dragend = (view) => {
  let dragging = view.dragging;
  window.setTimeout(() => {
    if (view.dragging == dragging)
      view.dragging = null;
  }, 50);
};
editHandlers.dragover = editHandlers.dragenter = (_2, e) => e.preventDefault();
editHandlers.drop = (view, _event) => {
  let event = _event;
  let dragging = view.dragging;
  view.dragging = null;
  if (!event.dataTransfer)
    return;
  let eventPos = view.posAtCoords(eventCoords(event));
  if (!eventPos)
    return;
  let $mouse = view.state.doc.resolve(eventPos.pos);
  let slice2 = dragging && dragging.slice;
  if (slice2) {
    view.someProp("transformPasted", (f) => {
      slice2 = f(slice2, view);
    });
  } else {
    slice2 = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData("text/html"), false, $mouse);
  }
  let move2 = !!(dragging && dragMoves(view, event));
  if (view.someProp("handleDrop", (f) => f(view, event, slice2 || Slice.empty, move2))) {
    event.preventDefault();
    return;
  }
  if (!slice2)
    return;
  event.preventDefault();
  let insertPos = slice2 ? dropPoint(view.state.doc, $mouse.pos, slice2) : $mouse.pos;
  if (insertPos == null)
    insertPos = $mouse.pos;
  let tr = view.state.tr;
  if (move2) {
    let { node: node2 } = dragging;
    if (node2)
      node2.replace(tr);
    else
      tr.deleteSelection();
  }
  let pos = tr.mapping.map(insertPos);
  let isNode2 = slice2.openStart == 0 && slice2.openEnd == 0 && slice2.content.childCount == 1;
  let beforeInsert = tr.doc;
  if (isNode2)
    tr.replaceRangeWith(pos, pos, slice2.content.firstChild);
  else
    tr.replaceRange(pos, pos, slice2);
  if (tr.doc.eq(beforeInsert))
    return;
  let $pos = tr.doc.resolve(pos);
  if (isNode2 && NodeSelection.isSelectable(slice2.content.firstChild) && $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice2.content.firstChild)) {
    tr.setSelection(new NodeSelection($pos));
  } else {
    let end2 = tr.mapping.map(insertPos);
    tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end2 = newTo);
    tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end2)));
  }
  view.focus();
  view.dispatch(tr.setMeta("uiEvent", "drop"));
};
handlers.focus = (view) => {
  view.input.lastFocus = Date.now();
  if (!view.focused) {
    view.domObserver.stop();
    view.dom.classList.add("ProseMirror-focused");
    view.domObserver.start();
    view.focused = true;
    setTimeout(() => {
      if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))
        selectionToDOM(view);
    }, 20);
  }
};
handlers.blur = (view, _event) => {
  let event = _event;
  if (view.focused) {
    view.domObserver.stop();
    view.dom.classList.remove("ProseMirror-focused");
    view.domObserver.start();
    if (event.relatedTarget && view.dom.contains(event.relatedTarget))
      view.domObserver.currentSelection.clear();
    view.focused = false;
  }
};
handlers.beforeinput = (view, _event) => {
  let event = _event;
  if (chrome && android && event.inputType == "deleteContentBackward") {
    view.domObserver.flushSoon();
    let { domChangeCount } = view.input;
    setTimeout(() => {
      if (view.input.domChangeCount != domChangeCount)
        return;
      view.dom.blur();
      view.focus();
      if (view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace"))))
        return;
      let { $cursor } = view.state.selection;
      if ($cursor && $cursor.pos > 0)
        view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());
    }, 50);
  }
};
for (let prop in editHandlers)
  handlers[prop] = editHandlers[prop];
function compareObjs(a, b2) {
  if (a == b2)
    return true;
  for (let p in a)
    if (a[p] !== b2[p])
      return false;
  for (let p in b2)
    if (!(p in a))
      return false;
  return true;
}
class WidgetType {
  constructor(toDOM, spec) {
    this.toDOM = toDOM;
    this.spec = spec || noSpec;
    this.side = this.spec.side || 0;
  }
  map(mapping, span, offset2, oldOffset) {
    let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);
    return deleted ? null : new Decoration(pos - offset2, pos - offset2, this);
  }
  valid() {
    return true;
  }
  eq(other) {
    return this == other || other instanceof WidgetType && (this.spec.key && this.spec.key == other.spec.key || this.toDOM == other.toDOM && compareObjs(this.spec, other.spec));
  }
  destroy(node2) {
    if (this.spec.destroy)
      this.spec.destroy(node2);
  }
}
class InlineType {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset2;
    let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset2;
    return from2 >= to ? null : new Decoration(from2, to, this);
  }
  valid(_2, span) {
    return span.from < span.to;
  }
  eq(other) {
    return this == other || other instanceof InlineType && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  static is(span) {
    return span.type instanceof InlineType;
  }
  destroy() {
  }
}
class NodeType2 {
  constructor(attrs, spec) {
    this.attrs = attrs;
    this.spec = spec || noSpec;
  }
  map(mapping, span, offset2, oldOffset) {
    let from2 = mapping.mapResult(span.from + oldOffset, 1);
    if (from2.deleted)
      return null;
    let to = mapping.mapResult(span.to + oldOffset, -1);
    if (to.deleted || to.pos <= from2.pos)
      return null;
    return new Decoration(from2.pos - offset2, to.pos - offset2, this);
  }
  valid(node2, span) {
    let { index: index2, offset: offset2 } = node2.content.findIndex(span.from), child;
    return offset2 == span.from && !(child = node2.child(index2)).isText && offset2 + child.nodeSize == span.to;
  }
  eq(other) {
    return this == other || other instanceof NodeType2 && compareObjs(this.attrs, other.attrs) && compareObjs(this.spec, other.spec);
  }
  destroy() {
  }
}
class Decoration {
  /**
  @internal
  */
  constructor(from2, to, type2) {
    this.from = from2;
    this.to = to;
    this.type = type2;
  }
  /**
  @internal
  */
  copy(from2, to) {
    return new Decoration(from2, to, this.type);
  }
  /**
  @internal
  */
  eq(other, offset2 = 0) {
    return this.type.eq(other.type) && this.from + offset2 == other.from && this.to + offset2 == other.to;
  }
  /**
  @internal
  */
  map(mapping, offset2, oldOffset) {
    return this.type.map(mapping, this, offset2, oldOffset);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(pos, toDOM, spec) {
    return new Decoration(pos, pos, new WidgetType(toDOM, spec));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(from2, to, attrs, spec) {
    return new Decoration(from2, to, new InlineType(attrs, spec));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(from2, to, attrs, spec) {
    return new Decoration(from2, to, new NodeType2(attrs, spec));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof InlineType;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof WidgetType;
  }
}
const none = [], noSpec = {};
class DecorationSet {
  /**
  @internal
  */
  constructor(local, children) {
    this.local = local.length ? local : none;
    this.children = children.length ? children : none;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(doc2, decorations) {
    return decorations.length ? buildTree(decorations, doc2, 0, noSpec) : empty;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(start2, end2, predicate) {
    let result = [];
    this.findInner(start2 == null ? 0 : start2, end2 == null ? 1e9 : end2, result, 0, predicate);
    return result;
  }
  findInner(start2, end2, result, offset2, predicate) {
    for (let i = 0; i < this.local.length; i++) {
      let span = this.local[i];
      if (span.from <= end2 && span.to >= start2 && (!predicate || predicate(span.spec)))
        result.push(span.copy(span.from + offset2, span.to + offset2));
    }
    for (let i = 0; i < this.children.length; i += 3) {
      if (this.children[i] < end2 && this.children[i + 1] > start2) {
        let childOff = this.children[i] + 1;
        this.children[i + 2].findInner(start2 - childOff, end2 - childOff, result, offset2 + childOff, predicate);
      }
    }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(mapping, doc2, options) {
    if (this == empty || mapping.maps.length == 0)
      return this;
    return this.mapInner(mapping, doc2, 0, 0, options || noSpec);
  }
  /**
  @internal
  */
  mapInner(mapping, node2, offset2, oldOffset, options) {
    let newLocal;
    for (let i = 0; i < this.local.length; i++) {
      let mapped = this.local[i].map(mapping, offset2, oldOffset);
      if (mapped && mapped.type.valid(node2, mapped))
        (newLocal || (newLocal = [])).push(mapped);
      else if (options.onRemove)
        options.onRemove(this.local[i].spec);
    }
    if (this.children.length)
      return mapChildren(this.children, newLocal || [], mapping, node2, offset2, oldOffset, options);
    else
      return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(doc2, decorations) {
    if (!decorations.length)
      return this;
    if (this == empty)
      return DecorationSet.create(doc2, decorations);
    return this.addInner(doc2, decorations, 0);
  }
  addInner(doc2, decorations, offset2) {
    let children, childIndex = 0;
    doc2.forEach((childNode, childOffset) => {
      let baseOffset = childOffset + offset2, found2;
      if (!(found2 = takeSpansForNode(decorations, childNode, baseOffset)))
        return;
      if (!children)
        children = this.children.slice();
      while (childIndex < children.length && children[childIndex] < childOffset)
        childIndex += 3;
      if (children[childIndex] == childOffset)
        children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found2, baseOffset + 1);
      else
        children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found2, childNode, baseOffset + 1, noSpec));
      childIndex += 3;
    });
    let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset2);
    for (let i = 0; i < local.length; i++)
      if (!local[i].type.valid(doc2, local[i]))
        local.splice(i--, 1);
    return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(decorations) {
    if (decorations.length == 0 || this == empty)
      return this;
    return this.removeInner(decorations, 0);
  }
  removeInner(decorations, offset2) {
    let children = this.children, local = this.local;
    for (let i = 0; i < children.length; i += 3) {
      let found2;
      let from2 = children[i] + offset2, to = children[i + 1] + offset2;
      for (let j2 = 0, span; j2 < decorations.length; j2++)
        if (span = decorations[j2]) {
          if (span.from > from2 && span.to < to) {
            decorations[j2] = null;
            (found2 || (found2 = [])).push(span);
          }
        }
      if (!found2)
        continue;
      if (children == this.children)
        children = this.children.slice();
      let removed = children[i + 2].removeInner(found2, from2 + 1);
      if (removed != empty) {
        children[i + 2] = removed;
      } else {
        children.splice(i, 3);
        i -= 3;
      }
    }
    if (local.length) {
      for (let i = 0, span; i < decorations.length; i++)
        if (span = decorations[i]) {
          for (let j2 = 0; j2 < local.length; j2++)
            if (local[j2].eq(span, offset2)) {
              if (local == this.local)
                local = this.local.slice();
              local.splice(j2--, 1);
            }
        }
    }
    if (children == this.children && local == this.local)
      return this;
    return local.length || children.length ? new DecorationSet(local, children) : empty;
  }
  forChild(offset2, node2) {
    if (this == empty)
      return this;
    if (node2.isLeaf)
      return DecorationSet.empty;
    let child, local;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] >= offset2) {
        if (this.children[i] == offset2)
          child = this.children[i + 2];
        break;
      }
    let start2 = offset2 + 1, end2 = start2 + node2.content.size;
    for (let i = 0; i < this.local.length; i++) {
      let dec = this.local[i];
      if (dec.from < end2 && dec.to > start2 && dec.type instanceof InlineType) {
        let from2 = Math.max(start2, dec.from) - start2, to = Math.min(end2, dec.to) - start2;
        if (from2 < to)
          (local || (local = [])).push(dec.copy(from2, to));
      }
    }
    if (local) {
      let localSet = new DecorationSet(local.sort(byPos), none);
      return child ? new DecorationGroup([localSet, child]) : localSet;
    }
    return child || empty;
  }
  /**
  @internal
  */
  eq(other) {
    if (this == other)
      return true;
    if (!(other instanceof DecorationSet) || this.local.length != other.local.length || this.children.length != other.children.length)
      return false;
    for (let i = 0; i < this.local.length; i++)
      if (!this.local[i].eq(other.local[i]))
        return false;
    for (let i = 0; i < this.children.length; i += 3)
      if (this.children[i] != other.children[i] || this.children[i + 1] != other.children[i + 1] || !this.children[i + 2].eq(other.children[i + 2]))
        return false;
    return true;
  }
  /**
  @internal
  */
  locals(node2) {
    return removeOverlap(this.localsInner(node2));
  }
  /**
  @internal
  */
  localsInner(node2) {
    if (this == empty)
      return none;
    if (node2.inlineContent || !this.local.some(InlineType.is))
      return this.local;
    let result = [];
    for (let i = 0; i < this.local.length; i++) {
      if (!(this.local[i].type instanceof InlineType))
        result.push(this.local[i]);
    }
    return result;
  }
  forEachSet(f) {
    f(this);
  }
}
DecorationSet.empty = new DecorationSet([], []);
DecorationSet.removeOverlap = removeOverlap;
const empty = DecorationSet.empty;
class DecorationGroup {
  constructor(members) {
    this.members = members;
  }
  map(mapping, doc2) {
    const mappedDecos = this.members.map((member) => member.map(mapping, doc2, noSpec));
    return DecorationGroup.from(mappedDecos);
  }
  forChild(offset2, child) {
    if (child.isLeaf)
      return DecorationSet.empty;
    let found2 = [];
    for (let i = 0; i < this.members.length; i++) {
      let result = this.members[i].forChild(offset2, child);
      if (result == empty)
        continue;
      if (result instanceof DecorationGroup)
        found2 = found2.concat(result.members);
      else
        found2.push(result);
    }
    return DecorationGroup.from(found2);
  }
  eq(other) {
    if (!(other instanceof DecorationGroup) || other.members.length != this.members.length)
      return false;
    for (let i = 0; i < this.members.length; i++)
      if (!this.members[i].eq(other.members[i]))
        return false;
    return true;
  }
  locals(node2) {
    let result, sorted = true;
    for (let i = 0; i < this.members.length; i++) {
      let locals = this.members[i].localsInner(node2);
      if (!locals.length)
        continue;
      if (!result) {
        result = locals;
      } else {
        if (sorted) {
          result = result.slice();
          sorted = false;
        }
        for (let j2 = 0; j2 < locals.length; j2++)
          result.push(locals[j2]);
      }
    }
    return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(members) {
    switch (members.length) {
      case 0:
        return empty;
      case 1:
        return members[0];
      default:
        return new DecorationGroup(members.every((m2) => m2 instanceof DecorationSet) ? members : members.reduce((r2, m2) => r2.concat(m2 instanceof DecorationSet ? m2 : m2.members), []));
    }
  }
  forEachSet(f) {
    for (let i = 0; i < this.members.length; i++)
      this.members[i].forEachSet(f);
  }
}
function mapChildren(oldChildren, newLocal, mapping, node2, offset2, oldOffset, options) {
  let children = oldChildren.slice();
  for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {
    let moved = 0;
    mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {
      let dSize = newEnd - newStart - (oldEnd - oldStart);
      for (let i2 = 0; i2 < children.length; i2 += 3) {
        let end2 = children[i2 + 1];
        if (end2 < 0 || oldStart > end2 + baseOffset - moved)
          continue;
        let start2 = children[i2] + baseOffset - moved;
        if (oldEnd >= start2) {
          children[i2 + 1] = oldStart <= start2 ? -2 : -1;
        } else if (oldStart >= baseOffset && dSize) {
          children[i2] += dSize;
          children[i2 + 1] += dSize;
        }
      }
      moved += dSize;
    });
    baseOffset = mapping.maps[i].map(baseOffset, -1);
  }
  let mustRebuild = false;
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] < 0) {
      if (children[i + 1] == -2) {
        mustRebuild = true;
        children[i + 1] = -1;
        continue;
      }
      let from2 = mapping.map(oldChildren[i] + oldOffset), fromLocal = from2 - offset2;
      if (fromLocal < 0 || fromLocal >= node2.content.size) {
        mustRebuild = true;
        continue;
      }
      let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset2;
      let { index: index2, offset: childOffset } = node2.content.findIndex(fromLocal);
      let childNode = node2.maybeChild(index2);
      if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {
        let mapped = children[i + 2].mapInner(mapping, childNode, from2 + 1, oldChildren[i] + oldOffset + 1, options);
        if (mapped != empty) {
          children[i] = fromLocal;
          children[i + 1] = toLocal;
          children[i + 2] = mapped;
        } else {
          children[i + 1] = -2;
          mustRebuild = true;
        }
      } else {
        mustRebuild = true;
      }
    }
  if (mustRebuild) {
    let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset2, oldOffset, options);
    let built = buildTree(decorations, node2, 0, options);
    newLocal = built.local;
    for (let i = 0; i < children.length; i += 3)
      if (children[i + 1] < 0) {
        children.splice(i, 3);
        i -= 3;
      }
    for (let i = 0, j2 = 0; i < built.children.length; i += 3) {
      let from2 = built.children[i];
      while (j2 < children.length && children[j2] < from2)
        j2 += 3;
      children.splice(j2, 0, built.children[i], built.children[i + 1], built.children[i + 2]);
    }
  }
  return new DecorationSet(newLocal.sort(byPos), children);
}
function moveSpans(spans, offset2) {
  if (!offset2 || !spans.length)
    return spans;
  let result = [];
  for (let i = 0; i < spans.length; i++) {
    let span = spans[i];
    result.push(new Decoration(span.from + offset2, span.to + offset2, span.type));
  }
  return result;
}
function mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset2, oldOffset, options) {
  function gather(set, oldOffset2) {
    for (let i = 0; i < set.local.length; i++) {
      let mapped = set.local[i].map(mapping, offset2, oldOffset2);
      if (mapped)
        decorations.push(mapped);
      else if (options.onRemove)
        options.onRemove(set.local[i].spec);
    }
    for (let i = 0; i < set.children.length; i += 3)
      gather(set.children[i + 2], set.children[i] + oldOffset2 + 1);
  }
  for (let i = 0; i < children.length; i += 3)
    if (children[i + 1] == -1)
      gather(children[i + 2], oldChildren[i] + oldOffset + 1);
  return decorations;
}
function takeSpansForNode(spans, node2, offset2) {
  if (node2.isLeaf)
    return null;
  let end2 = offset2 + node2.nodeSize, found2 = null;
  for (let i = 0, span; i < spans.length; i++) {
    if ((span = spans[i]) && span.from > offset2 && span.to < end2) {
      (found2 || (found2 = [])).push(span);
      spans[i] = null;
    }
  }
  return found2;
}
function withoutNulls(array) {
  let result = [];
  for (let i = 0; i < array.length; i++)
    if (array[i] != null)
      result.push(array[i]);
  return result;
}
function buildTree(spans, node2, offset2, options) {
  let children = [], hasNulls = false;
  node2.forEach((childNode, localStart) => {
    let found2 = takeSpansForNode(spans, childNode, localStart + offset2);
    if (found2) {
      hasNulls = true;
      let subtree = buildTree(found2, childNode, offset2 + localStart + 1, options);
      if (subtree != empty)
        children.push(localStart, localStart + childNode.nodeSize, subtree);
    }
  });
  let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset2).sort(byPos);
  for (let i = 0; i < locals.length; i++)
    if (!locals[i].type.valid(node2, locals[i])) {
      if (options.onRemove)
        options.onRemove(locals[i].spec);
      locals.splice(i--, 1);
    }
  return locals.length || children.length ? new DecorationSet(locals, children) : empty;
}
function byPos(a, b2) {
  return a.from - b2.from || a.to - b2.to;
}
function removeOverlap(spans) {
  let working = spans;
  for (let i = 0; i < working.length - 1; i++) {
    let span = working[i];
    if (span.from != span.to)
      for (let j2 = i + 1; j2 < working.length; j2++) {
        let next = working[j2];
        if (next.from == span.from) {
          if (next.to != span.to) {
            if (working == spans)
              working = spans.slice();
            working[j2] = next.copy(next.from, span.to);
            insertAhead(working, j2 + 1, next.copy(span.to, next.to));
          }
          continue;
        } else {
          if (next.from < span.to) {
            if (working == spans)
              working = spans.slice();
            working[i] = span.copy(span.from, next.from);
            insertAhead(working, j2, span.copy(next.from, span.to));
          }
          break;
        }
      }
  }
  return working;
}
function insertAhead(array, i, deco) {
  while (i < array.length && byPos(deco, array[i]) > 0)
    i++;
  array.splice(i, 0, deco);
}
function viewDecorations(view) {
  let found2 = [];
  view.someProp("decorations", (f) => {
    let result = f(view.state);
    if (result && result != empty)
      found2.push(result);
  });
  if (view.cursorWrapper)
    found2.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));
  return DecorationGroup.from(found2);
}
const observeOptions = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  attributes: true,
  attributeOldValue: true,
  subtree: true
};
const useCharData = ie$1 && ie_version <= 11;
class SelectionState {
  constructor() {
    this.anchorNode = null;
    this.anchorOffset = 0;
    this.focusNode = null;
    this.focusOffset = 0;
  }
  set(sel) {
    this.anchorNode = sel.anchorNode;
    this.anchorOffset = sel.anchorOffset;
    this.focusNode = sel.focusNode;
    this.focusOffset = sel.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(sel) {
    return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset && sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;
  }
}
class DOMObserver {
  constructor(view, handleDOMChange) {
    this.view = view;
    this.handleDOMChange = handleDOMChange;
    this.queue = [];
    this.flushingSoon = -1;
    this.observer = null;
    this.currentSelection = new SelectionState();
    this.onCharData = null;
    this.suppressingSelectionUpdates = false;
    this.lastChangedTextNode = null;
    this.observer = window.MutationObserver && new window.MutationObserver((mutations) => {
      for (let i = 0; i < mutations.length; i++)
        this.queue.push(mutations[i]);
      if (ie$1 && ie_version <= 11 && mutations.some((m2) => m2.type == "childList" && m2.removedNodes.length || m2.type == "characterData" && m2.oldValue.length > m2.target.nodeValue.length))
        this.flushSoon();
      else
        this.flush();
    });
    if (useCharData) {
      this.onCharData = (e) => {
        this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue });
        this.flushSoon();
      };
    }
    this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    if (this.flushingSoon < 0)
      this.flushingSoon = window.setTimeout(() => {
        this.flushingSoon = -1;
        this.flush();
      }, 20);
  }
  forceFlush() {
    if (this.flushingSoon > -1) {
      window.clearTimeout(this.flushingSoon);
      this.flushingSoon = -1;
      this.flush();
    }
  }
  start() {
    if (this.observer) {
      this.observer.takeRecords();
      this.observer.observe(this.view.dom, observeOptions);
    }
    if (this.onCharData)
      this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData);
    this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let take = this.observer.takeRecords();
      if (take.length) {
        for (let i = 0; i < take.length; i++)
          this.queue.push(take[i]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    if (this.onCharData)
      this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData);
    this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = true;
    setTimeout(() => this.suppressingSelectionUpdates = false, 50);
  }
  onSelectionChange() {
    if (!hasFocusAndSelection(this.view))
      return;
    if (this.suppressingSelectionUpdates)
      return selectionToDOM(this.view);
    if (ie$1 && ie_version <= 11 && !this.view.state.selection.empty) {
      let sel = this.view.domSelectionRange();
      if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))
        return this.flushSoon();
    }
    this.flush();
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(sel) {
    if (!sel.focusNode)
      return true;
    let ancestors = /* @__PURE__ */ new Set(), container;
    for (let scan = sel.focusNode; scan; scan = parentNode(scan))
      ancestors.add(scan);
    for (let scan = sel.anchorNode; scan; scan = parentNode(scan))
      if (ancestors.has(scan)) {
        container = scan;
        break;
      }
    let desc = container && this.view.docView.nearestDesc(container);
    if (desc && desc.ignoreMutation({
      type: "selection",
      target: container.nodeType == 3 ? container.parentNode : container
    })) {
      this.setCurSelection();
      return true;
    }
  }
  pendingRecords() {
    if (this.observer)
      for (let mut of this.observer.takeRecords())
        this.queue.push(mut);
    return this.queue;
  }
  flush() {
    let { view } = this;
    if (!view.docView || this.flushingSoon > -1)
      return;
    let mutations = this.pendingRecords();
    if (mutations.length)
      this.queue = [];
    let sel = view.domSelectionRange();
    let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);
    let from2 = -1, to = -1, typeOver = false, added = [];
    if (view.editable) {
      for (let i = 0; i < mutations.length; i++) {
        let result = this.registerMutation(mutations[i], added);
        if (result) {
          from2 = from2 < 0 ? result.from : Math.min(result.from, from2);
          to = to < 0 ? result.to : Math.max(result.to, to);
          if (result.typeOver)
            typeOver = true;
        }
      }
    }
    if (gecko && added.length) {
      let brs = added.filter((n) => n.nodeName == "BR");
      if (brs.length == 2) {
        let [a, b2] = brs;
        if (a.parentNode && a.parentNode.parentNode == b2.parentNode)
          b2.remove();
        else
          a.remove();
      } else {
        let { focusNode } = this.currentSelection;
        for (let br of brs) {
          let parent = br.parentNode;
          if (parent && parent.nodeName == "LI" && (!focusNode || blockParent(view, focusNode) != parent))
            br.remove();
        }
      }
    }
    let readSel = null;
    if (from2 < 0 && newSel && view.input.lastFocus > Date.now() - 200 && Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 && selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) && readSel.eq(Selection.near(view.state.doc.resolve(0), 1))) {
      view.input.lastFocus = 0;
      selectionToDOM(view);
      this.currentSelection.set(sel);
      view.scrollToSelection();
    } else if (from2 > -1 || newSel) {
      if (from2 > -1) {
        view.docView.markDirty(from2, to);
        checkCSS(view);
      }
      this.handleDOMChange(from2, to, typeOver, added);
      if (view.docView && view.docView.dirty)
        view.updateState(view.state);
      else if (!this.currentSelection.eq(sel))
        selectionToDOM(view);
      this.currentSelection.set(sel);
    }
  }
  registerMutation(mut, added) {
    if (added.indexOf(mut.target) > -1)
      return null;
    let desc = this.view.docView.nearestDesc(mut.target);
    if (mut.type == "attributes" && (desc == this.view.docView || mut.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    mut.attributeName == "style" && !mut.oldValue && !mut.target.getAttribute("style")))
      return null;
    if (!desc || desc.ignoreMutation(mut))
      return null;
    if (mut.type == "childList") {
      for (let i = 0; i < mut.addedNodes.length; i++) {
        let node2 = mut.addedNodes[i];
        added.push(node2);
        if (node2.nodeType == 3)
          this.lastChangedTextNode = node2;
      }
      if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))
        return { from: desc.posBefore, to: desc.posAfter };
      let prev = mut.previousSibling, next = mut.nextSibling;
      if (ie$1 && ie_version <= 11 && mut.addedNodes.length) {
        for (let i = 0; i < mut.addedNodes.length; i++) {
          let { previousSibling, nextSibling } = mut.addedNodes[i];
          if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)
            prev = previousSibling;
          if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)
            next = nextSibling;
        }
      }
      let fromOffset = prev && prev.parentNode == mut.target ? domIndex(prev) + 1 : 0;
      let from2 = desc.localPosFromDOM(mut.target, fromOffset, -1);
      let toOffset = next && next.parentNode == mut.target ? domIndex(next) : mut.target.childNodes.length;
      let to = desc.localPosFromDOM(mut.target, toOffset, 1);
      return { from: from2, to };
    } else if (mut.type == "attributes") {
      return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };
    } else {
      this.lastChangedTextNode = mut.target;
      return {
        from: desc.posAtStart,
        to: desc.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: mut.target.nodeValue == mut.oldValue
      };
    }
  }
}
let cssChecked = /* @__PURE__ */ new WeakMap();
let cssCheckWarned = false;
function checkCSS(view) {
  if (cssChecked.has(view))
    return;
  cssChecked.set(view, null);
  if (["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {
    view.requiresGeckoHackNode = gecko;
    if (cssCheckWarned)
      return;
    console["warn"]("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.");
    cssCheckWarned = true;
  }
}
function rangeToSelectionRange(view, range2) {
  let anchorNode = range2.startContainer, anchorOffset = range2.startOffset;
  let focusNode = range2.endContainer, focusOffset = range2.endOffset;
  let currentAnchor = view.domAtPos(view.state.selection.anchor);
  if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))
    [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];
  return { anchorNode, anchorOffset, focusNode, focusOffset };
}
function safariShadowSelectionRange(view, selection) {
  if (selection.getComposedRanges) {
    let range2 = selection.getComposedRanges(view.root)[0];
    if (range2)
      return rangeToSelectionRange(view, range2);
  }
  let found2;
  function read2(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
    found2 = event.getTargetRanges()[0];
  }
  view.dom.addEventListener("beforeinput", read2, true);
  document.execCommand("indent");
  view.dom.removeEventListener("beforeinput", read2, true);
  return found2 ? rangeToSelectionRange(view, found2) : null;
}
function blockParent(view, node2) {
  for (let p = node2.parentNode; p && p != view.dom; p = p.parentNode) {
    let desc = view.docView.nearestDesc(p, true);
    if (desc && desc.node.isBlock)
      return p;
  }
  return null;
}
function parseBetween(view, from_, to_) {
  let { node: parent, fromOffset, toOffset, from: from2, to } = view.docView.parseRange(from_, to_);
  let domSel = view.domSelectionRange();
  let find2;
  let anchor = domSel.anchorNode;
  if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {
    find2 = [{ node: anchor, offset: domSel.anchorOffset }];
    if (!selectionCollapsed(domSel))
      find2.push({ node: domSel.focusNode, offset: domSel.focusOffset });
  }
  if (chrome && view.input.lastKeyCode === 8) {
    for (let off2 = toOffset; off2 > fromOffset; off2--) {
      let node2 = parent.childNodes[off2 - 1], desc = node2.pmViewDesc;
      if (node2.nodeName == "BR" && !desc) {
        toOffset = off2;
        break;
      }
      if (!desc || desc.size)
        break;
    }
  }
  let startDoc = view.state.doc;
  let parser = view.someProp("domParser") || DOMParser$1.fromSchema(view.state.schema);
  let $from = startDoc.resolve(from2);
  let sel = null, doc2 = parser.parse(parent, {
    topNode: $from.parent,
    topMatch: $from.parent.contentMatchAt($from.index()),
    topOpen: true,
    from: fromOffset,
    to: toOffset,
    preserveWhitespace: $from.parent.type.whitespace == "pre" ? "full" : true,
    findPositions: find2,
    ruleFromNode,
    context: $from
  });
  if (find2 && find2[0].pos != null) {
    let anchor2 = find2[0].pos, head = find2[1] && find2[1].pos;
    if (head == null)
      head = anchor2;
    sel = { anchor: anchor2 + from2, head: head + from2 };
  }
  return { doc: doc2, sel, from: from2, to };
}
function ruleFromNode(dom) {
  let desc = dom.pmViewDesc;
  if (desc) {
    return desc.parseRule();
  } else if (dom.nodeName == "BR" && dom.parentNode) {
    if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {
      let skip = document.createElement("div");
      skip.appendChild(document.createElement("li"));
      return { skip };
    } else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {
      return { ignore: true };
    }
  } else if (dom.nodeName == "IMG" && dom.getAttribute("mark-placeholder")) {
    return { ignore: true };
  }
  return null;
}
const isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function readDOMChange(view, from2, to, typeOver, addedNodes) {
  let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);
  view.input.compositionPendingChanges = 0;
  if (from2 < 0) {
    let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;
    let newSel = selectionFromDOM(view, origin);
    if (newSel && !view.state.selection.eq(newSel)) {
      if (chrome && android && view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter"))))
        return;
      let tr = view.state.tr.setSelection(newSel);
      if (origin == "pointer")
        tr.setMeta("pointer", true);
      else if (origin == "key")
        tr.scrollIntoView();
      if (compositionID)
        tr.setMeta("composition", compositionID);
      view.dispatch(tr);
    }
    return;
  }
  let $before = view.state.doc.resolve(from2);
  let shared = $before.sharedDepth(to);
  from2 = $before.before(shared + 1);
  to = view.state.doc.resolve(to).after(shared + 1);
  let sel = view.state.selection;
  let parse = parseBetween(view, from2, to);
  let doc2 = view.state.doc, compare = doc2.slice(parse.from, parse.to);
  let preferredPos, preferredSide;
  if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {
    preferredPos = view.state.selection.to;
    preferredSide = "end";
  } else {
    preferredPos = view.state.selection.from;
    preferredSide = "start";
  }
  view.input.lastKeyCode = null;
  let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);
  if (change)
    view.input.domChangeCount++;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) && addedNodes.some((n) => n.nodeType == 1 && !isInline.test(n.nodeName)) && (!change || change.endA >= change.endB) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (!change) {
    if (typeOver && sel instanceof TextSelection$1 && !sel.empty && sel.$head.sameParent(sel.$anchor) && !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {
      change = { start: sel.from, endA: sel.to, endB: sel.to };
    } else {
      if (parse.sel) {
        let sel2 = resolveSelection(view, view.state.doc, parse.sel);
        if (sel2 && !sel2.eq(view.state.selection)) {
          let tr = view.state.tr.setSelection(sel2);
          if (compositionID)
            tr.setMeta("composition", compositionID);
          view.dispatch(tr);
        }
      }
      return;
    }
  }
  if (view.state.selection.from < view.state.selection.to && change.start == change.endB && view.state.selection instanceof TextSelection$1) {
    if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 && view.state.selection.from >= parse.from) {
      change.start = view.state.selection.from;
    } else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 && view.state.selection.to <= parse.to) {
      change.endB += view.state.selection.to - change.endA;
      change.endA = view.state.selection.to;
    }
  }
  if (ie$1 && ie_version <= 11 && change.endB == change.start + 1 && change.endA == change.start && change.start > parse.from && parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == "  ") {
    change.start--;
    change.endA--;
    change.endB--;
  }
  let $from = parse.doc.resolveNoCache(change.start - parse.from);
  let $to = parse.doc.resolveNoCache(change.endB - parse.from);
  let $fromA = doc2.resolve(change.start);
  let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;
  let nextSel;
  if ((ios && view.input.lastIOSEnter > Date.now() - 225 && (!inlineChange || addedNodes.some((n) => n.nodeName == "DIV" || n.nodeName == "P")) || !inlineChange && $from.pos < parse.doc.content.size && (!$from.sameParent($to) || !$from.parent.inlineContent) && !/\S/.test(parse.doc.textBetween($from.pos, $to.pos, "", "")) && (nextSel = Selection.findFrom(parse.doc.resolve($from.pos + 1), 1, true)) && nextSel.head > $from.pos) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(13, "Enter")))) {
    view.input.lastIOSEnter = 0;
    return;
  }
  if (view.state.selection.anchor > change.start && looksLikeBackspace(doc2, change.start, change.endA, $from, $to) && view.someProp("handleKeyDown", (f) => f(view, keyEvent(8, "Backspace")))) {
    if (android && chrome)
      view.domObserver.suppressSelectionUpdates();
    return;
  }
  if (chrome && change.endB == change.start)
    view.input.lastChromeDelete = Date.now();
  if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth && parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {
    change.endB -= 2;
    $to = parse.doc.resolveNoCache(change.endB - parse.from);
    setTimeout(() => {
      view.someProp("handleKeyDown", function(f) {
        return f(view, keyEvent(13, "Enter"));
      });
    }, 20);
  }
  let chFrom = change.start, chTo = change.endA;
  let mkTr = (base2) => {
    let tr = base2 || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));
    if (parse.sel) {
      let sel2 = resolveSelection(view, tr.doc, parse.sel);
      if (sel2 && !(chrome && view.composing && sel2.empty && (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) && (sel2.head == chFrom || sel2.head == tr.mapping.map(chTo) - 1) || ie$1 && sel2.empty && sel2.head == chFrom))
        tr.setSelection(sel2);
    }
    if (compositionID)
      tr.setMeta("composition", compositionID);
    return tr.scrollIntoView();
  };
  let markChange;
  if (inlineChange) {
    if ($from.pos == $to.pos) {
      if (ie$1 && ie_version <= 11 && $from.parentOffset == 0) {
        view.domObserver.suppressSelectionUpdates();
        setTimeout(() => selectionToDOM(view), 20);
      }
      let tr = mkTr(view.state.tr.delete(chFrom, chTo));
      let marks = doc2.resolve(change.start).marksAcross(doc2.resolve(change.endA));
      if (marks)
        tr.ensureMarks(marks);
      view.dispatch(tr);
    } else if (
      // Adding or removing a mark
      change.endA == change.endB && (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))
    ) {
      let tr = mkTr(view.state.tr);
      if (markChange.type == "add")
        tr.addMark(chFrom, chTo, markChange.mark);
      else
        tr.removeMark(chFrom, chTo, markChange.mark);
      view.dispatch(tr);
    } else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {
      let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);
      let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));
      if (!view.someProp("handleTextInput", (f) => f(view, chFrom, chTo, text, deflt)))
        view.dispatch(deflt());
    }
  } else {
    view.dispatch(mkTr());
  }
}
function resolveSelection(view, doc2, parsedSel) {
  if (Math.max(parsedSel.anchor, parsedSel.head) > doc2.content.size)
    return null;
  return selectionBetween(view, doc2.resolve(parsedSel.anchor), doc2.resolve(parsedSel.head));
}
function isMarkChange(cur, prev) {
  let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;
  let added = curMarks, removed = prevMarks, type2, mark, update;
  for (let i = 0; i < prevMarks.length; i++)
    added = prevMarks[i].removeFromSet(added);
  for (let i = 0; i < curMarks.length; i++)
    removed = curMarks[i].removeFromSet(removed);
  if (added.length == 1 && removed.length == 0) {
    mark = added[0];
    type2 = "add";
    update = (node2) => node2.mark(mark.addToSet(node2.marks));
  } else if (added.length == 0 && removed.length == 1) {
    mark = removed[0];
    type2 = "remove";
    update = (node2) => node2.mark(mark.removeFromSet(node2.marks));
  } else {
    return null;
  }
  let updated = [];
  for (let i = 0; i < prev.childCount; i++)
    updated.push(update(prev.child(i)));
  if (Fragment.from(updated).eq(cur))
    return { mark, type: type2 };
}
function looksLikeBackspace(old, start2, end2, $newStart, $newEnd) {
  if (
    // The content must have shrunk
    end2 - start2 <= $newEnd.pos - $newStart.pos || // newEnd must point directly at or after the end of the block that newStart points into
    skipClosingAndOpening($newStart, true, false) < $newEnd.pos
  )
    return false;
  let $start = old.resolve(start2);
  if (!$newStart.parent.isTextblock) {
    let after = $start.nodeAfter;
    return after != null && end2 == start2 + after.nodeSize;
  }
  if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)
    return false;
  let $next = old.resolve(skipClosingAndOpening($start, true, true));
  if (!$next.parent.isTextblock || $next.pos > end2 || skipClosingAndOpening($next, true, false) < end2)
    return false;
  return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);
}
function skipClosingAndOpening($pos, fromEnd, mayOpen) {
  let depth = $pos.depth, end2 = fromEnd ? $pos.end() : $pos.pos;
  while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {
    depth--;
    end2++;
    fromEnd = false;
  }
  if (mayOpen) {
    let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));
    while (next && !next.isLeaf) {
      next = next.firstChild;
      end2++;
    }
  }
  return end2;
}
function findDiff(a, b2, pos, preferredPos, preferredSide) {
  let start2 = a.findDiffStart(b2, pos);
  if (start2 == null)
    return null;
  let { a: endA, b: endB } = a.findDiffEnd(b2, pos + a.size, pos + b2.size);
  if (preferredSide == "end") {
    let adjust = Math.max(0, start2 - Math.min(endA, endB));
    preferredPos -= endA + adjust - start2;
  }
  if (endA < start2 && a.size < b2.size) {
    let move2 = preferredPos <= start2 && preferredPos >= endA ? start2 - preferredPos : 0;
    start2 -= move2;
    if (start2 && start2 < b2.size && isSurrogatePair(b2.textBetween(start2 - 1, start2 + 1)))
      start2 += move2 ? 1 : -1;
    endB = start2 + (endB - endA);
    endA = start2;
  } else if (endB < start2) {
    let move2 = preferredPos <= start2 && preferredPos >= endB ? start2 - preferredPos : 0;
    start2 -= move2;
    if (start2 && start2 < a.size && isSurrogatePair(a.textBetween(start2 - 1, start2 + 1)))
      start2 += move2 ? 1 : -1;
    endA = start2 + (endA - endB);
    endB = start2;
  }
  return { start: start2, endA, endB };
}
function isSurrogatePair(str) {
  if (str.length != 2)
    return false;
  let a = str.charCodeAt(0), b2 = str.charCodeAt(1);
  return a >= 56320 && a <= 57343 && b2 >= 55296 && b2 <= 56319;
}
class EditorView {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(place, props) {
    this._root = null;
    this.focused = false;
    this.trackWrites = null;
    this.mounted = false;
    this.markCursor = null;
    this.cursorWrapper = null;
    this.lastSelectedViewDesc = void 0;
    this.input = new InputState();
    this.prevDirectPlugins = [];
    this.pluginViews = [];
    this.requiresGeckoHackNode = false;
    this.dragging = null;
    this._props = props;
    this.state = props.state;
    this.directPlugins = props.plugins || [];
    this.directPlugins.forEach(checkStateComponent);
    this.dispatch = this.dispatch.bind(this);
    this.dom = place && place.mount || document.createElement("div");
    if (place) {
      if (place.appendChild)
        place.appendChild(this.dom);
      else if (typeof place == "function")
        place(this.dom);
      else if (place.mount)
        this.mounted = true;
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    this.nodeViews = buildNodeViews(this);
    this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);
    this.domObserver = new DOMObserver(this, (from2, to, typeOver, added) => readDOMChange(this, from2, to, typeOver, added));
    this.domObserver.start();
    initInput(this);
    this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let prev = this._props;
      this._props = {};
      for (let name in prev)
        this._props[name] = prev[name];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(props) {
    if (props.handleDOMEvents != this._props.handleDOMEvents)
      ensureListeners(this);
    let prevProps = this._props;
    this._props = props;
    if (props.plugins) {
      props.plugins.forEach(checkStateComponent);
      this.directPlugins = props.plugins;
    }
    this.updateStateInner(props.state, prevProps);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(props) {
    let updated = {};
    for (let name in this._props)
      updated[name] = this._props[name];
    updated.state = this.state;
    for (let name in props)
      updated[name] = props[name];
    this.update(updated);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(state2) {
    this.updateStateInner(state2, this._props);
  }
  updateStateInner(state2, prevProps) {
    var _a2;
    let prev = this.state, redraw = false, updateSel = false;
    if (state2.storedMarks && this.composing) {
      clearComposition(this);
      updateSel = true;
    }
    this.state = state2;
    let pluginsChanged = prev.plugins != state2.plugins || this._props.plugins != prevProps.plugins;
    if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {
      let nodeViews = buildNodeViews(this);
      if (changedNodeViews(nodeViews, this.nodeViews)) {
        this.nodeViews = nodeViews;
        redraw = true;
      }
    }
    if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {
      ensureListeners(this);
    }
    this.editable = getEditable(this);
    updateCursorWrapper(this);
    let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);
    let scroll = prev.plugins != state2.plugins && !prev.doc.eq(state2.doc) ? "reset" : state2.scrollToSelection > prev.scrollToSelection ? "to selection" : "preserve";
    let updateDoc = redraw || !this.docView.matchesNode(state2.doc, outerDeco, innerDeco);
    if (updateDoc || !state2.selection.eq(prev.selection))
      updateSel = true;
    let oldScrollPos = scroll == "preserve" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);
    if (updateSel) {
      this.domObserver.stop();
      let forceSelUpdate = updateDoc && (ie$1 || chrome) && !this.composing && !prev.selection.empty && !state2.selection.empty && selectionContextChanged(prev.selection, state2.selection);
      if (updateDoc) {
        let chromeKludge = chrome ? this.trackWrites = this.domSelectionRange().focusNode : null;
        if (this.composing)
          this.input.compositionNode = findCompositionNode(this);
        if (redraw || !this.docView.update(state2.doc, outerDeco, innerDeco, this)) {
          this.docView.updateOuterDeco(outerDeco);
          this.docView.destroy();
          this.docView = docViewDesc(state2.doc, outerDeco, innerDeco, this.dom, this);
        }
        if (chromeKludge && !this.trackWrites)
          forceSelUpdate = true;
      }
      if (forceSelUpdate || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && anchorInRightPlace(this))) {
        selectionToDOM(this, forceSelUpdate);
      } else {
        syncNodeSelection(this, state2.selection);
        this.domObserver.setCurSelection();
      }
      this.domObserver.start();
    }
    this.updatePluginViews(prev);
    if (((_a2 = this.dragging) === null || _a2 === void 0 ? void 0 : _a2.node) && !prev.doc.eq(state2.doc))
      this.updateDraggedNode(this.dragging, prev);
    if (scroll == "reset") {
      this.dom.scrollTop = 0;
    } else if (scroll == "to selection") {
      this.scrollToSelection();
    } else if (oldScrollPos) {
      resetScrollPos(oldScrollPos);
    }
  }
  /**
  @internal
  */
  scrollToSelection() {
    let startDOM = this.domSelectionRange().focusNode;
    if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;
    else if (this.someProp("handleScrollToSelection", (f) => f(this))) ;
    else if (this.state.selection instanceof NodeSelection) {
      let target = this.docView.domAfterPos(this.state.selection.from);
      if (target.nodeType == 1)
        scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);
    } else {
      scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);
    }
  }
  destroyPluginViews() {
    let view;
    while (view = this.pluginViews.pop())
      if (view.destroy)
        view.destroy();
  }
  updatePluginViews(prevState) {
    if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins;
      this.destroyPluginViews();
      for (let i = 0; i < this.directPlugins.length; i++) {
        let plugin2 = this.directPlugins[i];
        if (plugin2.spec.view)
          this.pluginViews.push(plugin2.spec.view(this));
      }
      for (let i = 0; i < this.state.plugins.length; i++) {
        let plugin2 = this.state.plugins[i];
        if (plugin2.spec.view)
          this.pluginViews.push(plugin2.spec.view(this));
      }
    } else {
      for (let i = 0; i < this.pluginViews.length; i++) {
        let pluginView = this.pluginViews[i];
        if (pluginView.update)
          pluginView.update(this, prevState);
      }
    }
  }
  updateDraggedNode(dragging, prev) {
    let sel = dragging.node, found2 = -1;
    if (this.state.doc.nodeAt(sel.from) == sel.node) {
      found2 = sel.from;
    } else {
      let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);
      let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);
      if (moved == sel.node)
        found2 = movedPos;
    }
    this.dragging = new Dragging(dragging.slice, dragging.move, found2 < 0 ? void 0 : NodeSelection.create(this.state.doc, found2));
  }
  someProp(propName, f) {
    let prop = this._props && this._props[propName], value;
    if (prop != null && (value = f ? f(prop) : prop))
      return value;
    for (let i = 0; i < this.directPlugins.length; i++) {
      let prop2 = this.directPlugins[i].props[propName];
      if (prop2 != null && (value = f ? f(prop2) : prop2))
        return value;
    }
    let plugins = this.state.plugins;
    if (plugins)
      for (let i = 0; i < plugins.length; i++) {
        let prop2 = plugins[i].props[propName];
        if (prop2 != null && (value = f ? f(prop2) : prop2))
          return value;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (ie$1) {
      let node2 = this.root.activeElement;
      if (node2 == this.dom)
        return true;
      if (!node2 || !this.dom.contains(node2))
        return false;
      while (node2 && this.dom != node2 && this.dom.contains(node2)) {
        if (node2.contentEditable == "false")
          return false;
        node2 = node2.parentElement;
      }
      return true;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop();
    if (this.editable)
      focusPreventScroll(this.dom);
    selectionToDOM(this);
    this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let cached = this._root;
    if (cached == null)
      for (let search2 = this.dom.parentNode; search2; search2 = search2.parentNode) {
        if (search2.nodeType == 9 || search2.nodeType == 11 && search2.host) {
          if (!search2.getSelection)
            Object.getPrototypeOf(search2).getSelection = () => search2.ownerDocument.getSelection();
          return this._root = search2;
        }
      }
    return cached || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(coords) {
    return posAtCoords(this, coords);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(pos, side = 1) {
    return coordsAtPos(this, pos, side);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(pos, side = 0) {
    return this.docView.domFromPos(pos, side);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(pos) {
    let desc = this.docView.descAt(pos);
    return desc ? desc.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(node2, offset2, bias = -1) {
    let pos = this.docView.posFromDOM(node2, offset2, bias);
    if (pos == null)
      throw new RangeError("DOM position not inside the editor");
    return pos;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(dir, state2) {
    return endOfTextblock(this, state2 || this.state, dir);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(html, event) {
    return doPaste(this, "", html, false, event || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(text, event) {
    return doPaste(this, text, null, true, event || new ClipboardEvent("paste"));
  }
  /**
  Serialize the given slice as it would be if it was copied from
  this editor. Returns a DOM element that contains a
  representation of the slice as its children, a textual
  representation, and the transformed slice (which can be
  different from the given input due to hooks like
  [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).
  */
  serializeForClipboard(slice2) {
    return serializeForClipboard(this, slice2);
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    if (!this.docView)
      return;
    destroyInput(this);
    this.destroyPluginViews();
    if (this.mounted) {
      this.docView.update(this.state.doc, [], viewDecorations(this), this);
      this.dom.textContent = "";
    } else if (this.dom.parentNode) {
      this.dom.parentNode.removeChild(this.dom);
    }
    this.docView.destroy();
    this.docView = null;
    clearReusedRange();
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(event) {
    return dispatchEvent(this, event);
  }
  /**
  @internal
  */
  domSelectionRange() {
    let sel = this.domSelection();
    if (!sel)
      return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };
    return safari && this.root.nodeType === 11 && deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
EditorView.prototype.dispatch = function(tr) {
  let dispatchTransaction = this._props.dispatchTransaction;
  if (dispatchTransaction)
    dispatchTransaction.call(this, tr);
  else
    this.updateState(this.state.apply(tr));
};
function computeDocDeco(view) {
  let attrs = /* @__PURE__ */ Object.create(null);
  attrs.class = "ProseMirror";
  attrs.contenteditable = String(view.editable);
  view.someProp("attributes", (value) => {
    if (typeof value == "function")
      value = value(view.state);
    if (value)
      for (let attr in value) {
        if (attr == "class")
          attrs.class += " " + value[attr];
        else if (attr == "style")
          attrs.style = (attrs.style ? attrs.style + ";" : "") + value[attr];
        else if (!attrs[attr] && attr != "contenteditable" && attr != "nodeName")
          attrs[attr] = String(value[attr]);
      }
  });
  if (!attrs.translate)
    attrs.translate = "no";
  return [Decoration.node(0, view.state.doc.content.size, attrs)];
}
function updateCursorWrapper(view) {
  if (view.markCursor) {
    let dom = document.createElement("img");
    dom.className = "ProseMirror-separator";
    dom.setAttribute("mark-placeholder", "true");
    dom.setAttribute("alt", "");
    view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };
  } else {
    view.cursorWrapper = null;
  }
}
function getEditable(view) {
  return !view.someProp("editable", (value) => value(view.state) === false);
}
function selectionContextChanged(sel1, sel2) {
  let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));
  return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);
}
function buildNodeViews(view) {
  let result = /* @__PURE__ */ Object.create(null);
  function add(obj) {
    for (let prop in obj)
      if (!Object.prototype.hasOwnProperty.call(result, prop))
        result[prop] = obj[prop];
  }
  view.someProp("nodeViews", add);
  view.someProp("markViews", add);
  return result;
}
function changedNodeViews(a, b2) {
  let nA = 0, nB = 0;
  for (let prop in a) {
    if (a[prop] != b2[prop])
      return true;
    nA++;
  }
  for (let _2 in b2)
    nB++;
  return nA != nB;
}
function checkStateComponent(plugin2) {
  if (plugin2.spec.state || plugin2.spec.filterTransaction || plugin2.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
const floor$1 = Math.floor;
const abs = Math.abs;
const min$2 = (a, b2) => a < b2 ? a : b2;
const max$2 = (a, b2) => a > b2 ? a : b2;
const isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;
const BIT7 = 64;
const BIT8 = 128;
const BIT30 = 1 << 29;
const BITS6 = 63;
const BITS7 = 127;
const BITS31 = 2147483647;
const isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor$1(num) === num);
const create$2 = () => /* @__PURE__ */ new Set();
const isArray$1 = Array.isArray;
const fromCharCode = String.fromCharCode;
const toLowerCase = (s) => s.toLowerCase();
const trimLeftRegex = /^\s*/g;
const trimLeft = (s) => s.replace(trimLeftRegex, "");
const fromCamelCaseRegex = /([A-Z])/g;
const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
const _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    buf[i] = /** @type {number} */
    encodedString.codePointAt(i);
  }
  return buf;
};
const utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
const _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
let utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}
class Encoder {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
}
const createEncoder = () => new Encoder();
const encode = (f) => {
  const encoder = createEncoder();
  f(encoder);
  return toUint8Array(encoder);
};
const length = (encoder) => {
  let len = encoder.cpos;
  for (let i = 0; i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
};
const toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i = 0; i < encoder.bufs.length; i++) {
    const d2 = encoder.bufs[i];
    uint8arr.set(d2, curPos);
    curPos += d2.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
const verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max$2(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
const write$1 = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
const writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write$1(encoder, BIT8 | BITS7 & num);
    num = floor$1(num / 128);
  }
  write$1(encoder, BITS7 & num);
};
const writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write$1(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor$1(num / 64);
  while (num > 0) {
    write$1(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor$1(num / 128);
  }
};
const _strBuffer = new Uint8Array(3e4);
const _maxStrBSize = _strBuffer.length / 3;
const _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i = 0; i < written; i++) {
      write$1(encoder, _strBuffer[i]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
const _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    write$1(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i)
    );
  }
};
const writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
const writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min$2(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max$2(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
const writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
const writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
const writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
const floatTestBed = new DataView(new ArrayBuffer(4));
const isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
const writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write$1(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write$1(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write$1(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write$1(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write$1(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write$1(encoder, 126);
      } else if (isArray$1(data)) {
        write$1(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i = 0; i < data.length; i++) {
          writeAny(encoder, data[i]);
        }
      } else if (data instanceof Uint8Array) {
        write$1(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write$1(encoder, 118);
        const keys2 = Object.keys(data);
        writeVarUint(encoder, keys2.length);
        for (let i = 0; i < keys2.length; i++) {
          const key = keys2[i];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write$1(encoder, data ? 120 : 121);
      break;
    default:
      write$1(encoder, 127);
  }
};
const create$1 = (s) => new Error(s);
const methodUnimplemented = () => {
  throw create$1("Method unimplemented");
};
const unexpectedCase = () => {
  throw create$1("Unexpected case");
};
const create = () => /* @__PURE__ */ new Map();
const setIfUndefined = (map22, key, createT) => {
  let set = map22.get(key);
  if (set === void 0) {
    map22.set(key, set = createT());
  }
  return set;
};
const keys$1 = Object.keys;
const every = (obj, f) => {
  for (const key in obj) {
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
};
const isOneOf = (value, options) => options.includes(value);
const createMutex = () => {
  let token = true;
  return (f, g) => {
    if (token) {
      token = false;
      try {
        f();
      } finally {
        token = true;
      }
    } else if (g !== void 0) {
      g();
    }
  };
};
const highSurrogateRegex = /[\uD800-\uDBFF]/;
const lowSurrogateRegex = /[\uDC00-\uDFFF]/;
const simpleDiffString = (a, b2) => {
  let left2 = 0;
  let right2 = 0;
  while (left2 < a.length && left2 < b2.length && a[left2] === b2[left2]) {
    left2++;
  }
  if (left2 > 0 && highSurrogateRegex.test(a[left2 - 1])) left2--;
  while (right2 + left2 < a.length && right2 + left2 < b2.length && a[a.length - right2 - 1] === b2[b2.length - right2 - 1]) {
    right2++;
  }
  if (right2 > 0 && lowSurrogateRegex.test(a[a.length - right2])) right2--;
  return {
    index: left2,
    remove: a.length - left2 - right2,
    insert: b2.slice(left2, b2.length - right2)
  };
};
const simpleDiff = simpleDiffString;
const ySyncPluginKey = new PluginKey("y-sync");
const yUndoPluginKey = new PluginKey("y-undo");
const yCursorPluginKey = new PluginKey("yjs-cursor");
const rand = Math.random;
const oneOf = (arr) => arr[floor$1(rand() * arr.length)];
const undefinedToNull = (v2) => v2 === void 0 ? null : v2;
class VarStoragePolyfill {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
}
let _localStorage = new VarStoragePolyfill();
let usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
const varStorage = _localStorage;
const isNode$1 = typeof process$1$1 !== "undefined" && process$1$1.release && /node|io\.js/.test(process$1$1.release.name) && Object.prototype.toString.call(typeof process$1$1 !== "undefined" ? process$1$1 : 0) === "[object process]";
const isBrowser$1$1 = typeof window !== "undefined" && typeof document !== "undefined" && !isNode$1;
let params;
const computeParams = () => {
  if (params === void 0) {
    if (isNode$1) {
      params = create();
      const pargs = process$1$1.argv;
      let currParamName = null;
      for (let i = 0; i < pargs.length; i++) {
        const parg = pargs[i];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
};
const hasParam = (name) => computeParams().has(name);
const getVariable = (name) => isNode$1 ? undefinedToNull(process$1$1.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
const hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
hasConf("production");
const forceColor = isNode$1 && isOneOf(process$1$1.env.FORCE_COLOR, ["true", "1", "2"]);
forceColor || !hasParam("--no-colors") && // @todo deprecate --no-colors
!hasConf("no-color") && (!isNode$1 || process$1$1.stdout.isTTY) && (!isNode$1 || hasParam("--color") || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));
const doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
typeof DOMParser !== "undefined" ? new DOMParser() : null;
const createTimeoutClass = (clearFunction) => class TT {
  /**
   * @param {number} timeoutId
   */
  constructor(timeoutId) {
    this._ = timeoutId;
  }
  destroy() {
    clearFunction(this._);
  }
};
const Timeout = createTimeoutClass(clearTimeout);
const timeout = (timeout2, callback) => new Timeout(setTimeout(callback, timeout2));
const rotr = (w2, shift2) => w2 >>> shift2 | w2 << 32 - shift2;
const sum0to256 = (x) => rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
const sum1to256 = (x) => rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
const sigma0to256 = (x) => rotr(x, 7) ^ rotr(x, 18) ^ x >>> 3;
const sigma1to256 = (x) => rotr(x, 17) ^ rotr(x, 19) ^ x >>> 10;
const K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
const HINIT = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
class Hasher {
  constructor() {
    const buf = new ArrayBuffer(64 + 64 * 4);
    this._H = new Uint32Array(buf, 0, 8);
    this._H.set(HINIT);
    this._W = new Uint32Array(buf, 64, 64);
  }
  _updateHash() {
    const H2 = this._H;
    const W2 = this._W;
    for (let t = 16; t < 64; t++) {
      W2[t] = sigma1to256(W2[t - 2]) + W2[t - 7] + sigma0to256(W2[t - 15]) + W2[t - 16];
    }
    let a = H2[0];
    let b2 = H2[1];
    let c2 = H2[2];
    let d2 = H2[3];
    let e = H2[4];
    let f = H2[5];
    let g = H2[6];
    let h2 = H2[7];
    for (let tt = 0, T1, T2; tt < 64; tt++) {
      T1 = h2 + sum1to256(e) + (e & f ^ ~e & g) + K[tt] + W2[tt] >>> 0;
      T2 = sum0to256(a) + (a & b2 ^ a & c2 ^ b2 & c2) >>> 0;
      h2 = g;
      g = f;
      f = e;
      e = d2 + T1 >>> 0;
      d2 = c2;
      c2 = b2;
      b2 = a;
      a = T1 + T2 >>> 0;
    }
    H2[0] += a;
    H2[1] += b2;
    H2[2] += c2;
    H2[3] += d2;
    H2[4] += e;
    H2[5] += f;
    H2[6] += g;
    H2[7] += h2;
  }
  /**
   * Returns a 32-byte hash.
   *
   * @param {Uint8Array} data
   */
  digest(data) {
    let i = 0;
    for (; i + 56 <= data.length; ) {
      let j22 = 0;
      for (; j22 < 16 && i + 3 < data.length; j22++) {
        this._W[j22] = data[i++] << 24 | data[i++] << 16 | data[i++] << 8 | data[i++];
      }
      if (i % 64 !== 0) {
        this._W.fill(0, j22, 16);
        while (i < data.length) {
          this._W[j22] |= data[i] << (3 - i % 4) * 8;
          i++;
        }
        this._W[j22] |= BIT8 << (3 - i % 4) * 8;
      }
      this._updateHash();
    }
    const isPaddedWith1 = i % 64 !== 0;
    this._W.fill(0, 0, 16);
    let j2 = 0;
    for (; i < data.length; j2++) {
      for (let ci = 3; ci >= 0 && i < data.length; ci--) {
        this._W[j2] |= data[i++] << ci * 8;
      }
    }
    if (!isPaddedWith1) {
      this._W[j2 - (i % 4 === 0 ? 0 : 1)] |= BIT8 << (3 - i % 4) * 8;
    }
    this._W[14] = data.byteLength / BIT30;
    this._W[15] = data.byteLength * 8;
    this._updateHash();
    const dv = new Uint8Array(32);
    for (let i2 = 0; i2 < this._H.length; i2++) {
      for (let ci = 0; ci < 4; ci++) {
        dv[i2 * 4 + ci] = this._H[i2] >>> (3 - ci) * 8;
      }
    }
    return dv;
  }
}
const digest = (data) => new Hasher().digest(data);
const toBase64Browser = (bytes) => {
  let s = "";
  for (let i = 0; i < bytes.byteLength; i++) {
    s += fromCharCode(bytes[i]);
  }
  return btoa(s);
};
const toBase64Node = (bytes) => Buffer2.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
const toBase64 = isBrowser$1$1 ? toBase64Browser : toBase64Node;
const encodeAny = (data) => encode((encoder) => writeAny(encoder, data));
const _convolute = (digest2) => {
  const N2 = 6;
  for (let i = N2; i < digest2.length; i++) {
    digest2[i % N2] = digest2[i % N2] ^ digest2[i];
  }
  return digest2.slice(0, N2);
};
const hashOfJSON = (json) => toBase64(_convolute(digest(encodeAny(json))));
const createEmptyMeta = () => ({
  mapping: /* @__PURE__ */ new Map(),
  isOMark: /* @__PURE__ */ new Map()
});
const isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && /** @type {number} */
snapshot.sv.get(item.id.client) > item.id.clock && !Y__namespace.isDeleted(snapshot.ds, item.id);
const defaultColors = [{ light: "#ecd44433", dark: "#ecd444" }];
const getUserColor = (colorMapping, colors2, user) => {
  if (!colorMapping.has(user)) {
    if (colorMapping.size < colors2.length) {
      const usedColors = create$2();
      colorMapping.forEach((color) => usedColors.add(color));
      colors2 = colors2.filter((color) => !usedColors.has(color));
    }
    colorMapping.set(user, oneOf(colors2));
  }
  return (
    /** @type {ColorDef} */
    colorMapping.get(user)
  );
};
const ySyncPlugin = (yXmlFragment, {
  colors: colors2 = defaultColors,
  colorMapping = /* @__PURE__ */ new Map(),
  permanentUserData = null,
  onFirstRender = () => {
  },
  mapping
} = {}) => {
  let initialContentChanged = false;
  const binding = new ProsemirrorBinding(yXmlFragment, mapping);
  const plugin2 = new Plugin({
    props: {
      editable: (state2) => {
        const syncState = ySyncPluginKey.getState(state2);
        return syncState.snapshot == null && syncState.prevSnapshot == null;
      }
    },
    key: ySyncPluginKey,
    state: {
      /**
       * @returns {any}
       */
      init: (_initargs, _state) => {
        return {
          type: yXmlFragment,
          doc: yXmlFragment.doc,
          binding,
          snapshot: null,
          prevSnapshot: null,
          isChangeOrigin: false,
          isUndoRedoOperation: false,
          addToHistory: true,
          colors: colors2,
          colorMapping,
          permanentUserData
        };
      },
      apply: (tr, pluginState) => {
        const change = tr.getMeta(ySyncPluginKey);
        if (change !== void 0) {
          pluginState = Object.assign({}, pluginState);
          for (const key in change) {
            pluginState[key] = change[key];
          }
        }
        pluginState.addToHistory = tr.getMeta("addToHistory") !== false;
        pluginState.isChangeOrigin = change !== void 0 && !!change.isChangeOrigin;
        pluginState.isUndoRedoOperation = change !== void 0 && !!change.isChangeOrigin && !!change.isUndoRedoOperation;
        if (binding.prosemirrorView !== null) {
          if (change !== void 0 && (change.snapshot != null || change.prevSnapshot != null)) {
            timeout(0, () => {
              if (binding.prosemirrorView == null) {
                return;
              }
              if (change.restore == null) {
                binding._renderSnapshot(
                  change.snapshot,
                  change.prevSnapshot,
                  pluginState
                );
              } else {
                binding._renderSnapshot(
                  change.snapshot,
                  change.snapshot,
                  pluginState
                );
                delete pluginState.restore;
                delete pluginState.snapshot;
                delete pluginState.prevSnapshot;
                binding.mux(() => {
                  binding._prosemirrorChanged(
                    binding.prosemirrorView.state.doc
                  );
                });
              }
            });
          }
        }
        return pluginState;
      }
    },
    view: (view) => {
      binding.initView(view);
      if (mapping == null) {
        binding._forceRerender();
      }
      onFirstRender();
      return {
        update: () => {
          const pluginState = plugin2.getState(view.state);
          if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {
            if (
              // If the content doesn't change initially, we don't render anything to Yjs
              // If the content was cleared by a user action, we want to catch the change and
              // represent it in Yjs
              initialContentChanged || view.state.doc.content.findDiffStart(
                view.state.doc.type.createAndFill().content
              ) !== null
            ) {
              initialContentChanged = true;
              if (pluginState.addToHistory === false && !pluginState.isChangeOrigin) {
                const yUndoPluginState = yUndoPluginKey.getState(view.state);
                const um = yUndoPluginState && yUndoPluginState.undoManager;
                if (um) {
                  um.stopCapturing();
                }
              }
              binding.mux(() => {
                pluginState.doc.transact((tr) => {
                  tr.meta.set("addToHistory", pluginState.addToHistory);
                  binding._prosemirrorChanged(view.state.doc);
                }, ySyncPluginKey);
              });
            }
          }
        },
        destroy: () => {
          binding.destroy();
        }
      };
    }
  });
  return plugin2;
};
const restoreRelativeSelection = (tr, relSel, binding) => {
  if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {
    if (relSel.type === "all") {
      tr.setSelection(new AllSelection(tr.doc));
    } else if (relSel.type === "node") {
      const anchor = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.anchor,
        binding.mapping
      );
      tr.setSelection(NodeSelection.create(tr.doc, anchor));
    } else {
      const anchor = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.anchor,
        binding.mapping
      );
      const head = relativePositionToAbsolutePosition(
        binding.doc,
        binding.type,
        relSel.head,
        binding.mapping
      );
      if (anchor !== null && head !== null) {
        const sel = TextSelection$1.between(tr.doc.resolve(anchor), tr.doc.resolve(head));
        tr.setSelection(sel);
      }
    }
  }
};
const getRelativeSelection = (pmbinding, state2) => ({
  type: (
    /** @type {any} */
    state2.selection.jsonID
  ),
  anchor: absolutePositionToRelativePosition(
    state2.selection.anchor,
    pmbinding.type,
    pmbinding.mapping
  ),
  head: absolutePositionToRelativePosition(
    state2.selection.head,
    pmbinding.type,
    pmbinding.mapping
  )
});
class ProsemirrorBinding {
  /**
   * @param {Y.XmlFragment} yXmlFragment The bind source
   * @param {ProsemirrorMapping} mapping
   */
  constructor(yXmlFragment, mapping = /* @__PURE__ */ new Map()) {
    this.type = yXmlFragment;
    this.prosemirrorView = null;
    this.mux = createMutex();
    this.mapping = mapping;
    this.isOMark = /* @__PURE__ */ new Map();
    this._observeFunction = this._typeChanged.bind(this);
    this.doc = yXmlFragment.doc;
    this.beforeTransactionSelection = null;
    this.beforeAllTransactions = () => {
      if (this.beforeTransactionSelection === null && this.prosemirrorView != null) {
        this.beforeTransactionSelection = getRelativeSelection(
          this,
          this.prosemirrorView.state
        );
      }
    };
    this.afterAllTransactions = () => {
      this.beforeTransactionSelection = null;
    };
    this._domSelectionInView = null;
  }
  /**
   * Create a transaction for changing the prosemirror state.
   *
   * @returns
   */
  get _tr() {
    return this.prosemirrorView.state.tr.setMeta("addToHistory", false);
  }
  _isLocalCursorInView() {
    if (!this.prosemirrorView.hasFocus()) return false;
    if (isBrowser$1$1 && this._domSelectionInView === null) {
      timeout(0, () => {
        this._domSelectionInView = null;
      });
      this._domSelectionInView = this._isDomSelectionInView();
    }
    return this._domSelectionInView;
  }
  _isDomSelectionInView() {
    const selection = this.prosemirrorView._root.getSelection();
    if (selection == null || selection.anchorNode == null) return false;
    const range2 = this.prosemirrorView._root.createRange();
    range2.setStart(selection.anchorNode, selection.anchorOffset);
    range2.setEnd(selection.focusNode, selection.focusOffset);
    const rects = range2.getClientRects();
    if (rects.length === 0) {
      if (range2.startContainer && range2.collapsed) {
        range2.selectNodeContents(range2.startContainer);
      }
    }
    const bounding = range2.getBoundingClientRect();
    const documentElement = doc.documentElement;
    return bounding.bottom >= 0 && bounding.right >= 0 && bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) && bounding.top <= (window.innerHeight || documentElement.clientHeight || 0);
  }
  /**
   * @param {Y.Snapshot} snapshot
   * @param {Y.Snapshot} prevSnapshot
   */
  renderSnapshot(snapshot, prevSnapshot) {
    if (!prevSnapshot) {
      prevSnapshot = Y__namespace.createSnapshot(Y__namespace.createDeleteSet(), /* @__PURE__ */ new Map());
    }
    this.prosemirrorView.dispatch(
      this._tr.setMeta(ySyncPluginKey, { snapshot, prevSnapshot })
    );
  }
  unrenderSnapshot() {
    this.mapping.clear();
    this.mux(() => {
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeFromYElement(
          /** @type {Y.XmlElement} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      const tr = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment.from(fragmentContent), 0, 0)
      );
      tr.setMeta(ySyncPluginKey, { snapshot: null, prevSnapshot: null });
      this.prosemirrorView.dispatch(tr);
    });
  }
  _forceRerender() {
    this.mapping.clear();
    this.mux(() => {
      const sel = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection;
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeFromYElement(
          /** @type {Y.XmlElement} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      const tr = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment.from(fragmentContent), 0, 0)
      );
      if (sel) {
        const clampedAnchor = min$2(max$2(sel.anchor, 0), tr.doc.content.size);
        const clampedHead = min$2(max$2(sel.head, 0), tr.doc.content.size);
        tr.setSelection(TextSelection$1.create(tr.doc, clampedAnchor, clampedHead));
      }
      this.prosemirrorView.dispatch(
        tr.setMeta(ySyncPluginKey, { isChangeOrigin: true, binding: this })
      );
    });
  }
  /**
   * @param {Y.Snapshot|Uint8Array} snapshot
   * @param {Y.Snapshot|Uint8Array} prevSnapshot
   * @param {Object} pluginState
   */
  _renderSnapshot(snapshot, prevSnapshot, pluginState) {
    let historyDoc = this.doc;
    let historyType = this.type;
    if (!snapshot) {
      snapshot = Y__namespace.snapshot(this.doc);
    }
    if (snapshot instanceof Uint8Array || prevSnapshot instanceof Uint8Array) {
      if (!(snapshot instanceof Uint8Array) || !(prevSnapshot instanceof Uint8Array)) {
        unexpectedCase();
      }
      historyDoc = new Y__namespace.Doc({ gc: false });
      Y__namespace.applyUpdateV2(historyDoc, prevSnapshot);
      prevSnapshot = Y__namespace.snapshot(historyDoc);
      Y__namespace.applyUpdateV2(historyDoc, snapshot);
      snapshot = Y__namespace.snapshot(historyDoc);
      if (historyType._item === null) {
        const rootKey = Array.from(this.doc.share.keys()).find(
          (key) => this.doc.share.get(key) === this.type
        );
        historyType = historyDoc.getXmlFragment(rootKey);
      } else {
        const historyStructs = historyDoc.store.clients.get(historyType._item.id.client) ?? [];
        const itemIndex = Y__namespace.findIndexSS(
          historyStructs,
          historyType._item.id.clock
        );
        const item = (
          /** @type {Y.Item} */
          historyStructs[itemIndex]
        );
        const content = (
          /** @type {Y.ContentType} */
          item.content
        );
        historyType = /** @type {Y.XmlFragment} */
        content.type;
      }
    }
    this.mapping.clear();
    this.mux(() => {
      historyDoc.transact((transaction) => {
        const pud = pluginState.permanentUserData;
        if (pud) {
          pud.dss.forEach((ds) => {
            Y__namespace.iterateDeletedStructs(transaction, ds, (_item) => {
            });
          });
        }
        const computeYChange = (type2, id) => {
          const user = type2 === "added" ? pud.getUserByClientId(id.client) : pud.getUserByDeletedId(id);
          return {
            user,
            type: type2,
            color: getUserColor(
              pluginState.colorMapping,
              pluginState.colors,
              user
            )
          };
        };
        const fragmentContent = Y__namespace.typeListToArraySnapshot(
          historyType,
          new Y__namespace.Snapshot(prevSnapshot.ds, snapshot.sv)
        ).map((t) => {
          if (!t._item.deleted || isVisible(t._item, snapshot) || isVisible(t._item, prevSnapshot)) {
            return createNodeFromYElement(
              t,
              this.prosemirrorView.state.schema,
              { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() },
              snapshot,
              prevSnapshot,
              computeYChange
            );
          } else {
            return null;
          }
        }).filter((n) => n !== null);
        const tr = this._tr.replace(
          0,
          this.prosemirrorView.state.doc.content.size,
          new Slice(Fragment.from(fragmentContent), 0, 0)
        );
        this.prosemirrorView.dispatch(
          tr.setMeta(ySyncPluginKey, { isChangeOrigin: true })
        );
      }, ySyncPluginKey);
    });
  }
  /**
   * @param {Array<Y.YEvent<any>>} events
   * @param {Y.Transaction} transaction
   */
  _typeChanged(events2, transaction) {
    if (this.prosemirrorView == null) return;
    const syncState = ySyncPluginKey.getState(this.prosemirrorView.state);
    if (events2.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {
      this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);
      return;
    }
    this.mux(() => {
      const delType = (_2, type2) => this.mapping.delete(type2);
      Y__namespace.iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        (struct) => {
          if (struct.constructor === Y__namespace.Item) {
            const type2 = (
              /** @type {Y.ContentType} */
              /** @type {Y.Item} */
              struct.content.type
            );
            type2 && this.mapping.delete(type2);
          }
        }
      );
      transaction.changed.forEach(delType);
      transaction.changedParentTypes.forEach(delType);
      const fragmentContent = this.type.toArray().map(
        (t) => createNodeIfNotExists(
          /** @type {Y.XmlElement | Y.XmlHook} */
          t,
          this.prosemirrorView.state.schema,
          this
        )
      ).filter((n) => n !== null);
      let tr = this._tr.replace(
        0,
        this.prosemirrorView.state.doc.content.size,
        new Slice(Fragment.from(fragmentContent), 0, 0)
      );
      restoreRelativeSelection(tr, this.beforeTransactionSelection, this);
      tr = tr.setMeta(ySyncPluginKey, { isChangeOrigin: true, isUndoRedoOperation: transaction.origin instanceof Y__namespace.UndoManager });
      if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {
        tr.scrollIntoView();
      }
      this.prosemirrorView.dispatch(tr);
    });
  }
  /**
   * @param {import('prosemirror-model').Node} doc
   */
  _prosemirrorChanged(doc2) {
    this.doc.transact(() => {
      updateYFragment(this.doc, this.type, doc2, this);
      this.beforeTransactionSelection = getRelativeSelection(
        this,
        this.prosemirrorView.state
      );
    }, ySyncPluginKey);
  }
  /**
   * View is ready to listen to changes. Register observers.
   * @param {any} prosemirrorView
   */
  initView(prosemirrorView) {
    if (this.prosemirrorView != null) this.destroy();
    this.prosemirrorView = prosemirrorView;
    this.doc.on("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.on("afterAllTransactions", this.afterAllTransactions);
    this.type.observeDeep(this._observeFunction);
  }
  destroy() {
    if (this.prosemirrorView == null) return;
    this.prosemirrorView = null;
    this.type.unobserveDeep(this._observeFunction);
    this.doc.off("beforeAllTransactions", this.beforeAllTransactions);
    this.doc.off("afterAllTransactions", this.afterAllTransactions);
  }
}
const createNodeIfNotExists = (el, schema, meta, snapshot, prevSnapshot, computeYChange) => {
  const node2 = (
    /** @type {PModel.Node} */
    meta.mapping.get(el)
  );
  if (node2 === void 0) {
    if (el instanceof Y__namespace.XmlElement) {
      return createNodeFromYElement(
        el,
        schema,
        meta,
        snapshot,
        prevSnapshot,
        computeYChange
      );
    } else {
      throw methodUnimplemented();
    }
  }
  return node2;
};
const createNodeFromYElement = (el, schema, meta, snapshot, prevSnapshot, computeYChange) => {
  const children = [];
  const createChildren = (type2) => {
    if (type2 instanceof Y__namespace.XmlElement) {
      const n = createNodeIfNotExists(
        type2,
        schema,
        meta,
        snapshot,
        prevSnapshot,
        computeYChange
      );
      if (n !== null) {
        children.push(n);
      }
    } else {
      const nextytext = (
        /** @type {Y.ContentType} */
        type2._item.right?.content?.type
      );
      if (nextytext instanceof Y__namespace.Text && !nextytext._item.deleted && nextytext._item.id.client === nextytext.doc.clientID) {
        type2.applyDelta([
          { retain: type2.length },
          ...nextytext.toDelta()
        ]);
        nextytext.doc.transact((tr) => {
          nextytext._item.delete(tr);
        });
      }
      const ns = createTextNodesFromYText(
        type2,
        schema,
        meta,
        snapshot,
        prevSnapshot,
        computeYChange
      );
      if (ns !== null) {
        ns.forEach((textchild) => {
          if (textchild !== null) {
            children.push(textchild);
          }
        });
      }
    }
  };
  if (snapshot === void 0 || prevSnapshot === void 0) {
    el.toArray().forEach(createChildren);
  } else {
    Y__namespace.typeListToArraySnapshot(el, new Y__namespace.Snapshot(prevSnapshot.ds, snapshot.sv)).forEach(createChildren);
  }
  try {
    const attrs = el.getAttributes(snapshot);
    if (snapshot !== void 0) {
      if (!isVisible(
        /** @type {Y.Item} */
        el._item,
        snapshot
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "removed",
          /** @type {Y.Item} */
          el._item.id
        ) : { type: "removed" };
      } else if (!isVisible(
        /** @type {Y.Item} */
        el._item,
        prevSnapshot
      )) {
        attrs.ychange = computeYChange ? computeYChange(
          "added",
          /** @type {Y.Item} */
          el._item.id
        ) : { type: "added" };
      }
    }
    const node2 = schema.node(el.nodeName, attrs, children);
    meta.mapping.set(el, node2);
    return node2;
  } catch (e) {
    el.doc.transact((transaction) => {
      el._item.delete(transaction);
    }, ySyncPluginKey);
    meta.mapping.delete(el);
    return null;
  }
};
const createTextNodesFromYText = (text, schema, _meta, snapshot, prevSnapshot, computeYChange) => {
  const nodes = [];
  const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange);
  try {
    for (let i = 0; i < deltas.length; i++) {
      const delta = deltas[i];
      nodes.push(schema.text(delta.insert, attributesToMarks(delta.attributes, schema)));
    }
  } catch (e) {
    text.doc.transact((transaction) => {
      text._item.delete(transaction);
    }, ySyncPluginKey);
    return null;
  }
  return nodes;
};
const createTypeFromTextNodes = (nodes, meta) => {
  const type2 = new Y__namespace.XmlText();
  const delta = nodes.map((node2) => ({
    // @ts-ignore
    insert: node2.text,
    attributes: marksToAttributes(node2.marks, meta)
  }));
  type2.applyDelta(delta);
  meta.mapping.set(type2, nodes);
  return type2;
};
const createTypeFromElementNode = (node2, meta) => {
  const type2 = new Y__namespace.XmlElement(node2.type.name);
  for (const key in node2.attrs) {
    const val = node2.attrs[key];
    if (val !== null && key !== "ychange") {
      type2.setAttribute(key, val);
    }
  }
  type2.insert(
    0,
    normalizePNodeContent(node2).map(
      (n) => createTypeFromTextOrElementNode(n, meta)
    )
  );
  meta.mapping.set(type2, node2);
  return type2;
};
const createTypeFromTextOrElementNode = (node2, meta) => node2 instanceof Array ? createTypeFromTextNodes(node2, meta) : createTypeFromElementNode(node2, meta);
const isObject$1 = (val) => typeof val === "object" && val !== null;
const equalAttrs = (pattrs, yattrs) => {
  const keys2 = Object.keys(pattrs).filter((key) => pattrs[key] !== null);
  let eq2 = keys2.length === (yattrs == null ? 0 : Object.keys(yattrs).filter((key) => yattrs[key] !== null).length);
  for (let i = 0; i < keys2.length && eq2; i++) {
    const key = keys2[i];
    const l3 = pattrs[key];
    const r2 = yattrs[key];
    eq2 = key === "ychange" || l3 === r2 || isObject$1(l3) && isObject$1(r2) && equalAttrs(l3, r2);
  }
  return eq2;
};
const normalizePNodeContent = (pnode) => {
  const c2 = pnode.content.content;
  const res = [];
  for (let i = 0; i < c2.length; i++) {
    const n = c2[i];
    if (n.isText) {
      const textNodes = [];
      for (let tnode = c2[i]; i < c2.length && tnode.isText; tnode = c2[++i]) {
        textNodes.push(tnode);
      }
      i--;
      res.push(textNodes);
    } else {
      res.push(n);
    }
  }
  return res;
};
const equalYTextPText = (ytext, ptexts) => {
  const delta = ytext.toDelta();
  return delta.length === ptexts.length && delta.every(
    /** @type {(d:any,i:number) => boolean} */
    (d2, i) => d2.insert === /** @type {any} */
    ptexts[i].text && keys$1(d2.attributes || {}).length === ptexts[i].marks.length && every(d2.attributes, (attr, yattrname) => {
      const markname = yattr2markname(yattrname);
      const pmarks = ptexts[i].marks;
      return equalAttrs(attr, pmarks.find(
        /** @param {any} mark */
        (mark) => mark.type.name === markname
      )?.attrs);
    })
  );
};
const equalYTypePNode = (ytype, pnode) => {
  if (ytype instanceof Y__namespace.XmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {
    const normalizedContent = normalizePNodeContent(pnode);
    return ytype._length === normalizedContent.length && equalAttrs(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every(
      (ychild, i) => equalYTypePNode(ychild, normalizedContent[i])
    );
  }
  return ytype instanceof Y__namespace.XmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);
};
const mappedIdentity = (mapped, pcontent) => mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every(
  (a, i) => pcontent[i] === a
);
const computeChildEqualityFactor = (ytype, pnode, meta) => {
  const yChildren = ytype.toArray();
  const pChildren = normalizePNodeContent(pnode);
  const pChildCnt = pChildren.length;
  const yChildCnt = yChildren.length;
  const minCnt = min$2(yChildCnt, pChildCnt);
  let left2 = 0;
  let right2 = 0;
  let foundMappedChild = false;
  for (; left2 < minCnt; left2++) {
    const leftY = yChildren[left2];
    const leftP = pChildren[left2];
    if (mappedIdentity(meta.mapping.get(leftY), leftP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(leftY, leftP)) {
      break;
    }
  }
  for (; left2 + right2 < minCnt; right2++) {
    const rightY = yChildren[yChildCnt - right2 - 1];
    const rightP = pChildren[pChildCnt - right2 - 1];
    if (mappedIdentity(meta.mapping.get(rightY), rightP)) {
      foundMappedChild = true;
    } else if (!equalYTypePNode(rightY, rightP)) {
      break;
    }
  }
  return {
    equalityFactor: left2 + right2,
    foundMappedChild
  };
};
const ytextTrans = (ytext) => {
  let str = "";
  let n = ytext._start;
  const nAttrs = {};
  while (n !== null) {
    if (!n.deleted) {
      if (n.countable && n.content instanceof Y__namespace.ContentString) {
        str += n.content.str;
      } else if (n.content instanceof Y__namespace.ContentFormat) {
        nAttrs[n.content.key] = null;
      }
    }
    n = n.right;
  }
  return {
    str,
    nAttrs
  };
};
const updateYText = (ytext, ptexts, meta) => {
  meta.mapping.set(ytext, ptexts);
  const { nAttrs, str } = ytextTrans(ytext);
  const content = ptexts.map((p) => ({
    insert: (
      /** @type {any} */
      p.text
    ),
    attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks, meta))
  }));
  const { insert, remove, index: index2 } = simpleDiff(
    str,
    content.map((c2) => c2.insert).join("")
  );
  ytext.delete(index2, remove);
  ytext.insert(index2, insert);
  ytext.applyDelta(
    content.map((c2) => ({ retain: c2.insert.length, attributes: c2.attributes }))
  );
};
const hashedMarkNameRegex = /(.*)(--[a-zA-Z0-9+/=]{8})$/;
const yattr2markname = (attrName) => hashedMarkNameRegex.exec(attrName)?.[1] ?? attrName;
const attributesToMarks = (attrs, schema) => {
  const marks = [];
  for (const markName in attrs) {
    marks.push(schema.mark(yattr2markname(markName), attrs[markName]));
  }
  return marks;
};
const marksToAttributes = (marks, meta) => {
  const pattrs = {};
  marks.forEach((mark) => {
    if (mark.type.name !== "ychange") {
      const isOverlapping = setIfUndefined(meta.isOMark, mark.type, () => !mark.type.excludes(mark.type));
      pattrs[isOverlapping ? `${mark.type.name}--${hashOfJSON(mark.toJSON())}` : mark.type.name] = mark.attrs;
    }
  });
  return pattrs;
};
const updateYFragment = (y2, yDomFragment, pNode, meta) => {
  if (yDomFragment instanceof Y__namespace.XmlElement && yDomFragment.nodeName !== pNode.type.name) {
    throw new Error("node name mismatch!");
  }
  meta.mapping.set(yDomFragment, pNode);
  if (yDomFragment instanceof Y__namespace.XmlElement) {
    const yDomAttrs = yDomFragment.getAttributes();
    const pAttrs = pNode.attrs;
    for (const key in pAttrs) {
      if (pAttrs[key] !== null) {
        if (yDomAttrs[key] !== pAttrs[key] && key !== "ychange") {
          yDomFragment.setAttribute(key, pAttrs[key]);
        }
      } else {
        yDomFragment.removeAttribute(key);
      }
    }
    for (const key in yDomAttrs) {
      if (pAttrs[key] === void 0) {
        yDomFragment.removeAttribute(key);
      }
    }
  }
  const pChildren = normalizePNodeContent(pNode);
  const pChildCnt = pChildren.length;
  const yChildren = yDomFragment.toArray();
  const yChildCnt = yChildren.length;
  const minCnt = min$2(pChildCnt, yChildCnt);
  let left2 = 0;
  let right2 = 0;
  for (; left2 < minCnt; left2++) {
    const leftY = yChildren[left2];
    const leftP = pChildren[left2];
    if (!mappedIdentity(meta.mapping.get(leftY), leftP)) {
      if (equalYTypePNode(leftY, leftP)) {
        meta.mapping.set(leftY, leftP);
      } else {
        break;
      }
    }
  }
  for (; right2 + left2 < minCnt; right2++) {
    const rightY = yChildren[yChildCnt - right2 - 1];
    const rightP = pChildren[pChildCnt - right2 - 1];
    if (!mappedIdentity(meta.mapping.get(rightY), rightP)) {
      if (equalYTypePNode(rightY, rightP)) {
        meta.mapping.set(rightY, rightP);
      } else {
        break;
      }
    }
  }
  y2.transact(() => {
    while (yChildCnt - left2 - right2 > 0 && pChildCnt - left2 - right2 > 0) {
      const leftY = yChildren[left2];
      const leftP = pChildren[left2];
      const rightY = yChildren[yChildCnt - right2 - 1];
      const rightP = pChildren[pChildCnt - right2 - 1];
      if (leftY instanceof Y__namespace.XmlText && leftP instanceof Array) {
        if (!equalYTextPText(leftY, leftP)) {
          updateYText(leftY, leftP, meta);
        }
        left2 += 1;
      } else {
        let updateLeft = leftY instanceof Y__namespace.XmlElement && matchNodeName(leftY, leftP);
        let updateRight = rightY instanceof Y__namespace.XmlElement && matchNodeName(rightY, rightP);
        if (updateLeft && updateRight) {
          const equalityLeft = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            meta
          );
          const equalityRight = computeChildEqualityFactor(
            /** @type {Y.XmlElement} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            meta
          );
          if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {
            updateRight = false;
          } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {
            updateLeft = false;
          } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {
            updateLeft = false;
          } else {
            updateRight = false;
          }
        }
        if (updateLeft) {
          updateYFragment(
            y2,
            /** @type {Y.XmlFragment} */
            leftY,
            /** @type {PModel.Node} */
            leftP,
            meta
          );
          left2 += 1;
        } else if (updateRight) {
          updateYFragment(
            y2,
            /** @type {Y.XmlFragment} */
            rightY,
            /** @type {PModel.Node} */
            rightP,
            meta
          );
          right2 += 1;
        } else {
          meta.mapping.delete(yDomFragment.get(left2));
          yDomFragment.delete(left2, 1);
          yDomFragment.insert(left2, [
            createTypeFromTextOrElementNode(leftP, meta)
          ]);
          left2 += 1;
        }
      }
    }
    const yDelLen = yChildCnt - left2 - right2;
    if (yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof Y__namespace.XmlText) {
      meta.mapping.delete(yChildren[0]);
      yChildren[0].delete(0, yChildren[0].length);
    } else if (yDelLen > 0) {
      yDomFragment.slice(left2, left2 + yDelLen).forEach((type2) => meta.mapping.delete(type2));
      yDomFragment.delete(left2, yDelLen);
    }
    if (left2 + right2 < pChildCnt) {
      const ins = [];
      for (let i = left2; i < pChildCnt - right2; i++) {
        ins.push(createTypeFromTextOrElementNode(pChildren[i], meta));
      }
      yDomFragment.insert(left2, ins);
    }
  }, ySyncPluginKey);
};
const matchNodeName = (yElement, pNode) => !(pNode instanceof Array) && yElement.nodeName === pNode.type.name;
let viewsToUpdate = null;
const updateMetas = () => {
  const ups = (
    /** @type {Map<EditorView, Map<any, any>>} */
    viewsToUpdate
  );
  viewsToUpdate = null;
  ups.forEach((metas, view) => {
    const tr = view.state.tr;
    const syncState = ySyncPluginKey.getState(view.state);
    if (syncState && syncState.binding && !syncState.binding.isDestroyed) {
      metas.forEach((val, key) => {
        tr.setMeta(key, val);
      });
      view.dispatch(tr);
    }
  });
};
const setMeta = (view, key, value) => {
  if (!viewsToUpdate) {
    viewsToUpdate = /* @__PURE__ */ new Map();
    timeout(0, updateMetas);
  }
  setIfUndefined(viewsToUpdate, view, create).set(key, value);
};
const absolutePositionToRelativePosition = (pos, type2, mapping) => {
  if (pos === 0) {
    return Y__namespace.createRelativePositionFromTypeIndex(type2, 0, type2.length === 0 ? -1 : 0);
  }
  let n = type2._first === null ? null : (
    /** @type {Y.ContentType} */
    type2._first.content.type
  );
  while (n !== null && type2 !== n) {
    if (n instanceof Y__namespace.XmlText) {
      if (n._length >= pos) {
        return Y__namespace.createRelativePositionFromTypeIndex(n, pos, type2.length === 0 ? -1 : 0);
      } else {
        pos -= n._length;
      }
      if (n._item !== null && n._item.next !== null) {
        n = /** @type {Y.ContentType} */
        n._item.next.content.type;
      } else {
        do {
          n = n._item === null ? null : n._item.parent;
          pos--;
        } while (n !== type2 && n !== null && n._item !== null && n._item.next === null);
        if (n !== null && n !== type2) {
          n = n._item === null ? null : (
            /** @type {Y.ContentType} */
            /** @type Y.Item */
            n._item.next.content.type
          );
        }
      }
    } else {
      const pNodeSize = (
        /** @type {any} */
        (mapping.get(n) || { nodeSize: 0 }).nodeSize
      );
      if (n._first !== null && pos < pNodeSize) {
        n = /** @type {Y.ContentType} */
        n._first.content.type;
        pos--;
      } else {
        if (pos === 1 && n._length === 0 && pNodeSize > 1) {
          return new Y__namespace.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y__namespace.findRootTypeKey(n) : null, null);
        }
        pos -= pNodeSize;
        if (n._item !== null && n._item.next !== null) {
          n = /** @type {Y.ContentType} */
          n._item.next.content.type;
        } else {
          if (pos === 0) {
            n = n._item === null ? n : n._item.parent;
            return new Y__namespace.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? Y__namespace.findRootTypeKey(n) : null, null);
          }
          do {
            n = /** @type {Y.Item} */
            n._item.parent;
            pos--;
          } while (n !== type2 && /** @type {Y.Item} */
          n._item.next === null);
          if (n !== type2) {
            n = /** @type {Y.ContentType} */
            /** @type {Y.Item} */
            /** @type {Y.Item} */
            n._item.next.content.type;
          }
        }
      }
    }
    if (n === null) {
      throw unexpectedCase();
    }
    if (pos === 0 && n.constructor !== Y__namespace.XmlText && n !== type2) {
      return createRelativePosition(n._item.parent, n._item);
    }
  }
  return Y__namespace.createRelativePositionFromTypeIndex(type2, type2._length, type2.length === 0 ? -1 : 0);
};
const createRelativePosition = (type2, item) => {
  let typeid = null;
  let tname = null;
  if (type2._item === null) {
    tname = Y__namespace.findRootTypeKey(type2);
  } else {
    typeid = Y__namespace.createID(type2._item.id.client, type2._item.id.clock);
  }
  return new Y__namespace.RelativePosition(typeid, tname, item.id);
};
const relativePositionToAbsolutePosition = (y2, documentType, relPos, mapping) => {
  const decodedPos = Y__namespace.createAbsolutePositionFromRelativePosition(relPos, y2);
  if (decodedPos === null || decodedPos.type !== documentType && !Y__namespace.isParentOf(documentType, decodedPos.type._item)) {
    return null;
  }
  let type2 = decodedPos.type;
  let pos = 0;
  if (type2.constructor === Y__namespace.XmlText) {
    pos = decodedPos.index;
  } else if (type2._item === null || !type2._item.deleted) {
    let n = type2._first;
    let i = 0;
    while (i < type2._length && i < decodedPos.index && n !== null) {
      if (!n.deleted) {
        const t = (
          /** @type {Y.ContentType} */
          n.content.type
        );
        i++;
        if (t instanceof Y__namespace.XmlText) {
          pos += t._length;
        } else {
          pos += /** @type {any} */
          mapping.get(t).nodeSize;
        }
      }
      n = /** @type {Y.Item} */
      n.right;
    }
    pos += 1;
  }
  while (type2 !== documentType && type2._item !== null) {
    const parent = type2._item.parent;
    if (parent._item === null || !parent._item.deleted) {
      pos += 1;
      let n = (
        /** @type {Y.AbstractType} */
        parent._first
      );
      while (n !== null) {
        const contentType = (
          /** @type {Y.ContentType} */
          n.content.type
        );
        if (contentType === type2) {
          break;
        }
        if (!n.deleted) {
          if (contentType instanceof Y__namespace.XmlText) {
            pos += contentType._length;
          } else {
            pos += /** @type {any} */
            mapping.get(contentType).nodeSize;
          }
        }
        n = n.right;
      }
    }
    type2 = /** @type {Y.AbstractType} */
    parent;
  }
  return pos - 1;
};
const yXmlFragmentToProseMirrorFragment = (yXmlFragment, schema) => {
  const fragmentContent = yXmlFragment.toArray().map(
    (t) => createNodeFromYElement(
      /** @type {Y.XmlElement} */
      t,
      schema,
      createEmptyMeta()
    )
  ).filter((n) => n !== null);
  return Fragment.fromArray(fragmentContent);
};
const yXmlFragmentToProseMirrorRootNode = (yXmlFragment, schema) => schema.topNodeType.create(null, yXmlFragmentToProseMirrorFragment(yXmlFragment, schema));
function prosemirrorToYDoc(doc2, xmlFragment = "prosemirror") {
  const ydoc = new Y__namespace.Doc();
  const type2 = (
    /** @type {Y.XmlFragment} */
    ydoc.get(xmlFragment, Y__namespace.XmlFragment)
  );
  if (!type2.doc) {
    return ydoc;
  }
  prosemirrorToYXmlFragment(doc2, type2);
  return type2.doc;
}
function prosemirrorToYXmlFragment(doc2, xmlFragment) {
  const type2 = xmlFragment || new Y__namespace.XmlFragment();
  const ydoc = type2.doc ? type2.doc : { transact: (transaction) => transaction(void 0) };
  updateYFragment(ydoc, type2, doc2, { mapping: /* @__PURE__ */ new Map(), isOMark: /* @__PURE__ */ new Map() });
  return type2;
}
const defaultAwarenessStateFilter = (currentClientId, userClientId, _user) => currentClientId !== userClientId;
const defaultCursorBuilder = (user) => {
  const cursor = document.createElement("span");
  cursor.classList.add("ProseMirror-yjs-cursor");
  cursor.setAttribute("style", `border-color: ${user.color}`);
  const userDiv = document.createElement("div");
  userDiv.setAttribute("style", `background-color: ${user.color}`);
  userDiv.insertBefore(document.createTextNode(user.name), null);
  const nonbreakingSpace1 = document.createTextNode("⁠");
  const nonbreakingSpace2 = document.createTextNode("⁠");
  cursor.insertBefore(nonbreakingSpace1, null);
  cursor.insertBefore(userDiv, null);
  cursor.insertBefore(nonbreakingSpace2, null);
  return cursor;
};
const defaultSelectionBuilder = (user) => {
  return {
    style: `background-color: ${user.color}70`,
    class: "ProseMirror-yjs-selection"
  };
};
const rxValidColor = /^#[0-9a-fA-F]{6}$/;
const createDecorations = (state2, awareness, awarenessFilter, createCursor, createSelection) => {
  const ystate = ySyncPluginKey.getState(state2);
  const y2 = ystate.doc;
  const decorations = [];
  if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding.mapping.size === 0) {
    return DecorationSet.create(state2.doc, []);
  }
  awareness.getStates().forEach((aw, clientId) => {
    if (!awarenessFilter(y2.clientID, clientId, aw)) {
      return;
    }
    if (aw.cursor != null) {
      const user = aw.user || {};
      if (user.color == null) {
        user.color = "#ffa500";
      } else if (!rxValidColor.test(user.color)) {
        console.warn("A user uses an unsupported color format", user);
      }
      if (user.name == null) {
        user.name = `User: ${clientId}`;
      }
      let anchor = relativePositionToAbsolutePosition(
        y2,
        ystate.type,
        Y__namespace.createRelativePositionFromJSON(aw.cursor.anchor),
        ystate.binding.mapping
      );
      let head = relativePositionToAbsolutePosition(
        y2,
        ystate.type,
        Y__namespace.createRelativePositionFromJSON(aw.cursor.head),
        ystate.binding.mapping
      );
      if (anchor !== null && head !== null) {
        const maxsize = max$2(state2.doc.content.size - 1, 0);
        anchor = min$2(anchor, maxsize);
        head = min$2(head, maxsize);
        decorations.push(
          Decoration.widget(head, () => createCursor(user, clientId), {
            key: clientId + "",
            side: 10
          })
        );
        const from2 = min$2(anchor, head);
        const to = max$2(anchor, head);
        decorations.push(
          Decoration.inline(from2, to, createSelection(user, clientId), {
            inclusiveEnd: true,
            inclusiveStart: false
          })
        );
      }
    }
  });
  return DecorationSet.create(state2.doc, decorations);
};
const yCursorPlugin = (awareness, {
  awarenessStateFilter = defaultAwarenessStateFilter,
  cursorBuilder = defaultCursorBuilder,
  selectionBuilder = defaultSelectionBuilder,
  getSelection: getSelection2 = (state2) => state2.selection
} = {}, cursorStateField = "cursor") => new Plugin({
  key: yCursorPluginKey,
  state: {
    init(_2, state2) {
      return createDecorations(
        state2,
        awareness,
        awarenessStateFilter,
        cursorBuilder,
        selectionBuilder
      );
    },
    apply(tr, prevState, _oldState, newState) {
      const ystate = ySyncPluginKey.getState(newState);
      const yCursorState = tr.getMeta(yCursorPluginKey);
      if (ystate && ystate.isChangeOrigin || yCursorState && yCursorState.awarenessUpdated) {
        return createDecorations(
          newState,
          awareness,
          awarenessStateFilter,
          cursorBuilder,
          selectionBuilder
        );
      }
      return prevState.map(tr.mapping, tr.doc);
    }
  },
  props: {
    decorations: (state2) => {
      return yCursorPluginKey.getState(state2);
    }
  },
  view: (view) => {
    const awarenessListener = () => {
      if (view.docView) {
        setMeta(view, yCursorPluginKey, { awarenessUpdated: true });
      }
    };
    const updateCursorInfo = () => {
      const ystate = ySyncPluginKey.getState(view.state);
      const current = awareness.getLocalState() || {};
      if (view.hasFocus()) {
        const selection = getSelection2(view.state);
        const anchor = absolutePositionToRelativePosition(
          selection.anchor,
          ystate.type,
          ystate.binding.mapping
        );
        const head = absolutePositionToRelativePosition(
          selection.head,
          ystate.type,
          ystate.binding.mapping
        );
        if (current.cursor == null || !Y__namespace.compareRelativePositions(
          Y__namespace.createRelativePositionFromJSON(current.cursor.anchor),
          anchor
        ) || !Y__namespace.compareRelativePositions(
          Y__namespace.createRelativePositionFromJSON(current.cursor.head),
          head
        )) {
          awareness.setLocalStateField(cursorStateField, {
            anchor,
            head
          });
        }
      } else if (current.cursor != null && relativePositionToAbsolutePosition(
        ystate.doc,
        ystate.type,
        Y__namespace.createRelativePositionFromJSON(current.cursor.anchor),
        ystate.binding.mapping
      ) !== null) {
        awareness.setLocalStateField(cursorStateField, null);
      }
    };
    awareness.on("change", awarenessListener);
    view.dom.addEventListener("focusin", updateCursorInfo);
    view.dom.addEventListener("focusout", updateCursorInfo);
    return {
      update: updateCursorInfo,
      destroy: () => {
        view.dom.removeEventListener("focusin", updateCursorInfo);
        view.dom.removeEventListener("focusout", updateCursorInfo);
        awareness.off("change", awarenessListener);
        awareness.setLocalStateField(cursorStateField, null);
      }
    };
  }
});
const undo = (state2) => yUndoPluginKey.getState(state2)?.undoManager?.undo() != null;
const redo = (state2) => yUndoPluginKey.getState(state2)?.undoManager?.redo() != null;
const defaultProtectedNodes = /* @__PURE__ */ new Set(["paragraph"]);
const defaultDeleteFilter = (item, protectedNodes) => !(item instanceof Y.Item) || !(item.content instanceof Y.ContentType) || !(item.content.type instanceof Y.Text || item.content.type instanceof Y.XmlElement && protectedNodes.has(item.content.type.nodeName)) || item.content.type._length === 0;
const yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {}) => new Plugin({
  key: yUndoPluginKey,
  state: {
    init: (initargs, state2) => {
      const ystate = ySyncPluginKey.getState(state2);
      const _undoManager = undoManager || new Y.UndoManager(ystate.type, {
        trackedOrigins: new Set([ySyncPluginKey].concat(trackedOrigins)),
        deleteFilter: (item) => defaultDeleteFilter(item, protectedNodes),
        captureTransaction: (tr) => tr.meta.get("addToHistory") !== false
      });
      return {
        undoManager: _undoManager,
        prevSel: null,
        hasUndoOps: _undoManager.undoStack.length > 0,
        hasRedoOps: _undoManager.redoStack.length > 0
      };
    },
    apply: (tr, val, oldState, state2) => {
      const binding = ySyncPluginKey.getState(state2).binding;
      const undoManager2 = val.undoManager;
      const hasUndoOps = undoManager2.undoStack.length > 0;
      const hasRedoOps = undoManager2.redoStack.length > 0;
      if (binding) {
        return {
          undoManager: undoManager2,
          prevSel: getRelativeSelection(binding, oldState),
          hasUndoOps,
          hasRedoOps
        };
      } else {
        if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {
          return Object.assign({}, val, {
            hasUndoOps: undoManager2.undoStack.length > 0,
            hasRedoOps: undoManager2.redoStack.length > 0
          });
        } else {
          return val;
        }
      }
    }
  },
  view: (view) => {
    const ystate = ySyncPluginKey.getState(view.state);
    const undoManager2 = yUndoPluginKey.getState(view.state).undoManager;
    undoManager2.on("stack-item-added", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        stackItem.meta.set(binding, yUndoPluginKey.getState(view.state).prevSel);
      }
    });
    undoManager2.on("stack-item-popped", ({ stackItem }) => {
      const binding = ystate.binding;
      if (binding) {
        binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection;
      }
    });
    return {
      destroy: () => {
        undoManager2.destroy();
      }
    };
  }
});
let EventEmitter$1 = class EventEmitter {
  constructor() {
    __privateAdd$1(this, _events, /* @__PURE__ */ new Map());
  }
  /**
   * Subscribe to the event.
   * @param {string} name Event name.
   * @param {(...args: any[]) => void} fn Callback.
   * @returns {void}
   */
  on(name, fn2) {
    const callbacks2 = __privateGet$1(this, _events).get(name);
    if (callbacks2) callbacks2.push(fn2);
    else __privateGet$1(this, _events).set(name, [fn2]);
  }
  /**
   * Emit event.
   * @param {string} name Event name.
   * @param {...any} args – Arguments to pass to each listener.
   * @returns {void}
   */
  emit(name, ...args) {
    const callbacks2 = __privateGet$1(this, _events).get(name);
    if (!callbacks2) return;
    for (const fn2 of callbacks2) {
      fn2.apply(this, args);
    }
  }
  /**
   * Remove a specific callback from event
   * or all event subscriptions.
   * @param {string} name Event name.
   * @param {(...args: any[]) => void} fn Callback.
   * @returns {void}
   */
  off(name, fn2) {
    const callbacks2 = __privateGet$1(this, _events).get(name);
    if (!callbacks2) return;
    if (fn2) {
      __privateGet$1(this, _events).set(
        name,
        callbacks2.filter((cb) => cb !== fn2)
      );
    } else {
      __privateGet$1(this, _events).delete(name);
    }
  }
  /**
   * Subscribe to an event that will be called only once.
   * @param {string} name Event name.
   * @param {(...args: any[]) => void} fn Callback.
   * @returns {void}
   */
  once(name, fn2) {
    const wrapper = (...args) => {
      this.off(name, wrapper);
      fn2.apply(this, args);
    };
    this.on(name, wrapper);
  }
  /**
   * Remove all registered events and subscriptions.
   */
  removeAllListeners() {
    __privateSet(this, _events, /* @__PURE__ */ new Map());
  }
};
_events = /* @__PURE__ */ new WeakMap();
var base$1 = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
};
var shift = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
};
var mac$1 = typeof navigator != "undefined" && /Mac/.test(navigator.platform);
var ie = typeof navigator != "undefined" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var i = 0; i < 10; i++) base$1[48 + i] = base$1[96 + i] = String(i);
for (var i = 1; i <= 24; i++) base$1[i + 111] = "F" + i;
for (var i = 65; i <= 90; i++) {
  base$1[i] = String.fromCharCode(i + 32);
  shift[i] = String.fromCharCode(i);
}
for (var code in base$1) if (!shift.hasOwnProperty(code)) shift[code] = base$1[code];
function keyName(event) {
  var ignoreKey = mac$1 && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey || ie && event.shiftKey && event.key && event.key.length == 1 || event.key == "Unidentified";
  var name = !ignoreKey && event.key || (event.shiftKey ? shift : base$1)[event.keyCode] || event.key || "Unidentified";
  if (name == "Esc") name = "Escape";
  if (name == "Del") name = "Delete";
  if (name == "Left") name = "ArrowLeft";
  if (name == "Up") name = "ArrowUp";
  if (name == "Right") name = "ArrowRight";
  if (name == "Down") name = "ArrowDown";
  return name;
}
const mac = typeof navigator != "undefined" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
const windows = typeof navigator != "undefined" && /Win/.test(navigator.platform);
function normalizeKeyName(name) {
  let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];
  if (result == "Space")
    result = " ";
  let alt, ctrl, shift2, meta;
  for (let i = 0; i < parts.length - 1; i++) {
    let mod = parts[i];
    if (/^(cmd|meta|m)$/i.test(mod))
      meta = true;
    else if (/^a(lt)?$/i.test(mod))
      alt = true;
    else if (/^(c|ctrl|control)$/i.test(mod))
      ctrl = true;
    else if (/^s(hift)?$/i.test(mod))
      shift2 = true;
    else if (/^mod$/i.test(mod)) {
      if (mac)
        meta = true;
      else
        ctrl = true;
    } else
      throw new Error("Unrecognized modifier name: " + mod);
  }
  if (alt)
    result = "Alt-" + result;
  if (ctrl)
    result = "Ctrl-" + result;
  if (meta)
    result = "Meta-" + result;
  if (shift2)
    result = "Shift-" + result;
  return result;
}
function normalize(map22) {
  let copy2 = /* @__PURE__ */ Object.create(null);
  for (let prop in map22)
    copy2[normalizeKeyName(prop)] = map22[prop];
  return copy2;
}
function modifiers(name, event, shift2 = true) {
  if (event.altKey)
    name = "Alt-" + name;
  if (event.ctrlKey)
    name = "Ctrl-" + name;
  if (event.metaKey)
    name = "Meta-" + name;
  if (shift2 && event.shiftKey)
    name = "Shift-" + name;
  return name;
}
function keymap(bindings) {
  return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });
}
function keydownHandler(bindings) {
  let map22 = normalize(bindings);
  return function(view, event) {
    let name = keyName(event), baseName, direct = map22[modifiers(name, event)];
    if (direct && direct(view.state, view.dispatch, view))
      return true;
    if (name.length == 1 && name != " ") {
      if (event.shiftKey) {
        let noShift = map22[modifiers(name, event, false)];
        if (noShift && noShift(view.state, view.dispatch, view))
          return true;
      }
      if ((event.altKey || event.metaKey || event.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
      !(windows && event.ctrlKey && event.altKey) && (baseName = base$1[event.keyCode]) && baseName != name) {
        let fromCode = map22[modifiers(baseName, event)];
        if (fromCode && fromCode(view.state, view.dispatch, view))
          return true;
      }
    }
    return false;
  };
}
function isExtensionRulesEnabled(extension, enabled) {
  if (Array.isArray(enabled)) {
    return enabled.some((enabledExtension) => {
      const name = typeof enabledExtension === "string" ? enabledExtension : enabledExtension.name;
      return name === extension.name;
    });
  }
  return enabled;
}
const _ExtensionService = class _ExtensionService2 {
  constructor(extensions, userExtensions, editor) {
    __privateAdd$1(this, _ExtensionService_instances);
    __publicField$1(this, "editor");
    __publicField$1(this, "schema");
    __publicField$1(this, "extensions");
    __publicField$1(this, "externalExtensions", []);
    __publicField$1(this, "splittableMarks", []);
    this.editor = editor;
    this.externalExtensions = userExtensions || [];
    this.externalExtensions = this.externalExtensions.map((extension) => {
      return {
        ...extension,
        isExternal: true
      };
    });
    this.extensions = _ExtensionService2.getResolvedExtensions([...extensions, ...this.externalExtensions]);
    this.schema = Schema2.createSchemaByExtensions(this.extensions, editor);
    __privateMethod$1(this, _ExtensionService_instances, setupExtensions_fn).call(this);
  }
  /**
   * Static method for creating ExtensionService.
   * @param args Arguments for the constructor.
   */
  static create(...args) {
    return new _ExtensionService2(...args);
  }
  /**
   * Get an array of resolved extensions (e.g. sorted by priority).
   * @param extensions Array of extensions.
   * @returns Array of resolved extensions.
   */
  static getResolvedExtensions(extensions) {
    const resolvedExtensions = _ExtensionService2.sortByPriority(extensions);
    return resolvedExtensions;
  }
  /**
   * Sort extensions by priority.
   * @param extensions Array of extensions.
   * @returns Array of sorted extensions by priority.
   */
  static sortByPriority(extensions) {
    const defaultValue = 100;
    return extensions.sort((a, b2) => {
      const priorityA = getExtensionConfigField(a, "priority") || defaultValue;
      const priorityB = getExtensionConfigField(b2, "priority") || defaultValue;
      if (priorityA > priorityB) return -1;
      if (priorityA < priorityB) return 1;
      return 0;
    });
  }
  /**
   * Get all attributes defined in the extensions.
   * @returns Array of attributes.
   */
  get attributes() {
    return Attribute2.getAttributesFromExtensions(this.extensions);
  }
  /**
   * Get all commands defined in the extensions.
   * @returns Object with commands (key - command name, value - function).
   */
  get commands() {
    let commandsObject = {};
    for (const extension of this.extensions) {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addCommands = getExtensionConfigField(extension, "addCommands", context);
      if (addCommands) {
        commandsObject = {
          ...commandsObject,
          ...addCommands()
        };
      }
    }
    return commandsObject;
  }
  /**
   * Get all helper methods defined in the extensions.
   * Each extension can define its own helper methods.
   * Example: editor.helpers.linkedStyles.getStyles()
   * @returns {Object} Object with helper methods for extensions.
   */
  get helpers() {
    const helpersObject = {};
    for (const extension of this.extensions) {
      const name = extension.name;
      if (!name) continue;
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor: this.editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const addHelpers = getExtensionConfigField(extension, "addHelpers", context);
      if (addHelpers) {
        helpersObject[name] = addHelpers();
      }
    }
    return helpersObject;
  }
  /**
   * Get all PM plugins defined in the extensions.
   * And also keyboard shortcuts.
   * @returns Array of PM plugins.
   */
  get plugins() {
    const editor = this.editor;
    const extensions = _ExtensionService2.sortByPriority([...this.extensions].reverse());
    const inputRules = [];
    const allPlugins = extensions.map((extension) => {
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getSchemaTypeByName(extension.name, this.schema)
      };
      const plugins = [];
      const addShortcuts = getExtensionConfigField(extension, "addShortcuts", context);
      let bindingsObject = {};
      if (addShortcuts) {
        const entries = Object.entries(addShortcuts()).map(([shortcut, method]) => {
          return [shortcut, (...args) => method({ editor, keymapArgs: args })];
        });
        bindingsObject = { ...Object.fromEntries(entries) };
      }
      plugins.push(keymap(bindingsObject));
      const addInputRules = getExtensionConfigField(extension, "addInputRules", context);
      if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {
        inputRules.push(...addInputRules());
      }
      const addPmPlugins = getExtensionConfigField(extension, "addPmPlugins", context);
      if (addPmPlugins) {
        const pmPlugins = addPmPlugins();
        plugins.push(...pmPlugins);
      }
      return plugins;
    }).flat();
    return [
      inputRulesPlugin({
        editor,
        rules: inputRules
      }),
      ...allPlugins
    ];
  }
  /**
   * Get all node views from the extensions.
   * @returns An object with all node views.
   */
  get nodeViews() {
    const { editor } = this;
    const nodeExtensions = this.extensions.filter((e) => e.type === "node");
    const entries = nodeExtensions.filter((extension) => !!getExtensionConfigField(extension, "addNodeView")).map((extension) => {
      const extensionAttrs = this.attributes.filter((a) => a.type === extension.name);
      const context = {
        name: extension.name,
        options: extension.options,
        storage: extension.storage,
        editor,
        type: getNodeType(extension.name, this.schema)
      };
      const addNodeView = getExtensionConfigField(extension, "addNodeView", context);
      if (!addNodeView) return [];
      const nodeview = (node2, _view, getPos, decorations) => {
        const htmlAttributes = Attribute2.getAttributesToRender(node2, extensionAttrs);
        return addNodeView()({
          editor,
          node: node2,
          getPos,
          decorations,
          htmlAttributes,
          extension
        });
      };
      return [extension.name, nodeview];
    });
    return Object.fromEntries(entries);
  }
};
_ExtensionService_instances = /* @__PURE__ */ new WeakSet();
setupExtensions_fn = function() {
  for (const extension of this.extensions) {
    this.editor.extensionStorage[extension.name] = extension.storage;
    const context = {
      name: extension.name,
      options: extension.options,
      storage: extension.storage,
      editor: this.editor,
      type: getSchemaTypeByName(extension.name, this.schema)
    };
    if (extension.type === "mark") {
      const keepOnSplit = callOrGet(getExtensionConfigField(extension, "keepOnSplit", context)) ?? true;
      if (keepOnSplit) {
        this.splittableMarks.push(extension.name);
      }
    }
    __privateMethod$1(this, _ExtensionService_instances, attachEditorEvents_fn).call(this, extension);
  }
};
attachEditorEvents_fn = function(extension) {
  const context = {
    name: extension.name,
    options: extension.options,
    storage: extension.storage,
    editor: this.editor,
    type: getSchemaTypeByName(extension.name, this.schema)
  };
  const onBeforeCreate = getExtensionConfigField(extension, "onBeforeCreate", context);
  const onCreate2 = getExtensionConfigField(extension, "onCreate", context);
  const onUpdate = getExtensionConfigField(extension, "onUpdate", context);
  const onSelectionUpdate = getExtensionConfigField(extension, "onSelectionUpdate", context);
  const onTransaction = getExtensionConfigField(extension, "onTransaction", context);
  const onFocus = getExtensionConfigField(extension, "onFocus", context);
  const onBlur = getExtensionConfigField(extension, "onBlur", context);
  const onDestroy2 = getExtensionConfigField(extension, "onDestroy", context);
  if (onBeforeCreate) this.editor.on("beforeCreate", onBeforeCreate);
  if (onCreate2) this.editor.on("create", onCreate2);
  if (onUpdate) this.editor.on("update", onUpdate);
  if (onSelectionUpdate) this.editor.on("selectionUpdate", onSelectionUpdate);
  if (onTransaction) this.editor.on("transaction", onTransaction);
  if (onFocus) this.editor.on("focus", onFocus);
  if (onBlur) this.editor.on("blur", onBlur);
  if (onDestroy2) this.editor.on("destroy", onDestroy2);
};
let ExtensionService = _ExtensionService;
const findTrackedMarkBetween = ({
  tr,
  from: from2,
  to,
  markName,
  attrs = {},
  offset: offset2 = 1
  // To get non-inclusive marks.
}) => {
  const { doc: doc2 } = tr;
  const startPos = Math.max(from2 - offset2, 0);
  const endPos = Math.min(to + offset2, doc2.content.size);
  let markFound;
  doc2.nodesBetween(startPos, endPos, (node2, pos) => {
    if (!node2 || node2?.nodeSize === void 0) {
      return;
    }
    const mark = node2.marks.find(
      (mark2) => mark2.type.name === markName && Object.keys(attrs).every((attr) => mark2.attrs[attr] === attrs[attr])
    );
    if (mark && !markFound) {
      markFound = {
        from: pos,
        to: pos + node2.nodeSize,
        mark
      };
    }
  });
  return markFound;
};
const markInsertion = ({ tr, from: from2, to, user, date }) => {
  tr.removeMark(from2, to, tr.doc.type.schema.marks[TrackDeleteMarkName]);
  tr.removeMark(from2, to, tr.doc.type.schema.marks[TrackInsertMarkName]);
  let trackedMark = findTrackedMarkBetween({
    tr,
    from: from2,
    to,
    markName: TrackInsertMarkName,
    attrs: { authorEmail: user.email }
  });
  let id;
  if (trackedMark) {
    id = trackedMark.mark.attrs.id;
  } else {
    id = v4();
  }
  const insertionMark = tr.doc.type.schema.marks[TrackInsertMarkName].create({
    id,
    author: user.name,
    authorEmail: user.email,
    date
  });
  tr.addMark(from2, to, insertionMark);
  tr.doc.nodesBetween(from2, to, (node2, pos) => {
    if (pos < from2 || ["bulletList", "orderedList"].includes(node2.type.name)) {
      return true;
    } else if (node2.isInline || ["tableRow", "tableCell"].includes(node2.type.name)) {
      return false;
    }
    if (node2.attrs.track) ;
    if (node2.type.name === "table") {
      return false;
    }
  });
  return insertionMark;
};
const markDeletion = ({ tr, from: from2, to, user, date }) => {
  let trackedMark = findTrackedMarkBetween({
    tr,
    from: from2,
    to,
    markName: TrackDeleteMarkName,
    attrs: { authorEmail: user.email }
  });
  let id;
  if (trackedMark) {
    id = trackedMark.mark.attrs.id;
  } else {
    id = v4();
  }
  const deletionMark = tr.doc.type.schema.marks[TrackDeleteMarkName].create({
    id,
    author: user.name,
    authorEmail: user.email,
    date
  });
  const deletionMap = new Mapping();
  let nodes = [];
  tr.doc.nodesBetween(from2, to, (node2, pos) => {
    if (node2.type.name.includes("table")) {
      return;
    }
    if (node2.isInline && node2.marks.find((mark) => mark.type.name === TrackInsertMarkName && mark.attrs.authorEmail === user.email)) {
      const removeStep = new ReplaceStep(
        deletionMap.map(Math.max(from2, pos)),
        deletionMap.map(Math.min(to, pos + node2.nodeSize)),
        Slice.empty
      );
      if (!tr.maybeStep(removeStep).failed) {
        deletionMap.appendMap(removeStep.getMap());
      }
    } else if (node2.isInline && !node2.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
      nodes.push(node2);
      tr.addMark(
        deletionMap.map(Math.max(from2, pos)),
        deletionMap.map(Math.min(to, pos + node2.nodeSize)),
        deletionMark
      );
    } else if (node2.attrs.track && !node2.attrs.track.find((trackAttr) => trackAttr.type === TrackDeleteMarkName) && !["bulletList", "orderedList"].includes(node2.type.name)) ;
  });
  return { deletionMark, deletionMap, nodes };
};
const findMarkPosition = (doc2, pos, markName) => {
  const $pos = doc2.resolve(pos);
  const parent = $pos.parent;
  const start2 = parent.childAfter($pos.parentOffset);
  if (!start2.node) {
    return null;
  }
  const actualMark = start2.node.marks.find((mark) => mark.type.name === markName);
  let startIndex = $pos.index();
  let startPos = $pos.start() + start2.offset;
  while (startIndex > 0 && actualMark.isInSet(parent.child(startIndex - 1).marks)) {
    startPos -= parent.child(--startIndex).nodeSize;
  }
  let endIndex = $pos.index() + 1;
  let endPos = $pos.start() + start2.offset + start2.node.nodeSize;
  while (endIndex < parent.childCount && actualMark.isInSet(parent.child(endIndex).marks)) {
    endPos += parent.child(endIndex++).nodeSize;
  }
  return {
    from: startPos,
    to: endPos,
    attrs: actualMark.attrs
  };
};
const flatten$3 = (node2, descend = true) => {
  if (!node2) {
    throw new Error('Invalid "node" parameter');
  }
  const result = [];
  node2.descendants((child, pos) => {
    result.push({ node: child, pos });
    if (!descend) {
      return false;
    }
  });
  return result;
};
const findChildren$4 = (node2, predicate, descend) => {
  if (!node2) {
    throw new Error('Invalid "node" parameter');
  } else if (!predicate) {
    throw new Error('Invalid "predicate" parameter');
  }
  return flatten$3(node2, descend).filter((child) => predicate(child.node));
};
const findInlineNodes = (node2, descend) => {
  return findChildren$4(node2, (child) => child.isInline, descend);
};
const documentHelpers = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  findChildren: findChildren$4,
  findInlineNodes,
  findMarkPosition,
  flatten: flatten$3
}, Symbol.toStringTag, { value: "Module" }));
const getTrackChanges = (state2, id = null) => {
  const trackedChanges = [];
  const allInlineNodes = findInlineNodes(state2.doc);
  if (!allInlineNodes.length) {
    return trackedChanges;
  }
  allInlineNodes.forEach(({ node: node2, pos }) => {
    const { marks } = node2;
    const trackedMarks = [TrackInsertMarkName, TrackDeleteMarkName, TrackFormatMarkName];
    if (marks.length > 0) {
      marks.forEach((mark) => {
        if (trackedMarks.includes(mark.type.name)) {
          trackedChanges.push({
            mark,
            from: pos,
            to: pos + node2.nodeSize
          });
        }
      });
    }
  });
  if (id) {
    return trackedChanges.filter(({ mark }) => mark.attrs.id === id);
  }
  return trackedChanges;
};
const TrackChangesBasePluginKey = new PluginKey("TrackChangesBase");
const TrackChangesBasePlugin = () => {
  return new Plugin({
    key: TrackChangesBasePluginKey,
    state: {
      init(_2, state2) {
        const decorations = getTrackChangesDecorations(state2, false, false);
        return {
          isTrackChangesActive: false,
          onlyOriginalShown: false,
          onlyModifiedShown: false,
          decorations
        };
      },
      apply(tr, oldState, prevEditorState, newEditorState) {
        const meta = tr.getMeta(TrackChangesBasePluginKey);
        if (!meta) {
          return {
            ...oldState,
            decorations: getTrackChangesDecorations(
              newEditorState,
              oldState.onlyOriginalShown,
              oldState.onlyModifiedShown
            )
          };
        }
        if (meta.type === "TRACK_CHANGES_ENABLE") {
          return {
            ...oldState,
            isTrackChangesActive: meta.value === true,
            decorations: getTrackChangesDecorations(
              newEditorState,
              oldState.onlyOriginalShown,
              oldState.onlyModifiedShown
            )
          };
        }
        if (meta.type === "SHOW_ONLY_ORIGINAL") {
          return {
            ...oldState,
            onlyOriginalShown: meta.value === true,
            onlyModifiedShown: false,
            decorations: getTrackChangesDecorations(newEditorState, meta.value === true, false)
          };
        }
        if (meta.type === "SHOW_ONLY_MODIFIED") {
          return {
            ...oldState,
            onlyOriginalShown: false,
            onlyModifiedShown: meta.value === true,
            decorations: getTrackChangesDecorations(newEditorState, false, meta.value === true)
          };
        }
        return {
          ...oldState,
          decorations: getTrackChangesDecorations(
            newEditorState,
            oldState.onlyOriginalShown,
            oldState.onlyModifiedShown
          )
        };
      }
    },
    props: {
      decorations(state2) {
        return this.getState(state2)?.decorations;
      }
    }
  });
};
const getTrackChangesDecorations = (state2, onlyOriginalShown, onlyModifiedShown) => {
  if (!state2.doc || !state2.doc.nodeSize || onlyModifiedShown && onlyOriginalShown) {
    return DecorationSet.empty;
  }
  const decorations = [];
  const trackedChanges = getTrackChanges(state2);
  if (!trackedChanges.length) {
    return DecorationSet.empty;
  }
  trackedChanges.forEach(({ mark, from: from2, to }) => {
    if (mark.type.name === TrackInsertMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-insert-dec hidden"
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-insert-dec normal"
        });
        decorations.push(decoration);
      } else {
        const decoration = Decoration.inline(from2, to, {
          class: "track-insert-dec highlighted"
        });
        decorations.push(decoration);
      }
    }
    if (mark.type.name === TrackDeleteMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-delete-dec normal"
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-delete-dec hidden"
        });
        decorations.push(decoration);
      } else {
        const decorationInline = Decoration.inline(from2, to, {
          class: "track-delete-dec highlighted"
          // 'hidden'
        });
        decorations.push(decorationInline);
        const decorationWidget = Decoration.widget(
          from2,
          () => {
            const span = document.createElement("span");
            span.classList.add("track-delete-widget");
            span.contentEditable = false;
            return span;
          },
          { ignoreSelection: true }
        );
        decorations.push(decorationWidget);
      }
    }
    if (mark.type.name === TrackFormatMarkName) {
      if (onlyOriginalShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-format-dec before"
        });
        decorations.push(decoration);
      } else if (onlyModifiedShown) {
        const decoration = Decoration.inline(from2, to, {
          class: "track-format-dec normal"
        });
        decorations.push(decoration);
      } else {
        const decoration = Decoration.inline(from2, to, {
          class: "track-format-dec highlighted"
        });
        decorations.push(decoration);
      }
    }
  });
  return DecorationSet.create(state2.doc, decorations);
};
const CommentMarkName = "commentMark";
const removeCommentsById = ({ commentId, state: state2, tr, dispatch }) => {
  const positions = getCommentPositionsById(commentId, state2.doc);
  positions.forEach(({ from: from2, to }) => {
    tr.removeMark(from2, to, state2.schema.marks[CommentMarkName]);
  });
  dispatch(tr);
};
const getCommentPositionsById = (commentId, doc2) => {
  const positions = [];
  doc2.descendants((node2, pos) => {
    const { marks } = node2;
    const commentMark = marks.find((mark) => mark.type.name === CommentMarkName);
    if (commentMark) {
      const { attrs } = commentMark;
      const { commentId: currentCommentId } = attrs;
      if (commentId === currentCommentId) {
        positions.push({ from: pos, to: pos + node2.nodeSize });
      }
    }
  });
  return positions;
};
const prepareCommentsForExport = (doc2, tr, schema, comments = []) => {
  const startNodes = [];
  const endNodes = [];
  const seen = /* @__PURE__ */ new Set();
  doc2.descendants((node2, pos) => {
    const commentMarks = node2.marks?.filter((mark) => mark.type.name === CommentMarkName);
    commentMarks.forEach((commentMark) => {
      if (commentMark) {
        const { attrs = {} } = commentMark;
        const { commentId } = attrs;
        if (commentId === "pending") return;
        if (seen.has(commentId)) return;
        seen.add(commentId);
        const commentStartNodeAttrs = getPreparedComment(commentMark.attrs);
        const startNode = schema.nodes.commentRangeStart.create(commentStartNodeAttrs);
        startNodes.push({
          pos,
          node: startNode
        });
        const endNode = schema.nodes.commentRangeEnd.create(commentStartNodeAttrs);
        endNodes.push({
          pos: pos + node2.nodeSize,
          node: endNode
        });
        const parentId = commentId;
        if (parentId) {
          const childComments = comments.filter((c2) => c2.parentCommentId === parentId).sort((a, b2) => a.createdTime - b2.createdTime);
          childComments.forEach((c2) => {
            const childMark = getPreparedComment(c2);
            const childStartNode = schema.nodes.commentRangeStart.create(childMark);
            seen.add(c2.commentId);
            startNodes.push({
              pos,
              node: childStartNode
            });
            const childEndNode = schema.nodes.commentRangeEnd.create(childMark);
            endNodes.push({
              pos: pos + node2.nodeSize,
              node: childEndNode
            });
          });
        }
      }
    });
  });
  startNodes.forEach((n) => {
    const { pos, node: node2 } = n;
    const mappedPos = tr.mapping.map(pos);
    tr.insert(mappedPos, node2);
  });
  endNodes.forEach((n) => {
    const { pos, node: node2 } = n;
    const mappedPos = tr.mapping.map(pos);
    tr.insert(mappedPos, node2);
  });
  return tr;
};
const getPreparedComment = (attrs) => {
  const { commentId, internal } = attrs;
  return {
    "w:id": commentId,
    internal
  };
};
const prepareCommentsForImport = (doc2, tr, schema, converter) => {
  const toMark = [];
  const toDelete = [];
  doc2.descendants((node2, pos) => {
    const { type: type2 } = node2;
    const commentNodes = ["commentRangeStart", "commentRangeEnd", "commentReference"];
    if (!commentNodes.includes(type2.name)) return;
    const matchingImportedComment = converter.comments?.find((c2) => c2.importedId == node2.attrs["w:id"]) || {};
    const { commentId } = matchingImportedComment;
    if (!commentId) return;
    if (type2.name === "commentRangeStart") {
      toMark.push({
        "w:id": commentId,
        importedId: node2.attrs["w:id"],
        internal: false,
        start: pos
      });
      toDelete.push({ start: pos, end: pos + 1 });
    } else if (type2.name === "commentRangeEnd") {
      const itemToMark = toMark.find((p) => p.importedId === node2.attrs["w:id"]);
      if (!itemToMark) return;
      const { start: start2 } = itemToMark;
      const markAttrs = {
        commentId,
        importedId: node2.attrs["w:id"],
        internal: itemToMark.internal
      };
      tr.addMark(start2, pos + 1, schema.marks[CommentMarkName].create(markAttrs));
      toDelete.push({ start: pos, end: pos + 1 });
    } else if (type2.name === "commentReference") {
      toDelete.push({ start: pos, end: pos + 1 });
    }
  });
  toDelete.sort((a, b2) => b2.start - a.start).forEach(({ start: start2, end: end2 }) => {
    tr.delete(start2, end2);
  });
};
const translateFormatChangesToEnglish = (attrs = {}) => {
  const { before = [], after = [] } = attrs;
  const beforeTypes = new Set(before.map((mark) => mark.type));
  const afterTypes = new Set(after.map((mark) => mark.type));
  const added = [...afterTypes].filter((type2) => !beforeTypes.has(type2));
  const removed = [...beforeTypes].filter((type2) => !afterTypes.has(type2));
  const messages = [];
  const nonTextStyleAdded = added.filter((type2) => !["textStyle", "commentMark"].includes(type2));
  if (nonTextStyleAdded.length) {
    messages.push(`Added formatting: ${nonTextStyleAdded.join(", ")}`);
  }
  const nonTextStyleRemoved = removed.filter((type2) => !["textStyle", "commentMark"].includes(type2));
  if (nonTextStyleRemoved.length) {
    messages.push(`Removed formatting: ${nonTextStyleRemoved.join(", ")}`);
  }
  const beforeTextStyle = before.find((mark) => mark.type === "textStyle")?.attrs || {};
  const afterTextStyle = after.find((mark) => mark.type === "textStyle")?.attrs || {};
  const textStyleChanges = [];
  const formatAttrName = (attr) => attr.replace(/([a-z])([A-Z])/g, "$1 $2").toLowerCase();
  Object.keys({ ...beforeTextStyle, ...afterTextStyle }).forEach((attr) => {
    const beforeValue = beforeTextStyle[attr];
    const afterValue = afterTextStyle[attr];
    if (beforeValue !== afterValue) {
      if (afterValue === null) {
        return;
      } else if (attr === "color") {
        textStyleChanges.push(`Changed color`);
      } else {
        const label = formatAttrName(attr);
        if (beforeValue === void 0 || beforeValue === null) {
          textStyleChanges.push(`Set ${label} to ${afterValue}`);
        } else {
          textStyleChanges.push(`Changed ${label} from ${beforeValue} to ${afterValue}`);
        }
      }
    }
  });
  if (textStyleChanges.length) {
    messages.push(`Modified text style: ${textStyleChanges.join(", ")}`);
  }
  return messages.length ? messages.join(". ") : "No formatting changes.";
};
const getHighlightColor = ({ activeThreadId, threadId, isInternal, editor }) => {
  if (!editor.options.isInternal && isInternal) return "transparent";
  const pluginState = CommentsPluginKey.getState(editor.state);
  const color = isInternal ? pluginState.internalColor : pluginState.externalColor;
  const alpha = activeThreadId == threadId ? "44" : "22";
  return `${color}${alpha}`;
};
const updateYdocDocxData = async (editor, ydoc) => {
  ydoc = ydoc || editor.options.ydoc;
  if (!ydoc) return;
  const metaMap = ydoc.getMap("meta");
  const docx = [...metaMap.get("docx")];
  const newXml = await editor.exportDocx({ getUpdatedDocs: true });
  Object.keys(newXml).forEach((key) => {
    const fileIndex = docx.findIndex((item) => item.name === key);
    if (fileIndex > -1) {
      docx.splice(fileIndex, 1);
    }
    docx.push({
      name: key,
      content: newXml[key]
    });
  });
  ydoc.transact(
    () => {
      metaMap.set("docx", docx);
    },
    { event: "docx-update", user: editor.options.user }
  );
};
const PaginationPluginKey = new PluginKey("paginationPlugin");
const initPaginationData = async (editor) => {
  if (!editor.converter) return;
  const sectionData = { headers: {}, footers: {} };
  const headerIds = editor.converter.headerIds.ids;
  const footerIds = editor.converter.footerIds.ids;
  for (let key in headerIds) {
    const sectionId = headerIds[key];
    if (!sectionId) continue;
    const dataForThisSection = editor.converter.headers[sectionId];
    if (!sectionData.headers[sectionId]) sectionData.headers[sectionId] = {};
    sectionData.headers[sectionId].data = dataForThisSection;
    const { height, sectionEditor, sectionContainer } = await getSectionHeight(editor, dataForThisSection);
    sectionData.headers[sectionId].height = height;
    sectionData.headers[sectionId].sectionEditor = sectionEditor;
    sectionData.headers[sectionId].sectionContainer = sectionContainer;
  }
  for (let key in footerIds) {
    const sectionId = footerIds[key];
    if (!sectionId) continue;
    const dataForThisSection = editor.converter.footers[sectionId];
    if (!sectionData.headers[sectionId]) sectionData.footers[sectionId] = {};
    sectionData.footers[sectionId].data = dataForThisSection;
    const { height, sectionEditor, sectionContainer } = await getSectionHeight(editor, dataForThisSection);
    sectionData.footers[sectionId].height = height;
    sectionData.footers[sectionId].sectionEditor = sectionEditor;
    sectionData.footers[sectionId].sectionContainer = sectionContainer;
  }
  return sectionData;
};
const getSectionHeight = async (editor, data) => {
  if (!data) return {};
  return new Promise((resolve) => {
    const editorContainer = document.createElement("div");
    editorContainer.className = "super-editor";
    editorContainer.style.padding = "0";
    editorContainer.style.margin = "0";
    const sectionEditor = createHeaderFooterEditor({ editor, data, editorContainer });
    sectionEditor.on("create", () => {
      sectionEditor.setEditable(false, false);
      requestAnimationFrame(() => {
        const height = editorContainer.offsetHeight;
        document.body.removeChild(editorContainer);
        resolve({ height, sectionEditor, sectionContainer: editorContainer });
      });
    });
  });
};
const createHeaderFooterEditor = ({
  editor,
  data,
  editorContainer,
  appendToBody = true,
  sectionId,
  type: type2,
  availableHeight,
  currentPageNumber
}) => {
  const parentStyles = editor.converter.getDocumentDefaultStyles();
  const { fontSizePt, typeface } = parentStyles;
  const fontSizeInPixles = fontSizePt * 1.3333;
  const lineHeight2 = fontSizeInPixles * 1.2;
  Object.assign(editorContainer.style, {
    padding: "0",
    margin: "0",
    border: "none",
    boxSizing: "border-box",
    position: "absolute",
    top: "0",
    left: "0",
    width: "auto",
    maxWidth: "none",
    fontFamily: typeface,
    fontSize: `${fontSizeInPixles}px`,
    lineHeight: `${lineHeight2}px`
  });
  Object.assign(editorContainer.style, {
    padding: "0",
    margin: "0",
    border: "none",
    boxSizing: "border-box",
    height: availableHeight + "px",
    overflow: "hidden"
  });
  if (appendToBody) document.body.appendChild(editorContainer);
  const headerFooterEditor = new Editor({
    role: editor.options.role,
    loadFromSchema: true,
    mode: "docx",
    element: editorContainer,
    content: data,
    extensions: getStarterExtensions(),
    documentId: sectionId || "sectionId",
    media: editor.storage.image.media,
    mediaFiles: editor.storage.image.media,
    fonts: editor.options.fonts,
    isHeaderOrFooter: true,
    isHeadless: editor.options.isHeadless,
    annotations: true,
    currentPageNumber,
    parentEditor: editor,
    editable: false,
    documentMode: "viewing",
    onCreate: (evt) => setEditorToolbar(evt, editor),
    onBlur: (evt) => onHeaderFooterDataUpdate(evt, editor, sectionId, type2)
  });
  headerFooterEditor.setEditable(false, false);
  const pm = editorContainer.querySelector(".ProseMirror");
  if (pm) {
    pm.style.maxHeight = "100%";
    pm.style.minHeight = "100%";
    pm.style.outline = "none";
    pm.style.border = "none";
    pm.setAttribute("role", "textbox");
    pm.setAttribute("aria-multiline", true);
    pm.setAttribute("aria-label", `${type2} content area. Double click to start typing.`);
  }
  return headerFooterEditor;
};
const broadcastEditorEvents = (editor, sectionEditor) => {
  const eventNames = [
    "fieldAnnotationDropped",
    "fieldAnnotationPaste",
    "fieldAnnotationSelected",
    "fieldAnnotationClicked",
    "fieldAnnotationDoubleClicked",
    "fieldAnnotationDeleted"
  ];
  eventNames.forEach((eventName) => {
    sectionEditor.on(eventName, (...args) => {
      editor.emit(eventName, ...args);
      console.debug("broadcastEditorEvents", { eventName, args });
    });
  });
};
const toggleHeaderFooterEditMode = ({ editor, focusedSectionEditor, isEditMode, documentMode }) => {
  editor.converter.headerEditors.forEach((item) => {
    item.editor.setEditable(isEditMode, false);
    item.editor.view.dom.setAttribute("aria-readonly", !isEditMode);
    item.editor.view.dom.setAttribute("documentmode", documentMode);
  });
  editor.converter.footerEditors.forEach((item) => {
    item.editor.setEditable(isEditMode, false);
    item.editor.view.dom.setAttribute("aria-readonly", !isEditMode);
    item.editor.view.dom.setAttribute("documentmode", documentMode);
  });
  if (isEditMode) {
    const pm = document.querySelector(".ProseMirror");
    pm.classList.add("header-footer-edit");
    pm.setAttribute("aria-readonly", true);
  }
  if (focusedSectionEditor) {
    focusedSectionEditor.view.focus();
  }
};
const onHeaderFooterDataUpdate = async ({ editor, transaction }, mainEditor, sectionId, type2) => {
  if (!type2 || !sectionId) return;
  const updatedData = editor.getUpdatedJson();
  mainEditor.converter[`${type2}Editors`].forEach((item) => {
    if (item.id === sectionId) {
      item.editor.setOptions({
        media: editor.options.media,
        mediaFiles: editor.options.mediaFiles
      });
      item.editor.replaceContent(updatedData);
    }
    item.editor.setOptions({
      lastSelection: transaction?.selection
    });
  });
  mainEditor.converter[`${type2}s`][sectionId] = updatedData;
  mainEditor.setOptions({ isHeaderFooterChanged: editor.docChanged });
  await updateYdocDocxData(mainEditor);
};
const setEditorToolbar = ({ editor }, mainEditor) => {
  editor.setToolbar(mainEditor.toolbar);
};
const TRACK_CHANGE_MARKS = [TrackInsertMarkName, TrackDeleteMarkName, TrackFormatMarkName];
const CommentsPluginKey = new PluginKey("comments");
const CommentsPlugin = Extension.create({
  name: "comments",
  addCommands() {
    return {
      insertComment: (conversation) => ({ tr, dispatch }) => {
        const { selection } = tr;
        const { $from, $to } = selection;
        const { commentId, isInternal } = conversation;
        tr.setMeta(CommentsPluginKey, { event: "add" });
        tr.addMark(
          $from.pos,
          $to.pos,
          this.editor.schema.marks[CommentMarkName].create({
            commentId,
            internal: isInternal
          })
        );
        dispatch(tr);
        return true;
      },
      removeComment: ({ commentId, importedId }) => ({ tr, dispatch, state: state2 }) => {
        tr.setMeta(CommentsPluginKey, { event: "deleted" });
        removeCommentsById({ commentId, state: state2, tr, dispatch });
      },
      setActiveComment: ({ commentId }) => ({ tr }) => {
        tr.setMeta(CommentsPluginKey, { type: "setActiveComment", activeThreadId: commentId, forceUpdate: true });
        return true;
      },
      setCommentInternal: ({ commentId, isInternal }) => ({ tr, dispatch, state: state2 }) => {
        const { doc: doc2 } = state2;
        let foundStartNode;
        let foundPos;
        tr.setMeta(CommentsPluginKey, { event: "update" });
        doc2.descendants((node2, pos) => {
          if (foundStartNode) return;
          const { marks = [] } = node2;
          const commentMark = marks.find((mark) => mark.type.name === CommentMarkName);
          if (commentMark) {
            const { attrs } = commentMark;
            const wid = attrs.commentId;
            if (wid === commentId) {
              foundStartNode = node2;
              foundPos = pos;
            }
          }
        });
        if (!foundStartNode) return false;
        tr.addMark(
          foundPos,
          foundPos + foundStartNode.nodeSize,
          this.editor.schema.marks[CommentMarkName].create({
            commentId,
            internal: isInternal
          })
        );
        tr.setMeta(CommentsPluginKey, { type: "setCommentInternal" });
        dispatch(tr);
        return true;
      },
      resolveComment: ({ commentId }) => ({ tr, dispatch, state: state2 }) => {
        tr.setMeta(CommentsPluginKey, { event: "update" });
        removeCommentsById({ commentId, state: state2, tr, dispatch });
      },
      setCursorById: (id) => ({ state: state2, editor }) => {
        const { from: from2 } = findRangeById(state2.doc, id) || {};
        if (from2 != null) {
          state2.tr.setSelection(TextSelection$1.create(state2.doc, from2));
          editor.view.focus();
          return true;
        }
        return false;
      }
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    let shouldUpdate;
    if (editor.options.isHeadless) return [];
    const commentsPlugin = new Plugin({
      key: CommentsPluginKey,
      state: {
        init() {
          return {
            activeThreadId: null,
            externalColor: "#B1124B",
            internalColor: "#078383",
            decorations: DecorationSet.empty,
            allCommentPositions: {},
            allCommentIds: [],
            changedActiveThread: false,
            trackedChanges: {}
          };
        },
        apply(tr, pluginState, _2, newEditorState) {
          const paginationMeta = tr.getMeta(PaginationPluginKey);
          const isPaginationInit = paginationMeta?.isReadyToInit;
          if (isPaginationInit) shouldUpdate = true;
          const meta = tr.getMeta(CommentsPluginKey);
          const { type: type2 } = meta || {};
          if (type2 === "force" || type2 === "forceTrackChanges") shouldUpdate = true;
          if (type2 === "setActiveComment") {
            shouldUpdate = true;
            pluginState.activeThreadId = meta.activeThreadId;
            return {
              ...pluginState,
              activeThreadId: meta.activeThreadId,
              changedActiveThread: true
            };
          }
          if (!isPaginationInit && !shouldUpdate && meta && meta.decorations) {
            return {
              ...pluginState,
              decorations: meta.decorations,
              allCommentPositions: meta.allCommentPositions
            };
          }
          const trackedChangeMeta = tr.getMeta(TrackChangesBasePluginKey);
          const currentTrackedChanges = pluginState.trackedChanges;
          if (trackedChangeMeta) {
            pluginState.trackedChanges = handleTrackedChangeTransaction(
              trackedChangeMeta,
              currentTrackedChanges,
              newEditorState,
              editor
            );
          }
          const trChangedActiveComment = meta?.type === "setActiveComment";
          if (!tr.docChanged && tr.selectionSet || trChangedActiveComment) {
            const { selection } = tr;
            let currentActiveThread = getActiveCommentId(newEditorState.doc, selection);
            if (trChangedActiveComment) currentActiveThread = meta.activeThreadId;
            const previousSelectionId = pluginState.activeThreadId;
            if (previousSelectionId !== currentActiveThread) {
              pluginState.activeThreadId = currentActiveThread;
              const update = {
                type: comments_module_events.SELECTED,
                activeCommentId: currentActiveThread ? currentActiveThread : null
              };
              shouldUpdate = true;
              editor.emit("commentsUpdate", update);
              const { tr: newTr } = editor.view.state;
              const { dispatch } = editor.view;
              newTr.setMeta(CommentsPluginKey, { type: "force" });
              dispatch(newTr);
            }
          }
          return pluginState;
        }
      },
      props: {
        decorations(state2) {
          return this.getState(state2).decorations;
        }
      },
      view() {
        let prevDoc;
        let prevActiveThreadId;
        return {
          update(view) {
            const { state: state2 } = view;
            const { doc: doc2, tr } = state2;
            const pluginState = CommentsPluginKey.getState(state2);
            const currentActiveThreadId = pluginState.activeThreadId;
            const meta = tr.getMeta(CommentsPluginKey);
            if (meta?.type === "setActiveComment" || meta?.forceUpdate) {
              shouldUpdate = true;
            }
            if (prevDoc && !prevDoc.eq(doc2)) shouldUpdate = true;
            if (prevActiveThreadId !== currentActiveThreadId) {
              shouldUpdate = true;
              prevActiveThreadId = currentActiveThreadId;
            }
            if (!shouldUpdate) return;
            prevDoc = doc2;
            shouldUpdate = false;
            const decorations = [];
            const allCommentPositions = {};
            doc2.descendants((node2, pos) => {
              const { marks = [] } = node2;
              const commentMarks = marks.filter((mark) => mark.type.name === CommentMarkName);
              let hasActive = false;
              commentMarks.forEach((commentMark) => {
                const { attrs } = commentMark;
                const threadId = attrs.commentId || attrs.importedId;
                const currentBounds = view.coordsAtPos(pos);
                updatePosition({
                  allCommentPositions,
                  threadId,
                  pos,
                  currentBounds,
                  node: node2
                });
                const isInternal = attrs.internal;
                if (!hasActive) hasActive = currentActiveThreadId === threadId;
                let color = getHighlightColor({
                  activeThreadId: currentActiveThreadId,
                  threadId,
                  isInternal,
                  editor
                });
                const deco = Decoration.inline(pos, pos + node2.nodeSize, {
                  style: `background-color: ${color};`,
                  "data-thread-id": threadId,
                  class: "sd-editor-comment-highlight"
                });
                if (hasActive && currentActiveThreadId !== threadId) return;
                decorations.push(deco);
              });
              const trackedChangeMark = findTrackedMark({
                doc: doc2,
                from: pos,
                to: pos + node2.nodeSize
              });
              if (trackedChangeMark) {
                const currentBounds = view.coordsAtPos(pos);
                const { id } = trackedChangeMark.mark.attrs;
                updatePosition({
                  allCommentPositions,
                  threadId: id,
                  pos,
                  currentBounds,
                  node: node2
                });
                const isActiveTrackedChange = currentActiveThreadId === id;
                if (isActiveTrackedChange) {
                  const trackedChangeDeco = Decoration.inline(pos, pos + node2.nodeSize, {
                    style: `border-width: 2px;`,
                    "data-thread-id": id,
                    class: "sd-editor-tracked-change-highlight"
                  });
                  decorations.push(trackedChangeDeco);
                }
              }
            });
            const decorationSet = DecorationSet.create(doc2, decorations);
            const oldDecorations = pluginState.decorations;
            const same = oldDecorations.eq(decorationSet);
            if (!same) {
              const tr2 = state2.tr.setMeta(CommentsPluginKey, {
                decorations: decorationSet,
                allCommentPositions,
                forceUpdate: true
              });
              view.dispatch(tr2);
            }
            editor.emit("comment-positions", { allCommentPositions });
          }
        };
      }
    });
    return [commentsPlugin];
  }
});
const updatePosition = ({ allCommentPositions, threadId, pos, currentBounds, node: node2 }) => {
  let bounds = {};
  if (currentBounds instanceof DOMRect) {
    bounds = {
      top: currentBounds.top,
      bottom: currentBounds.bottom,
      left: currentBounds.left,
      right: currentBounds.right
    };
  } else {
    bounds = { ...currentBounds };
  }
  if (!allCommentPositions[threadId]) {
    allCommentPositions[threadId] = {
      threadId,
      start: pos,
      end: pos + node2.nodeSize,
      bounds
    };
  } else {
    const existing = allCommentPositions[threadId];
    existing.start = Math.min(existing.start, pos);
    existing.end = Math.max(existing.end, pos + node2.nodeSize);
    existing.bounds.top = Math.min(existing.bounds.top, currentBounds.top);
    existing.bounds.bottom = Math.max(existing.bounds.bottom, currentBounds.bottom);
  }
};
const getActiveCommentId = (doc2, selection) => {
  if (!selection) return;
  const { $from, $to } = selection;
  if ($from.pos !== $to.pos) return;
  const nodeAtPos = doc2.nodeAt($from.pos);
  if (!nodeAtPos) return;
  const trackedChangeMark = findTrackedMark({
    doc: doc2,
    from: $from.pos,
    to: $to.pos
  });
  if (trackedChangeMark) {
    return trackedChangeMark.mark.attrs.id;
  }
  const overlaps = [];
  let found2 = false;
  doc2.descendants((node2, pos) => {
    if (found2) return;
    const end2 = pos + node2.nodeSize;
    if ($from.pos < pos || $from.pos >= end2) {
      return;
    }
    const { marks = [] } = node2;
    const commentMark = marks.find((mark) => mark.type.name === CommentMarkName);
    if (commentMark) {
      overlaps.push({
        node: node2,
        pos,
        size: node2.nodeSize
      });
    }
    if (pos > $from.pos) {
      found2 = true;
    }
  });
  let closest = null;
  let closestCommentRangeStart = null;
  overlaps.forEach(({ pos, node: node2 }) => {
    if (!closest) closest = $from.pos - pos;
    const diff = $from.pos - pos;
    if (diff >= 0 && diff <= closest) {
      closestCommentRangeStart = node2;
      closest = diff;
    }
  });
  const { marks: closestMarks = [] } = closestCommentRangeStart || {};
  const closestCommentMark = closestMarks.find((mark) => mark.type.name === CommentMarkName);
  return closestCommentMark?.attrs?.commentId || closestCommentMark?.attrs?.importedId;
};
const findTrackedMark = ({
  doc: doc2,
  from: from2,
  to,
  offset: offset2 = 1
  // To get non-inclusive marks.
}) => {
  const startPos = Math.max(from2 - offset2, 0);
  const endPos = Math.min(to + offset2, doc2.content.size);
  let markFound;
  doc2.nodesBetween(startPos, endPos, (node2, pos) => {
    if (!node2 || node2?.nodeSize === void 0) {
      return;
    }
    const mark = node2.marks.find((mark2) => TRACK_CHANGE_MARKS.includes(mark2.type.name));
    if (mark && !markFound) {
      markFound = {
        from: pos,
        to: pos + node2.nodeSize,
        mark
      };
    }
  });
  return markFound;
};
const handleTrackedChangeTransaction = (trackedChangeMeta, trackedChanges, newEditorState, editor) => {
  const { insertedMark, deletionMark, formatMark, deletionNodes } = trackedChangeMeta;
  if (!insertedMark && !deletionMark && !formatMark) {
    return;
  }
  const newTrackedChanges = { ...trackedChanges };
  let id = insertedMark?.attrs?.id || deletionMark?.attrs?.id || formatMark?.attrs?.id;
  if (!id) {
    return trackedChanges;
  }
  let isNewChange = false;
  if (!newTrackedChanges[id]) {
    newTrackedChanges[id] = {};
    isNewChange = true;
  }
  if (insertedMark) newTrackedChanges[id].insertion = id;
  if (deletionMark) newTrackedChanges[id].deletion = deletionMark.attrs?.id;
  if (formatMark) newTrackedChanges[id].format = formatMark.attrs?.id;
  const { step } = trackedChangeMeta;
  let nodes = step?.slice?.content?.content || [];
  if (!nodes.length) {
    newEditorState.doc.descendants((node2) => {
      const hasFormatMark = node2.marks.find((mark) => mark.type.name === TrackFormatMarkName);
      if (hasFormatMark) {
        nodes = [node2];
        return false;
      }
    });
  }
  const emitParams = createOrUpdateTrackedChangeComment({
    documentId: editor.options.documentId,
    event: isNewChange ? "add" : "update",
    marks: {
      insertedMark,
      deletionMark,
      formatMark
    },
    deletionNodes,
    nodes,
    newEditorState
  });
  if (emitParams) editor.emit("commentsUpdate", emitParams);
  return newTrackedChanges;
};
const getTrackedChangeText = ({ state: state2, node: node2, mark, marks, trackedChangeType, isDeletionInsertion }) => {
  let trackedChangeText = "";
  let deletionText = "";
  if (trackedChangeType === TrackInsertMarkName) {
    trackedChangeText = node2?.text ?? "";
  }
  if (trackedChangeType === TrackFormatMarkName) {
    trackedChangeText = translateFormatChangesToEnglish(mark.attrs);
  }
  if (trackedChangeType === TrackDeleteMarkName || isDeletionInsertion) {
    deletionText = node2?.text ?? "";
    if (isDeletionInsertion) {
      let { id } = marks.deletionMark.attrs;
      let deletionNode = findNode$1(state2.doc, (node22) => {
        const { marks: marks2 = [] } = node22;
        const changeMarks = marks2.filter((mark2) => TRACK_CHANGE_MARKS.includes(mark2.type.name));
        if (!changeMarks.length) return false;
        const hasMatchingId = changeMarks.find((mark2) => mark2.attrs.id === id);
        if (hasMatchingId) return true;
      });
      deletionText = deletionNode?.node.text ?? "";
    }
  }
  return {
    deletionText,
    trackedChangeText
  };
};
const createOrUpdateTrackedChangeComment = ({ event, marks, deletionNodes, nodes, newEditorState, documentId }) => {
  const trackedMark = marks.insertedMark || marks.deletionMark || marks.formatMark;
  const { type: type2, attrs } = trackedMark;
  const { name: trackedChangeType } = type2;
  const { author, authorEmail, date, importedAuthor } = attrs;
  const id = attrs.id;
  const node2 = nodes[0];
  const isDeletionInsertion = !!(marks.insertedMark && marks.deletionMark);
  let existingNode;
  newEditorState.doc.descendants((node22) => {
    const { marks: marks2 = [] } = node22;
    const changeMarks = marks2.filter((mark) => TRACK_CHANGE_MARKS.includes(mark.type.name));
    if (!changeMarks.length) return;
    const hasMatchingId = changeMarks.find((mark) => mark.attrs.id === id);
    if (hasMatchingId) existingNode = node22;
    if (existingNode) return false;
  });
  const { deletionText, trackedChangeText } = getTrackedChangeText({
    state: newEditorState,
    node: existingNode || node2,
    mark: trackedMark,
    marks,
    trackedChangeType,
    isDeletionInsertion
  });
  if (!deletionText && !trackedChangeText) {
    return;
  }
  const params2 = {
    event: comments_module_events.ADD,
    type: "trackedChange",
    documentId,
    changeId: id,
    trackedChangeType: isDeletionInsertion ? "both" : trackedChangeType,
    trackedChangeText,
    deletedText: marks.deletionMark ? deletionText : null,
    author,
    authorEmail,
    date,
    ...importedAuthor && {
      importedAuthor: {
        name: importedAuthor
      }
    }
  };
  if (event === "add") params2.event = comments_module_events.ADD;
  else if (event === "update") params2.event = comments_module_events.UPDATE;
  return params2;
};
function findNode$1(node2, predicate) {
  let found2 = null;
  node2.descendants((node22, pos) => {
    if (predicate(node22)) found2 = { node: node22, pos };
    if (found2) return false;
  });
  return found2;
}
function findRangeById(doc2, id) {
  let from2 = null, to = null;
  doc2.descendants((node2, pos) => {
    const trackedMark = node2.marks.find((m2) => TRACK_CHANGE_MARKS.includes(m2.type.name) && m2.attrs.id === id);
    if (trackedMark) {
      if (from2 === null || pos < from2) from2 = pos;
      if (to === null || pos + node2.nodeSize > to) to = pos + node2.nodeSize;
    }
    const commentMark = node2.marks.find(
      (m2) => m2.type.name === CommentMarkName && (m2.attrs.commentId === id || m2.attrs.importedId === id)
    );
    if (commentMark) {
      if (from2 === null || pos < from2) from2 = pos;
      if (to === null || pos + node2.nodeSize > to) to = pos + node2.nodeSize;
    }
  });
  return from2 !== null && to !== null ? { from: from2, to } : null;
}
const replaceStep = ({ state: state2, tr, step, newTr, map: map22, user, date, originalStep, originalStepIndex }) => {
  const deletionMarkSchema = state2.schema.marks[TrackDeleteMarkName];
  const deletionMark = findMark(state2, deletionMarkSchema, false);
  const positionTo = deletionMark ? deletionMark.to : step.to;
  const newStep = new ReplaceStep(
    positionTo,
    // We insert all the same steps, but with "from"/"to" both set to "to" in order not to delete content. Mapped as needed.
    positionTo,
    step.slice,
    step.structure
  );
  const invertStep = originalStep.invert(tr.docs[originalStepIndex]).map(map22);
  map22.appendMap(invertStep.getMap());
  const meta = {};
  if (newStep) {
    const trTemp = state2.apply(newTr).tr;
    if (trTemp.maybeStep(newStep).failed) {
      return;
    }
    const mappedNewStepTo = newStep.getMap().map(newStep.to);
    const insertedMark = markInsertion({
      tr: trTemp,
      from: newStep.from,
      to: mappedNewStepTo,
      user,
      date
    });
    const condensedStep = new ReplaceStep(newStep.from, newStep.to, trTemp.doc.slice(newStep.from, mappedNewStepTo));
    newTr.step(condensedStep);
    const mirrorIndex = map22.maps.length - 1;
    map22.appendMap(condensedStep.getMap(), mirrorIndex);
    if (newStep.from !== mappedNewStepTo) {
      meta.insertedMark = insertedMark;
      meta.step = condensedStep;
    }
    if (!newTr.selection.eq(trTemp.selection)) {
      newTr.setSelection(trTemp.selection);
    }
  }
  if (step.from !== step.to) {
    const {
      deletionMark: deletionMark2,
      deletionMap,
      nodes: deletionNodes
    } = markDeletion({
      tr: newTr,
      from: step.from,
      to: step.to,
      user,
      date
    });
    meta.deletionNodes = deletionNodes;
    meta.deletionMark = deletionMark2;
    map22.appendMapping(deletionMap);
  }
  newTr.setMeta(TrackChangesBasePluginKey, meta);
  newTr.setMeta(CommentsPluginKey, { type: "force" });
};
const addMarkStep = ({ state: state2, step, newTr, doc: doc2, user, date }) => {
  const meta = {};
  doc2.nodesBetween(step.from, step.to, (node2, pos) => {
    if (!node2.isInline) {
      return;
    }
    if (node2.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
      return false;
    }
    const existingChangeMark = node2.marks.find(
      (mark) => [TrackDeleteMarkName, TrackFormatMarkName].includes(mark.type.name)
    );
    const wid = existingChangeMark ? existingChangeMark.attrs.id : v4();
    newTr.addMark(Math.max(step.from, pos), Math.min(step.to, pos + node2.nodeSize), step.mark);
    const allowedMarks = ["bold", "italic", "strike", "underline", "textStyle"];
    if (allowedMarks.includes(step.mark.type.name) && !node2.marks.find((mark) => mark.type === step.mark.type)) {
      const formatChangeMark = node2.marks.find((mark) => mark.type.name === TrackFormatMarkName);
      let after = [];
      let before = [];
      if (formatChangeMark) {
        let foundBefore = formatChangeMark.attrs.before.find((mark) => {
          if (mark.type === "textStyle") {
            return mark.type === step.mark.type.name && objectIncludes(mark.attrs, step.mark.attrs);
          }
          return mark.type === step.mark.type.name;
        });
        if (foundBefore) {
          before = [...formatChangeMark.attrs.before.filter((mark) => mark.type !== step.mark.type.name)];
          after = [...formatChangeMark.attrs.after];
        } else {
          before = [...formatChangeMark.attrs.before];
          after = [
            ...formatChangeMark.attrs.after,
            {
              type: step.mark.type.name,
              attrs: { ...step.mark.attrs }
            }
          ];
        }
      } else {
        before = node2.marks.map((mark) => ({
          type: mark.type.name,
          attrs: { ...mark.attrs }
        }));
        after = [
          {
            type: step.mark.type.name,
            attrs: { ...step.mark.attrs }
          }
        ];
      }
      if (after.length || before.length) {
        const newFormatMark = state2.schema.marks[TrackFormatMarkName].create({
          id: wid,
          author: user.name,
          authorEmail: user.email,
          date,
          before,
          after
        });
        newTr.addMark(
          step.from,
          // Math.max(step.from, pos)
          step.to,
          // Math.min(step.to, pos + node.nodeSize),
          newFormatMark
        );
        meta.formatMark = newFormatMark;
        meta.step = step;
        newTr.setMeta(TrackChangesBasePluginKey, meta);
        newTr.setMeta(CommentsPluginKey, { type: "force" });
      } else if (formatChangeMark) {
        newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node2.nodeSize), formatChangeMark);
      }
    }
  });
};
const removeMarkStep = ({ state: state2, step, newTr, doc: doc2, user, date }) => {
  const meta = {};
  doc2.nodesBetween(step.from, step.to, (node2, pos) => {
    if (!node2.isInline) {
      return true;
    }
    if (node2.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
      return false;
    }
    newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node2.nodeSize), step.mark);
    const allowedMarks = ["bold", "italic", "strike", "underline", "textStyle"];
    if (allowedMarks.includes(step.mark.type.name) && node2.marks.find((mark) => mark.type === step.mark.type)) {
      const formatChangeMark = node2.marks.find((mark) => mark.type.name === TrackFormatMarkName);
      let after = [];
      let before = [];
      if (formatChangeMark) {
        let foundAfter = formatChangeMark.attrs.after.find((mark) => mark.type === step.mark.type.name);
        if (foundAfter) {
          after = [...formatChangeMark.attrs.after.filter((mark) => mark.type !== step.mark.type.name)];
          before = [...formatChangeMark.attrs.before];
        } else {
          after = [...formatChangeMark.attrs.after];
          before = [
            ...formatChangeMark.attrs.before,
            {
              type: step.mark.type.name,
              attrs: { ...step.mark.attrs }
            }
          ];
        }
      } else {
        after = [];
        before = [
          {
            type: step.mark.type.name,
            attrs: { ...step.mark.attrs }
          }
        ];
      }
      if (after.length || before.length) {
        const newFormatMark = state2.schema.marks[TrackFormatMarkName].create({
          id: v4(),
          author: user.name,
          authorEmail: user.email,
          date,
          before,
          after
        });
        newTr.addMark(Math.max(step.from, pos), Math.min(step.to, pos + node2.nodeSize), newFormatMark);
        meta.formatMark = newFormatMark;
        meta.step = step;
        newTr.setMeta(TrackChangesBasePluginKey, meta);
        newTr.setMeta(CommentsPluginKey, { type: "force" });
      } else if (formatChangeMark) {
        newTr.removeMark(Math.max(step.from, pos), Math.min(step.to, pos + node2.nodeSize), formatChangeMark);
      }
    }
  });
};
const trackedTransaction = ({ tr, state: state2, user }) => {
  const onlyInputTypeMeta = ["inputType", "uiEvent", "paste", "pointer"];
  const notAllowedMeta = ["historyUndo", "historyRedo", "acceptReject"];
  if (!tr.steps.length || tr.meta && !Object.keys(tr.meta).every((meta) => onlyInputTypeMeta.includes(meta)) || notAllowedMeta.includes(tr.getMeta("inputType")) || tr.getMeta(CommentsPluginKey)) {
    return tr;
  }
  const newTr = state2.tr;
  const map22 = new Mapping();
  const fixedTimeTo10Mins = Math.floor(Date.now() / 6e5) * 6e5;
  const date = new Date(fixedTimeTo10Mins).toISOString();
  tr.steps.forEach((originalStep, originalStepIndex) => {
    const step = originalStep.map(map22);
    const { doc: doc2 } = newTr;
    if (!step) {
      return;
    }
    if (step instanceof ReplaceStep) {
      replaceStep({
        state: state2,
        tr,
        step,
        newTr,
        map: map22,
        user,
        date,
        originalStep,
        originalStepIndex
      });
      console.debug("[track-changes]: replaceStep");
    } else if (step instanceof AddMarkStep) {
      addMarkStep({
        state: state2,
        step,
        newTr,
        doc: doc2,
        user,
        date
      });
      console.debug("[track-changes]: addMarkStep");
    } else if (step instanceof RemoveMarkStep) {
      removeMarkStep({
        state: state2,
        step,
        newTr,
        doc: doc2,
        user,
        date
      });
      console.debug("[track-changes]: removeMarkStep");
    } else {
      newTr.step(step);
      console.log("[track-changes]: otherStep");
    }
  });
  if (tr.getMeta("inputType")) {
    newTr.setMeta(tr.getMeta("inputType"));
  }
  if (tr.getMeta("uiEvent")) {
    newTr.setMeta(tr.getMeta("uiEvent"));
  }
  if (tr.selectionSet) {
    const deletionMarkSchema = state2.schema.marks[TrackDeleteMarkName];
    const deletionMark = findMark(state2, deletionMarkSchema, false);
    if (tr.selection instanceof TextSelection$1 && (tr.selection.from < state2.selection.from || tr.getMeta("inputType") === "deleteContentBackward")) {
      const caretPos = map22.map(tr.selection.from, -1);
      newTr.setSelection(new TextSelection$1(newTr.doc.resolve(caretPos)));
    } else if (tr.selection.from > state2.selection.from && deletionMark) {
      const caretPos = map22.map(deletionMark.to + 1, 1);
      newTr.setSelection(new TextSelection$1(newTr.doc.resolve(caretPos)));
    } else {
      newTr.setSelection(tr.selection.map(newTr.doc, map22));
    }
  } else if (state2.selection.from - tr.selection.from > 1 && tr.selection.$head.depth > 1) {
    const caretPos = map22.map(tr.selection.from - 2, -1);
    newTr.setSelection(new TextSelection$1(newTr.doc.resolve(caretPos)));
  } else ;
  if (tr.storedMarksSet) {
    newTr.setStoredMarks(tr.storedMarks);
  }
  if (tr.scrolledIntoView) {
    newTr.scrollIntoView();
  }
  return newTr;
};
const migration_after_0_4_14 = (editor) => {
  const { state: state2 } = editor;
  const { dispatch } = editor.view;
  const { tr } = state2;
  if (!dispatch) return;
  state2.doc.descendants((node2, pos) => {
    if (node2.type.name === "paragraph") {
      const { attrs } = node2;
      const { spacing } = attrs;
      if (!spacing) return;
      const newSpacing = {
        line: twipsToLines(pixelsToTwips(spacing.line)),
        lineSpaceBefore: twipsToLines(pixelsToTwips(spacing.lineSpaceBefore)),
        lineSpaceAfter: twipsToLines(pixelsToTwips(spacing.lineSpaceAfter))
      };
      tr.setNodeMarkup(pos, void 0, {
        ...attrs,
        spacing: {
          ...spacing,
          ...newSpacing
        }
      });
    }
  });
  dispatch(tr);
  return true;
};
const DOCUMENT_MIGRATIONS = {
  initial: migration_after_0_4_14
};
const getNecessaryMigrations = (version2) => {
  if (version2 === "initial" || version2 === "0.4.14") return Object.values(DOCUMENT_MIGRATIONS);
};
const getFieldAttrs = (field, value, input) => {
  const { type: type2 } = field.attrs;
  const annotatorHandlers = {
    html: annotateHtml,
    text: annotateText,
    checkbox: annotateCheckbox,
    image: annotateImage,
    link: annotateLink,
    yesno: annotateYesNo,
    date: annotateDate
  };
  const handler = annotatorHandlers[type2];
  if (!handler) return {};
  return handler(value, input);
};
const annotateHtml = (value) => ({ rawHtml: value });
const annotateText = (value) => ({ displayLabel: value });
const annotateImage = (value) => ({ imageSrc: value });
const annotateCheckbox = (value) => ({ displayLabel: value });
const annotateDate = (value, input) => {
  const formatted = getFormattedDate(value, input.input_format);
  return { displayLabel: formatted };
};
const annotateLink = (value) => {
  if (!value.startsWith("http")) value = `http://${value}`;
  return { linkUrl: value };
};
const annotateYesNo = (value) => {
  const yesNoValues = {
    YES: "Yes",
    NO: "No"
  };
  const parsedValue = yesNoValues[value[0].toUpperCase()];
  return { displayLabel: parsedValue };
};
const processTables = ({ state: state2, tr, annotationValues }) => {
  const { doc: doc2 } = state2;
  const tables = [];
  doc2.descendants((node2, pos) => {
    if (node2.type.name === "table") tables.push({ node: node2, pos });
  });
  tables.reverse().forEach(({ pos }) => {
    const currentTableNode = tr.doc.nodeAt(pos);
    if (!currentTableNode || currentTableNode.type.name !== "table") return;
    try {
      generateTableIfNecessary({ tableNode: { node: currentTableNode, pos }, annotationValues, tr, state: state2 });
    } catch (error) {
      console.error("Error generating table at pos", pos, ":", error);
    }
  });
  return tr;
};
const generateTableIfNecessary = ({ tableNode, annotationValues, tr, state: state2 }) => {
  const {
    tableRow: RowType,
    tableCell: CellType,
    fieldAnnotation: FieldType,
    paragraph: ParaType
  } = state2.schema.nodes;
  const rows = [];
  tableNode.node.descendants((node2, pos) => {
    if (node2.type === RowType) {
      rows.push({ node: node2, pos });
    }
  });
  let rowNodeToGenerate = null;
  for (const row of rows) {
    let hasArrayAnnotation = false;
    row.node.descendants((node2) => {
      if (node2.type === FieldType) {
        const annotationValue = getAnnotationValue(node2.attrs.fieldId, annotationValues);
        if (Array.isArray(annotationValue) && node2.attrs.generatorIndex === null) {
          hasArrayAnnotation = true;
        }
      }
    });
    if (hasArrayAnnotation) {
      rowNodeToGenerate = row;
      break;
    }
  }
  if (!rowNodeToGenerate) return;
  const { node: rowNode, pos: rowStartPos } = rowNodeToGenerate;
  const absoluteRowStart = tableNode.pos + 1 + rowStartPos;
  let rowsToGenerate = 0;
  rowNode.descendants((childNode) => {
    if (childNode.type === FieldType) {
      const annotationValue = getAnnotationValue(childNode.attrs.fieldId, annotationValues);
      if (Array.isArray(annotationValue)) {
        rowsToGenerate = Math.max(rowsToGenerate, annotationValue.length);
      }
    }
  });
  if (rowsToGenerate <= 1) return;
  const validateAttributes = (attrs) => {
    const cleaned = {};
    for (const [key, value] of Object.entries(attrs)) {
      if (value !== void 0 && value !== null) {
        if (key === "displayLabel") {
          cleaned[key] = String(value);
        } else if (key === "rawHtml" || key === "linkUrl" || key === "imageSrc") {
          cleaned[key] = String(value);
        } else if (typeof value === "string" && value.length > 0) {
          cleaned[key] = value;
        } else if (typeof value !== "string") {
          cleaned[key] = value;
        }
      }
    }
    return cleaned;
  };
  const rebuildCell = (cellNode, rowIndex) => {
    try {
      const updatedBlocks = cellNode.content.content.map((blockNode) => {
        if (blockNode.type !== ParaType) return blockNode;
        const updatedInlines = blockNode.content.content.map((inlineNode) => {
          if (inlineNode.type !== FieldType) return inlineNode;
          let matchedAnnotationValues = getAnnotationValue(inlineNode.attrs.fieldId, annotationValues);
          if (!Array.isArray(matchedAnnotationValues)) {
            matchedAnnotationValues = [matchedAnnotationValues];
          }
          const value = matchedAnnotationValues[rowIndex];
          let extraAttrs = {};
          try {
            const rawExtraAttrs = getFieldAttrs(inlineNode, value, null);
            extraAttrs = validateAttributes(rawExtraAttrs || {});
          } catch (error) {
            console.error("Error getting field attrs:", error);
            extraAttrs = {};
          }
          const baseAttrs = validateAttributes(inlineNode.attrs || {});
          const newAttrs = {
            ...baseAttrs,
            ...extraAttrs,
            generatorIndex: rowIndex
          };
          try {
            return FieldType.create(newAttrs, inlineNode.content || Fragment.empty, inlineNode.marks || []);
          } catch (error) {
            console.error("Error creating field node:", error);
            try {
              const fallbackAttrs = {
                ...baseAttrs,
                generatorIndex: rowIndex,
                displayLabel: String(value || "")
              };
              return FieldType.create(
                validateAttributes(fallbackAttrs),
                inlineNode.content || Fragment.empty,
                inlineNode.marks || []
              );
            } catch (fallbackError) {
              console.error("Fallback also failed:", fallbackError);
              return inlineNode;
            }
          }
        });
        try {
          return ParaType.create(
            validateAttributes(blockNode.attrs || {}),
            Fragment.from(updatedInlines),
            blockNode.marks || []
          );
        } catch (error) {
          console.error("Error creating paragraph node:", error);
          return blockNode;
        }
      });
      return CellType.create(
        validateAttributes(cellNode.attrs || {}),
        Fragment.from(updatedBlocks),
        cellNode.marks || []
      );
    } catch (error) {
      console.error(`Failed to rebuild cell for row ${rowIndex}:`, error);
      throw error;
    }
  };
  try {
    const newRows = [];
    for (let rowIndex = 0; rowIndex < rowsToGenerate; rowIndex++) {
      const newCells = rowNode.content.content.map((cellNode) => rebuildCell(cellNode, rowIndex));
      const newRow = RowType.create(
        validateAttributes(rowNode.attrs || {}),
        Fragment.from(newCells),
        rowNode.marks || []
      );
      newRows.push(newRow);
    }
    const mappedRowStart = tr.mapping.map(absoluteRowStart);
    const rowEnd = mappedRowStart + rowNode.nodeSize;
    tr.replaceWith(mappedRowStart, rowEnd, Fragment.from(newRows));
  } catch (error) {
    console.error("Error during row generation:", error);
    throw error;
  }
};
const getAnnotationValue = (id, annotationValues) => {
  return annotationValues.find((value) => value.input_id === id)?.input_value || null;
};
const getAllHeaderFooterEditors = (editor) => {
  const sections = {
    header: editor.converter.headers || {},
    footer: editor.converter.footers || {}
  };
  const allEditors = [];
  Object.entries(sections).forEach(([type2, items]) => {
    const editorsKey = `${type2}Editors`;
    Object.entries(items).forEach(([sectionId, data]) => {
      let sectionEditor = editor.converter[editorsKey][sectionId];
      if (!sectionEditor) {
        sectionEditor = {
          id: sectionId,
          editor: createHeaderFooterEditor({
            editor,
            data,
            editorContainer: document.createElement("div"),
            appendToBody: false,
            sectionId,
            type: type2
          })
        };
        editor.converter[editorsKey].push(sectionEditor);
        allEditors.push({
          ...sectionEditor,
          key: editorsKey,
          type: type2,
          sectionId
        });
      }
    });
  });
  return allEditors;
};
const annotateHeadersAndFooters = ({
  editor,
  annotationValues = [],
  hiddenFieldIds = [],
  removeEmptyFields = false
}) => {
  const allEditors = getAllHeaderFooterEditors(editor);
  allEditors.forEach(({ sectionId, editor: sectionEditor, type: type2 }) => {
    sectionEditor.annotate(annotationValues, hiddenFieldIds, removeEmptyFields);
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type2);
  });
};
const annotateDocument = ({
  annotationValues = [],
  hiddenFieldIds = [],
  removeEmptyFields = false,
  schema,
  tr,
  editor
}) => {
  annotateHeadersAndFooters({ editor, annotationValues, hiddenFieldIds, removeEmptyFields });
  const annotations = [];
  const FieldType = schema.nodes.fieldAnnotation;
  tr.doc.descendants((node2, pos) => {
    if (node2.type === FieldType) {
      annotations.push({ node: node2, pos, size: node2.nodeSize });
    }
  });
  const toDelete = /* @__PURE__ */ new Set();
  if (hiddenFieldIds.length) {
    for (const { node: node2, pos } of annotations) {
      if (hiddenFieldIds.includes(node2.attrs.fieldId)) {
        toDelete.add(pos);
      }
    }
  }
  for (const { node: node2, pos } of annotations) {
    const { type: type2, fieldType, fieldId } = node2.attrs;
    if (toDelete.has(pos)) continue;
    let newValue = null;
    const input = annotationValues.find((i) => i.input_id === fieldId);
    if (!input) {
      const checkboxInputs = annotationValues.filter((i) => i.input_field_type === "CHECKBOXINPUT");
      inputsLoop: for (const cb of checkboxInputs) {
        for (const opt of cb.input_options) {
          if (opt.itemid === fieldId) {
            newValue = cb.input_link_value[opt.itemid] || " ";
            break inputsLoop;
          }
        }
      }
    }
    newValue = newValue || input?.input_value || null;
    if (Array.isArray(newValue) && node2.attrs.generatorIndex != null) {
      continue;
    }
    if (type2 === "checkbox" || fieldType === "CHECKBOXINPUT") {
      const isEmptyOrSquare = !newValue || typeof newValue === "string" && newValue.codePointAt(0) === 9744;
      if (isEmptyOrSquare) newValue = " ";
    }
    if (!newValue) {
      toDelete.add(pos);
    } else {
      const attrs = getFieldAttrs(node2, newValue, input);
      tr = tr.setNodeMarkup(pos, void 0, {
        ...node2.attrs,
        ...attrs
      });
    }
  }
  if (removeEmptyFields) {
    Array.from(toDelete).sort((a, b2) => b2 - a).forEach((pos) => {
      const ann = annotations.find((a) => a.pos === pos);
      if (!ann) return;
      tr = tr.delete(pos, pos + ann.node.nodeSize);
    });
  }
  return tr;
};
const getFormattedDate = (input = null, format = "") => {
  const date = input ? new Date(input) : /* @__PURE__ */ new Date();
  if (isNaN(date.getTime())) {
    return input;
  }
  if (format) return dateFormat(date, format);
  return date.toLocaleDateString("en-US", {
    month: "short",
    // e.g. “May”
    day: "2-digit",
    // e.g. “05”
    year: "numeric"
    // e.g. “2025”
  });
};
const updateHeaderFooterFieldAnnotations = ({ editor, fieldIdOrArray, attrs = {} }) => {
  if (!editor) return;
  const sectionEditors = getAllHeaderFooterEditors(editor);
  sectionEditors.forEach(({ editor: sectionEditor, sectionId, type: type2 }) => {
    sectionEditor.commands.updateFieldAnnotations(fieldIdOrArray, attrs);
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type2);
  });
};
const deleteHeaderFooterFieldAnnotations = ({ editor, fieldIdOrArray }) => {
  if (!editor) return;
  const sectionEditors = getAllHeaderFooterEditors(editor);
  sectionEditors.forEach(({ editor: sectionEditor, sectionId, type: type2 }) => {
    sectionEditor.commands.deleteFieldAnnotations(fieldIdOrArray);
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type2);
  });
};
const resetHeaderFooterFieldAnnotations = ({ editor }) => {
  if (!editor) return;
  const sectionEditors = getAllHeaderFooterEditors(editor);
  sectionEditors.forEach(({ editor: sectionEditor, sectionId, type: type2 }) => {
    sectionEditor.commands.resetFieldAnnotations();
    onHeaderFooterDataUpdate({ editor: sectionEditor }, editor, sectionId, type2);
  });
};
const AnnotatorHelpers = {
  getFieldAttrs,
  processTables,
  annotateDocument,
  annotateHeadersAndFooters,
  getAllHeaderFooterEditors,
  updateHeaderFooterFieldAnnotations,
  deleteHeaderFooterFieldAnnotations,
  resetHeaderFooterFieldAnnotations
};
const CollaborationPluginKey = new PluginKey("collaboration");
const Collaboration = Extension.create({
  name: "collaboration",
  priority: 1e3,
  addOptions() {
    return {
      ydoc: null,
      field: "supereditor",
      fragment: null,
      isReady: false
    };
  },
  addPmPlugins() {
    if (!this.editor.options.ydoc) return [];
    this.options.ydoc = this.editor.options.ydoc;
    const undoPlugin = createUndoPlugin();
    initSyncListener(this.options.ydoc, this.editor, this);
    initDocumentListener({ ydoc: this.options.ydoc, editor: this.editor });
    const [syncPlugin, fragment] = createSyncPlugin(this.options.ydoc, this.editor);
    this.options.fragment = fragment;
    const metaMap = this.options.ydoc.getMap("media");
    metaMap.observe((event) => {
      event.changes.keys.forEach((_2, key) => {
        if (!(key in this.editor.storage.image.media)) {
          const fileData = metaMap.get(key);
          this.editor.storage.image.media[key] = fileData;
        }
      });
    });
    return [syncPlugin, undoPlugin];
  },
  addCommands() {
    return {
      undo: () => ({ tr, state: state2, dispatch }) => {
        tr.setMeta("preventDispatch", true);
        tr.setMeta("inputType", "historyUndo");
        const undoManager = yUndoPluginKey.getState(state2).undoManager;
        if (undoManager.undoStack.length === 0) return false;
        if (!dispatch) return true;
        return undo(state2);
      },
      redo: () => ({ tr, state: state2, dispatch }) => {
        tr.setMeta("preventDispatch", true);
        tr.setMeta("inputType", "historyRedo");
        const undoManager = yUndoPluginKey.getState(state2).undoManager;
        if (undoManager.redoStack.length === 0) return false;
        if (!dispatch) return true;
        return redo(state2);
      },
      addImageToCollaboration: ({ mediaPath, fileData }) => () => {
        if (!this.options.ydoc) return;
        const mediaMap = this.options.ydoc.getMap("media");
        mediaMap.set(mediaPath, fileData);
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-z": () => this.editor.commands.undo(),
      "Mod-Shift-z": () => this.editor.commands.redo(),
      "Mod-y": () => this.editor.commands.redo()
    };
  }
});
const createSyncPlugin = (ydoc, editor) => {
  const fragment = ydoc.getXmlFragment("supereditor");
  const onFirstRender = () => {
    if (!editor.options.isNewFile) return;
    initializeMetaMap(ydoc, editor);
  };
  return [ySyncPlugin(fragment, { onFirstRender }), fragment];
};
const initializeMetaMap = (ydoc, editor) => {
  const metaMap = ydoc.getMap("meta");
  metaMap.set("docx", editor.options.content);
  metaMap.set("fonts", editor.options.fonts);
  const mediaMap = ydoc.getMap("media");
  Object.entries(editor.options.mediaFiles).forEach(([key, value]) => {
    mediaMap.set(key, value);
  });
};
const createUndoPlugin = () => {
  const yUndoPluginInstance = yUndoPlugin();
  return yUndoPluginInstance;
};
const checkDocxChanged = (transaction) => {
  if (!transaction.changed) return false;
  for (const [, value] of transaction.changed.entries()) {
    if (value instanceof Set && value.has("docx")) {
      return true;
    }
  }
  return false;
};
const initDocumentListener = ({ ydoc, editor }) => {
  const debouncedUpdate = debounce$2((editor2) => {
    updateYdocDocxData(editor2);
  }, 1e3);
  ydoc.on("afterTransaction", (transaction) => {
    const { local } = transaction;
    const hasChangedDocx = checkDocxChanged(transaction);
    if (!hasChangedDocx && transaction.changed?.size && local) {
      debouncedUpdate(editor);
    }
  });
};
const debounce$2 = (fn2, wait) => {
  let timeout2 = null;
  return (...args) => {
    clearTimeout(timeout2);
    timeout2 = setTimeout(() => fn2.apply(void 0, args), wait);
  };
};
const initSyncListener = (ydoc, editor, extension) => {
  const provider = editor.options.collaborationProvider;
  if (!provider) return;
  const emit = () => {
    extension.options.isReady = true;
    provider.off("synced", emit);
    editor.emit("collaborationReady", { editor, ydoc });
  };
  if (provider.synced) {
    setTimeout(() => {
      emit();
    }, 250);
    return;
  }
  provider.on("synced", emit);
};
const generateCollaborationData = async (editor) => {
  const ydoc = prosemirrorToYDoc(editor.state.doc, "supereditor");
  initializeMetaMap(ydoc, editor);
  await updateYdocDocxData(editor, ydoc);
  return Y.encodeStateAsUpdate(ydoc);
};
const isHighContrastMode = vue.ref(false);
function useHighContrastMode() {
  const setHighContrastMode = (value) => {
    isHighContrastMode.value = value;
  };
  return {
    isHighContrastMode,
    setHighContrastMode
  };
}
const findWordBounds = (doc2, pos) => {
  const $pos = doc2.resolve(pos);
  const parent = $pos.parent;
  const offsetInParent = $pos.parentOffset;
  let offset2 = 0;
  let targetNode = null;
  let nodeStart = 0;
  parent.forEach((child, childOffset) => {
    if (child.isText) {
      const start2 = offset2;
      const end2 = offset2 + child.nodeSize;
      if (start2 <= offsetInParent && offsetInParent <= end2) {
        targetNode = child;
        nodeStart = childOffset;
      }
      offset2 = end2;
    } else {
      offset2 += child.nodeSize;
    }
  });
  if (!targetNode) return;
  const text = targetNode.text;
  const cursorOffset = offsetInParent - nodeStart;
  const isWordChar = (ch) => /\w/.test(ch);
  const isPunctOrSpace = (ch) => /[.,;:!-?=()[\]{}"'\s]/.test(ch);
  let from2, to;
  if (isPunctOrSpace(text[cursorOffset])) {
    from2 = $pos.start() + nodeStart + cursorOffset;
    to = from2 + 1;
  } else {
    let start2 = cursorOffset;
    while (start2 > 0 && isWordChar(text[start2 - 1])) start2--;
    let end2 = cursorOffset;
    while (end2 < text.length && isWordChar(text[end2])) end2++;
    if (start2 === end2) return;
    from2 = $pos.start() + nodeStart + start2;
    to = $pos.start() + nodeStart + end2;
  }
  return { from: from2, to };
};
const setWordSelection = (view, pos) => {
  const { state: state2, dispatch } = view;
  const word = findWordBounds(state2.doc, pos);
  if (!word) return;
  const tr = state2.tr.setSelection(TextSelection$1.create(state2.doc, word.from, word.to));
  dispatch(tr);
};
const setImageNodeSelection = (view, pos) => {
  const { doc: doc2 } = view.state;
  const node2 = doc2.nodeAt(pos);
  if (node2 && node2.type.name === "image") {
    const tr = view.state.tr.setSelection(NodeSelection.create(doc2, pos));
    view.dispatch(tr);
    return true;
  }
  return false;
};
const { findChildren: findChildren$3 } = helpers;
function getAllFieldAnnotations(state2) {
  let fieldAnnotations = findChildren$3(state2.doc, (node2) => node2.type.name === "fieldAnnotation");
  return fieldAnnotations;
}
function getAllFieldAnnotationsWithRect(view, state2) {
  let fieldAnnotations = getAllFieldAnnotations(state2).map(({ node: node2, pos }) => {
    let rect = posToDOMRect(view, pos, pos + node2.nodeSize);
    return {
      node: node2,
      pos,
      rect
    };
  });
  return fieldAnnotations;
}
function findFieldAnnotations(predicate, state2) {
  let allFieldAnnotations = getAllFieldAnnotations(state2);
  let fieldAnnotations = [];
  allFieldAnnotations.forEach((annotation) => {
    if (predicate(annotation.node)) {
      fieldAnnotations.push(annotation);
    }
  });
  return fieldAnnotations;
}
const { findChildren: findChildren$2 } = helpers;
function findFieldAnnotationsByFieldId(fieldIdOrArray, state2) {
  let fieldAnnotations = findChildren$2(state2.doc, (node2) => {
    let isFieldAnnotation = node2.type.name === "fieldAnnotation";
    if (Array.isArray(fieldIdOrArray)) {
      return isFieldAnnotation && fieldIdOrArray.includes(node2.attrs.fieldId);
    } else {
      return isFieldAnnotation && node2.attrs.fieldId === fieldIdOrArray;
    }
  });
  return fieldAnnotations;
}
function findFirstFieldAnnotationByFieldId(fieldId, state2) {
  let fieldAnnotation = findNode(state2.doc, (node2) => {
    return node2.type.name === "fieldAnnotation" && node2.attrs.fieldId === fieldId;
  });
  return fieldAnnotation;
}
function findNode(node2, predicate) {
  let found2 = null;
  node2.descendants((node22, pos) => {
    if (predicate(node22)) found2 = { node: node22, pos };
    if (found2) return false;
  });
  return found2;
}
function findFieldAnnotationsBetween(from2, to, doc2) {
  let fieldAnnotations = [];
  doc2.nodesBetween(from2, to, (node2, pos) => {
    if (!node2 || node2?.nodeSize === void 0) {
      return;
    }
    if (node2.type.name === "fieldAnnotation") {
      fieldAnnotations.push({
        node: node2,
        pos
      });
    }
  });
  return fieldAnnotations;
}
function findRemovedFieldAnnotations(tr) {
  let removedNodes = [];
  if (!tr.steps.length || tr.meta && !Object.keys(tr.meta).every((meta) => ["inputType", "uiEvent", "paste"].includes(meta)) || ["historyUndo", "historyRedo"].includes(tr.getMeta("inputType")) || ["drop"].includes(tr.getMeta("uiEvent")) || tr.getMeta("fieldAnnotationUpdate") === true) {
    return removedNodes;
  }
  const hasDeletion = transactionDeletedAnything(tr);
  if (!hasDeletion) return removedNodes;
  tr.steps.forEach((step, stepIndex) => {
    if (step instanceof ReplaceStep && step.from !== step.to) {
      let mapping = tr.mapping.maps[stepIndex];
      let originalDoc = tr.before;
      originalDoc.nodesBetween(step.from, step.to, (node2, pos) => {
        if (node2.type.name === "fieldAnnotation") {
          let mappedPos = mapping.mapResult(pos);
          if (mappedPos.deleted) {
            removedNodes.push({ node: node2, pos });
          }
        }
      });
    }
  });
  return removedNodes;
}
function transactionDeletedAnything(tr) {
  return tr.steps.some((step) => {
    if (step instanceof ReplaceStep || step instanceof ReplaceAroundStep) {
      return step.from !== step.to;
    }
    return false;
  });
}
function trackFieldAnnotationsDeletion(editor, tr) {
  let removedAnnotations = [];
  try {
    removedAnnotations = findRemovedFieldAnnotations(tr);
  } catch {
  }
  if (removedAnnotations.length > 0) {
    setTimeout(() => {
      editor.emit("fieldAnnotationDeleted", {
        editor,
        removedNodes: removedAnnotations
      });
    }, 0);
  }
}
const getHeaderFooterAnnotations = (editor) => {
  const editors = getAllHeaderFooterEditors(editor);
  const allAnnotations = [];
  editors.forEach(({ editor: editor2 }) => {
    const annotations = getAllFieldAnnotations(editor2.state);
    allAnnotations.push(...annotations);
  });
  return allAnnotations;
};
const { findChildren: findChildren$1 } = helpers;
function findHeaderFooterAnnotationsByFieldId(fieldIdOrArray, editor, activeSectionEditor) {
  const sectionEditors = getAllHeaderFooterEditors(editor);
  const annotations = [];
  sectionEditors.forEach(({ editor: sectionEditor }) => {
    const state2 = activeSectionEditor.options.documentId === sectionEditor.options.documentId ? activeSectionEditor.state : sectionEditor.state;
    const fieldAnnotations = findChildren$1(state2.doc, (node2) => {
      let isFieldAnnotation = node2.type.name === "fieldAnnotation";
      if (Array.isArray(fieldIdOrArray)) {
        return isFieldAnnotation && fieldIdOrArray.includes(node2.attrs.fieldId);
      } else {
        return isFieldAnnotation && node2.attrs.fieldId === fieldIdOrArray;
      }
    });
    annotations.push(...fieldAnnotations);
  });
  return annotations;
}
const index$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  findFieldAnnotations,
  findFieldAnnotationsBetween,
  findFieldAnnotationsByFieldId,
  findFirstFieldAnnotationByFieldId,
  findHeaderFooterAnnotationsByFieldId,
  findRemovedFieldAnnotations,
  getAllFieldAnnotations,
  getAllFieldAnnotationsWithRect,
  getHeaderFooterAnnotations,
  trackFieldAnnotationsDeletion
}, Symbol.toStringTag, { value: "Module" }));
const migrateListsToV2IfNecessary = (editor) => {
  const replacements = [];
  const numbering = editor.converter.numbering;
  if (!numbering) return replacements;
  const { state: state2 } = editor;
  const { doc: doc2 } = state2;
  const { dispatch } = editor.view;
  const LIST_TYPES = ["orderedList", "bulletList"];
  let lastListEndPos = 0;
  doc2.descendants((node2, pos) => {
    if (!LIST_TYPES.includes(node2.type.name)) return;
    if (pos < lastListEndPos) return;
    const extracted = flattenListCompletely(node2, editor, 0);
    if (extracted.length > 0) {
      replacements.push({
        from: pos,
        to: pos + node2.nodeSize,
        listNode: node2,
        replacement: extracted
      });
    }
    lastListEndPos = pos + node2.nodeSize;
  });
  let tr = state2.tr;
  if (replacements.length > 0) {
    for (let i = replacements.length - 1; i >= 0; i--) {
      const { from: from2, to, replacement, listNode } = replacements[i];
      const nodesToInsert = [];
      for (const item of replacement) {
        if (item.node.type.name === "listItem") {
          const singleItemList = listNode.type.create(listNode.attrs, [item.node]);
          nodesToInsert.push(singleItemList);
        } else {
          nodesToInsert.push(item.node);
        }
      }
      tr = tr.replaceWith(from2, to, nodesToInsert);
    }
  }
  tr.setMeta("listsv2migration", replacements);
  editor.options.migrated = true;
  dispatch(tr);
  return replacements;
};
function flattenListCompletely(listNode, editor, baseLevel = 0, sharedNumId = null) {
  const result = [];
  const listTypes = ["orderedList", "bulletList"];
  const currentListType = listNode.type.name;
  const needsMigration = shouldMigrateList(listNode);
  const hasValidDefinition = checkValidDefinition(listNode, editor);
  if (!needsMigration) {
    if (!hasValidDefinition) {
      return generateMissingListDefinition(listNode, editor);
    } else {
      return result;
    }
  }
  let numId = parseInt(listNode.attrs?.listId);
  if (!numId || Number.isNaN(numId)) numId = ListHelpers.getNewListId(editor);
  const listHasDef = ListHelpers.getListDefinitionDetails({ numId, level: baseLevel, editor });
  if (!listHasDef || !sharedNumId && !numId) {
    numId = ListHelpers.getNewListId(editor);
    ListHelpers.generateNewListDefinition({
      numId,
      listType: currentListType,
      editor
    });
  }
  if (!sharedNumId) sharedNumId = numId;
  for (const listItem of listNode.content.content) {
    if (!listItem.content.content?.length) {
      result.push({ node: listItem, baseLevel });
    } else if (listItem.content.content.length === 1) {
      const contentNode = listItem.content.content[0];
      if (listTypes.includes(contentNode.type.name)) {
        const flattened = flattenListCompletely(contentNode, editor, baseLevel + 1, sharedNumId);
        result.push(...flattened);
      } else {
        const newList = ListHelpers.createSchemaOrderedListNode({
          level: baseLevel,
          numId: sharedNumId,
          listType: listNode.type.name,
          editor,
          contentNode: contentNode.toJSON(),
          listLevel: listItem.attrs.listLevel || [1]
        });
        result.push({ node: newList, baseLevel });
      }
    } else {
      const firstItem = listItem.content.content[0];
      if (listTypes.includes(firstItem.type.name)) {
        const flattened = flattenListCompletely(firstItem, editor, baseLevel + 1, sharedNumId);
        result.push(...flattened);
      } else {
        if (firstItem.type.name === "paragraph" || firstItem.isTextblock) {
          const newList = ListHelpers.createSchemaOrderedListNode({
            level: baseLevel,
            numId: sharedNumId,
            listType: listNode.type.name,
            editor,
            contentNode: firstItem.toJSON(),
            listLevel: listItem.attrs.listLevel || [1]
          });
          result.push({ node: newList, baseLevel });
        } else {
          result.push({ node: firstItem });
        }
      }
      for (let contentItem of listItem.content.content.slice(1)) {
        if (listTypes.includes(contentItem.type.name)) {
          const flattened = flattenListCompletely(contentItem, editor, baseLevel + 1, sharedNumId);
          result.push(...flattened);
        } else {
          result.push({ node: contentItem });
        }
      }
    }
  }
  return result;
}
const shouldMigrateList = (listItem) => {
  const content = listItem.content;
  if (content?.content?.length > 1) {
    return true;
  }
  const firstChild = content.firstChild;
  if (firstChild && firstChild.type.name === "listItem") {
    const { attrs } = firstChild;
    const { level, listNumberingType } = attrs || {};
    if (typeof level === "undefined" || !listNumberingType) {
      return true;
    }
    const childContent = firstChild?.content?.content;
    const nestedLists = childContent.filter((child) => ["bulletList", "orderedList"].includes(child.type.name));
    return nestedLists.length > 0;
  }
  return false;
};
const checkValidDefinition = (listNode, editor) => {
  const listType = listNode.type.name;
  const listItem = listNode.content.firstChild;
  const { attrs } = listItem;
  const { numId, level } = attrs || {};
  const listDef = ListHelpers.getListDefinitionDetails({ numId, level, listType, editor });
  const { abstract } = listDef || {};
  if (abstract) return true;
  return false;
};
const generateMissingListDefinition = (listNode, editor) => {
  const listType = listNode.type.name;
  const listItem = listNode.content.firstChild;
  const { attrs } = listItem;
  const { numId } = attrs || {};
  return ListHelpers.generateNewListDefinition({
    numId,
    listType,
    editor
  });
};
const migrateParagraphFieldsListsV2 = async (annotationValues = [], editor) => {
  const annotations = getAllFieldAnnotations(editor.state);
  const newValues = [];
  if (!annotations.length) {
    return annotationValues;
  }
  for (const annotation of annotations) {
    const type2 = annotation.node?.attrs?.type;
    const matchedAnnotation = annotationValues.find((v2) => v2.input_id === annotation.node.attrs.fieldId);
    if (!!matchedAnnotation && (!type2 || type2 !== "html")) {
      newValues.push(matchedAnnotation);
      continue;
    }
    const value = matchedAnnotation?.input_value;
    if (!value) continue;
    await new Promise((resolve, reject) => {
      const element = document.createElement("div");
      editor.createChildEditor({
        element,
        html: value,
        onCreate: ({ editor: localEditor }) => {
          const { migrated } = localEditor.options;
          if (migrated) {
            const newHTML = localEditor.getHTML();
            matchedAnnotation.input_value = newHTML;
            newValues.push(matchedAnnotation);
          }
          resolve();
        },
        onError: (error) => {
          reject(error);
        }
      });
    });
  }
  return newValues;
};
const createLinkedChildEditor = (currentEditor, options = {}) => {
  if (currentEditor.options.isChildEditor) {
    return null;
  }
  const editor = new Editor({
    ...currentEditor.options,
    pagination: false,
    suppressDefaultDocxStyles: true,
    ydoc: null,
    collaborationProvider: null,
    fileSource: null,
    initialState: null,
    documentId: null,
    isCommentsEnabled: false,
    isNewFile: false,
    fragment: false,
    onCreate: () => null,
    onListDefinitionsChange: linkListDefinitionsChange,
    // Options overrides
    ...options,
    isChildEditor: true,
    parentEditor: currentEditor
  });
  return editor;
};
const linkListDefinitionsChange = (options) => {
  const { editor, numbering } = options;
  const { parentEditor = {} } = editor.options;
  const { converter: parentConverter } = parentEditor;
  if (!parentConverter) return;
  parentConverter.numbering = numbering;
  const { tr } = parentEditor.state;
  const { dispatch } = parentEditor.view;
  tr.setMeta("updatedListItemNodeViews", true);
  dispatch(tr);
};
function createLogger(debug, additionalPrefixes = []) {
  const basePrefix = "[SuperValidator]";
  const style2 = "color: teal; font-weight: bold;";
  const allPrefixes = [basePrefix, ...additionalPrefixes.map((p) => `[${p}]`)];
  const format = allPrefixes.map(() => "%c%s").join(" ");
  const styledPrefixes = allPrefixes.map((p) => [style2, p]).flat();
  return {
    debug: (...args) => {
      if (!debug) return;
      console.debug(format, ...styledPrefixes, ...args);
    },
    withPrefix: (prefix2) => createLogger(debug, [...additionalPrefixes, prefix2])
  };
}
function ensureValidImageRID(images, editor, tr, logger) {
  let modified = false;
  const results = [];
  images.forEach(({ node: node2, pos }) => {
    const { rId, src } = node2.attrs;
    if (!rId && src) {
      let newId = editor.converter.docxHelpers.findRelationshipIdFromTarget(src, editor);
      if (newId) logger.debug("Reusing existing rId for image:", newId, "at pos:", pos);
      if (!newId) {
        newId = editor.converter.docxHelpers.insertNewRelationship(src, "image", editor);
        logger.debug("Creating new rId for image at pos:", pos, "with src:", src);
      }
      tr.setNodeMarkup(pos, void 0, {
        ...node2.attrs,
        rId: newId
      });
      results.push(`Added missing rId to image at pos ${pos}`);
      modified = true;
    }
  });
  return { modified, results };
}
function createImageNodeValidator({ editor, logger }) {
  const validator = (tr, analysis) => {
    const images = analysis.image || [];
    const ruleResults = [ensureValidImageRID(images, editor, tr, logger)];
    const modified = ruleResults.some((r2) => r2.modified);
    const results = ruleResults.flatMap((r2) => r2.results);
    return { modified, results };
  };
  validator.requiredElements = {
    nodes: ["image"]
  };
  return validator;
}
function ensureValidLinkRID(links, editor, tr, logger) {
  let modified = false;
  const results = [];
  links.forEach(({ mark, from: from2, to }) => {
    const { rId, href } = mark.attrs;
    if (!rId && href) {
      let newId = editor.converter.docxHelpers.findRelationshipIdFromTarget(href, editor);
      if (newId) logger.debug("Reusing existing rId for link:", newId, "from pos:", from2, "to pos:", to);
      if (!newId) {
        newId = editor.converter.docxHelpers.insertNewRelationship(href, "hyperlink", editor);
        logger.debug("Creating new rId for link from pos:", from2, "to pos:", to, "with href:", href);
      }
      if (newId) {
        const linkMarkType = editor.schema.marks.link;
        const newMark = linkMarkType.create({
          ...mark.attrs,
          rId: newId
        });
        tr.removeMark(from2, to, linkMarkType);
        tr.addMark(from2, to, newMark);
        results.push(`Added missing rId to link from pos ${from2} to ${to}`);
        modified = true;
      }
    }
  });
  return { modified, results };
}
function createLinkMarkValidator({ editor, logger }) {
  const validator = (tr, analysis) => {
    const links = analysis.link || [];
    const ruleResults = [ensureValidLinkRID(links, editor, tr, logger)];
    const modified = ruleResults.some((r2) => r2.modified);
    const results = ruleResults.flatMap((r2) => r2.results);
    return { modified, results };
  };
  validator.requiredElements = {
    marks: ["link"]
  };
  return validator;
}
const StateValidators = {
  imageNodeValidator: createImageNodeValidator,
  linkMarkValidator: createLinkMarkValidator
};
class SuperValidator {
  /**
   * Create a SuperValidator instance.
   * @param {SuperValidatorOptions} options - Options for the validator.
   */
  constructor(options) {
    __privateAdd$1(this, _SuperValidator_instances);
    __privateAdd$1(this, _editor);
    __privateAdd$1(this, _stateValidators);
    __privateAdd$1(this, _requiredNodeTypes);
    __privateAdd$1(this, _requiredMarkTypes);
    __privateSet(this, _editor, options.editor);
    this.dryRun = options.dryRun || false;
    this.debug = options.debug || false;
    this.logger = createLogger(this.debug);
    const { validators, nodeTypes, markTypes } = __privateMethod$1(this, _SuperValidator_instances, initializeValidators_fn).call(this);
    __privateSet(this, _stateValidators, validators);
    __privateSet(this, _requiredNodeTypes, nodeTypes);
    __privateSet(this, _requiredMarkTypes, markTypes);
  }
  /**
   * Validate the active document in the editor. Triggered automatically on editor initialization.
   * @returns {{ modified: boolean, results: Array<{ key: string, results: string[] }> }}
   */
  validateActiveDocument() {
    const { tr } = __privateGet$1(this, _editor).state;
    const { dispatch } = __privateGet$1(this, _editor).view;
    const documentAnalysis = __privateMethod$1(this, _SuperValidator_instances, analyzeDocument_fn).call(this);
    this.logger.debug("Document analysis:", documentAnalysis);
    let hasModifiedDocument = false;
    const validationResults = [];
    Object.entries(__privateGet$1(this, _stateValidators)).forEach(([key, validator]) => {
      this.logger.debug(`🕵 Validating with ${key}...`);
      const { results, modified } = validator(tr, documentAnalysis);
      validationResults.push({ key, results });
      hasModifiedDocument = hasModifiedDocument || modified;
    });
    if (!this.dryRun) dispatch(tr);
    else this.logger.debug("DRY RUN: No changes applied to the document.");
    this.logger.debug("Results:", validationResults);
    return { modified: hasModifiedDocument, results: validationResults };
  }
}
_editor = /* @__PURE__ */ new WeakMap();
_stateValidators = /* @__PURE__ */ new WeakMap();
_requiredNodeTypes = /* @__PURE__ */ new WeakMap();
_requiredMarkTypes = /* @__PURE__ */ new WeakMap();
_SuperValidator_instances = /* @__PURE__ */ new WeakSet();
initializeValidators_fn = function() {
  const requiredNodes = /* @__PURE__ */ new Set();
  const requiredMarks = /* @__PURE__ */ new Set();
  const validators = Object.fromEntries(
    Object.entries(StateValidators).map(([key, factory]) => {
      const validatorLogger = this.logger.withPrefix(key);
      const validator = factory({ editor: __privateGet$1(this, _editor), logger: validatorLogger });
      __privateMethod$1(this, _SuperValidator_instances, collectValidatorRequirements_fn).call(this, validator, requiredNodes, requiredMarks);
      return [key, validator];
    })
  );
  return {
    validators,
    nodeTypes: requiredNodes,
    markTypes: requiredMarks
  };
};
collectValidatorRequirements_fn = function(validator, requiredNodes, requiredMarks) {
  if (!validator.requiredElements) return;
  if (typeof validator.requiredElements === "object") {
    if (validator.requiredElements.nodes) {
      validator.requiredElements.nodes.forEach((nodeType) => {
        requiredNodes.add(nodeType);
      });
    }
    if (validator.requiredElements.marks) {
      validator.requiredElements.marks.forEach((markType) => {
        requiredMarks.add(markType);
      });
    }
  }
};
analyzeDocument_fn = function() {
  const { doc: doc2 } = __privateGet$1(this, _editor).state;
  const analysis = {};
  __privateGet$1(this, _requiredNodeTypes).forEach((type2) => analysis[type2] = []);
  __privateGet$1(this, _requiredMarkTypes).forEach((type2) => analysis[type2] = []);
  const collectElements = (node2, pos) => {
    if (__privateGet$1(this, _requiredNodeTypes).has(node2.type.name)) {
      analysis[node2.type.name].push({ node: node2, pos });
    }
    if (node2.isText && node2.marks) {
      node2.marks.forEach(
        /** @param {Mark} mark */
        (mark) => {
          if (__privateGet$1(this, _requiredMarkTypes).has(mark.type.name)) {
            analysis[mark.type.name].push({
              mark,
              node: node2,
              pos,
              from: pos,
              to: pos + node2.nodeSize
            });
          }
        }
      );
    }
  };
  doc2.descendants(collectElements);
  return analysis;
};
const _Editor = class _Editor2 extends EventEmitter$1 {
  /**
   * Create a new Editor instance
   * @param {EditorOptions} options - Editor configuration options
   * @returns {void}
   */
  constructor(options) {
    super();
    __privateAdd$1(this, _Editor_instances);
    __privateAdd$1(this, _commandService);
    __publicField$1(this, "extensionService");
    __publicField$1(this, "extensionStorage", {});
    __publicField$1(this, "schema");
    __publicField$1(this, "view");
    __publicField$1(this, "isFocused", false);
    __publicField$1(this, "options", {
      element: null,
      selector: null,
      isHeadless: false,
      mockDocument: null,
      mockWindow: null,
      content: "",
      // XML content
      user: null,
      users: [],
      media: {},
      mediaFiles: {},
      fonts: {},
      documentMode: "editing",
      mode: "docx",
      role: "editor",
      colors: [],
      converter: null,
      fileSource: null,
      initialState: null,
      documentId: null,
      extensions: [],
      editable: true,
      editorProps: {},
      parseOptions: {},
      coreExtensionOptions: {},
      enableInputRules: true,
      isCommentsEnabled: false,
      isNewFile: false,
      scale: 1,
      annotations: false,
      isInternal: false,
      externalExtensions: [],
      numbering: {},
      isHeaderOrFooter: false,
      lastSelection: null,
      suppressDefaultDocxStyles: false,
      jsonOverride: false,
      onBeforeCreate: () => null,
      onCreate: () => null,
      onUpdate: () => null,
      onSelectionUpdate: () => null,
      onTransaction: () => null,
      onFocus: () => null,
      onBlur: () => null,
      onDestroy: () => null,
      onContentError: ({ error }) => {
        throw error;
      },
      onTrackedChangesUpdate: () => null,
      onCommentsUpdate: () => null,
      onCommentsLoaded: () => null,
      onCommentClicked: () => null,
      onCommentLocationsUpdate: () => null,
      onDocumentLocked: () => null,
      onFirstRender: () => null,
      onCollaborationReady: () => null,
      onPaginationUpdate: () => null,
      onException: () => null,
      onListDefinitionsChange: () => null,
      // async (file) => url;
      handleImageUpload: null,
      // telemetry
      telemetry: null,
      // Docx xml updated by User
      customUpdatedFiles: {},
      isHeaderFooterChanged: false,
      isCustomXmlChanged: false,
      focusTarget: null
    });
    __privateMethod$1(this, _Editor_instances, initContainerElement_fn).call(this, options);
    __privateMethod$1(this, _Editor_instances, checkHeadless_fn).call(this, options);
    this.setOptions(options);
    let modes = {
      docx: () => __privateMethod$1(this, _Editor_instances, init_fn).call(this),
      text: () => __privateMethod$1(this, _Editor_instances, initRichText_fn).call(this),
      html: () => __privateMethod$1(this, _Editor_instances, initRichText_fn).call(this),
      default: () => {
        console.log("Not implemented.");
      }
    };
    let initMode = modes[this.options.mode] ?? modes.default;
    const { setHighContrastMode } = useHighContrastMode();
    this.setHighContrastMode = setHighContrastMode;
    initMode();
  }
  /**
   * Getter which indicates if any changes happen in Editor
   * @returns {boolean}
   */
  get docChanged() {
    return this.options.isHeaderFooterChanged || this.options.isCustomXmlChanged || !this.options.initialState.doc.eq(this.state.doc);
  }
  mount(el) {
    __privateMethod$1(this, _Editor_instances, createView_fn).call(this, el);
    window.setTimeout(() => {
      if (this.isDestroyed) return;
      this.emit("create", { editor: this });
    }, 0);
  }
  unmount() {
    if (this.view) {
      this.view.destroy();
    }
    this.view = null;
  }
  /**
   * Set the toolbar for this editor
   * @param {Object} toolbar - The toolbar instance
   * @returns {void}
   */
  setToolbar(toolbar) {
    this.toolbar = toolbar;
  }
  /**
   * Focus the editor.
   * @returns {void}
   */
  focus() {
    this.view?.focus();
  }
  /**
   * Get the editor state
   * @returns {Object} ProseMirror state
   */
  get state() {
    return this.view?.state;
  }
  /**
   * Get the editor storage.
   * @returns {Object} Editor storage object
   */
  get storage() {
    return this.extensionStorage;
  }
  /**
   * Get object of registered commands.
   * @returns {import('./commands/types/index.js').EditorCommands} Commands object
   */
  get commands() {
    return __privateGet$1(this, _commandService)?.commands;
  }
  /**
   * Get extension helpers.
   * @returns {EditorHelpers} Object with helper methods for extensions
   */
  get helpers() {
    return this.extensionService.helpers;
  }
  /**
   * Check if the editor is editable.
   * @returns {boolean}
   */
  get isEditable() {
    return this.options.editable && this.view && this.view.editable;
  }
  /**
   * Check if editor is destroyed.
   * @returns {boolean}
   */
  get isDestroyed() {
    return this.view?.isDestroyed ?? true;
  }
  /**
   * Get the editor element
   * @returns {HTMLElement} The editor element
   */
  get element() {
    return this.options.element;
  }
  /**
   * Get possible users of the editor.
   * @returns {Array.<User>} List of users
   */
  get users() {
    return this.options.users;
  }
  /**
   * Create a chain of commands to call multiple commands at once.
   * @returns {Object} Command chain
   */
  chain() {
    return __privateGet$1(this, _commandService).chain();
  }
  /**
   * Check if a command or a chain of commands can be executed. Without executing it.
   * @returns {Object} Object with methods to check command availability
   */
  can() {
    return __privateGet$1(this, _commandService).can();
  }
  /**
   * Set the document mode
   * @param {string} documentMode - The document mode ('editing', 'viewing', 'suggesting')
   */
  setDocumentMode(documentMode) {
    let cleanedMode = documentMode?.toLowerCase() || "editing";
    if (!this.extensionService || !this.state) return;
    const pm = document.querySelector(".ProseMirror");
    if (this.options.role === "viewer") cleanedMode = "viewing";
    if (this.options.role === "suggester" && cleanedMode === "editing") cleanedMode = "suggesting";
    if (cleanedMode === "viewing") {
      this.commands.toggleTrackChangesShowOriginal();
      this.setEditable(false, false);
      this.setOptions({ documentMode: "viewing" });
      toggleHeaderFooterEditMode({
        editor: this,
        focusedSectionEditor: null,
        isEditMode: false,
        documentMode: cleanedMode
      });
      if (!this.options.isHeaderOrFooter && pm) pm.classList.add("view-mode");
    } else if (cleanedMode === "suggesting") {
      __privateMethod$1(this, _Editor_instances, registerPluginByNameIfNotExists_fn).call(this, "TrackChangesBase");
      this.commands.disableTrackChangesShowOriginal();
      this.commands.enableTrackChanges();
      this.setOptions({ documentMode: "suggesting" });
      this.setEditable(true, false);
      if (pm) pm.classList.remove("view-mode");
    } else if (cleanedMode === "editing") {
      __privateMethod$1(this, _Editor_instances, registerPluginByNameIfNotExists_fn).call(this, "TrackChangesBase");
      this.commands.disableTrackChangesShowOriginal();
      this.commands.disableTrackChanges();
      this.setEditable(true, false);
      this.setOptions({ documentMode: "editing" });
      toggleHeaderFooterEditMode({
        editor: this,
        focusedSectionEditor: null,
        isEditMode: false,
        documentMode: cleanedMode
      });
      if (pm) pm.classList.remove("view-mode");
    }
  }
  /**
   * Export the yjs binary from the current state.
   * @returns {Promise<Uint8Array>} The exported yjs binary
   */
  async generateCollaborationUpdate() {
    return await generateCollaborationData(this);
  }
  /**
   * Initialize data for collaborative editing
   * If we are replacing data and have a valid provider, listen for synced event
   * so that we can initialize the data
   * @returns {void}
   */
  initializeCollaborationData() {
    if (!this.options.isNewFile || !this.options.collaborationProvider) return;
    const { collaborationProvider: provider } = this.options;
    const postSyncInit = () => {
      provider.off("synced", postSyncInit);
      __privateMethod$1(this, _Editor_instances, insertNewFileData_fn).call(this);
    };
    if (provider.synced) __privateMethod$1(this, _Editor_instances, insertNewFileData_fn).call(this);
    else provider.on("synced", postSyncInit);
  }
  /**
   * Replace content of editor that was created with loadFromSchema option
   * Used to replace content of other header/footer when one of it was edited
   *
   * @param {object} content - new editor content json (retrieved from editor.getUpdatedJson)
   * @returns {void}
   */
  replaceContent(content) {
    this.setOptions({
      content
    });
    __privateMethod$1(this, _Editor_instances, createConverter_fn).call(this);
    this.initDefaultStyles();
    __privateMethod$1(this, _Editor_instances, createConverter_fn).call(this);
    __privateMethod$1(this, _Editor_instances, initMedia_fn).call(this);
    const doc2 = __privateMethod$1(this, _Editor_instances, generatePmData_fn).call(this);
    const tr = this.state.tr.replaceWith(0, this.state.doc.content.size, doc2);
    tr.setMeta("replaceContent", true);
    this.view.dispatch(tr);
  }
  /**
   * Set editor options and update state.
   * @param {EditorOptions} options - Editor options
   * @returns {void}
   */
  setOptions(options = {}) {
    this.options = {
      ...this.options,
      ...options
    };
    if (this.options.collaborationProvider && this.options.ydoc) {
      const nonCollabHistoryIndex = this.options.extensions.findIndex((e) => e.name === "history");
      if (nonCollabHistoryIndex !== -1) {
        this.options.extensions.splice(nonCollabHistoryIndex, 1);
      }
    }
    if ((this.options.isNewFile || !this.options.ydoc) && this.options.isCommentsEnabled) {
      this.options.shouldLoadComments = true;
    }
    if (!this.view || !this.state || this.ifsDestroyed) {
      return;
    }
    if (this.options.editorProps) {
      this.view.setProps(this.options.editorProps);
    }
    this.view.updateState(this.state);
  }
  /**
   * Set whether the editor is editable
   * @param {boolean} [editable=true] - Whether the editor is editable
   * @param {boolean} [emitUpdate=true] - Whether to emit an update event
   * @returns {void}
   */
  setEditable(editable = true, emitUpdate = true) {
    this.setOptions({ editable });
    if (emitUpdate) {
      this.emit("update", { editor: this, transaction: this.state.tr });
    }
  }
  /**
   * Register PM plugin.
   * @param plugin PM plugin.
   * @param handlePlugins Optional function for handling plugin merge.
   * @returns {void}
   */
  registerPlugin(plugin2, handlePlugins) {
    if (!this.state?.plugins) return;
    const plugins = typeof handlePlugins === "function" ? handlePlugins(plugin2, [...this.state.plugins]) : [...this.state.plugins, plugin2];
    const state2 = this.state.reconfigure({ plugins });
    this.view.updateState(state2);
  }
  /**
   * Unregister a PM plugin
   * @param {string|Object} nameOrPluginKey - Plugin name or plugin instance
   * @returns {void}
   */
  unregisterPlugin(nameOrPluginKey) {
    if (this.isDestroyed) return;
    const name = typeof nameOrPluginKey === "string" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;
    const state2 = this.state.reconfigure({
      plugins: this.state.plugins.filter((plugin2) => !plugin2.key.startsWith(name))
    });
    this.view.updateState(state2);
  }
  /**
   * Load the data from DOCX to be used in the schema.
   * Expects a DOCX file.
   * @static
   * @async
   * @param {File|Blob|Buffer} fileSource - The DOCX file to load (File/Blob in browser, Buffer in Node.js)
   * @param {boolean} [isNode=false] - Whether the method is being called in a Node.js environment
   * @returns {Promise<Array>} - A promise that resolves to an array containing:
   *   - [0] xmlFiles - Array of XML files extracted from the DOCX
   *   - [1] mediaFiles - Object containing media files with URLs (browser only)
   *   - [2] mediaFiles - Object containing media files with base64 data
   *   - [3] fonts - Object containing font files from the DOCX
   */
  static async loadXmlData(fileSource, isNode2 = false) {
    if (!fileSource) return;
    const zipper = new DocxZipper();
    const xmlFiles = await zipper.getDocxData(fileSource, isNode2);
    const mediaFiles = zipper.media;
    return [xmlFiles, mediaFiles, zipper.mediaFiles, zipper.fonts];
  }
  /**
   * Get the document version
   * @static
   * @param {Object} doc - Document object
   * @returns {string} Document version
   */
  static getDocumentVersion(doc2) {
    const version2 = SuperConverter.getStoredSuperdocVersion(doc2);
    return version2;
  }
  /**
   * Update the document version
   * @static
   * @param {Object} doc - Document object
   * @param {string} version - New version
   * @returns {Object}
   */
  static updateDocumentVersion(doc2, version2) {
    const updatedContent = SuperConverter.updateDocumentVersion(doc2, version2);
    return updatedContent;
  }
  /**
   * Creates all node views.
   * @returns {void}
   */
  createNodeViews() {
    this.view.setProps({
      nodeViews: this.extensionService.nodeViews
    });
  }
  /**
   * Get the maximum content size
   * @returns {Object} Size object with width and height
   */
  getMaxContentSize() {
    if (!this.converter) return {};
    const { pageSize = {}, pageMargins = {} } = this.converter.pageStyles ?? {};
    const { width, height } = pageSize;
    const { top: top2 = 0, bottom: bottom2 = 0, left: left2 = 0, right: right2 = 0 } = pageMargins;
    if (!width || !height) return {};
    const maxHeight = height * 96 - top2 * 96 - bottom2 * 96 - 50;
    const maxWidth = width * 96 - left2 * 96 - right2 * 96 - 20;
    return {
      width: maxWidth,
      height: maxHeight
    };
  }
  /**
   * Attach styles and attributes to the editor element
   */
  updateEditorStyles(element, proseMirror, hasPaginationEnabled = true) {
    const { pageSize, pageMargins } = this.converter.pageStyles ?? {};
    if (!proseMirror || !element) {
      return;
    }
    proseMirror.setAttribute("role", "document");
    proseMirror.setAttribute("aria-multiline", true);
    proseMirror.setAttribute("aria-label", "Main content area, start typing to enter text.");
    proseMirror.setAttribute("aria-description", "");
    proseMirror.classList.remove("view-mode");
    if (pageSize) {
      element.style.width = pageSize.width + "in";
      element.style.minWidth = pageSize.width + "in";
      element.style.minHeight = pageSize.height + "in";
    }
    if (pageMargins) {
      element.style.paddingLeft = pageMargins.left + "in";
      element.style.paddingRight = pageMargins.right + "in";
    }
    element.style.boxSizing = "border-box";
    element.style.isolation = "isolate";
    proseMirror.style.outline = "none";
    proseMirror.style.border = "none";
    const { typeface, fontSizePt } = this.converter.getDocumentDefaultStyles() ?? {};
    if (typeface) {
      element.style.fontFamily = typeface;
    }
    if (fontSizePt) {
      element.style.fontSize = `${fontSizePt}pt`;
    }
    element.style.transformOrigin = "top left";
    element.style.touchAction = "auto";
    element.style.webkitOverflowScrolling = "touch";
    const defaultLineHeight = 1.2;
    proseMirror.style.lineHeight = defaultLineHeight;
    if (!hasPaginationEnabled) {
      proseMirror.style.paddingTop = "1in";
      proseMirror.style.paddingBottom = "1in";
    } else {
      proseMirror.style.paddingTop = "0";
      proseMirror.style.paddingBottom = "0";
    }
  }
  /**
   * Initialize default styles for the editor container and ProseMirror.
   * Get page size and margins from the converter.
   * Set document default font and font size.
   *
   * @param {HTMLElement} [element=this.element] - The DOM element to apply styles to
   * @returns {void}
   */
  initDefaultStyles(element = this.element, isPaginationEnabled = true) {
    if (this.options.isHeadless || this.options.suppressDefaultDocxStyles) return;
    const proseMirror = element?.querySelector(".ProseMirror");
    this.updateEditorStyles(element, proseMirror, isPaginationEnabled);
    this.initMobileStyles(element);
  }
  /**
   * Initializes responsive styles for mobile devices.
   * Sets up scaling based on viewport width and handles orientation changes.
   *
   * @param {HTMLElement|void} element - The DOM element to apply mobile styles to
   * @returns {void}
   */
  initMobileStyles(element) {
    if (!element) {
      return;
    }
    const initialWidth = element.offsetWidth;
    const updateScale = () => {
      const minPageSideMargin = 10;
      const elementWidth = initialWidth;
      const availableWidth = document.documentElement.clientWidth - minPageSideMargin;
      this.options.scale = Math.min(1, availableWidth / elementWidth);
      const superEditorElement = element.closest(".super-editor");
      const superEditorContainer = element.closest(".super-editor-container");
      if (!superEditorElement || !superEditorContainer) {
        return;
      }
      if (this.options.scale < 1) {
        superEditorElement.style.maxWidth = `${elementWidth * this.options.scale}px`;
        superEditorContainer.style.minWidth = "0px";
        element.style.transform = `scale(${this.options.scale})`;
      } else {
        superEditorElement.style.maxWidth = "";
        superEditorContainer.style.minWidth = "";
        element.style.transform = "none";
      }
    };
    updateScale();
    const handleResize = () => {
      setTimeout(() => {
        updateScale();
      }, 150);
    };
    if ("orientation" in screen && "addEventListener" in screen.orientation) {
      screen.orientation.addEventListener("change", handleResize);
    } else {
      window.matchMedia("(orientation: portrait)").addEventListener("change", handleResize);
    }
    window.addEventListener("resize", () => handleResize);
  }
  /**
   * Get attrs of the currently selected node or mark.
   * @param {String} nameOrType
   * @example
   * editor.getAttributes('textStyle').color
   */
  getAttributes(nameOrType) {
    return Attribute2.getAttributes(this.state, nameOrType);
  }
  /**
   * Returns if the currently selected node or mark is active.
   * @param {String|Object} nameOrAttributes - The name of the node/mark or an attributes object
   * @param {Object} [attributesOrUndefined] - Optional attributes to check when first parameter is a name
   * @returns {Boolean} Whether the node or mark is active with the specified attributes
   * @example
   * editor.isActive('bold')
   * editor.isActive('textStyle', { color: 'purple' })
   * editor.isActive({ textAlign: 'center' })
   */
  isActive(nameOrAttributes, attributesOrUndefined) {
    const name = typeof nameOrAttributes === "string" ? nameOrAttributes : null;
    const attributes = typeof nameOrAttributes === "string" ? attributesOrUndefined : nameOrAttributes;
    return isActive(this.state, name, attributes);
  }
  /**
   * Get the editor content as JSON
   * @returns {Object} Editor content as JSON
   */
  getJSON() {
    return this.state.doc.toJSON();
  }
  /**
   * Get the editor content as HTML
   * @returns {string} Editor content as HTML
   */
  getHTML({ unflattenLists = false } = {}) {
    const tempDocument = document.implementation.createHTMLDocument();
    const container = tempDocument.createElement("div");
    const fragment = DOMSerializer.fromSchema(this.schema).serializeFragment(this.state.doc.content);
    container.appendChild(fragment);
    let html = container.innerHTML;
    if (unflattenLists) {
      html = unflattenListsInHtml(html);
    }
    return html;
  }
  /**
   * Create a child editor linked to this editor.
   * This is useful for creating header/footer editors that are linked to the main editor.
   * Or paragraph fields that rely on the same underlying document and list defintions
   * @param {EditorOptions} options - Options for the child editor
   * @returns {Editor} A new child editor instance linked to this editor
   */
  createChildEditor(options) {
    return createLinkedChildEditor(this, options);
  }
  /**
   * Get page styles
   * @returns {Object} Page styles
   */
  getPageStyles() {
    return this.converter?.pageStyles || {};
  }
  /**
   * Update page styles
   *
   * @param {Object} param0
   * @param {Object} param0.pageMargins The new page margins
   * @returns {void}
   */
  updatePageStyle({ pageMargins }) {
    if (!this.converter) return;
    let hasMadeUpdate = false;
    if (pageMargins) {
      this.converter.pageStyles.pageMargins = pageMargins;
      this.initDefaultStyles();
      hasMadeUpdate = true;
    }
    if (hasMadeUpdate) {
      const newTr = this.view.state.tr;
      newTr.setMeta("forceUpdatePagination", true);
      this.view.dispatch(newTr);
    }
  }
  migrateListsToV2() {
    if (this.options.isHeaderOrFooter) return [];
    const replacements = migrateListsToV2IfNecessary(this);
    return replacements;
  }
  getUpdatedJson() {
    return __privateMethod$1(this, _Editor_instances, prepareDocumentForExport_fn).call(this);
  }
  /**
   * Export the editor document to DOCX.
   * @async
   * @param {Object} options - The export options
   * @param {boolean} [options.isFinalDoc=false] - Whether this is the final document version
   * @param {string} [options.commentsType] - The type of comments to include
   * @param {Array} [options.comments=[]] - Array of comments to include in the document
   * @param {boolean} [options.getUpdatedDocs=false] - When set to true return only updated docx files
   * @returns {Promise<Blob|ArrayBuffer|Object>} The exported DOCX file or updated docx files
   */
  async exportDocx({
    isFinalDoc = false,
    commentsType = "external",
    exportJsonOnly = false,
    exportXmlOnly = false,
    comments = [],
    getUpdatedDocs = false,
    fieldsHighlightColor = null
  } = {}) {
    const json = __privateMethod$1(this, _Editor_instances, prepareDocumentForExport_fn).call(this, comments);
    const documentXml = await this.converter.exportToDocx(
      json,
      this.schema,
      this.storage.image.media,
      isFinalDoc,
      commentsType,
      comments,
      this,
      exportJsonOnly,
      fieldsHighlightColor
    );
    if (exportXmlOnly || exportJsonOnly) return documentXml;
    const customXml = this.converter.schemaToXml(this.converter.convertedXml["docProps/custom.xml"].elements[0]);
    const styles = this.converter.schemaToXml(this.converter.convertedXml["word/styles.xml"].elements[0]);
    const customSettings = this.converter.schemaToXml(this.converter.convertedXml["word/settings.xml"].elements[0]);
    const rels = this.converter.schemaToXml(this.converter.convertedXml["word/_rels/document.xml.rels"].elements[0]);
    const media = this.converter.addedMedia;
    const updatedHeadersFooters = {};
    Object.entries(this.converter.convertedXml).forEach(([name, json2]) => {
      if (name.includes("header") || name.includes("footer")) {
        const resultXml = this.converter.schemaToXml(json2.elements[0]);
        updatedHeadersFooters[name] = String(resultXml);
      }
    });
    const numberingData = this.converter.convertedXml["word/numbering.xml"];
    const numbering = this.converter.schemaToXml(numberingData.elements[0]);
    const updatedDocs = {
      ...this.options.customUpdatedFiles,
      "word/document.xml": String(documentXml),
      "docProps/custom.xml": String(customXml),
      "word/settings.xml": String(customSettings),
      "word/_rels/document.xml.rels": String(rels),
      "word/numbering.xml": String(numbering),
      // Replace & with &amp; in styles.xml as DOCX viewers can't handle it
      "word/styles.xml": String(styles).replace(/&/gi, "&amp;"),
      ...updatedHeadersFooters
    };
    if (comments.length) {
      const commentsXml = this.converter.schemaToXml(this.converter.convertedXml["word/comments.xml"].elements[0]);
      const commentsExtendedXml = this.converter.schemaToXml(
        this.converter.convertedXml["word/commentsExtended.xml"].elements[0]
      );
      const commentsExtensibleXml = this.converter.schemaToXml(
        this.converter.convertedXml["word/commentsExtensible.xml"].elements[0]
      );
      const commentsIdsXml = this.converter.schemaToXml(
        this.converter.convertedXml["word/commentsIds.xml"].elements[0]
      );
      updatedDocs["word/comments.xml"] = String(commentsXml);
      updatedDocs["word/commentsExtended.xml"] = String(commentsExtendedXml);
      updatedDocs["word/commentsExtensible.xml"] = String(commentsExtensibleXml);
      updatedDocs["word/commentsIds.xml"] = String(commentsIdsXml);
    }
    const zipper = new DocxZipper();
    if (getUpdatedDocs) {
      updatedDocs["[Content_Types].xml"] = await zipper.updateContentTypes(
        {
          files: this.options.content
        },
        media,
        true
      );
      return updatedDocs;
    }
    const result = await zipper.updateZip({
      docx: this.options.content,
      updatedDocs,
      originalDocxFile: this.options.fileSource,
      media,
      fonts: this.options.fonts,
      isHeadless: this.options.isHeadless
    });
    this.options.telemetry?.trackUsage("document_export", {
      documentType: "docx",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
    return result;
  }
  /**
   * Destroy the editor and clean up resources
   * @returns {void}
   */
  destroy() {
    this.emit("destroy");
    this.unmount();
    this.destroyHeaderFooterEditors();
    __privateMethod$1(this, _Editor_instances, endCollaboration_fn).call(this);
    this.removeAllListeners();
  }
  destroyHeaderFooterEditors() {
    try {
      const editors = [...this.converter.headerEditors, ...this.converter.footerEditors];
      for (let editorData of editors) {
        editorData.editor.destroy();
      }
      this.converter.headerEditors.length = 0;
      this.converter.footerEditors.length = 0;
    } catch {
    }
  }
  /**
   * Check if migrations are needed for the data
   * @static
   * @param {Object} data - Document data
   * @returns {boolean} Whether migrations are needed
   */
  static checkIfMigrationsNeeded() {
    const dataVersion = version || "initial";
    const migrations = getNecessaryMigrations(dataVersion) || [];
    console.debug("[checkVersionMigrations] Migrations needed:", dataVersion, migrations.length);
    return migrations.length > 0;
  }
  /**
   * Process collaboration migrations
   * @returns {Object | void} Migration results
   */
  processCollaborationMigrations() {
    console.debug("[checkVersionMigrations] Current editor version", "0.15.17-next.11");
    if (!this.options.ydoc) return;
    const metaMap = this.options.ydoc.getMap("meta");
    let docVersion = metaMap.get("version");
    if (!docVersion) docVersion = "initial";
    console.debug("[checkVersionMigrations] Document version", docVersion);
    const migrations = getNecessaryMigrations(docVersion) || [];
    const plugins = this.state.plugins;
    const syncPlugin = plugins.find((p) => p.key.startsWith("y-sync"));
    if (!syncPlugin) return this.options.ydoc;
    let hasRunMigrations = false;
    for (let migration of migrations) {
      console.debug("🏃‍♂️ Running migration", migration.name);
      const result = migration(this);
      if (!result) throw new Error("Migration failed at " + migration.name);
      else hasRunMigrations = true;
    }
    if (!hasRunMigrations) return;
    const pluginState = syncPlugin?.getState(this.state);
    return pluginState.doc;
  }
  /**
   * Replace the current file
   * @async
   * @param {Object} newFile - New file data
   * @returns {Promise<void>}
   */
  async replaceFile(newFile) {
    this.setOptions({ annotations: true });
    const [docx, media, mediaFiles, fonts] = await _Editor2.loadXmlData(newFile);
    this.setOptions({
      fileSource: newFile,
      content: docx,
      media,
      mediaFiles,
      fonts,
      isNewFile: true,
      shouldLoadComments: true,
      replacedFile: true
    });
    __privateMethod$1(this, _Editor_instances, createConverter_fn).call(this);
    __privateMethod$1(this, _Editor_instances, initMedia_fn).call(this);
    this.initDefaultStyles();
    if (this.options.ydoc && this.options.collaborationProvider) {
      updateYdocDocxData(this);
      this.initializeCollaborationData(true);
    } else {
      __privateMethod$1(this, _Editor_instances, insertNewFileData_fn).call(this);
    }
    if (!this.options.ydoc) {
      __privateMethod$1(this, _Editor_instances, initPagination_fn).call(this);
      __privateMethod$1(this, _Editor_instances, initComments_fn).call(this);
    }
  }
  /**
   * Get internal docx file content
   * @param {string} name - File name
   * @param {string} type - type of result (json, string)
   * @returns {Object|String} - file content
   */
  getInternalXmlFile(name, type2 = "json") {
    if (!this.converter.convertedXml[name]) {
      console.warn("Cannot find file in docx");
      return null;
    }
    if (type2 === "json") {
      return this.converter.convertedXml[name].elements[0] || null;
    }
    return this.converter.schemaToXml(this.converter.convertedXml[name].elements[0]);
  }
  /**
   * Update internal docx file content
   * @param {string} name - File name
   * @param {string} updatedContent - new file content
   */
  updateInternalXmlFile(name, updatedContent) {
    if (typeof updatedContent === "string") {
      this.options.customUpdatedFiles[name] = String(updatedContent);
    } else {
      const internalFileXml = this.converter.schemaToXml(updatedContent);
      this.options.customUpdatedFiles[name] = String(internalFileXml);
    }
    this.options.isCustomXmlChanged = true;
  }
  /**
   * Get all nodes of a specific type
   * @param {string} type - Node type
   * @returns {Array} Array of nodes
   */
  getNodesOfType(type2) {
    const { findChildren: findChildren2 } = helpers;
    return findChildren2(this.state.doc, (node2) => node2.type.name === type2);
  }
  /**
   * Replace a node with HTML content
   * @param {Object} targetNode - The node to replace
   * @param {string} html - HTML content to replace with
   * @returns {void}
   */
  replaceNodeWithHTML(targetNode, html) {
    const { tr } = this.state;
    const { dispatch } = this.view;
    if (!targetNode || !html) return;
    const start2 = targetNode.pos;
    const end2 = start2 + targetNode.node.nodeSize;
    const htmlNode = createDocFromHTML(html, this.schema);
    tr.replaceWith(start2, end2, htmlNode);
    dispatch(tr);
  }
  /**
   * A command to prepare the editor to receive annotations. This will
   * pre-process the document as needed prior to running in the annotator.
   *
   * Currently this is only used for table generation but additional pre-processing can be done here.
   *
   * @param {FieldValue[]} annotationValues
   * @returns {void}
   */
  prepareForAnnotations(annotationValues = []) {
    const { tr } = this.state;
    const newTr = AnnotatorHelpers.processTables({ state: this.state, tr, annotationValues });
    this.view.dispatch(newTr);
  }
  /**
   * Migrate paragraph fields to lists V2 structure if necessary.
   * @param {FieldValue[]} annotationValues - List of field values to migrate.
   * @returns {Promise<FieldValue[]>} - Returns a promise that resolves to the migrated
   */
  async migrateParagraphFields(annotationValues = []) {
    if (!Array.isArray(annotationValues) || !annotationValues.length) return annotationValues;
    const result = await migrateParagraphFieldsListsV2(annotationValues, this);
    return result;
  }
  /**
   * Annotate the document with the given annotation values.
   *
   * @param {FieldValue[]} annotationValues List of field values to apply.
   * @param {String[]} hiddenIds List of field ids to remove from the document.
   * @returns {void}
   */
  annotate(annotationValues = [], hiddenIds = [], removeEmptyFields = false) {
    const { state: state2, view, schema } = this;
    let tr = state2.tr;
    tr = AnnotatorHelpers.processTables({ state: this.state, tr, annotationValues });
    tr = AnnotatorHelpers.annotateDocument({
      tr,
      schema,
      annotationValues,
      hiddenFieldIds: hiddenIds,
      removeEmptyFields,
      editor: this
    });
    if (tr.docChanged) view.dispatch(tr.scrollIntoView());
  }
  /**
   * Preview annotations in the editor. It stores a copy of the original state.
   * This can be reverted via closePreview()
   *
   * @param {Object[]} annotationValues
   * @param {string[]} hiddenIds
   * @returns {void}
   */
  previewAnnotations(annotationValues = [], hiddenIds = []) {
    this.originalState = this.view.state;
    this.annotate(annotationValues, hiddenIds);
  }
  /**
   * If there is a preview active, this will revert the editor to the original state.
   *
   * @returns {void}
   */
  closePreview() {
    if (!this.originalState) return;
    this.view.updateState(this.originalState);
  }
};
_commandService = /* @__PURE__ */ new WeakMap();
_Editor_instances = /* @__PURE__ */ new WeakSet();
initContainerElement_fn = function(options) {
  if (!options.element && options.selector) {
    const { selector } = options;
    if (selector.startsWith("#") || selector.startsWith(".")) {
      options.element = document.querySelector(selector);
    } else {
      options.element = document.getElementById(selector);
    }
    const textModes = ["text", "html"];
    if (textModes.includes(options.mode) && options.element) {
      options.element.classList.add("sd-super-editor-html");
    }
  }
  options.element = options.isHeadless ? null : options.element || document.createElement("div");
};
init_fn = function() {
  __privateMethod$1(this, _Editor_instances, createExtensionService_fn).call(this);
  __privateMethod$1(this, _Editor_instances, createCommandService_fn).call(this);
  __privateMethod$1(this, _Editor_instances, createSchema_fn).call(this);
  __privateMethod$1(this, _Editor_instances, createConverter_fn).call(this);
  __privateMethod$1(this, _Editor_instances, initMedia_fn).call(this);
  if (!this.options.isHeadless) {
    __privateMethod$1(this, _Editor_instances, initFonts_fn).call(this);
  }
  this.on("beforeCreate", this.options.onBeforeCreate);
  this.emit("beforeCreate", { editor: this });
  this.on("contentError", this.options.onContentError);
  this.on("exception", this.options.onException);
  this.mount(this.options.element);
  this.on("create", this.options.onCreate);
  this.on("update", this.options.onUpdate);
  this.on("selectionUpdate", this.options.onSelectionUpdate);
  this.on("transaction", this.options.onTransaction);
  this.on("focus", __privateMethod$1(this, _Editor_instances, onFocus_fn));
  this.on("blur", this.options.onBlur);
  this.on("destroy", this.options.onDestroy);
  this.on("trackedChangesUpdate", this.options.onTrackedChangesUpdate);
  this.on("commentsLoaded", this.options.onCommentsLoaded);
  this.on("commentClick", this.options.onCommentClicked);
  this.on("commentsUpdate", this.options.onCommentsUpdate);
  this.on("locked", this.options.onDocumentLocked);
  this.on("collaborationReady", __privateMethod$1(this, _Editor_instances, onCollaborationReady_fn));
  this.on("paginationUpdate", this.options.onPaginationUpdate);
  this.on("comment-positions", this.options.onCommentLocationsUpdate);
  this.on("list-definitions-change", this.options.onListDefinitionsChange);
  if (!this.options.isHeadless) {
    this.initializeCollaborationData();
    this.initDefaultStyles();
  }
  if (!this.options.ydoc) this.migrateListsToV2();
  this.setDocumentMode(this.options.documentMode);
  if (!this.options.ydoc) {
    if (!this.options.isChildEditor) {
      __privateMethod$1(this, _Editor_instances, initPagination_fn).call(this);
      __privateMethod$1(this, _Editor_instances, initComments_fn).call(this);
      __privateMethod$1(this, _Editor_instances, validateDocumentInit_fn).call(this);
    }
  }
};
initRichText_fn = function() {
  if (!this.options.extensions || !this.options.extensions.length) {
    this.options.extensions = getRichTextExtensions();
  }
  __privateMethod$1(this, _Editor_instances, createExtensionService_fn).call(this);
  __privateMethod$1(this, _Editor_instances, createCommandService_fn).call(this);
  __privateMethod$1(this, _Editor_instances, createSchema_fn).call(this);
  this.on("beforeCreate", this.options.onBeforeCreate);
  this.emit("beforeCreate", { editor: this });
  this.on("contentError", this.options.onContentError);
  this.mount(this.options.element);
  this.on("create", this.options.onCreate);
  this.on("update", this.options.onUpdate);
  this.on("selectionUpdate", this.options.onSelectionUpdate);
  this.on("transaction", this.options.onTransaction);
  this.on("focus", __privateMethod$1(this, _Editor_instances, onFocus_fn));
  this.on("blur", this.options.onBlur);
  this.on("destroy", this.options.onDestroy);
  this.on("commentsLoaded", this.options.onCommentsLoaded);
  this.on("commentClick", this.options.onCommentClicked);
  this.on("locked", this.options.onDocumentLocked);
  this.on("list-definitions-change", this.options.onListDefinitionsChange);
};
onFocus_fn = function({ editor, event }) {
  this.toolbar?.setActiveEditor(editor);
  this.options.onFocus({ editor, event });
};
checkHeadless_fn = function(options) {
  if (!options.isHeadless) return;
  if (typeof navigator === "undefined") {
    global$1.navigator = { isHeadless: true };
  }
  if (options.mockDocument) {
    global$1.document = options.mockDocument;
    global$1.window = options.mockWindow;
  }
};
insertNewFileData_fn = function() {
  if (!this.options.isNewFile) return;
  this.options.isNewFile = false;
  const doc2 = __privateMethod$1(this, _Editor_instances, generatePmData_fn).call(this);
  const tr = this.state.tr.replaceWith(0, this.state.doc.content.size, doc2).setMeta("addToHistory", false);
  this.view.dispatch(tr);
  setTimeout(() => {
    __privateMethod$1(this, _Editor_instances, initPagination_fn).call(this);
    __privateMethod$1(this, _Editor_instances, initComments_fn).call(this);
  }, 50);
};
registerPluginByNameIfNotExists_fn = function(name) {
  const plugin2 = this.extensionService?.plugins.find((p) => p.key.startsWith(name));
  const hasPlugin = this.state?.plugins?.find((p) => p.key.startsWith(name));
  if (plugin2 && !hasPlugin) this.registerPlugin(plugin2);
  return plugin2?.key;
};
createExtensionService_fn = function() {
  const allowedExtensions = ["extension", "node", "mark"];
  const coreExtensions = [Editable, Commands, EditorFocus, Keymap];
  const externalExtensions = this.options.externalExtensions || [];
  const allExtensions = [...coreExtensions, ...this.options.extensions].filter(
    (e) => allowedExtensions.includes(e?.type)
  );
  this.extensionService = ExtensionService.create(allExtensions, externalExtensions, this);
};
createCommandService_fn = function() {
  __privateSet(this, _commandService, CommandService.create({
    editor: this
  }));
};
createConverter_fn = function() {
  if (this.options.converter) {
    this.converter = this.options.converter;
  } else {
    this.converter = new SuperConverter({
      docx: this.options.content,
      media: this.options.mediaFiles,
      fonts: this.options.fonts,
      debug: true,
      telemetry: this.options.telemetry,
      fileSource: this.options.fileSource,
      documentId: this.options.documentId
    });
  }
};
initMedia_fn = function() {
  if (this.options.isChildEditor) return;
  if (!this.options.ydoc) return this.storage.image.media = this.options.mediaFiles;
  const mediaMap = this.options.ydoc.getMap("media");
  if (this.options.isNewFile) {
    Object.entries(this.options.mediaFiles).forEach(([key, value]) => {
      mediaMap.set(key, value);
    });
    this.storage.image.media = this.options.mediaFiles;
  } else {
    this.storage.image.media = Object.fromEntries(mediaMap.entries());
  }
};
initFonts_fn = function() {
  const styleString = this.converter.getDocumentFonts();
  if (styleString?.length) {
    const style2 = document.createElement("style");
    style2.textContent = styleString;
    document.head.appendChild(style2);
  }
};
createSchema_fn = function() {
  this.schema = this.extensionService.schema;
};
generatePmData_fn = function() {
  let doc2;
  try {
    const { mode, fragment, content, loadFromSchema } = this.options;
    if (mode === "docx") {
      if (loadFromSchema && !this.options.jsonOverride) {
        doc2 = this.schema.nodeFromJSON(content);
        doc2 = __privateMethod$1(this, _Editor_instances, prepareDocumentForImport_fn).call(this, doc2);
      } else {
        doc2 = createDocument(this.converter, this.schema, this);
        doc2 = __privateMethod$1(this, _Editor_instances, prepareDocumentForImport_fn).call(this, doc2);
        if (this.options.markdown) {
          doc2 = createDocFromMarkdown(this.options.markdown, this.schema);
        } else if (this.options.html) doc2 = createDocFromHTML(this.options.html, this.schema);
        else if (this.options.jsonOverride) doc2 = this.schema.nodeFromJSON(this.options.jsonOverride);
        if (fragment) doc2 = yXmlFragmentToProseMirrorRootNode(fragment, this.schema);
      }
    } else if (mode === "text" || mode === "html") {
      if (loadFromSchema) doc2 = this.schema.nodeFromJSON(content);
      else if (content) doc2 = createDocFromHTML(content, this.schema);
      else doc2 = this.schema.topNodeType.createAndFill();
    }
  } catch (err) {
    console.error(err);
    this.emit("contentError", { editor: this, error: err });
  }
  return doc2;
};
createView_fn = function(element) {
  let doc2 = __privateMethod$1(this, _Editor_instances, generatePmData_fn).call(this);
  const state2 = { schema: this.schema };
  if (!this.options.ydoc) state2.doc = doc2;
  this.options.initialState = EditorState.create(state2);
  this.view = new EditorView(element, {
    ...this.options.editorProps,
    dispatchTransaction: __privateMethod$1(this, _Editor_instances, dispatchTransaction_fn).bind(this),
    state: this.options.initialState,
    handleClick: __privateMethod$1(this, _Editor_instances, handleNodeSelection_fn).bind(this),
    handleDoubleClick: async (view, pos, event) => {
      if (this.options.documentMode !== "editing") return;
      const isHeader = hasSomeParentWithClass(event.target, "pagination-section-header");
      const isFooter = hasSomeParentWithClass(event.target, "pagination-section-footer");
      if (isHeader || isFooter) {
        const eventClone = new event.constructor(event.type);
        event.target.dispatchEvent(eventClone);
        if (this.options.isHeaderOrFooter && this.options.editable) setWordSelection(view, pos);
        return;
      }
      event.stopPropagation();
      if (!this.options.editable) {
        this.setEditable(true, false);
        toggleHeaderFooterEditMode({
          editor: this,
          focusedSectionEditor: null,
          isEditMode: false,
          documentMode: this.options.documentMode
        });
        const pm = document.querySelector(".ProseMirror");
        pm.classList.remove("header-footer-edit");
        pm.setAttribute("aria-readonly", false);
      }
      setWordSelection(view, pos);
    }
  });
  const newState = this.state.reconfigure({
    plugins: [...this.extensionService.plugins]
  });
  this.view.updateState(newState);
  this.createNodeViews();
  this.options.telemetry?.sendReport();
};
onCollaborationReady_fn = function({ editor, ydoc }) {
  if (this.options.collaborationIsReady) return;
  console.debug("🔗 [super-editor] Collaboration ready");
  __privateMethod$1(this, _Editor_instances, validateDocumentInit_fn).call(this);
  this.options.onCollaborationReady({ editor, ydoc });
  this.options.collaborationIsReady = true;
  this.options.initialState = this.state;
  const { tr } = this.state;
  tr.setMeta("collaborationReady", true);
  this.view.dispatch(tr);
  if (!this.options.isNewFile) {
    __privateMethod$1(this, _Editor_instances, initPagination_fn).call(this);
    __privateMethod$1(this, _Editor_instances, initComments_fn).call(this);
    updateYdocDocxData(this);
  }
};
initComments_fn = function() {
  if (!this.options.isCommentsEnabled) return;
  if (this.options.isHeadless) return;
  if (!this.options.shouldLoadComments) return;
  const replacedFile = this.options.replacedFile;
  this.emit("commentsLoaded", { editor: this, replacedFile, comments: this.converter.comments || [] });
  setTimeout(() => {
    this.options.replacedFile = false;
    const { state: state2, dispatch } = this.view;
    const tr = state2.tr.setMeta(CommentsPluginKey, { type: "force" });
    dispatch(tr);
  }, 50);
};
initPagination_fn = async function() {
  if (this.options.isHeadless || !this.extensionService || this.options.isHeaderOrFooter) {
    return;
  }
  const pagination = this.options.extensions.find((e) => e.name === "pagination");
  if (pagination && this.options.pagination) {
    const sectionData = await initPaginationData(this);
    this.storage.pagination.sectionData = sectionData;
    const { state: state2, dispatch } = this.view;
    const tr = state2.tr.setMeta(PaginationPluginKey, { isReadyToInit: true });
    dispatch(tr);
  }
};
dispatchTransaction_fn = function(transaction) {
  if (this.isDestroyed) return;
  const start2 = Date.now();
  let state2;
  try {
    const trackChangesState = TrackChangesBasePluginKey.getState(this.view.state);
    const isTrackChangesActive = trackChangesState?.isTrackChangesActive ?? false;
    const tr = isTrackChangesActive ? trackedTransaction({
      tr: transaction,
      state: this.state,
      user: this.options.user
    }) : transaction;
    const { state: newState } = this.view.state.applyTransaction(tr);
    state2 = newState;
  } catch (error) {
    state2 = this.state.apply(transaction);
    console.log(error);
  }
  const selectionHasChanged = !this.state.selection.eq(state2.selection);
  this.view.updateState(state2);
  const end2 = Date.now();
  this.emit("transaction", {
    editor: this,
    transaction,
    duration: end2 - start2
  });
  if (selectionHasChanged) {
    this.emit("selectionUpdate", {
      editor: this,
      transaction
    });
  }
  const focus = transaction.getMeta("focus");
  if (focus) {
    this.emit("focus", {
      editor: this,
      event: focus.event,
      transaction
    });
  }
  const blur = transaction.getMeta("blur");
  if (blur) {
    this.emit("blur", {
      editor: this,
      event: blur.event,
      transaction
    });
  }
  if (!transaction.docChanged) {
    return;
  }
  this.emit("update", {
    editor: this,
    transaction
  });
};
handleNodeSelection_fn = function(view, pos) {
  this.setOptions({
    lastSelection: null
  });
  if (this.options.isHeaderOrFooter) {
    return setImageNodeSelection(view, pos);
  }
};
prepareDocumentForImport_fn = function(doc2) {
  const newState = EditorState.create({
    schema: this.schema,
    doc: doc2
  });
  const { tr, doc: newDoc } = newState;
  prepareCommentsForImport(newDoc, tr, this.schema, this.converter);
  const updatedState = newState.apply(tr);
  return updatedState.doc;
};
prepareDocumentForExport_fn = function(comments = []) {
  const newState = EditorState.create({
    schema: this.schema,
    doc: this.state.doc,
    plugins: this.state.plugins
  });
  const { tr, doc: doc2 } = newState;
  prepareCommentsForExport(doc2, tr, this.schema, comments);
  const updatedState = newState.apply(tr);
  return updatedState.doc.toJSON();
};
endCollaboration_fn = function() {
  if (!this.options.ydoc) return;
  try {
    console.debug("🔗 [super-editor] Ending collaboration");
    if (this.options.collaborationProvider) this.options.collaborationProvider.disconnect();
    if (this.options.ydoc) this.options.ydoc.destroy();
  } catch {
  }
};
validateDocumentInit_fn = function() {
  if (this.options.isHeaderOrFooter || this.options.isChildEditor) return;
  const validator = new SuperValidator({ editor: this, dryRun: false, debug: false });
  validator.validateActiveDocument();
};
let Editor = _Editor;
const Color = Extension.create({
  name: "color",
  addOptions() {
    return {
      /**
       * @typedef {Object} ColorOptions
       * @category Options
       * @property {string[]} [types=['textStyle']] - Mark types to add color support to
       */
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {ColorValue} [color] - Text color value
           */
          color: {
            default: null,
            parseDOM: (el) => el.style.color?.replace(/['"]+/g, ""),
            renderDOM: (attrs) => {
              if (!attrs.color) return {};
              return { style: `color: ${attrs.color}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      /**
       * Set text color
       * @category Command
       * @param {ColorValue} color - Color value to apply
       * @returns {Function} Command function
       * @example
       * // Set to red using hex
       * setColor('#ff0000')
       *
       * // Set using rgb
       * setColor('rgb(255, 0, 0)')
       *
       * // Set using named color
       * setColor('blue')
       * @note Preserves other text styling attributes
       */
      setColor: (color) => ({ chain }) => {
        return chain().setMark("textStyle", { color }).run();
      },
      /**
       * Remove text color
       * @category Command
       * @returns {Function} Command function
       * @example
       * unsetColor()
       * @note Removes color while preserving other text styles
       */
      unsetColor: () => ({ chain }) => {
        return chain().setMark("textStyle", { color: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const FontFamily = Extension.create({
  name: "fontFamily",
  addOptions() {
    return {
      /**
       * @typedef {Object} FontFamilyOptions
       * @category Options
       * @property {string[]} [types=['textStyle']] - Mark types to add font family support to
       */
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {FontFamilyValue} [fontFamily] - Font family for text
           */
          fontFamily: {
            default: null,
            parseDOM: (el) => el.style.fontFamily?.replace(/['"]+/g, ""),
            renderDOM: (attrs) => {
              if (!attrs.fontFamily) return {};
              return { style: `font-family: ${attrs.fontFamily}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      /**
       * Set font family
       * @category Command
       * @param {FontFamilyValue} fontFamily - Font family to apply
       * @returns {Function} Command function
       * @example
       * // Set to Arial
       * setFontFamily('Arial')
       *
       * // Set to serif font
       * setFontFamily('Georgia, serif')
       * @note Preserves other text styling attributes
       */
      setFontFamily: (fontFamily2) => ({ chain }) => {
        return chain().setMark("textStyle", { fontFamily: fontFamily2 }).run();
      },
      /**
       * Remove font family
       * @category Command
       * @returns {Function} Command function
       * @example
       * unsetFontFamily()
       * @note Reverts to default document font
       */
      unsetFontFamily: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontFamily: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const FontSize = Extension.create({
  name: "fontSize",
  addOptions() {
    return {
      /**
       * @typedef {Object} FontSizeOptions
       * @category Options
       * @property {string[]} [types=['textStyle', 'tableCell']] - Node/mark types to add font size support to
       * @property {FontSizeDefaults} [defaults] - Default size configuration
       */
      types: ["textStyle", "tableCell"],
      defaults: {
        value: 12,
        unit: "pt",
        min: 8,
        max: 96
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {FontSizeValue} [fontSize] - Font size with unit
           */
          fontSize: {
            default: null,
            parseDOM: (el) => el.style.fontSize,
            renderDOM: (attrs) => {
              if (!attrs.fontSize) return {};
              let [value, unit] = parseSizeUnit(attrs.fontSize);
              if (Number.isNaN(value)) return {};
              unit = unit ? unit : this.options.defaults.unit;
              return { style: `font-size: ${value}${unit}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      /**
       * Set font size
       * @category Command
       * @param {FontSizeValue} fontSize - Size to apply (with optional unit)
       * @returns {Function} Command function
       * @example
       * // Set to 14pt
       * setFontSize('14pt')
       *
       * // Set to 18px
       * setFontSize('18px')
       *
       * // Set without unit (uses default)
       * setFontSize(16)
       * @note Automatically clamps to min/max values
       */
      setFontSize: (fontSize2) => ({ chain }) => {
        let value, unit;
        if (typeof fontSize2 === "number") {
          value = fontSize2;
          unit = null;
        } else {
          [value, unit] = parseSizeUnit(fontSize2);
        }
        if (Number.isNaN(value)) {
          return false;
        }
        let { min: min2, max: max2, unit: defaultUnit } = this.options.defaults;
        value = minMax(Number(value), min2, max2);
        unit = unit ? unit : defaultUnit;
        return chain().setMark("textStyle", { fontSize: `${value}${unit}` }).run();
      },
      /**
       * Remove font size
       * @category Command
       * @returns {Function} Command function
       * @example
       * unsetFontSize()
       * @note Reverts to default document size
       */
      unsetFontSize: () => ({ chain }) => {
        return chain().setMark("textStyle", { fontSize: null }).removeEmptyTextStyle().run();
      }
    };
  }
});
const TextAlign = Extension.create({
  name: "textAlign",
  addOptions() {
    return {
      types: ["heading", "paragraph"],
      alignments: ["left", "center", "right", "justify"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textAlign: {
            default: this.options.defaultAlignment,
            parseDOM: (el) => {
              const alignment2 = el.style.textAlign || this.options.defaultAlignment;
              const containsAlignment = this.options.alignments.includes(alignment2);
              return containsAlignment ? alignment2 : this.options.defaultAlignment;
            },
            renderDOM: (attrs) => {
              if (attrs.textAlign === this.options.defaultAlignment) return {};
              const textAlign = attrs.textAlign === "both" ? "justify" : attrs.textAlign;
              if (!textAlign) return {};
              return { style: `text-align: ${textAlign}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextAlign: (alignment2) => ({ commands: commands2 }) => {
        const containsAlignment = this.options.alignments.includes(alignment2);
        if (!containsAlignment) return false;
        return this.options.types.map((type2) => commands2.updateAttributes(type2, { textAlign: alignment2 })).every((result) => result);
      },
      unsetTextAlign: () => ({ commands: commands2 }) => {
        return this.options.types.map((type2) => commands2.resetAttributes(type2, "textAlign")).every((result) => result);
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
      "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
      "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
      "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify")
    };
  }
});
const TextIndent = Extension.create({
  name: "textIndent",
  addOptions() {
    return {
      types: ["heading", "paragraph"],
      defaults: {
        unit: "in",
        increment: 0.125
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textIndent: {
            default: null,
            parseDOM: (el) => el.style.textIndent,
            renderDOM: (attrs) => {
              if (!attrs.textIndent) return {};
              let [value, unit] = parseSizeUnit(attrs.textIndent);
              if (Number.isNaN(value) || !value) return {};
              unit = unit ? unit : this.options.defaults.unit;
              return { style: `margin-left: ${value}${unit}` };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      setTextIndent: (indent) => ({ commands: commands2 }) => {
        if (!indent) return false;
        return this.options.types.map((type2) => commands2.updateAttributes(type2, { textIndent: indent })).every((result) => result);
      },
      unsetTextIndent: () => ({ commands: commands2 }) => {
        return this.options.types.map((type2) => commands2.resetAttributes(type2, "textIndent")).every((result) => result);
      },
      increaseTextIndent: () => ({ commands: commands2 }) => {
        return this.options.types.map((type2) => {
          let { textIndent } = this.editor.getAttributes(type2);
          if (!textIndent) {
            let { increment, unit: unit2 } = this.options.defaults;
            return commands2.updateAttributes(type2, {
              textIndent: `${increment}${unit2}`
            });
          }
          let [value, unit] = parseSizeUnit(textIndent);
          value = value + this.options.defaults.increment;
          unit = unit ? unit : this.options.defaults.unit;
          if (Number.isNaN(value)) return false;
          return commands2.updateAttributes(type2, {
            textIndent: `${value}${unit}`
          });
        }).every((result) => result);
      },
      decreaseTextIndent: () => ({ commands: commands2 }) => {
        return this.options.types.map((type2) => {
          let { textIndent } = this.editor.getAttributes(type2);
          if (!textIndent) return false;
          let [value, unit] = parseSizeUnit(textIndent);
          value = value - this.options.defaults.increment;
          unit = unit ? unit : this.options.defaults.unit;
          if (Number.isNaN(value)) return false;
          if (value <= 0) {
            return commands2.unsetTextIndent();
          }
          return commands2.updateAttributes(type2, {
            textIndent: `${value}${unit}`
          });
        }).every((result) => result);
      }
    };
  }
});
const LineHeight = Extension.create({
  name: "lineHeight",
  addOptions() {
    return {
      /**
       * @typedef {Object} LineHeightOptions
       * @category Options
       * @property {string[]} [types=['heading', 'paragraph']] - Block types to add line height support to
       * @property {Object} [defaults] - Default configuration
       * @property {string} [defaults.unit=''] - Default unit for line height values
       */
      types: ["heading", "paragraph"],
      defaults: {
        unit: ""
      }
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          /**
           * @category Attribute
           * @param {LineHeightValue} [lineHeight] - Line height value
           */
          lineHeight: {
            default: null,
            parseDOM: (el) => el.style.lineHeight,
            renderDOM: (attrs) => {
              if (!attrs.lineHeight) return {};
              const lineHeightStyle = getLineHeightValueString(
                attrs.lineHeight,
                this.options.defaults.unit,
                attrs.spacing?.lineRule
              );
              return {
                style: `${lineHeightStyle}`
              };
            }
          }
        }
      }
    ];
  },
  addCommands() {
    return {
      /**
       * Set line height for blocks
       * @category Command
       * @param {LineHeightValue} lineHeight - Line height to apply
       * @returns {Function} Command function
       * @example
       * // Set to 1.5x spacing
       * setLineHeight(1.5)
       *
       * // Set to 24px spacing
       * setLineHeight('24px')
       *
       * // Set to double spacing
       * setLineHeight(2)
       * @note Applies to paragraphs and headings
       */
      setLineHeight: (lineHeight2) => ({ commands: commands2 }) => {
        if (!lineHeight2) return false;
        return this.options.types.map((type2) => commands2.updateAttributes(type2, { lineHeight: lineHeight2 })).every((result) => result);
      },
      /**
       * Remove line height
       * @category Command
       * @returns {Function} Command function
       * @example
       * unsetLineHeight()
       * @note Reverts to default line spacing
       */
      unsetLineHeight: () => ({ commands: commands2 }) => {
        return this.options.types.map((type2) => commands2.resetAttributes(type2, "lineHeight")).every((result) => result);
      }
    };
  }
});
const FormatCommands = Extension.create({
  name: "formatCommands",
  addOptions() {
    return {};
  },
  addStorage() {
    return {
      /**
       * @private
       * @type {StoredStyle[]|null}
       */
      storedStyle: null
    };
  },
  addCommands() {
    return {
      /**
       * Clear all formatting (nodes and marks)
       * @category Command
       * @returns {Function} Command function
       * @example
       * clearFormat()
       * @note Removes all marks and resets nodes to default paragraph
       */
      clearFormat: () => ({ chain }) => {
        return chain().clearNodes().unsetAllMarks().run();
      },
      /**
       * Clear only mark formatting
       * @category Command
       * @returns {Function} Command function
       * @example
       * clearMarksFormat()
       * @note Removes bold, italic, underline, colors, etc. but preserves block structure
       */
      clearMarksFormat: () => ({ chain }) => {
        return chain().unsetAllMarks().run();
      },
      /**
       * Clear only node formatting
       * @category Command
       * @returns {Function} Command function
       * @example
       * clearNodesFormat()
       * @note Converts headings, lists, etc. to paragraphs but preserves text marks
       */
      clearNodesFormat: () => ({ chain }) => {
        return chain().clearNodes().run();
      },
      /**
       * Copy format from selection or apply copied format
       * @category Command
       * @returns {Function} Command function
       * @example
       * // First call: copy format from selection
       * copyFormat()
       *
       * // Second call: apply copied format to new selection
       * copyFormat()
       * @note Works like format painter - first click copies, second click applies
       */
      copyFormat: () => ({ chain }) => {
        if (!this.storage.storedStyle) {
          const marks = getMarksFromSelection(this.editor.state);
          this.storage.storedStyle = marks;
          return true;
        }
        if (!this.storage.storedStyle.length) {
          this.storage.storedStyle = null;
          return chain().clearFormat().run();
        }
        const storedMarks = this.storage.storedStyle;
        const processedMarks = [];
        storedMarks.forEach((mark) => {
          const { type: type2, attrs } = mark;
          const { name } = type2;
          if (name === "textStyle") {
            Object.keys(attrs).forEach((key) => {
              if (!attrs[key]) return;
              const attributes = {};
              attributes[key] = attrs[key];
              processedMarks.push({ name: key, attrs: attributes });
            });
          } else {
            processedMarks.push({ name, attrs });
          }
        });
        const marksToCommands = {
          bold: ["setBold", "unsetBold"],
          italic: ["setItalic", "unsetItalic"],
          underline: ["setUnderline", "unsetUnderline"],
          color: ["setColor", "setColor", null],
          fontSize: ["setFontSize", "unsetFontSize"],
          fontFamily: ["setFontFamily", "unsetFontFamily"]
        };
        let result = chain();
        Object.keys(marksToCommands).forEach((key) => {
          const [setCommand, unsetCommand, defaultParam] = marksToCommands[key];
          const markToApply = processedMarks.find((mark) => mark.name === key);
          const hasEmptyAttrs = markToApply?.attrs && markToApply?.attrs[key];
          let cmd = {};
          if (!markToApply && !hasEmptyAttrs) cmd = { command: unsetCommand, argument: defaultParam };
          else cmd = { command: setCommand, argument: markToApply.attrs[key] || defaultParam };
          result = result[cmd.command](cmd.argument);
        });
        this.storage.storedStyle = null;
        return result;
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.clearFormat()
    };
  }
});
function dropCursor(options = {}) {
  return new Plugin({
    view(editorView) {
      return new DropCursorView(editorView, options);
    }
  });
}
class DropCursorView {
  constructor(editorView, options) {
    var _a2;
    this.editorView = editorView;
    this.cursorPos = null;
    this.element = null;
    this.timeout = -1;
    this.width = (_a2 = options.width) !== null && _a2 !== void 0 ? _a2 : 1;
    this.color = options.color === false ? void 0 : options.color || "black";
    this.class = options.class;
    this.handlers = ["dragover", "dragend", "drop", "dragleave"].map((name) => {
      let handler = (e) => {
        this[name](e);
      };
      editorView.dom.addEventListener(name, handler);
      return { name, handler };
    });
  }
  destroy() {
    this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));
  }
  update(editorView, prevState) {
    if (this.cursorPos != null && prevState.doc != editorView.state.doc) {
      if (this.cursorPos > editorView.state.doc.content.size)
        this.setCursor(null);
      else
        this.updateOverlay();
    }
  }
  setCursor(pos) {
    if (pos == this.cursorPos)
      return;
    this.cursorPos = pos;
    if (pos == null) {
      this.element.parentNode.removeChild(this.element);
      this.element = null;
    } else {
      this.updateOverlay();
    }
  }
  updateOverlay() {
    let $pos = this.editorView.state.doc.resolve(this.cursorPos);
    let isBlock = !$pos.parent.inlineContent, rect;
    let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();
    let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;
    if (isBlock) {
      let before = $pos.nodeBefore, after = $pos.nodeAfter;
      if (before || after) {
        let node2 = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));
        if (node2) {
          let nodeRect = node2.getBoundingClientRect();
          let top2 = before ? nodeRect.bottom : nodeRect.top;
          if (before && after)
            top2 = (top2 + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;
          let halfWidth = this.width / 2 * scaleY;
          rect = { left: nodeRect.left, right: nodeRect.right, top: top2 - halfWidth, bottom: top2 + halfWidth };
        }
      }
    }
    if (!rect) {
      let coords = this.editorView.coordsAtPos(this.cursorPos);
      let halfWidth = this.width / 2 * scaleX;
      rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };
    }
    let parent = this.editorView.dom.offsetParent;
    if (!this.element) {
      this.element = parent.appendChild(document.createElement("div"));
      if (this.class)
        this.element.className = this.class;
      this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;";
      if (this.color) {
        this.element.style.backgroundColor = this.color;
      }
    }
    this.element.classList.toggle("prosemirror-dropcursor-block", isBlock);
    this.element.classList.toggle("prosemirror-dropcursor-inline", !isBlock);
    let parentLeft, parentTop;
    if (!parent || parent == document.body && getComputedStyle(parent).position == "static") {
      parentLeft = -pageXOffset;
      parentTop = -pageYOffset;
    } else {
      let rect2 = parent.getBoundingClientRect();
      let parentScaleX = rect2.width / parent.offsetWidth, parentScaleY = rect2.height / parent.offsetHeight;
      parentLeft = rect2.left - parent.scrollLeft * parentScaleX;
      parentTop = rect2.top - parent.scrollTop * parentScaleY;
    }
    this.element.style.left = (rect.left - parentLeft) / scaleX + "px";
    this.element.style.top = (rect.top - parentTop) / scaleY + "px";
    this.element.style.width = (rect.right - rect.left) / scaleX + "px";
    this.element.style.height = (rect.bottom - rect.top) / scaleY + "px";
  }
  scheduleRemoval(timeout2) {
    clearTimeout(this.timeout);
    this.timeout = setTimeout(() => this.setCursor(null), timeout2);
  }
  dragover(event) {
    if (!this.editorView.editable)
      return;
    let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });
    let node2 = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);
    let disableDropCursor = node2 && node2.type.spec.disableDropCursor;
    let disabled = typeof disableDropCursor == "function" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;
    if (pos && !disabled) {
      let target = pos.pos;
      if (this.editorView.dragging && this.editorView.dragging.slice) {
        let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);
        if (point != null)
          target = point;
      }
      this.setCursor(target);
      this.scheduleRemoval(5e3);
    }
  }
  dragend() {
    this.scheduleRemoval(20);
  }
  drop() {
    this.scheduleRemoval(20);
  }
  dragleave(event) {
    if (!this.editorView.dom.contains(event.relatedTarget))
      this.setCursor(null);
  }
}
const DropCursor = Extension.create({
  name: "dropCursor",
  addOptions() {
    return {
      color: "currentColor",
      width: 2,
      class: void 0
    };
  },
  addPmPlugins() {
    return [dropCursor(this.options)];
  }
});
class GapCursor extends Selection {
  /**
  Create a gap cursor.
  */
  constructor($pos) {
    super($pos, $pos);
  }
  map(doc2, mapping) {
    let $pos = doc2.resolve(mapping.map(this.head));
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
  content() {
    return Slice.empty;
  }
  eq(other) {
    return other instanceof GapCursor && other.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(doc2, json) {
    if (typeof json.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new GapCursor(doc2.resolve(json.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new GapBookmark(this.anchor);
  }
  /**
  @internal
  */
  static valid($pos) {
    let parent = $pos.parent;
    if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))
      return false;
    let override = parent.type.spec.allowGapCursor;
    if (override != null)
      return override;
    let deflt = parent.contentMatchAt($pos.index()).defaultType;
    return deflt && deflt.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom($pos, dir, mustMove = false) {
    search: for (; ; ) {
      if (!mustMove && GapCursor.valid($pos))
        return $pos;
      let pos = $pos.pos, next = null;
      for (let d2 = $pos.depth; ; d2--) {
        let parent = $pos.node(d2);
        if (dir > 0 ? $pos.indexAfter(d2) < parent.childCount : $pos.index(d2) > 0) {
          next = parent.child(dir > 0 ? $pos.indexAfter(d2) : $pos.index(d2) - 1);
          break;
        } else if (d2 == 0) {
          return null;
        }
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      for (; ; ) {
        let inside = dir > 0 ? next.firstChild : next.lastChild;
        if (!inside) {
          if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {
            $pos = $pos.doc.resolve(pos + next.nodeSize * dir);
            mustMove = false;
            continue search;
          }
          break;
        }
        next = inside;
        pos += dir;
        let $cur = $pos.doc.resolve(pos);
        if (GapCursor.valid($cur))
          return $cur;
      }
      return null;
    }
  }
}
GapCursor.prototype.visible = false;
GapCursor.findFrom = GapCursor.findGapCursorFrom;
Selection.jsonID("gapcursor", GapCursor);
class GapBookmark {
  constructor(pos) {
    this.pos = pos;
  }
  map(mapping) {
    return new GapBookmark(mapping.map(this.pos));
  }
  resolve(doc2) {
    let $pos = doc2.resolve(this.pos);
    return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);
  }
}
function closedBefore($pos) {
  for (let d2 = $pos.depth; d2 >= 0; d2--) {
    let index2 = $pos.index(d2), parent = $pos.node(d2);
    if (index2 == 0) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let before = parent.child(index2 - 1); ; before = before.lastChild) {
      if (before.childCount == 0 && !before.inlineContent || before.isAtom || before.type.spec.isolating)
        return true;
      if (before.inlineContent)
        return false;
    }
  }
  return true;
}
function closedAfter($pos) {
  for (let d2 = $pos.depth; d2 >= 0; d2--) {
    let index2 = $pos.indexAfter(d2), parent = $pos.node(d2);
    if (index2 == parent.childCount) {
      if (parent.type.spec.isolating)
        return true;
      continue;
    }
    for (let after = parent.child(index2); ; after = after.firstChild) {
      if (after.childCount == 0 && !after.inlineContent || after.isAtom || after.type.spec.isolating)
        return true;
      if (after.inlineContent)
        return false;
    }
  }
  return true;
}
function gapCursor() {
  return new Plugin({
    props: {
      decorations: drawGapCursor,
      createSelectionBetween(_view, $anchor, $head) {
        return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;
      },
      handleClick,
      handleKeyDown: handleKeyDown$1,
      handleDOMEvents: { beforeinput }
    }
  });
}
const handleKeyDown$1 = keydownHandler({
  "ArrowLeft": arrow$3("horiz", -1),
  "ArrowRight": arrow$3("horiz", 1),
  "ArrowUp": arrow$3("vert", -1),
  "ArrowDown": arrow$3("vert", 1)
});
function arrow$3(axis, dir) {
  const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
  return function(state2, dispatch, view) {
    let sel = state2.selection;
    let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;
    if (sel instanceof TextSelection$1) {
      if (!view.endOfTextblock(dirStr) || $start.depth == 0)
        return false;
      mustMove = false;
      $start = state2.doc.resolve(dir > 0 ? $start.after() : $start.before());
    }
    let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);
    if (!$found)
      return false;
    if (dispatch)
      dispatch(state2.tr.setSelection(new GapCursor($found)));
    return true;
  };
}
function handleClick(view, pos, event) {
  if (!view || !view.editable)
    return false;
  let $pos = view.state.doc.resolve(pos);
  if (!GapCursor.valid($pos))
    return false;
  let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });
  if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))
    return false;
  view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));
  return true;
}
function beforeinput(view, event) {
  if (event.inputType != "insertCompositionText" || !(view.state.selection instanceof GapCursor))
    return false;
  let { $from } = view.state.selection;
  let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);
  if (!insert)
    return false;
  let frag = Fragment.empty;
  for (let i = insert.length - 1; i >= 0; i--)
    frag = Fragment.from(insert[i].createAndFill(null, frag));
  let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));
  tr.setSelection(TextSelection$1.near(tr.doc.resolve($from.pos + 1)));
  view.dispatch(tr);
  return false;
}
function drawGapCursor(state2) {
  if (!(state2.selection instanceof GapCursor))
    return null;
  let node2 = document.createElement("div");
  node2.className = "ProseMirror-gapcursor";
  return DecorationSet.create(state2.doc, [Decoration.widget(state2.selection.head, node2, { key: "gapcursor" })]);
}
const Gapcursor = Extension.create({
  name: "gapCursor",
  addPmPlugins() {
    return [gapCursor()];
  },
  extendNodeSchema(extension) {
    return {
      allowGapCursor: callOrGet(
        getExtensionConfigField(extension, "allowGapCursor", {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        })
      ) ?? null
    };
  }
});
const CollaborationCursor = Extension.create({
  name: "collaborationCursor",
  priority: 999,
  addOptions() {
    return {
      provider: null,
      user: {
        name: null,
        color: null
      }
    };
  },
  addStorage() {
    return {
      users: []
    };
  },
  addPmPlugins() {
    const { collaborationProvider: provider = null } = this.editor.options;
    if (!provider) return [];
    return [yCursorPlugin(provider.awareness, { cursorBuilder: customCursors })];
  }
});
const customCursors = (user) => {
  const cursor = document.createElement("span");
  cursor.classList.add("ProseMirror-yjs-cursor");
  cursor.setAttribute("style", `border-color: ${user.color}`);
  const userDiv = document.createElement("div");
  userDiv.setAttribute("style", `background-color: ${user.color}`);
  userDiv.insertBefore(document.createTextNode(user.name || user.email), null);
  cursor.insertBefore(userDiv, null);
  return cursor;
};
const AiMarkName = "aiMark";
const AiAnimationMarkName = "aiAnimationMark";
const AiLoaderNodeName = "aiLoaderNode";
const AiMark = Mark2.create({
  name: AiMarkName,
  group: "ai",
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: { class: "sd-ai-highlight" }
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: AiMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [AiMarkName, Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  }
});
const AiAnimationMark = Mark2.create({
  name: AiAnimationMarkName,
  group: "ai",
  inclusive: false,
  spanning: false,
  excludes: AiAnimationMarkName,
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      id: {
        default: null,
        rendered: false
      },
      class: {
        default: null,
        rendered: true
      },
      dataMarkId: {
        default: null,
        rendered: true
      }
    };
  },
  parseDOM() {
    return [{ tag: AiAnimationMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [AiAnimationMarkName, Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  }
});
const dotsLoader = "data:image/svg+xml,%3csvg%20fill='hsla(278,%2077.40%25,%2020.80%25,%200.65)'%20viewBox='0%200%2024%2024'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='4'%20cy='12'%20r='0'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_lo66'%20begin='spinner_Aguh.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_z0Or'%20begin='spinner_lo66.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='4'%20cy='12'%20r='3'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_JsnR'%20begin='spinner_UHR2.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_Aguh'%20begin='spinner_JsnR.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='12'%20cy='12'%20r='3'%3e%3canimate%20begin='0;spinner_z0Or.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3canimate%20id='spinner_hSjk'%20begin='spinner_OLMs.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_UHR2'%20begin='spinner_hSjk.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3c/circle%3e%3ccircle%20cx='20'%20cy='12'%20r='3'%3e%3canimate%20id='spinner_4v5M'%20begin='0;spinner_z0Or.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='3;0'%20fill='freeze'/%3e%3canimate%20id='spinner_OLMs'%20begin='spinner_4v5M.end'%20attributeName='cx'%20dur='0.001s'%20values='20;4'%20fill='freeze'/%3e%3canimate%20begin='spinner_OLMs.end'%20attributeName='r'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='0;3'%20fill='freeze'/%3e%3canimate%20begin='spinner_UHR2.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='4;12'%20fill='freeze'/%3e%3canimate%20begin='spinner_Aguh.end'%20attributeName='cx'%20calcMode='spline'%20dur='0.5s'%20keySplines='.36,.6,.31,1'%20values='12;20'%20fill='freeze'/%3e%3c/circle%3e%3c/svg%3e";
const AiLoaderNode = Node$1.create({
  name: AiLoaderNodeName,
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-ai-loader",
        contentEditable: "false",
        "aria-label": "AI loader node"
      }
    };
  },
  parseDOM() {
    return [{ tag: "span.sd-ai-loader" }];
  },
  renderDOM({ htmlAttributes }) {
    const span = document.createElement("span");
    Object.entries(Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes)).forEach(
      ([k, v2]) => span.setAttribute(k, v2)
    );
    const img = document.createElement("img");
    img.src = dotsLoader;
    img.alt = "loading...";
    img.width = 100;
    img.height = 50;
    span.appendChild(img);
    return span;
  }
});
const AiPluginKey = new PluginKey("ai");
const AiPlugin = Extension.create({
  name: "ai",
  addCommands() {
    return {
      insertAiMark: () => ({ tr, dispatch }) => {
        const { selection } = tr;
        const { $from, $to } = selection;
        if ($from.pos === $to.pos) return false;
        tr.addMark(
          $from.pos,
          $to.pos,
          this.editor.schema.marks[AiMarkName].create({
            id: "ai-highlight"
          })
        );
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Remove selection before ai pulse styles
       */
      removeSelectionAfterAiPulse: () => ({ tr, dispatch, state: state2 }) => {
        const { selection } = tr;
        const { $to } = selection;
        tr.setSelection(state2.selection.constructor.create(tr.doc, $to.pos, $to.pos));
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Update the AI highlights with custom styling
       * @remarks This is to avoid manipulating the DOM directly - use Prosemirror state. Avoids re-rendering the entire document
       * @param {String} className - The CSS class to add to the AI highlights
       * @returns {Boolean} - True if the highlight style was updated
       */
      updateAiHighlightStyle: (className) => ({ tr, dispatch }) => {
        tr.setMeta(AiPluginKey, { type: "updateStyle", className });
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Clear any custom styling from AI highlights
       * @returns {Boolean} - True if the highlight style was cleared
       */
      clearAiHighlightStyle: () => ({ tr, dispatch }) => {
        tr.setMeta(AiPluginKey, { type: "updateStyle", className: null });
        if (dispatch) dispatch(tr);
        return true;
      },
      /**
       * Remove all AI marks from the document
       * @param {String} markName - The name of the mark to remove - defaults to AiMarkName
       * Can also be used to remove the ai animation mark after streams are complete
       * @returns {Boolean} - True if the mark was removed, false otherwise
       */
      removeAiMark: (markName = AiMarkName) => ({ tr, dispatch, state: state2 }) => {
        const { doc: doc2 } = state2;
        let markFound = false;
        doc2.descendants((node2, pos) => {
          const { marks = [] } = node2;
          const aiMark = marks.find((mark) => mark.type.name === markName);
          if (aiMark) {
            markFound = true;
            tr.removeMark(pos, pos + node2.nodeSize, state2.schema.marks[markName]);
          }
        });
        if (markFound) {
          if (dispatch) dispatch(tr);
          return true;
        }
        return false;
      },
      /**
       * Remove all AI nodes of a specific type from the document
       * @param {String} nodeName - The name of the node to remove
       * @returns {Boolean} - True if any nodes were removed, false otherwise
       */
      removeAiNode: (nodeName = AiLoaderNodeName) => ({ tr, dispatch, state: state2 }) => {
        const { doc: doc2 } = state2;
        const positions = [];
        doc2.descendants((node2, pos) => {
          if (node2.type.name === nodeName) {
            positions.push(pos);
          }
        });
        if (positions.length === 0) {
          return false;
        }
        positions.sort((a, b2) => b2 - a);
        positions.forEach((pos) => {
          const node2 = doc2.nodeAt(pos);
          if (node2) {
            tr.delete(pos, pos + node2.nodeSize);
          }
        });
        if (dispatch) dispatch(tr);
        return true;
      }
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    const aiPlugin = new Plugin({
      key: AiPluginKey,
      state: {
        init() {
          return {
            decorations: DecorationSet.empty,
            highlightColor: "#6366f1",
            // Indigo color, matches AiLayer
            customClass: null
            // Pulse animation class spot (later)
          };
        },
        apply(tr, oldState, _2, newEditorState) {
          const meta = tr.getMeta(AiPluginKey);
          let customClass = oldState.customClass;
          if (meta && meta.type === "updateStyle") {
            customClass = meta.className;
          }
          if (tr.docChanged && customClass === "sd-ai-highlight-pulse") {
            let hasTextChanges = false;
            tr.steps.forEach((step) => {
              if (step.slice && step.slice.content.size > 0) {
                hasTextChanges = true;
              }
            });
            if (hasTextChanges) {
              customClass = null;
            }
          }
          if (!tr.docChanged && !meta) return oldState;
          const { decorations } = processAiHighlights(editor, newEditorState.doc, oldState.highlightColor, customClass) || {};
          const decorationSet = DecorationSet.create(newEditorState.doc, decorations);
          return {
            ...oldState,
            decorations: decorationSet,
            customClass
          };
        }
      },
      props: {
        decorations(state2) {
          return this.getState(state2).decorations;
        }
      }
    });
    return [aiPlugin];
  }
});
const processAiHighlights = (editor, doc2, highlightColor, customClass = null) => {
  const decorations = [];
  doc2.descendants((node2, pos) => {
    const { marks = [] } = node2;
    const aiMark = marks.find((mark) => mark.type.name === AiMarkName);
    if (aiMark) {
      const attrs = {
        style: `background-color: ${highlightColor}33; border-radius: 4px; transition: background-color 250ms ease;`,
        // 33 is 20% opacity in hex
        class: "sd-ai-highlight-element"
      };
      if (customClass) {
        attrs.class += ` ${customClass}`;
      }
      const deco = Decoration.inline(pos, pos + node2.nodeSize, attrs);
      decorations.push(deco);
    }
  });
  return { decorations };
};
function getCursorPositionRelativeToContainer(view, eventLocation) {
  const { state: state2, dom } = view;
  const { selection } = state2;
  const containerRect = dom.getBoundingClientRect();
  let x, y2;
  if (typeof eventLocation.clientX === "number" && typeof eventLocation.clientY === "number") {
    x = eventLocation.clientX - containerRect.left;
    y2 = eventLocation.clientY - containerRect.top;
  } else {
    const cursorCoords = view.coordsAtPos(selection.from);
    x = cursorCoords.left - containerRect.left;
    y2 = cursorCoords.top - containerRect.top;
  }
  return { left: x, top: y2 };
}
const SlashMenuPluginKey = new PluginKey("slashMenu");
const SlashMenu = Extension.create({
  name: "slashMenu",
  addPmPlugins() {
    if (this.editor.options?.disableContextMenu) {
      return [];
    }
    const editor = this.editor;
    let slashCooldown = false;
    let slashCooldownTimeout = null;
    const slashMenuPlugin = new Plugin({
      key: SlashMenuPluginKey,
      state: {
        init() {
          return {
            open: false,
            selected: null,
            anchorPos: null,
            menuPosition: null
          };
        },
        apply(tr, value) {
          const meta = tr.getMeta(SlashMenuPluginKey);
          if (!meta) return value;
          switch (meta.type) {
            case "open": {
              const pos = getCursorPositionRelativeToContainer(editor.view, meta);
              const menuPosition = {
                left: `${pos.left + 100}px`,
                top: `${pos.top + 28}px`
              };
              const newState = {
                ...value,
                open: true,
                anchorPos: meta.pos,
                menuPosition
              };
              editor.emit("slashMenu:open", { menuPosition });
              return newState;
            }
            case "select": {
              return { ...value, selected: meta.id };
            }
            case "close": {
              editor.emit("slashMenu:close");
              return { ...value, open: false, anchorPos: null };
            }
            default:
              return value;
          }
        }
      },
      view(editorView) {
        const updatePosition2 = () => {
          const state2 = SlashMenuPluginKey.getState(editorView.state);
          if (state2.open) {
            editorView.dispatch(
              editorView.state.tr.setMeta(SlashMenuPluginKey, {
                type: "updatePosition"
              })
            );
          }
        };
        window.addEventListener("scroll", updatePosition2, true);
        window.addEventListener("resize", updatePosition2);
        return {
          destroy() {
            window.removeEventListener("scroll", updatePosition2, true);
            window.removeEventListener("resize", updatePosition2);
            if (slashCooldownTimeout) {
              clearTimeout(slashCooldownTimeout);
              slashCooldownTimeout = null;
            }
          }
        };
      },
      props: {
        handleKeyDown(view, event) {
          const pluginState = this.getState(view.state);
          if (event.key === "/" && slashCooldown) {
            return false;
          }
          if (event.key === "/" && !pluginState.open) {
            const { $cursor } = view.state.selection;
            if (!$cursor) return false;
            const isParagraph = $cursor.parent.type.name === "paragraph";
            if (!isParagraph) return false;
            const textBefore = $cursor.parent.textContent.slice(0, $cursor.parentOffset);
            const isEmptyOrAfterSpace = !textBefore || textBefore.endsWith(" ");
            if (!isEmptyOrAfterSpace) return false;
            event.preventDefault();
            slashCooldown = true;
            if (slashCooldownTimeout) clearTimeout(slashCooldownTimeout);
            slashCooldownTimeout = setTimeout(() => {
              slashCooldown = false;
              slashCooldownTimeout = null;
            }, 5e3);
            view.dispatch(
              view.state.tr.setMeta(SlashMenuPluginKey, {
                type: "open",
                pos: $cursor.pos
              })
            );
            return true;
          }
          if (pluginState.open && (event.key === "Escape" || event.key === "ArrowLeft")) {
            const { anchorPos } = pluginState;
            view.dispatch(
              view.state.tr.setMeta(SlashMenuPluginKey, {
                type: "close"
              })
            );
            if (anchorPos !== null) {
              const tr = view.state.tr.setSelection(
                view.state.selection.constructor.near(view.state.doc.resolve(anchorPos))
              );
              view.dispatch(tr);
              view.focus();
            }
            return true;
          }
          return false;
        }
      }
    });
    return this.editor.options.isHeadless ? [] : [slashMenuPlugin];
  }
});
const Document = Node$1.create({
  name: "doc",
  topNode: true,
  content: "block+",
  parseDOM() {
    return [{ tag: "doc" }];
  },
  renderDOM() {
    return ["doc", 0];
  },
  addAttributes() {
    return {
      /**
       * @private
       * @category Attribute
       * @param {Object} [attributes] - Internal document attributes
       */
      attributes: {
        rendered: false,
        "aria-label": "Document node"
      }
    };
  },
  addCommands() {
    return {
      /**
       * Get document statistics
       * @category Command
       * @returns {Function} Command function
       * @example
       * // Get word and character count
       * getDocumentStats()
       * @note Returns word count, character count, and paragraph count
       */
      getDocumentStats: () => ({ editor }) => {
        const text = editor.getText();
        const words = text.split(/\s+/).filter((word) => word.length > 0).length;
        const characters = text.length;
        const paragraphs = editor.state.doc.content.childCount;
        return {
          words,
          characters,
          paragraphs
        };
      },
      /**
       * Clear entire document
       * @category Command
       * @returns {Function} Command function
       * @example
       * clearDocument()
       * @note Replaces all content with an empty paragraph
       */
      clearDocument: () => ({ commands: commands2 }) => {
        return commands2.setContent("<p></p>");
      }
    };
  }
});
const Text = Node$1.create({
  name: "text",
  group: "inline",
  inline: true
});
const RunItem = Node$1.create({
  name: "run",
  group: "inline",
  content: "text*",
  inline: true,
  parseDOM() {
    return [{ tag: "run" }];
  },
  renderDOM() {
    return ["run", 0];
  },
  addAttributes() {
    return {
      attributes: {
        rendered: false,
        "aria-label": "Run node"
      }
    };
  }
});
const inputRegex$1 = /^\s*([-+*])\s$/;
const BulletList = Node$1.create({
  name: "bulletList",
  group: "block list",
  selectable: false,
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addOptions() {
    return {
      /**
       * @typedef {Object} BulletListOptions
       * @category Options
       * @property {string} [itemTypeName='listItem'] - Name of the list item node type
       * @property {Object} [htmlAttributes] - HTML attributes for the ul element
       * @property {boolean} [keepMarks=true] - Whether to preserve marks when splitting
       * @property {boolean} [keepAttributes=false] - Whether to preserve attributes when splitting
       */
      itemTypeName: "listItem",
      htmlAttributes: {
        "aria-label": "Bullet list node"
      },
      keepMarks: true,
      keepAttributes: false
    };
  },
  parseDOM() {
    return [{ tag: "ul" }];
  },
  renderDOM({ htmlAttributes }) {
    const attributes = Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes);
    return ["ul", attributes, 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [list-style-type='bullet'] - List style type for this list
       */
      "list-style-type": {
        default: "bullet",
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [listId] - Internal list identifier for numbering
       */
      listId: {
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking ID
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      /**
       * @private
       * @category Attribute
       * @param {Object} [attributes] - Additional attributes for the list
       */
      attributes: {
        rendered: false,
        keepOnSplit: true
      }
    };
  },
  addCommands() {
    return {
      /**
       * Toggle a bullet list at the current selection
       * @category Command
       * @returns {Function} Command function
       * @example
       * // Toggle bullet list on selected text
       * toggleBulletList()
       * @note Converts selected paragraphs to list items or removes list formatting
       */
      toggleBulletList: () => (params2) => {
        return toggleList(this.type)(params2);
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-8": () => {
        return this.editor.commands.toggleBulletList();
      }
    };
  },
  addInputRules() {
    return [
      new InputRule({
        match: inputRegex$1,
        handler: ({ state: state2, range: range2 }) => {
          const $pos = state2.selection.$from;
          const listItemType = state2.schema.nodes.listItem;
          for (let depth = $pos.depth; depth >= 0; depth--) {
            if ($pos.node(depth).type === listItemType) {
              return null;
            }
          }
          const { tr } = state2;
          tr.delete(range2.from, range2.to);
          ListHelpers.createNewList({
            listType: this.type,
            tr,
            editor: this.editor
          });
        }
      })
    ];
  }
});
const inputRegex = /^(\d+)\.\s$/;
const OrderedList = Node$1.create({
  name: "orderedList",
  group: "block list",
  selectable: false,
  content() {
    return `${this.options.itemTypeName}+`;
  },
  addOptions() {
    return {
      itemTypeName: "listItem",
      htmlAttributes: {
        "aria-label": "Ordered list node"
      },
      keepMarks: true,
      keepAttributes: false,
      listStyleTypes: ["decimal", "lowerAlpha", "lowerRoman"]
    };
  },
  addAttributes() {
    return {
      order: {
        default: 1,
        parseDOM: (element) => {
          return element.hasAttribute("start") ? parseInt(element.getAttribute("start") || "", 10) : 1;
        },
        renderDOM: (attrs) => {
          return {
            start: attrs.order
          };
        }
      },
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      syncId: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-sync-id"),
        renderDOM: (attrs) => {
          if (!attrs.syncId) return {};
          return {
            "data-sync-id": attrs.syncId
          };
        }
        // rendered: false,
      },
      listId: {
        keepOnSplit: true,
        parseDOM: (elem) => elem.getAttribute("data-list-id"),
        renderDOM: (attrs) => {
          if (!attrs.listId) return {};
          return {
            "data-list-id": attrs.listId
          };
        }
      },
      "list-style-type": {
        default: "decimal",
        rendered: false
      },
      attributes: {
        rendered: false,
        keepOnSplit: true
      }
    };
  },
  parseDOM() {
    return [{ tag: "ol" }];
  },
  renderDOM({ htmlAttributes }) {
    const { start: start2, ...restAttributes } = htmlAttributes;
    return start2 === 1 ? ["ol", Attribute2.mergeAttributes(this.options.htmlAttributes, restAttributes), 0] : ["ol", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      toggleOrderedList: () => (params2) => {
        return toggleList(this.type)(params2);
      },
      restartListNodes: (followingNodes, pos) => ({ tr }) => {
        let currentNodePos = pos;
        const nodes = followingNodes.map((node2) => {
          const resultNode = {
            node: node2,
            pos: currentNodePos
          };
          currentNodePos += node2.nodeSize;
          return resultNode;
        });
        nodes.forEach((item) => {
          const { pos: pos2 } = item;
          const newPos = tr.mapping.map(pos2);
          tr.setNodeMarkup(newPos, void 0, {});
        });
        return true;
      },
      /**
       * Updates ordered list style type when sink or lift `listItem`.
       * @example 1,2,3 -> a,b,c -> i,ii,iii -> 1,2,3 -> etc
       */
      updateOrderedListStyleType: () => ({ dispatch, tr }) => {
        let list = findParentNode((node2) => node2.type.name === this.name)(tr.selection);
        if (!list) {
          return true;
        }
        if (dispatch) {
          let listLevel = (list.depth - 1) / 2;
          let listStyleTypes = this.options.listStyleTypes;
          let listStyle = listStyleTypes[listLevel % listStyleTypes.length];
          let currentListStyle = list.node.attrs["list-style-type"];
          let nodeAtPos = tr.doc.nodeAt(list.pos);
          if (currentListStyle !== listStyle && nodeAtPos.eq(list.node)) {
            tr.setNodeMarkup(list.pos, void 0, {
              ...list.node.attrs,
              ...{
                "list-style-type": listStyle
              }
            });
          }
        }
        return true;
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-7": () => {
        return this.editor.commands.toggleOrderedList();
      }
    };
  },
  addInputRules() {
    return [
      new InputRule({
        match: inputRegex,
        handler: ({ state: state2, range: range2 }) => {
          const $pos = state2.selection.$from;
          const listItemType = state2.schema.nodes.listItem;
          for (let depth = $pos.depth; depth >= 0; depth--) {
            if ($pos.node(depth).type === listItemType) {
              return null;
            }
          }
          const { tr } = state2;
          tr.delete(range2.from, range2.to);
          ListHelpers.createNewList({
            listType: this.type,
            tr,
            editor: this.editor
          });
        }
      })
    ];
  }
});
const CustomSelectionPluginKey = new PluginKey("CustomSelection");
const handleClickOutside = (event, editor) => {
  const editorElem = editor?.options?.element;
  if (!editorElem) return;
  const isInsideEditor = editorElem?.contains(event.target);
  if (!isInsideEditor) {
    editor.setOptions({
      focusTarget: event.target
    });
  } else {
    editor.setOptions({
      focusTarget: null
    });
  }
};
function getFocusMeta(tr) {
  return tr.getMeta(CustomSelectionPluginKey);
}
function setFocusMeta(tr, value) {
  return tr.setMeta(CustomSelectionPluginKey, value);
}
function getFocusState(state2) {
  return CustomSelectionPluginKey.getState(state2);
}
const isToolbarInput = (target) => {
  return !!target?.closest(".button-text-input") || target?.classList?.contains("button-text-input");
};
const isToolbarButton = (target) => {
  return !!target?.closest(".toolbar-button") || target?.classList?.contains("toolbar-button");
};
const CustomSelection = Extension.create({
  name: "customSelection",
  addPmPlugins() {
    const editor = this.editor;
    const customSelectionPlugin = new Plugin({
      key: CustomSelectionPluginKey,
      state: {
        init: () => ({
          focused: false,
          preservedSelection: null,
          showVisualSelection: false
        }),
        apply: (tr, value) => {
          const meta = getFocusMeta(tr);
          if (meta !== void 0) {
            return { ...value, ...meta };
          }
          return value;
        }
      },
      view: () => {
        const clickHandler = (event) => handleClickOutside(event, editor);
        document?.addEventListener("mousedown", clickHandler);
        return {
          destroy: () => {
            document?.removeEventListener("mousedown", clickHandler);
          }
        };
      },
      props: {
        handleDOMEvents: {
          contextmenu: (view, event) => {
            event.preventDefault();
            const { selection } = view.state;
            if (!selection.empty) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: selection,
                  showVisualSelection: true
                })
              );
            }
            setTimeout(() => {
              view.focus();
            }, 0);
            return false;
          },
          mousedown: (view, event) => {
            if (event.button === 2) {
              event.preventDefault();
              const { selection: selection2 } = view.state;
              if (!selection2.empty) {
                view.dispatch(
                  setFocusMeta(view.state.tr, {
                    focused: true,
                    preservedSelection: selection2,
                    showVisualSelection: true
                  })
                );
                this.editor.setOptions({
                  lastSelection: selection2,
                  preservedSelection: selection2
                });
              }
              return false;
            }
            const { selection } = view.state;
            const target = event.target;
            const isElement2 = target instanceof Element;
            const isToolbarBtn = isElement2 && isToolbarButton(target);
            const isToolbarInp = isElement2 && isToolbarInput(target);
            this.editor.setOptions({
              focusTarget: target
            });
            if (isToolbarInp && !selection.empty) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: selection,
                  showVisualSelection: true
                })
              );
              this.editor.setOptions({
                lastSelection: selection,
                preservedSelection: selection
              });
              return false;
            }
            if (isToolbarBtn && !isToolbarInp) {
              if (!selection.empty) {
                this.editor.setOptions({
                  lastSelection: selection
                });
                view.dispatch(
                  setFocusMeta(view.state.tr, {
                    focused: true,
                    preservedSelection: selection,
                    showVisualSelection: true
                  })
                );
              }
              return false;
            }
            if (!isToolbarBtn && !isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false
                })
              );
              if (!selection.empty && !this.editor.options.element?.contains(target)) {
                this.editor.setOptions({
                  lastSelection: selection
                });
                const clearSelectionTr = view.state.tr.setSelection(TextSelection$1.create(view.state.doc, 0));
                view.dispatch(clearSelectionTr);
              }
            }
          },
          focus: (view) => {
            const target = this.editor.options.focusTarget;
            const isElement2 = target instanceof Element;
            const isToolbarBtn = isElement2 && isToolbarButton(target);
            const isToolbarInp = isElement2 && isToolbarInput(target);
            if (!isToolbarBtn && !isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false
                })
              );
            }
          },
          blur: (view) => {
            const target = this.editor.options.focusTarget;
            const isElement2 = target instanceof Element;
            const isToolbarBtn = isElement2 && isToolbarButton(target);
            const isToolbarInp = isElement2 && isToolbarInput(target);
            const state2 = getFocusState(view.state);
            if (isToolbarBtn || isToolbarInp) {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: true,
                  preservedSelection: state2.preservedSelection || view.state.selection,
                  showVisualSelection: true
                })
              );
            } else {
              view.dispatch(
                setFocusMeta(view.state.tr, {
                  focused: false,
                  preservedSelection: null,
                  showVisualSelection: false
                })
              );
            }
          }
        },
        decorations: (state2) => {
          const { selection, doc: doc2 } = state2;
          const focusState = getFocusState(state2);
          const shouldShowSelection = focusState.showVisualSelection && (focusState.preservedSelection || !selection.empty && focusState.focused);
          if (!shouldShowSelection) {
            return null;
          }
          const targetSelection = focusState.preservedSelection || selection;
          if (targetSelection.empty) {
            return null;
          }
          return DecorationSet.create(doc2, [
            Decoration.inline(targetSelection.from, targetSelection.to, {
              class: "sd-custom-selection"
            })
          ]);
        }
      }
    });
    return [customSelectionPlugin];
  },
  addCommands() {
    return {
      /**
       * Restore the preserved selection
       * @category Command
       * @returns {Function} Command function
       * @example
       * // Restore selection after toolbar interaction
       * restorePreservedSelection()
       * @note Used internally to maintain selection when interacting with toolbar
       */
      restorePreservedSelection: () => ({ tr, state: state2 }) => {
        const focusState = getFocusState(state2);
        if (focusState.preservedSelection) {
          return tr.setSelection(focusState.preservedSelection);
        }
        const lastSelection = this.editor.options.lastSelection;
        if (lastSelection) {
          return tr.setSelection(lastSelection);
        }
        return tr;
      }
    };
  }
});
const getLinkedStyle = (styleId, styles = []) => {
  const linkedStyle = styles.find((style2) => style2.id === styleId);
  const basedOn = linkedStyle?.definition?.attrs?.basedOn;
  const basedOnStyle = styles.find((style2) => style2.id === basedOn);
  return { linkedStyle, basedOnStyle };
};
const getSpacingStyle = (spacing) => {
  const { lineSpaceBefore, lineSpaceAfter, line, lineRule } = spacing;
  return {
    "margin-top": lineSpaceBefore + "px",
    "margin-bottom": lineSpaceAfter + "px",
    ...getLineHeightValueString(line, "", lineRule, true)
  };
};
const getSpacingStyleString = (spacing) => {
  const { lineSpaceBefore, lineSpaceAfter, line } = spacing;
  return `
    ${lineSpaceBefore ? `margin-top: ${lineSpaceBefore}px;` : ""}
    ${lineSpaceAfter ? `margin-bottom: ${lineSpaceAfter}px;` : ""}
    ${line ? getLineHeightValueString(line, "") : ""}
  `.trim();
};
const getMarksStyle = (attrs) => {
  let styles = "";
  for (const attr of attrs) {
    switch (attr.type) {
      case "bold":
        styles += `font-weight: bold; `;
        break;
      case "italic":
        styles += `font-style: italic; `;
        break;
      case "underline":
        styles += `text-decoration: underline; `;
        break;
      case "highlight":
        styles += `background-color: ${attr.attrs.color}; `;
        break;
      case "textStyle":
        const { fontFamily: fontFamily2, fontSize: fontSize2 } = attr.attrs;
        styles += `${fontFamily2 ? `font-family: ${fontFamily2};` : ""} ${fontSize2 ? `font-size: ${fontSize2};` : ""}`;
    }
  }
  return styles.trim();
};
const getQuickFormatList = (editor) => {
  if (!editor?.converter) return [];
  const styles = editor.converter.linkedStyles || [];
  return styles.filter((style2) => {
    return style2.type === "paragraph" && style2.definition.attrs;
  }).sort((a, b2) => {
    return a.definition.attrs?.name.localeCompare(b2.definition.attrs?.name);
  });
};
const generateLinkedStyleString = (linkedStyle, basedOnStyle, node2, parent, includeSpacing = true) => {
  if (!linkedStyle?.definition?.styles) return "";
  const markValue = {};
  const linkedDefinitionStyles = { ...linkedStyle.definition.styles };
  const basedOnDefinitionStyles = { ...basedOnStyle?.definition?.styles };
  const resultStyles = { ...linkedDefinitionStyles };
  if (!linkedDefinitionStyles["font-size"] && basedOnDefinitionStyles["font-size"]) {
    resultStyles["font-size"] = basedOnDefinitionStyles["font-size"];
  }
  if (!linkedDefinitionStyles["text-transform"] && basedOnDefinitionStyles["text-transform"]) {
    resultStyles["text-transform"] = basedOnDefinitionStyles["text-transform"];
  }
  Object.entries(resultStyles).forEach(([k, value]) => {
    const key = kebabCase$1(k);
    const flattenedMarks = [];
    node2?.marks?.forEach((n) => {
      if (n.type.name === "textStyle") {
        Object.entries(n.attrs).forEach(([styleKey, value2]) => {
          const parsedKey = kebabCase$1(styleKey);
          if (!value2) return;
          flattenedMarks.push({ key: parsedKey, value: value2 });
        });
        return;
      }
      flattenedMarks.push({ key: n.type.name, value: n.attrs[key] });
    });
    const mark = flattenedMarks.find((n) => n.key === key);
    const hasParentIndent = Object.keys(parent?.attrs?.indent || {});
    const hasParentSpacing = Object.keys(parent?.attrs?.spacing || {});
    const listTypes = ["orderedList", "listItem"];
    if (!mark) {
      if (key === "spacing" && includeSpacing && !hasParentSpacing) {
        const space = getSpacingStyle(value);
        Object.entries(space).forEach(([k2, v2]) => {
          markValue[k2] = v2;
        });
      } else if (key === "indent" && includeSpacing && !hasParentIndent) {
        const { leftIndent, rightIndent, firstLine } = value;
        if (leftIndent) markValue["margin-left"] = leftIndent + "px";
        if (rightIndent) markValue["margin-right"] = rightIndent + "px";
        if (firstLine) markValue["text-indent"] = firstLine + "px";
      } else if (key === "bold" && node2) {
        const val = value?.value;
        if (!listTypes.includes(node2.type.name) && val !== "0") {
          markValue["font-weight"] = "bold";
        }
      } else if (key === "text-transform" && node2) {
        if (!listTypes.includes(node2.type.name)) {
          markValue[key] = value;
        }
      } else if (key === "font-size" && node2) {
        if (!listTypes.includes(node2.type.name)) {
          markValue[key] = value;
        }
      } else if (key === "color" && node2) {
        if (!listTypes.includes(node2.type.name)) {
          markValue[key] = value;
        }
      } else if (typeof value === "string") {
        markValue[key] = value;
      }
    }
  });
  const final = Object.entries(markValue).map(([key, value]) => `${key}: ${value}`).join(";");
  return final;
};
const applyLinkedStyleToTransaction = (tr, editor, style2) => {
  if (!style2) return false;
  let selection = tr.selection;
  const state2 = editor.state;
  const focusState = CustomSelectionPluginKey.getState(state2);
  if (selection.empty && focusState?.preservedSelection) {
    selection = focusState.preservedSelection;
    tr.setSelection(selection);
  } else if (selection.empty && editor.options.lastSelection) {
    selection = editor.options.lastSelection;
    tr.setSelection(selection);
  }
  const { from: from2, to } = selection;
  const getCleanParagraphAttrs = (node2) => {
    const cleanAttrs = {};
    const preservedAttrs = ["id", "class"];
    preservedAttrs.forEach((attr) => {
      if (node2.attrs[attr] !== void 0) {
        cleanAttrs[attr] = node2.attrs[attr];
      }
    });
    cleanAttrs.styleId = style2.id;
    return cleanAttrs;
  };
  const clearFormattingMarks = (startPos, endPos) => {
    tr.doc.nodesBetween(startPos, endPos, (node2, pos) => {
      if (node2.isText && node2.marks.length > 0) {
        const marksToRemove = [
          "textStyle",
          "bold",
          "italic",
          "underline",
          "strike",
          "subscript",
          "superscript",
          "highlight"
        ];
        node2.marks.forEach((mark) => {
          if (marksToRemove.includes(mark.type.name)) {
            tr.removeMark(pos, pos + node2.nodeSize, mark);
          }
        });
      }
      return true;
    });
  };
  if (from2 === to) {
    let pos = from2;
    let paragraphNode = tr.doc.nodeAt(from2);
    if (paragraphNode?.type.name !== "paragraph") {
      const parentNode2 = findParentNode((node2) => node2.type.name === "paragraph")(selection);
      if (!parentNode2) return false;
      pos = parentNode2.pos;
      paragraphNode = parentNode2.node;
    }
    clearFormattingMarks(pos + 1, pos + paragraphNode.nodeSize - 1);
    tr.setNodeMarkup(pos, void 0, getCleanParagraphAttrs(paragraphNode));
    return true;
  }
  const paragraphPositions = [];
  tr.doc.nodesBetween(from2, to, (node2, pos) => {
    if (node2.type.name === "paragraph") {
      paragraphPositions.push({ node: node2, pos });
    }
    return true;
  });
  paragraphPositions.forEach(({ node: node2, pos }) => {
    clearFormattingMarks(pos + 1, pos + node2.nodeSize - 1);
    tr.setNodeMarkup(pos, void 0, getCleanParagraphAttrs(node2));
  });
  return true;
};
const LinkedStylesPluginKey = new PluginKey("linkedStyles");
const createLinkedStylesPlugin = (editor) => {
  return new Plugin({
    key: LinkedStylesPluginKey,
    state: {
      init() {
        if (!editor.converter || editor.options.mode !== "docx") return {};
        const styles = editor.converter?.linkedStyles || [];
        return {
          styles,
          decorations: generateDecorations(editor.state, styles)
        };
      },
      apply(tr, prev, oldEditorState, newEditorState) {
        if (!editor.converter || editor.options.mode !== "docx") return { ...prev };
        let decorations = prev.decorations || DecorationSet.empty;
        if (tr.docChanged) {
          const styles = LinkedStylesPluginKey.getState(editor.state).styles;
          decorations = generateDecorations(newEditorState, styles);
        }
        return { ...prev, decorations };
      }
    },
    props: {
      decorations(state2) {
        return LinkedStylesPluginKey.getState(state2)?.decorations;
      }
    }
  });
};
const generateDecorations = (state2, styles) => {
  const decorations = [];
  let lastStyleId = null;
  const doc2 = state2?.doc;
  doc2.descendants((node2, pos) => {
    const { name } = node2.type;
    if (node2?.attrs?.styleId) lastStyleId = node2.attrs.styleId;
    if (name === "paragraph" && !node2.attrs?.styleId) lastStyleId = null;
    if (name !== "text" && name !== "listItem" && name !== "orderedList") return;
    for (const mark of node2.marks) {
      if (mark.type.name === "textStyle" && mark.attrs.styleId) {
        lastStyleId = mark.attrs.styleId;
      }
    }
    const { linkedStyle, basedOnStyle } = getLinkedStyle(lastStyleId, styles);
    if (!linkedStyle) return;
    const $pos = state2.doc.resolve(pos);
    const parent = $pos.parent;
    const styleString = generateLinkedStyleString(linkedStyle, basedOnStyle, node2, parent);
    if (!styleString) return;
    const decoration = Decoration.inline(pos, pos + node2.nodeSize, { style: styleString });
    decorations.push(decoration);
  });
  return DecorationSet.create(doc2, decorations);
};
const LinkedStyles = Extension.create({
  name: "linkedStyles",
  priority: 1,
  // We need this plugin to run before the list plugins
  addPmPlugins() {
    return [createLinkedStylesPlugin(this.editor)];
  },
  addCommands() {
    return {
      setLinkedStyle: (style2) => (params2) => {
        const { tr } = params2;
        return applyLinkedStyleToTransaction(tr, this.editor, style2);
      },
      setStyleById: (styleId) => (params2) => {
        const { state: state2, tr } = params2;
        const pluginState = LinkedStylesPluginKey.getState(state2);
        if (!pluginState) return false;
        const style2 = pluginState.styles?.find((s) => s.id === styleId);
        if (!style2) return false;
        return applyLinkedStyleToTransaction(tr, this.editor, style2);
      }
    };
  },
  addHelpers() {
    return {
      getStyles: () => {
        const styles = LinkedStylesPluginKey.getState(this.editor.state)?.styles || [];
        return styles;
      },
      getStyleById: (styleId) => {
        const styles = this.getStyles();
        return styles.find((s) => s.id === styleId);
      },
      getLinkedStyleString: (styleId) => {
        const styles = this.editor.helpers.linkedStyles.getStyles();
        const style2 = styles.find((s) => s.id === styleId);
        if (!style2) return "";
        return generateLinkedStyleString(style2);
      }
    };
  }
});
const generateOrderedListIndex = ({ listLevel, lvlText, listNumberingType, customFormat }) => {
  const handler = listIndexMap[listNumberingType];
  return handler ? handler(listLevel, lvlText, customFormat) : null;
};
const handleDecimal = (path, lvlText) => generateNumbering(path, lvlText, String);
const handleRoman = (path, lvlText) => generateNumbering(path, lvlText, intToRoman);
const handleLowerRoman = (path, lvlText) => handleRoman(path, lvlText).toLowerCase();
const handleLowerAlpha = (path, lvlText) => handleAlpha(path, lvlText).toLowerCase();
const handleAlpha = (path, lvlText) => generateNumbering(path, lvlText, (p) => intToAlpha(p));
const handleOrdinal = (path, lvlText) => generateNumbering(path, lvlText, ordinalFormatter);
const handleCustom = (path, lvlText, customFormat) => generateFromCustom(path, lvlText, customFormat);
const listIndexMap = {
  decimal: handleDecimal,
  lowerRoman: handleLowerRoman,
  upperRoman: handleRoman,
  lowerLetter: handleLowerAlpha,
  upperLetter: handleAlpha,
  ordinal: handleOrdinal,
  custom: handleCustom
};
const createNumbering = (values, lvlText) => {
  return values.reduce((acc, value, index2) => {
    return value > 9 ? acc.replace(/^0/, "").replace(`%${index2 + 1}`, value) : acc.replace(`%${index2 + 1}`, value);
  }, lvlText);
};
const generateNumbering = (path, lvlText, formatter) => {
  const formattedValues = path.map(formatter);
  return createNumbering(formattedValues, lvlText);
};
const ordinalFormatter = (level) => {
  const suffixes = ["th", "st", "nd", "rd"];
  const value = level % 100;
  const suffix2 = suffixes[(value - 20) % 10] || suffixes[value] || suffixes[0];
  const p = level + suffix2;
  return p;
};
const generateFromCustom = (path, lvlText, customFormat) => {
  if (customFormat !== "001, 002, 003, ...") return generateNumbering(path, lvlText, String);
  const match = customFormat.match(/(\d+)/);
  if (!match) throw new Error("Invalid format string: no numeric pattern found");
  const sample = match[1];
  const digitCount = sample.length;
  const index2 = path.pop();
  return String(index2).padStart(digitCount, "0");
};
const intToRoman = (num) => {
  const romanNumeralMap = [
    { value: 1e3, numeral: "M" },
    { value: 900, numeral: "CM" },
    { value: 500, numeral: "D" },
    { value: 400, numeral: "CD" },
    { value: 100, numeral: "C" },
    { value: 90, numeral: "XC" },
    { value: 50, numeral: "L" },
    { value: 40, numeral: "XL" },
    { value: 10, numeral: "X" },
    { value: 9, numeral: "IX" },
    { value: 5, numeral: "V" },
    { value: 4, numeral: "IV" },
    { value: 1, numeral: "I" }
  ];
  let result = "";
  for (const { value, numeral } of romanNumeralMap) {
    while (num >= value) {
      result += numeral;
      num -= value;
    }
  }
  return result;
};
const intToAlpha = (num) => {
  let result = "";
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  while (num > 0) {
    let index2 = (num - 1) % 26;
    result = alphabet[index2] + result;
    num = Math.floor((num - 1) / 26);
  }
  return result;
};
const MARKER_PADDING = 6;
const MARKER_OFFSET_RIGHT = 4;
const MIN_MARKER_WIDTH = 20;
const POINT_TO_PIXEL_CONVERSION_FACTOR = 1.33;
const DEFAULT_FONT_FAMILY = "Arial, sans-serif";
const DEFAULT_FONT_SIZE = "10pt";
const activeListItemNodeViews = /* @__PURE__ */ new Set();
class ListItemNodeView {
  constructor(node2, getPos, decorations, editor) {
    __privateAdd$1(this, _ListItemNodeView_instances);
    __publicField$1(this, "handleNumberingClick", () => {
    });
    this.node = node2;
    this.editor = editor;
    this.decorations = decorations;
    this.view = editor.view;
    this.getPos = getPos;
    activeListItemNodeViews.add(this);
    __privateMethod$1(this, _ListItemNodeView_instances, init_fn2).call(this);
  }
  refreshIndentStyling() {
    const { attrs } = this.node;
    const { styleId, numId, level, indent: inlineIndent } = attrs;
    const defs = getListItemStyleDefinitions({ styleId, node: this.node, numId, level, editor: this.editor });
    const visibleIndent = getVisibleIndent(defs.stylePpr, defs.numDefPpr, inlineIndent);
    const lvlJc = defs.numLvlJs?.attributes?.["w:val"] || "left";
    const contentLeft = visibleIndent.left || 0;
    const hanging = visibleIndent.hanging || 0;
    const handlers2 = {
      right: () => {
        const calculatedWidth = calculateMarkerWidth(this.dom, this.numberingDOM, this.editor);
        const minMarkerWidth = Math.max(calculatedWidth, MIN_MARKER_WIDTH);
        const effectiveHanging = Math.max(hanging, minMarkerWidth);
        const markerLeft = contentLeft - effectiveHanging - MARKER_OFFSET_RIGHT;
        this.contentDOM.style.marginLeft = `${contentLeft}px`;
        this.numberingDOM.style.left = `${markerLeft}px`;
        this.numberingDOM.style.width = `${effectiveHanging}px`;
        this.numberingDOM.style.textAlign = "right";
      },
      left: () => {
        const calculatedWidth = calculateMarkerWidth(this.dom, this.numberingDOM, this.editor);
        const minMarkerWidth = Math.max(calculatedWidth, MIN_MARKER_WIDTH);
        let markerLeft = contentLeft - hanging;
        if (markerLeft === contentLeft) {
          markerLeft -= minMarkerWidth;
        } else if (minMarkerWidth > hanging) {
          const diff = minMarkerWidth - hanging;
          markerLeft -= diff;
        }
        this.contentDOM.style.marginLeft = `${contentLeft}px`;
        this.numberingDOM.style.left = `${markerLeft}px`;
        this.numberingDOM.style.width = "";
        this.numberingDOM.style.textAlign = "";
      }
    };
    const handleStyles = handlers2[lvlJc] ?? handlers2.left;
    handleStyles();
  }
  update(node2, decorations) {
    this.node = node2;
    this.decorations = decorations;
    const { fontSize: fontSize2, fontFamily: fontFamily2, lineHeight: lineHeight2 } = getTextStyleMarksFromLinkedStyles({
      node: node2,
      pos: this.getPos(),
      editor: this.editor
    });
    this.dom.style.fontSize = fontSize2;
    this.dom.style.fontFamily = fontFamily2 || "inherit";
    this.dom.style.lineHeight = lineHeight2 || "";
  }
  destroy() {
    activeListItemNodeViews.delete(this);
    this.numberingDOM.removeEventListener("click", this.handleNumberingClick);
  }
}
_ListItemNodeView_instances = /* @__PURE__ */ new WeakSet();
init_fn2 = function() {
  const { attrs } = this.node;
  const { listLevel, listNumberingType, lvlText, numId, level, customFormat } = attrs;
  let orderMarker = "";
  if (listLevel) {
    if (listNumberingType !== "bullet") {
      orderMarker = generateOrderedListIndex({
        listLevel,
        lvlText,
        listNumberingType,
        customFormat
      });
    } else {
      orderMarker = docxNumberigHelpers.normalizeLvlTextChar(lvlText);
    }
  }
  const pos = this.getPos();
  const { fontSize: fontSize2, fontFamily: fontFamily2, lineHeight: lineHeight2 } = getTextStyleMarksFromLinkedStyles({
    node: this.node,
    pos,
    editor: this.editor
  });
  this.dom = document.createElement("li");
  this.dom.className = "sd-editor-list-item-node-view";
  this.dom.style.fontSize = fontSize2;
  this.dom.style.fontFamily = fontFamily2 ? fontFamily2 : "inherit";
  this.dom.style.lineHeight = lineHeight2 || "";
  this.dom.setAttribute("data-marker-type", orderMarker);
  this.dom.setAttribute("data-num-id", numId);
  this.dom.setAttribute("data-list-level", JSON.stringify(listLevel));
  this.dom.setAttribute("data-list-numbering-type", listNumberingType);
  this.dom.setAttribute("data-level", level);
  this.numberingDOM = document.createElement("span");
  this.numberingDOM.className = "sd-editor-list-item-numbering";
  this.numberingDOM.textContent = orderMarker;
  this.numberingDOM.setAttribute("contenteditable", "false");
  this.numberingDOM.addEventListener("click", this.handleNumberingClick);
  this.contentDOM = document.createElement("div");
  this.contentDOM.className = "sd-editor-list-item-content-dom";
  this.dom.appendChild(this.numberingDOM);
  this.dom.appendChild(this.contentDOM);
  this.refreshIndentStyling();
};
function refreshAllListItemNodeViews() {
  activeListItemNodeViews.forEach((nodeView) => {
    try {
      nodeView.refreshIndentStyling();
    } catch (error) {
      console.error("Error refreshing list item node view:", error);
      activeListItemNodeViews.delete(nodeView);
    }
  });
}
function getListItemTextStyleMarks(listItem, markType) {
  let textStyleMarks = [];
  let attrs = {};
  listItem.forEach((childNode) => {
    if (childNode.type.name !== "paragraph") return;
    attrs.lineHeight = childNode.attrs.lineHeight;
    childNode.forEach((textNode) => {
      let isTextNode = textNode.type.name === "text";
      let hasTextStyleMarks = markType.isInSet(textNode.marks);
      if (isTextNode && hasTextStyleMarks) {
        let marks = textNode.marks.filter((mark) => mark.type === markType);
        textStyleMarks.push(...marks);
      }
    });
  });
  return {
    marks: textStyleMarks,
    attrs
  };
}
function getTextStyleMarksFromLinkedStyles({ node: node2, pos, editor }) {
  const { font: defaultFont, size: defaultSize } = getStylesFromLinkedStyles({ node: node2, pos, editor });
  const textStyleType = getMarkType("textStyle", editor.schema);
  const { marks: allMarks, attrs: allAttrs } = getListItemTextStyleMarks(node2, textStyleType);
  const styleMarks = allMarks.filter((m2) => m2.type === textStyleType);
  const sizeMark = styleMarks.find((m2) => m2.attrs.fontSize);
  const familyMark = styleMarks.find((m2) => m2.attrs.fontFamily);
  const lineHeight2 = allAttrs.lineHeight;
  let fontSize2 = sizeMark ? (() => {
    const [value, unit = "pt"] = parseSizeUnit(sizeMark.attrs.fontSize);
    return Number.isNaN(value) ? defaultSize : `${value}${unit}`;
  })() : defaultSize;
  let fontFamily2 = familyMark?.attrs.fontFamily ?? defaultFont;
  const firstChild = node2.firstChild;
  const hasOnlyOnePar = node2.childCount === 1 && firstChild?.type.name === "paragraph";
  if (hasOnlyOnePar) {
    const par = firstChild;
    const parFirstChild = par?.firstChild;
    if (par?.childCount === 1 && parFirstChild?.type.name === "fieldAnnotation") {
      const aFontSize = parFirstChild.attrs.fontSize;
      const aFontFamily = parFirstChild.attrs.fontFamily;
      if (!sizeMark && aFontSize) fontSize2 = aFontSize;
      if (!familyMark && aFontFamily) fontFamily2 = aFontFamily;
    }
  }
  return { fontSize: fontSize2, fontFamily: fontFamily2, lineHeight: lineHeight2 };
}
const getStylesFromLinkedStyles = ({ node: node2, pos, editor }) => {
  const { state: state2 } = editor.view;
  const linkedStyles = LinkedStylesPluginKey.getState(state2)?.decorations;
  const decorationsInPlace = linkedStyles?.find(pos, pos + node2.nodeSize);
  const predicates = [
    (style22) => style22.includes("font-size") && style22.includes("font-family"),
    (style22) => style22.includes("font-size"),
    (style22) => style22.includes("font-family")
  ];
  let styleDeco;
  for (const predicateFn of predicates) {
    styleDeco = decorationsInPlace?.find((dec) => {
      const style22 = dec.type.attrs?.style || "";
      return style22 && predicateFn(style22);
    });
    if (styleDeco) break;
  }
  const style2 = styleDeco?.type.attrs?.style;
  const stylesArray = style2?.split(";") || [];
  const fontSizeFromStyles = stylesArray.find((s) => s.includes("font-size"))?.split(":")[1].trim();
  const fontFamilyFromStyles = stylesArray.find((s) => s.includes("font-family"))?.split(":")[1].trim();
  return {
    font: fontFamilyFromStyles,
    size: fontSizeFromStyles
  };
};
const getVisibleIndent = (stylePpr, numDefPpr, inlineIndent) => {
  const styleIndentTag = stylePpr?.elements?.find((el) => el.name === "w:ind") || {};
  const styleIndent = parseIndentElement(styleIndentTag);
  const numDefIndentTag = numDefPpr?.elements?.find((el) => el.name === "w:ind") || {};
  const numDefIndent = parseIndentElement(numDefIndentTag);
  const indent = combineIndents(styleIndent, numDefIndent);
  const result = combineIndents(indent, inlineIndent);
  return result;
};
function calculateMarkerWidth(dom, numberingDOM, editor, { withPadding = true } = {}) {
  const markerText = numberingDOM.textContent || "";
  const fontSize2 = dom.style.fontSize || DEFAULT_FONT_SIZE;
  const fontValue = dom.style.fontFamily;
  const fontFamily2 = fontValue && fontValue !== "inherit" ? fontValue : DEFAULT_FONT_FAMILY;
  if (!markerText.trim()) return 0;
  try {
    if (editor?.options?.isHeadless) return 0;
    const canvas = document.createElement("canvas");
    const context = canvas.getContext("2d");
    const fontSizePx = fontSize2.includes("pt") ? Number.parseFloat(fontSize2) * POINT_TO_PIXEL_CONVERSION_FACTOR : Number.parseFloat(fontSize2);
    context.font = `${fontSizePx}px ${fontFamily2}`;
    const textWidth = context.measureText(markerText).width;
    const resultWidth = withPadding ? Math.ceil(textWidth + MARKER_PADDING) : Math.ceil(textWidth);
    return resultWidth;
  } catch {
    return 0;
  }
}
const orderedListSyncPluginKey = new PluginKey("orderedListSync");
function orderedListSync(editor) {
  let hasInitialized = false;
  const docx = editor.converter.convertedXml;
  return new Plugin({
    key: orderedListSyncPluginKey,
    appendTransaction(transactions, oldState, newState) {
      const updateNodeViews = transactions.some((tr2) => tr2.getMeta("updatedListItemNodeViews"));
      if (updateNodeViews || !hasInitialized) refreshAllListItemNodeViews();
      const isFromPlugin = transactions.some((tr2) => tr2.getMeta("orderedListSync"));
      if (isFromPlugin || !transactions.some((tr2) => tr2.docChanged)) {
        return null;
      }
      hasInitialized = true;
      const tr = newState.tr;
      tr.setMeta("orderedListSync", true);
      const listMap = /* @__PURE__ */ new Map();
      const listInitialized = /* @__PURE__ */ new Map();
      const shouldProcess = transactions.some((tr2) => {
        return tr2.steps.some((step) => {
          const stepJSON = step.toJSON();
          const hasUpdateMeta = tr2.getMeta("updateListSync");
          return hasUpdateMeta || stepJSON && stepJSON.slice && JSON.stringify(stepJSON).includes('"listItem"');
        });
      });
      if (!shouldProcess) return null;
      newState.doc.descendants((node2, pos) => {
        if (node2.type.name !== "listItem") return;
        const { level: attrLvl, numId: attrNumId, styleId } = node2.attrs;
        const level = parseInt(attrLvl);
        const numId = parseInt(attrNumId);
        let {
          lvlText,
          customFormat,
          listNumberingType,
          start: numberingDefStart
        } = ListHelpers.getListDefinitionDetails({ numId, level, editor });
        const start2 = parseInt(numberingDefStart) || 1;
        if (!listMap.has(numId)) {
          const generatedLevels = {};
          const initialPath = docxNumberigHelpers.generateListPath(level, numId, styleId, generatedLevels, docx);
          listMap.set(numId, initialPath || []);
          listInitialized.set(numId, false);
        }
        let currentListLevels = [...listMap.get(numId)];
        if (!listInitialized.get(numId)) {
          listInitialized.set(numId, true);
          if (typeof start2 === "number") {
            while (currentListLevels.length <= level) {
              currentListLevels.push(0);
            }
            currentListLevels[level] = start2;
            for (let i = level + 1; i < currentListLevels.length; i++) {
              currentListLevels[i] = 0;
            }
          }
        } else {
          while (currentListLevels.length <= level) {
            currentListLevels.push(0);
          }
          currentListLevels[level] = (currentListLevels[level] || 0) + 1;
          for (let i = level + 1; i < currentListLevels.length; i++) {
            currentListLevels[i] = 0;
          }
        }
        if (currentListLevels.length === 0) {
          currentListLevels = [1];
        }
        listMap.set(numId, currentListLevels);
        const updatedAttrs = {
          ...node2.attrs,
          listLevel: [...currentListLevels],
          level,
          lvlText,
          listNumberingType,
          customFormat
        };
        const keysChanged = Object.keys(updatedAttrs).some((key) => node2.attrs[key] !== updatedAttrs[key]);
        if (keysChanged) {
          tr.setNodeMarkup(pos, void 0, updatedAttrs);
        }
      });
      return tr;
    }
  });
}
const ListItem = Node$1.create({
  name: "listItem",
  content: "paragraph* block*",
  defining: true,
  priority: 101,
  // to run listItem commands first
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "List item node"
      },
      bulletListTypeName: "bulletList",
      orderedListTypeName: "orderedList"
    };
  },
  parseDOM() {
    return [{ tag: "li" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["li", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addPmPlugins() {
    return this.editor?.converter?.convertedXml ? [orderedListSync(this.editor)] : [];
  },
  /**
   * Important: The listItem node uses a custom node view.
   * @returns {import('@core/NodeView.js').NodeView}
   */
  addNodeView() {
    return ({ node: node2, editor, getPos, decorations }) => {
      return new ListItemNodeView(node2, getPos, decorations, editor);
    };
  },
  addAttributes() {
    return {
      // Virtual attribute.
      markerType: {
        default: null,
        renderDOM: (attrs) => {
          let { listLevel, listNumberingType, lvlText } = attrs;
          let hasListLevel = !!listLevel?.length;
          if (!hasListLevel || !lvlText) {
            return {};
          }
          let orderMarker = generateOrderedListIndex({
            listLevel,
            lvlText,
            listNumberingType
          });
          if (!orderMarker) return {};
          return {
            "data-marker-type": orderMarker
          };
        }
      },
      lvlText: {
        default: null,
        keepOnSplit: true,
        parseDOM: (elem) => elem.getAttribute("data-lvl-text"),
        renderDOM: (attrs) => {
          if (!attrs.lvlText) return {};
          return {
            "data-lvl-text": attrs.lvlText
          };
        }
      },
      listNumberingType: {
        default: null,
        keepOnSplit: true,
        parseDOM: (elem) => elem.getAttribute("data-num-fmt"),
        renderDOM: (attrs) => {
          if (!attrs.listNumberingType) return {};
          return {
            "data-num-fmt": attrs.listNumberingType
          };
        }
      },
      listLevel: {
        default: null,
        parseDOM: (elem) => {
          let listLevel = elem.getAttribute("data-list-level");
          try {
            listLevel = JSON.parse(listLevel);
          } catch {
          }
          return listLevel;
        },
        renderDOM: (attrs) => {
          if (!attrs.listLevel) return {};
          return {
            "data-list-level": JSON.stringify(attrs.listLevel)
          };
        }
      },
      // JC = justification. Expect left, right, center
      lvlJc: {
        keepOnSplit: true,
        default: null,
        rendered: false
      },
      // This will contain indentation and space info.
      // ie: w:left (left indent), w:hanging (hanging indent)
      listParagraphProperties: {
        keepOnSplit: true,
        default: null,
        rendered: false
      },
      // This will contain run properties for the list item
      listRunProperties: {
        keepOnSplit: true,
        default: null,
        rendered: false
      },
      numId: {
        keepOnSplit: true,
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-num-id"),
        renderDOM: (attrs) => {
          if (!attrs.numId) return {};
          return {
            "data-num-id": attrs.numId
          };
        }
      },
      numPrType: {
        rendered: false,
        default: "inline",
        keepOnSplit: true
      },
      level: {
        parseDOM: (elem) => {
          return elem.getAttribute("data-level");
        },
        renderDOM: (attrs) => {
          if (attrs.level === void 0 || attrs.level === null) return {};
          return {
            "data-level": attrs.level
          };
        }
      },
      attributes: {
        keepOnSplit: true,
        rendered: false
      },
      spacing: {
        keepOnSplit: true,
        default: null,
        rendered: false
      },
      indent: {
        parseDOM: (elem) => JSON.parse(elem.getAttribute("data-indent")),
        keepOnSplit: true,
        default: null,
        rendered: false
      },
      markerStyle: {
        default: null,
        rendered: false,
        keepOnSplit: true
      },
      styleId: {
        rendered: false,
        keepOnSplit: true
      },
      customFormat: {
        default: null,
        rendered: false,
        keepOnSplit: true
      },
      importedFontFamily: {
        parseDOM: (elem) => elem.getAttribute("data-font-family"),
        renderDOM: (attrs) => {
          if (!attrs.importedFontFamily) return {};
          return {
            "data-font-family": attrs.importedFontFamily
          };
        }
      },
      importedFontSize: {
        parseDOM: (elem) => elem.getAttribute("data-font-size"),
        renderDOM: (attrs) => {
          if (!attrs.importedFontSize) return {};
          return {
            "data-font-size": attrs.importedFontSize
          };
        }
      }
    };
  },
  addShortcuts() {
    return {
      Enter: () => {
        return this.editor.commands.splitListItem();
      },
      "Shift-Enter": () => {
        return this.editor.commands.first(({ commands: commands2 }) => [
          () => commands2.createParagraphNear(),
          () => commands2.splitBlock()
        ]);
      },
      Tab: () => {
        return this.editor.commands.first(({ commands: commands2 }) => [() => commands2.increaseListIndent()]);
      },
      "Shift-Tab": () => {
        return this.editor.commands.first(({ commands: commands2 }) => [() => commands2.decreaseListIndent()]);
      }
    };
  }
});
const getDefaultSpacing = () => ({
  lineSpaceAfter: 0,
  lineSpaceBefore: 0,
  line: 0,
  lineRule: null
});
const Paragraph = Node$1.create({
  name: "paragraph",
  priority: 1e3,
  group: "block",
  content: "inline*",
  inline: false,
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      spacing: {
        default: getDefaultSpacing(),
        renderDOM: (attrs) => {
          const { spacing } = attrs;
          if (!spacing) return {};
          const spacingCopy = { ...spacing };
          if (attrs.lineHeight) delete spacingCopy.line;
          const style2 = getSpacingStyleString(spacingCopy);
          if (style2) return { style: style2 };
          return {};
        }
      },
      extraAttrs: {
        default: {},
        parseDOM: (element) => {
          const extra = {};
          Array.from(element.attributes).forEach((attr) => {
            extra[attr.name] = attr.value;
          });
          return extra;
        },
        renderDOM: (attributes) => {
          return attributes.extraAttrs || {};
        }
      },
      marksAttrs: {
        renderDOM: (attrs) => {
          const { marksAttrs } = attrs;
          if (!marksAttrs?.length) return {};
          const style2 = getMarksStyle(marksAttrs);
          if (style2) return { style: style2 };
          return {};
        }
      },
      indent: {
        default: null,
        renderDOM: ({ indent }) => {
          if (!indent) return {};
          const { left: left2, right: right2, firstLine, hanging } = indent;
          if (indent && Object.values(indent).every((v2) => v2 === 0)) {
            return {};
          }
          let style2 = "";
          if (left2) style2 += `margin-left: ${left2}px;`;
          if (right2) style2 += `margin-right: ${right2}px;`;
          if (firstLine && !hanging) style2 += `text-indent: ${firstLine}px;`;
          if (firstLine && hanging) style2 += `text-indent: ${firstLine - hanging}px;`;
          if (!firstLine && hanging) style2 += `text-indent: ${-hanging}px;`;
          return { style: style2 };
        }
      },
      class: {
        renderDOM: (attributes) => {
          if (attributes.dropcap) {
            return { class: `sd-editor-dropcap` };
          }
          return null;
        }
      },
      styleId: {},
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      attributes: {
        rendered: false
      },
      filename: { rendered: false },
      rsidRDefault: { rendered: false },
      keepLines: { rendered: false },
      keepNext: { rendered: false },
      paragraphProperties: { rendered: false },
      dropcap: { rendered: false },
      pageBreakSource: { rendered: false },
      justify: {
        renderDOM: ({ justify }) => {
          const { val: jc } = justify || {};
          if (!jc) return {};
          let style2 = "";
          if (jc === "left") style2 += "text-align: left;";
          else if (jc === "right") style2 += "text-align: right;";
          else if (jc === "center") style2 += "text-align: center;";
          else if (jc === "both") style2 += "text-align: justify;";
          return { style: style2 };
        }
      },
      tabStops: { rendered: false }
    };
  },
  parseDOM() {
    return [
      {
        tag: "p",
        getAttrs: (node2) => {
          let extra = {};
          Array.from(node2.attributes).forEach((attr) => {
            extra[attr.name] = attr.value;
          });
          return { extraAttrs: extra };
        }
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["p", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addPmPlugins() {
    const { view } = this.editor;
    const dropcapPlugin = new Plugin({
      name: "dropcapPlugin",
      key: new PluginKey("dropcapPlugin"),
      state: {
        init(_2, state2) {
          let decorations = getDropcapDecorations(state2, view);
          return DecorationSet.create(state2.doc, decorations);
        },
        apply(tr, oldDecorationSet, oldState, newState) {
          if (!tr.docChanged) return oldDecorationSet;
          const decorations = getDropcapDecorations(newState, view);
          return DecorationSet.create(newState.doc, decorations);
        }
      },
      props: {
        decorations(state2) {
          return this.getState(state2);
        }
      }
    });
    return [dropcapPlugin];
  }
});
const getDropcapDecorations = (state2, view) => {
  let decorations = [];
  state2.doc.descendants((node2, pos) => {
    if (node2.type.name === "paragraph") {
      if (node2.attrs.dropcap?.type === "margin") {
        const width = getDropcapWidth(view, pos);
        decorations.push(Decoration.inline(pos, pos + node2.nodeSize, { style: `margin-left: -${width}px;` }));
      }
      return false;
    }
  });
  return decorations;
};
function getDropcapWidth(view, pos) {
  const domNode = view.nodeDOM(pos);
  if (domNode) {
    const range2 = document.createRange();
    range2.selectNodeContents(domNode);
    return range2.getBoundingClientRect().width;
  }
  return 0;
}
const Heading = Node$1.create({
  name: "heading",
  group: "block",
  content: "inline*",
  defining: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} HeadingOptions
       * @category Options
       * @property {number[]} [levels=[1,2,3,4,5,6]] - Supported heading levels
       * @property {Object} [htmlAttributes] - HTML attributes for heading elements
       */
      levels: [1, 2, 3, 4, 5, 6],
      htmlAttributes: {
        "aria-label": "Heading node"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {number} [level=1] - Heading level from 1 (largest) to 6 (smallest)
       */
      level: {
        default: 1,
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {Object} [tabStops] - Internal tab stop configuration
       */
      tabStops: { rendered: false },
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking ID
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      }
    };
  },
  parseDOM() {
    return this.options.levels.map((level) => ({
      tag: `h${level}`,
      attrs: { level }
    }));
  },
  renderDOM({ node: node2, htmlAttributes }) {
    const hasLevel = this.options.levels.includes(node2.attrs.level);
    const level = hasLevel ? node2.attrs.level : this.options.levels[0];
    return [`h${level}`, Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Set a heading with specified level
       * @category Command
       * @param {HeadingAttributes} attributes - Heading attributes including level
       * @returns {Function} Command function
       * @example
       * // Set heading level 2
       * setHeading({ level: 2 })
       * @note Converts current block to heading
       */
      setHeading: (attributes) => ({ commands: commands2 }) => {
        const containsLevel = this.options.levels.includes(attributes.level);
        if (!containsLevel) return false;
        return commands2.setNode(this.name, attributes);
      },
      /**
       * Toggle between heading and paragraph
       * @category Command
       * @param {HeadingAttributes} attributes - Heading attributes including level
       * @returns {Function} Command function
       * @example
       * // Toggle heading level 1
       * toggleHeading({ level: 1 })
       *
       * // Toggle heading level 3
       * toggleHeading({ level: 3 })
       * @note Switches between heading and paragraph for the same level
       */
      toggleHeading: (attributes) => ({ commands: commands2 }) => {
        const containsLevel = this.options.levels.includes(attributes.level);
        if (!containsLevel) return false;
        return commands2.toggleNode(this.name, "paragraph", attributes);
      }
    };
  },
  addShortcuts() {
    return this.options.levels.reduce(
      (items, level) => ({
        ...items,
        ...{
          [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level })
        }
      }),
      {}
    );
  }
});
const CommentRangeStart = Node$1.create({
  name: "commentRangeStart",
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  parseDOM() {
    return [{ tag: "commentRangeStart" }];
  },
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: "false",
        "aria-label": "Comment range start node"
      }
    };
  },
  renderDOM({ htmlAttributes }) {
    return ["commentRangeStart", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      "w:id": {
        rendered: false
      },
      internal: {
        default: true,
        rendered: false
      }
    };
  }
});
const CommentRangeEnd = Node$1.create({
  name: "commentRangeEnd",
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: "false",
        "aria-label": "Comment range end node"
      }
    };
  },
  parseDOM() {
    return [{ tag: "commentRangeEnd" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["commentRangeEnd", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      "w:id": {
        rendered: false
      }
    };
  }
});
const CommentReference = Node$1.create({
  name: "commentReference",
  group: "inline",
  inline: true,
  atom: true,
  selectable: false,
  draggable: false,
  addOptions() {
    return {
      htmlAttributes: {
        contentEditable: "false",
        "aria-label": "Comment reference node"
      }
    };
  },
  parseDOM() {
    return [{ tag: "commentReference" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["commentReference", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addAttributes() {
    return {
      attributes: {
        rendered: false
      }
    };
  }
});
const CommentsMark = Mark2.create({
  name: CommentMarkName,
  group: "comments",
  excludes: "",
  addOptions() {
    return {
      htmlAttributes: { class: "sd-editor-comment" }
    };
  },
  addAttributes() {
    return {
      commentId: {},
      importedId: {},
      internal: {
        default: true,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: CommentMarkName }];
  },
  renderDOM({ htmlAttributes }) {
    return [CommentMarkName, Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  }
});
const TabNode = Node$1.create({
  name: "tab",
  group: "inline",
  inline: true,
  // need this prop so Prosemirror doesn't treat tab as an
  // empty node and doesn't insert separator after
  content: "inline*",
  selectable: false,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-tab",
        // this works together with content prop:
        // since tab can't have content inside but content prop is defined I have to manually add attribute
        contentEditable: false
      }
    };
  },
  parseDOM() {
    return [{ tag: "span.sd-editor-tab" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      tabSize: {
        renderDOM: ({ tabSize }) => {
          if (!tabSize) return {};
          const style2 = `width: ${tabSize}px; min-width: ${tabSize}px;`;
          return { style: style2 };
        }
      }
    };
  },
  addPmPlugins() {
    const { view, schema } = this.editor;
    const domSerializer = DOMSerializer.fromSchema(schema);
    const tabPlugin = new Plugin({
      name: "tabPlugin",
      key: new PluginKey("tabPlugin"),
      state: {
        init() {
          return { decorations: false };
        },
        apply(tr, { decorations }, _oldState, newState) {
          if (!decorations) {
            decorations = DecorationSet.create(
              newState.doc,
              getTabDecorations(newState.doc, StepMap.empty, view, domSerializer)
            );
          }
          if (!tr.docChanged) {
            return { decorations };
          }
          decorations = decorations.map(tr.mapping, tr.doc);
          let rangesToRecalculate = [];
          tr.steps.forEach((step, index2) => {
            const stepMap = step.getMap();
            if (step instanceof ReplaceStep || step instanceof ReplaceAroundStep$1) {
              const $from = tr.docs[index2].resolve(step.from);
              const $to = tr.docs[index2].resolve(step.to);
              const start2 = $from.start(Math.min($from.depth, 1));
              const end2 = $to.end(Math.min($to.depth, 1));
              let addRange2 = false;
              tr.docs[index2].nodesBetween(start2, end2, (node2) => {
                if (node2.type.name === "tab") {
                  addRange2 = true;
                }
              });
              if (!addRange2 && step.slice?.content) {
                step.slice.content.descendants((node2) => {
                  if (node2.type.name === "tab") {
                    addRange2 = true;
                  }
                });
              }
              if (addRange2) {
                rangesToRecalculate.push([start2, end2]);
              }
            }
            rangesToRecalculate = rangesToRecalculate.map(([from2, to]) => {
              const mappedFrom = stepMap.map(from2, -1);
              const mappedTo = stepMap.map(to, 1);
              return [mappedFrom, mappedTo];
            });
          });
          rangesToRecalculate.forEach(([start2, end2]) => {
            const oldDecorations = decorations.find(start2, end2);
            decorations = decorations.remove(oldDecorations);
            const invertMapping = tr.mapping.invert();
            const newDecorations = getTabDecorations(newState.doc, invertMapping, view, domSerializer, start2, end2);
            decorations = decorations.add(newState.doc, newDecorations);
          });
          return { decorations };
        }
      },
      props: {
        decorations(state2) {
          return this.getState(state2).decorations;
        }
      }
    });
    return [tabPlugin];
  }
});
const defaultTabDistance = 48;
const defaultLineLength = 816;
const getTabDecorations = (doc2, invertMapping, view, domSerializer, from2 = 0, to = null) => {
  if (!to) {
    to = doc2.content.size;
  }
  const nodeWidthCache = {};
  let decorations = [];
  doc2.nodesBetween(from2, to, (node2, pos, parent) => {
    if (node2.type.name === "tab") {
      let extraStyles = "";
      const $pos = doc2.resolve(pos);
      const tabIndex = $pos.index($pos.depth);
      const fistlineIndent = parent.attrs?.indent?.firstLine || 0;
      const currentWidth = calcChildNodesWidth(
        parent,
        pos - $pos.parentOffset,
        0,
        tabIndex,
        domSerializer,
        view,
        invertMapping,
        nodeWidthCache
      ) + fistlineIndent;
      let tabWidth;
      if ($pos.depth === 1 && parent.attrs.tabStops && parent.attrs.tabStops.length > 0) {
        const tabStop = parent.attrs.tabStops.find((tabStop2) => tabStop2.pos > currentWidth && tabStop2.val !== "clear");
        if (tabStop) {
          tabWidth = tabStop.pos - currentWidth;
          if (["end", "center"].includes(tabStop.val)) {
            let nextTabIndex = tabIndex + 1;
            while (nextTabIndex < parent.childCount && parent.child(nextTabIndex).type.name !== "tab") {
              nextTabIndex++;
            }
            const tabSectionWidth = calcChildNodesWidth(
              parent,
              pos - $pos.parentOffset,
              tabIndex,
              nextTabIndex,
              domSerializer,
              view,
              invertMapping,
              nodeWidthCache
            );
            tabWidth -= tabStop.val === "end" ? tabSectionWidth : tabSectionWidth / 2;
          } else if (["decimal", "num"].includes(tabStop.val)) {
            const breakChar = ".";
            let nodeIndex = tabIndex + 1;
            let integralWidth = 0;
            let nodePos = pos - $pos.parentOffset;
            while (nodeIndex < parent.childCount) {
              const node22 = parent.child(nodeIndex);
              if (node22.type.name === "tab") {
                break;
              }
              const oldPos = invertMapping.map(nodePos);
              if (node22.type.name === "text" && node22.text.includes(breakChar)) {
                const modifiedNode = node22.cut(0, node22.text.indexOf(breakChar));
                integralWidth += calcNodeWidth(domSerializer, modifiedNode, view, oldPos);
                break;
              }
              integralWidth += calcNodeWidth(domSerializer, node22, view, oldPos);
              nodeWidthCache[nodePos] = integralWidth;
              nodePos += node22.nodeSize;
              nodeIndex += 1;
            }
            tabWidth -= integralWidth;
          }
          if (tabStop.leader) {
            if (tabStop.leader === "dot") {
              extraStyles += `border-bottom: 1px dotted black;`;
            } else if (tabStop.leader === "heavy") {
              extraStyles += `border-bottom: 2px solid black;`;
            } else if (tabStop.leader === "hyphen") {
              extraStyles += `border-bottom: 1px solid black;`;
            } else if (tabStop.leader === "middleDot") {
              extraStyles += `border-bottom: 1px dotted black; margin-bottom: 2px;`;
            } else if (tabStop.leader === "underscore") {
              extraStyles += `border-bottom: 1px solid black;`;
            }
          }
        }
      }
      if (!tabWidth || tabWidth < 1) {
        tabWidth = defaultTabDistance - currentWidth % defaultLineLength % defaultTabDistance;
        if (tabWidth === 0) {
          tabWidth = defaultTabDistance;
        }
      }
      nodeWidthCache[pos] = tabWidth;
      const tabHeight = calcTabHeight($pos);
      decorations.push(
        Decoration.node(pos, pos + node2.nodeSize, {
          style: `width: ${tabWidth}px; height: ${tabHeight};${extraStyles}`
        })
      );
    }
  });
  return decorations;
};
function calcNodeWidth(domSerializer, node2, view, oldPos) {
  const oldDomNode = view.nodeDOM(oldPos);
  const styleReference = oldDomNode ? oldDomNode.nodeName === "#text" ? oldDomNode.parentNode : oldDomNode : view.dom;
  const temp = document.createElement("div");
  const style2 = window.getComputedStyle(styleReference);
  temp.style.cssText = `
        position: absolute;
        top: -9999px;
        left: -9999px;
        white-space: nowrap;
        font-family: ${style2.fontFamily};
        font-size: ${style2.fontSize};
        font-weight: ${style2.fontWeight};
        font-style: ${style2.fontStyle};
        letter-spacing: ${style2.letterSpacing};
        word-spacing: ${style2.wordSpacing};
        text-transform: ${style2.textTransform};
        display: inline-block;
    `;
  const domNode = domSerializer.serializeNode(node2);
  temp.appendChild(domNode);
  document.body.appendChild(temp);
  const width = temp.offsetWidth;
  document.body.removeChild(temp);
  return width;
}
function calcChildNodesWidth(parent, parentPos, startIndex, endIndex, domSerializer, view, invertMapping, nodeWidthCache) {
  let pos = parentPos;
  let width = 0;
  for (let i = 0; i < endIndex; i++) {
    const node2 = parent.child(i);
    if (i >= startIndex) {
      if (!nodeWidthCache[pos]) {
        nodeWidthCache[pos] = calcNodeWidth(domSerializer, node2, view, invertMapping.map(pos));
      }
      width += nodeWidthCache[pos];
    }
    pos += node2.nodeSize;
  }
  return width;
}
function calcTabHeight(pos) {
  const ptToPxRatio = 1.333;
  const defaultFontSize = 16;
  const defaultLineHeight = 1.1;
  const blockParent2 = pos.node(1);
  const parentTextStyleMark = blockParent2.firstChild.marks.find((mark) => mark.type.name === "textStyle");
  const fontSize2 = parseInt(parentTextStyleMark?.attrs.fontSize) * ptToPxRatio || defaultFontSize;
  return `${fontSize2 * defaultLineHeight}px`;
}
const LineBreak = Node$1.create({
  name: "lineBreak",
  group: "inline",
  inline: true,
  marks: "",
  defining: true,
  selectable: false,
  content: "",
  atom: true,
  parseDOM() {
    return [{ tag: "br" }];
  },
  renderDOM() {
    return ["br", {}];
  },
  addCommands() {
    return {
      /**
       * Insert a line break
       * @category Command
       * @returns {Function} Command function
       * @example
       * insertLineBreak()
       * @note Creates a soft break within the same paragraph
       */
      insertLineBreak: () => ({ commands: commands2 }) => {
        return commands2.insertContent({ type: "lineBreak" });
      }
    };
  }
});
const HardBreak = Node$1.create({
  name: "hardBreak",
  group: "inline",
  inline: true,
  selectable: false,
  atom: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} HardBreakOptions
       * @category Options
       * @property {Object} [htmlAttributes] - HTML attributes for the break element
       */
      htmlAttributes: {
        contentEditable: "false",
        lineBreakType: "page",
        "aria-hidden": "true",
        "aria-label": "Hard break node"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @private
       * @category Attribute
       * @param {string} [pageBreakSource] - Source of the page break
       */
      pageBreakSource: {
        rendered: false,
        default: null
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [pageBreakType] - Type of page break
       */
      pageBreakType: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: 'span[linebreaktype="page"]',
        getAttrs: (dom) => {
          if (!(dom instanceof HTMLElement)) return false;
          return {
            pageBreakSource: dom.getAttribute("pagebreaksource") || null,
            pageBreakType: dom.getAttribute("linebreaktype") || null
          };
        }
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      /**
       * Insert a page break
       * @category Command
       * @returns {Function} Command function
       * @example
       * insertPageBreak()
       * @note Forces content to start on a new page when printed
       */
      insertPageBreak: () => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: "hardBreak",
          attrs: { pageBreakType: "page" }
        });
      }
    };
  }
});
const createTableView = ({ editor }) => {
  return class TableView {
    constructor(node2, cellMinWidth) {
      __publicField$1(this, "editor");
      __publicField$1(this, "node");
      __publicField$1(this, "dom");
      __publicField$1(this, "table");
      __publicField$1(this, "colgroup");
      __publicField$1(this, "contentDOM");
      __publicField$1(this, "cellMinWidth");
      this.editor = editor;
      this.node = node2;
      this.cellMinWidth = cellMinWidth;
      this.dom = document.createElement("div");
      this.dom.className = "tableWrapper";
      this.table = this.dom.appendChild(document.createElement("table"));
      this.colgroup = this.table.appendChild(document.createElement("colgroup"));
      updateTable(this.editor, this.node, this.table);
      updateColumns(node2, this.colgroup, this.table, cellMinWidth);
      this.contentDOM = this.table.appendChild(document.createElement("tbody"));
      setTimeout(() => {
        updateTableWrapper(this.dom, this.table);
      }, 0);
    }
    update(node2) {
      if (node2.type !== this.node.type) {
        return false;
      }
      this.node = node2;
      updateTable(this.editor, node2, this.table);
      updateColumns(node2, this.colgroup, this.table, this.cellMinWidth);
      updateTableWrapper(this.dom, this.table);
      return true;
    }
    ignoreMutation(mutation) {
      const tableWrapper = this.dom;
      if (mutation.target === tableWrapper && mutation.type === "attributes" && mutation.attributeName === "style") {
        return true;
      }
      return mutation.type === "attributes" && (mutation.target === this.table || this.colgroup.contains(mutation.target));
    }
  };
};
function updateColumns(node2, colgroup, table, cellMinWidth, overrideCol, overrideValue) {
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node2.firstChild;
  if (row !== null) {
    for (let i = 0, col = 0; i < row.childCount; i++) {
      const { colspan, colwidth } = row.child(i).attrs;
      for (let j2 = 0; j2 < colspan; j2++, col++) {
        const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j2];
        const cssWidth = hasWidth ? `${hasWidth}px` : "";
        totalWidth += hasWidth || cellMinWidth;
        if (!hasWidth) fixedWidth = false;
        if (!nextDOM) {
          const col2 = document.createElement("col");
          const [propKey, propVal] = getColStyleDeclaration(cellMinWidth, hasWidth);
          col2.style.setProperty(propKey, propVal);
          colgroup.appendChild(col2);
        } else {
          if (nextDOM.style.width !== cssWidth) {
            const [propKey, propVal] = getColStyleDeclaration(cellMinWidth, hasWidth);
            nextDOM.style.setProperty(propKey, propVal);
          }
          nextDOM = nextDOM.nextSibling;
        }
      }
    }
  }
  while (nextDOM) {
    const after = nextDOM.nextSibling;
    nextDOM.parentNode?.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = `${totalWidth}px`;
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = `${totalWidth}px`;
  }
}
function updateTable(editor, node2, table) {
  const allExtensionsAttrs = editor.extensionService.attributes;
  const tableExtensionAttrs = allExtensionsAttrs.filter((e) => e.type === "table");
  const htmlAttributes = Attribute2.getAttributesToRender(node2, tableExtensionAttrs);
  Object.entries(htmlAttributes).forEach(([key, value]) => {
    if (key === "style") {
      table.style.cssText = value;
    } else {
      table.setAttribute(key, value);
    }
  });
}
function updateTableWrapper(tableWrapper, table) {
  let defaultBorderWidth = 1;
  let borderWidth;
  if (!table) {
    return;
  }
  let borderLeftMax = parseFloat(table.style.borderLeftWidth || 0);
  let borderRightMax = parseFloat(table.style.borderRightWidth) || 0;
  let firstColumnCells = [...table.querySelectorAll(":scope > tbody > tr > td:first-child")];
  let lastColumnCells = [...table.querySelectorAll(":scope > tbody > tr > td:last-child")];
  for (let cell of firstColumnCells) {
    let borderLeft = parseFloat(cell.style.borderLeftWidth) || 0;
    borderLeftMax = Math.max(borderLeftMax, borderLeft);
  }
  for (let cell of lastColumnCells) {
    let borderRight = parseFloat(cell.style.borderRightWidth) || 0;
    borderRightMax = Math.max(borderRightMax, borderRight);
  }
  borderWidth = Math.ceil(Math.max(borderLeftMax, borderRightMax));
  tableWrapper.style.setProperty("--table-border-width", `${borderWidth || defaultBorderWidth}px`);
}
const createCell = (cellType, cellContent = null) => {
  if (cellContent) {
    return cellType.createChecked(null, cellContent);
  }
  return cellType.createAndFill();
};
const createTableBorders = ({ size: size2 = 0.66665, color = "#000000" } = {}) => {
  return {
    top: { size: size2, color },
    left: { size: size2, color },
    bottom: { size: size2, color },
    right: { size: size2, color },
    insideH: { size: size2, color },
    insideV: { size: size2, color }
  };
};
const createTable = (schema, rowsCount, colsCount, withHeaderRow, cellContent = null) => {
  const types2 = {
    table: getNodeType("table", schema),
    tableRow: getNodeType("tableRow", schema),
    tableCell: getNodeType("tableCell", schema),
    tableHeader: getNodeType("tableHeader", schema)
  };
  const headerCells = [];
  const cells = [];
  for (let index2 = 0; index2 < colsCount; index2++) {
    const cell = createCell(types2.tableCell, cellContent);
    if (cell) cells.push(cell);
    if (withHeaderRow) {
      const headerCell = createCell(types2.tableHeader, cellContent);
      if (headerCell) {
        headerCells.push(headerCell);
      }
    }
  }
  const rows = [];
  for (let index2 = 0; index2 < rowsCount; index2++) {
    const cellsToInsert = withHeaderRow && index2 === 0 ? headerCells : cells;
    rows.push(types2.tableRow.createChecked(null, cellsToInsert));
  }
  const tableBorders = createTableBorders();
  return types2.table.createChecked({ borders: tableBorders }, rows);
};
var readFromCache;
var addToCache;
if (typeof WeakMap != "undefined") {
  let cache2 = /* @__PURE__ */ new WeakMap();
  readFromCache = (key) => cache2.get(key);
  addToCache = (key, value) => {
    cache2.set(key, value);
    return value;
  };
} else {
  const cache2 = [];
  const cacheSize = 10;
  let cachePos = 0;
  readFromCache = (key) => {
    for (let i = 0; i < cache2.length; i += 2)
      if (cache2[i] == key) return cache2[i + 1];
  };
  addToCache = (key, value) => {
    if (cachePos == cacheSize) cachePos = 0;
    cache2[cachePos++] = key;
    return cache2[cachePos++] = value;
  };
}
var TableMap = class {
  constructor(width, height, map22, problems) {
    this.width = width;
    this.height = height;
    this.map = map22;
    this.problems = problems;
  }
  // Find the dimensions of the cell at the given position.
  findCell(pos) {
    for (let i = 0; i < this.map.length; i++) {
      const curPos = this.map[i];
      if (curPos != pos) continue;
      const left2 = i % this.width;
      const top2 = i / this.width | 0;
      let right2 = left2 + 1;
      let bottom2 = top2 + 1;
      for (let j2 = 1; right2 < this.width && this.map[i + j2] == curPos; j2++) {
        right2++;
      }
      for (let j2 = 1; bottom2 < this.height && this.map[i + this.width * j2] == curPos; j2++) {
        bottom2++;
      }
      return { left: left2, top: top2, right: right2, bottom: bottom2 };
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the left side of the cell at the given position.
  colCount(pos) {
    for (let i = 0; i < this.map.length; i++) {
      if (this.map[i] == pos) {
        return i % this.width;
      }
    }
    throw new RangeError(`No cell with offset ${pos} found`);
  }
  // Find the next cell in the given direction, starting from the cell
  // at `pos`, if any.
  nextCell(pos, axis, dir) {
    const { left: left2, right: right2, top: top2, bottom: bottom2 } = this.findCell(pos);
    if (axis == "horiz") {
      if (dir < 0 ? left2 == 0 : right2 == this.width) return null;
      return this.map[top2 * this.width + (dir < 0 ? left2 - 1 : right2)];
    } else {
      if (dir < 0 ? top2 == 0 : bottom2 == this.height) return null;
      return this.map[left2 + this.width * (dir < 0 ? top2 - 1 : bottom2)];
    }
  }
  // Get the rectangle spanning the two given cells.
  rectBetween(a, b2) {
    const {
      left: leftA,
      right: rightA,
      top: topA,
      bottom: bottomA
    } = this.findCell(a);
    const {
      left: leftB,
      right: rightB,
      top: topB,
      bottom: bottomB
    } = this.findCell(b2);
    return {
      left: Math.min(leftA, leftB),
      top: Math.min(topA, topB),
      right: Math.max(rightA, rightB),
      bottom: Math.max(bottomA, bottomB)
    };
  }
  // Return the position of all cells that have the top left corner in
  // the given rectangle.
  cellsInRect(rect) {
    const result = [];
    const seen = {};
    for (let row = rect.top; row < rect.bottom; row++) {
      for (let col = rect.left; col < rect.right; col++) {
        const index2 = row * this.width + col;
        const pos = this.map[index2];
        if (seen[pos]) continue;
        seen[pos] = true;
        if (col == rect.left && col && this.map[index2 - 1] == pos || row == rect.top && row && this.map[index2 - this.width] == pos) {
          continue;
        }
        result.push(pos);
      }
    }
    return result;
  }
  // Return the position at which the cell at the given row and column
  // starts, or would start, if a cell started there.
  positionAt(row, col, table) {
    for (let i = 0, rowStart = 0; ; i++) {
      const rowEnd = rowStart + table.child(i).nodeSize;
      if (i == row) {
        let index2 = col + row * this.width;
        const rowEndIndex = (row + 1) * this.width;
        while (index2 < rowEndIndex && this.map[index2] < rowStart) index2++;
        return index2 == rowEndIndex ? rowEnd - 1 : this.map[index2];
      }
      rowStart = rowEnd;
    }
  }
  // Find the table map for the given table node.
  static get(table) {
    return readFromCache(table) || addToCache(table, computeMap(table));
  }
};
function computeMap(table) {
  if (table.type.spec.tableRole != "table")
    throw new RangeError("Not a table node: " + table.type.name);
  const width = findWidth(table), height = table.childCount;
  const map22 = [];
  let mapPos = 0;
  let problems = null;
  const colWidths = [];
  for (let i = 0, e = width * height; i < e; i++) map22[i] = 0;
  for (let row = 0, pos = 0; row < height; row++) {
    const rowNode = table.child(row);
    pos++;
    for (let i = 0; ; i++) {
      while (mapPos < map22.length && map22[mapPos] != 0) mapPos++;
      if (i == rowNode.childCount) break;
      const cellNode = rowNode.child(i);
      const { colspan, rowspan, colwidth } = cellNode.attrs;
      for (let h2 = 0; h2 < rowspan; h2++) {
        if (h2 + row >= height) {
          (problems || (problems = [])).push({
            type: "overlong_rowspan",
            pos,
            n: rowspan - h2
          });
          break;
        }
        const start2 = mapPos + h2 * width;
        for (let w2 = 0; w2 < colspan; w2++) {
          if (map22[start2 + w2] == 0) map22[start2 + w2] = pos;
          else
            (problems || (problems = [])).push({
              type: "collision",
              row,
              pos,
              n: colspan - w2
            });
          const colW = colwidth && colwidth[w2];
          if (colW) {
            const widthIndex = (start2 + w2) % width * 2, prev = colWidths[widthIndex];
            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {
              colWidths[widthIndex] = colW;
              colWidths[widthIndex + 1] = 1;
            } else if (prev == colW) {
              colWidths[widthIndex + 1]++;
            }
          }
        }
      }
      mapPos += colspan;
      pos += cellNode.nodeSize;
    }
    const expectedPos = (row + 1) * width;
    let missing = 0;
    while (mapPos < expectedPos) if (map22[mapPos++] == 0) missing++;
    if (missing)
      (problems || (problems = [])).push({ type: "missing", row, n: missing });
    pos++;
  }
  if (width === 0 || height === 0)
    (problems || (problems = [])).push({ type: "zero_sized" });
  const tableMap = new TableMap(width, height, map22, problems);
  let badWidths = false;
  for (let i = 0; !badWidths && i < colWidths.length; i += 2)
    if (colWidths[i] != null && colWidths[i + 1] < height) badWidths = true;
  if (badWidths) findBadColWidths(tableMap, colWidths, table);
  return tableMap;
}
function findWidth(table) {
  let width = -1;
  let hasRowSpan = false;
  for (let row = 0; row < table.childCount; row++) {
    const rowNode = table.child(row);
    let rowWidth = 0;
    if (hasRowSpan)
      for (let j2 = 0; j2 < row; j2++) {
        const prevRow = table.child(j2);
        for (let i = 0; i < prevRow.childCount; i++) {
          const cell = prevRow.child(i);
          if (j2 + cell.attrs.rowspan > row) rowWidth += cell.attrs.colspan;
        }
      }
    for (let i = 0; i < rowNode.childCount; i++) {
      const cell = rowNode.child(i);
      rowWidth += cell.attrs.colspan;
      if (cell.attrs.rowspan > 1) hasRowSpan = true;
    }
    if (width == -1) width = rowWidth;
    else if (width != rowWidth) width = Math.max(width, rowWidth);
  }
  return width;
}
function findBadColWidths(map22, colWidths, table) {
  if (!map22.problems) map22.problems = [];
  const seen = {};
  for (let i = 0; i < map22.map.length; i++) {
    const pos = map22.map[i];
    if (seen[pos]) continue;
    seen[pos] = true;
    const node2 = table.nodeAt(pos);
    if (!node2) {
      throw new RangeError(`No cell with offset ${pos} found`);
    }
    let updated = null;
    const attrs = node2.attrs;
    for (let j2 = 0; j2 < attrs.colspan; j2++) {
      const col = (i + j2) % map22.width;
      const colWidth = colWidths[col * 2];
      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j2] != colWidth))
        (updated || (updated = freshColWidth(attrs)))[j2] = colWidth;
    }
    if (updated)
      map22.problems.unshift({
        type: "colwidth mismatch",
        pos,
        colwidth: updated
      });
  }
}
function freshColWidth(attrs) {
  if (attrs.colwidth) return attrs.colwidth.slice();
  const result = [];
  for (let i = 0; i < attrs.colspan; i++) result.push(0);
  return result;
}
function tableNodeTypes(schema) {
  let result = schema.cached.tableNodeTypes;
  if (!result) {
    result = schema.cached.tableNodeTypes = {};
    for (const name in schema.nodes) {
      const type2 = schema.nodes[name], role = type2.spec.tableRole;
      if (role) result[role] = type2;
    }
  }
  return result;
}
var tableEditingKey = new PluginKey("selectingCells");
function cellAround$1($pos) {
  for (let d2 = $pos.depth - 1; d2 > 0; d2--)
    if ($pos.node(d2).type.spec.tableRole == "row")
      return $pos.node(0).resolve($pos.before(d2 + 1));
  return null;
}
function cellWrapping$1($pos) {
  for (let d2 = $pos.depth; d2 > 0; d2--) {
    const role = $pos.node(d2).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") return $pos.node(d2);
  }
  return null;
}
function isInTable(state2) {
  const $head = state2.selection.$head;
  for (let d2 = $head.depth; d2 > 0; d2--)
    if ($head.node(d2).type.spec.tableRole == "row") return true;
  return false;
}
function selectionCell(state2) {
  const sel = state2.selection;
  if ("$anchorCell" in sel && sel.$anchorCell) {
    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;
  } else if ("node" in sel && sel.node && sel.node.type.spec.tableRole == "cell") {
    return sel.$anchor;
  }
  const $cell = cellAround$1(sel.$head) || cellNear(sel.$head);
  if ($cell) {
    return $cell;
  }
  throw new RangeError(`No cell found around position ${sel.head}`);
}
function cellNear($pos) {
  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {
    const role = after.type.spec.tableRole;
    if (role == "cell" || role == "header_cell") return $pos.doc.resolve(pos);
  }
  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {
    const role = before.type.spec.tableRole;
    if (role == "cell" || role == "header_cell")
      return $pos.doc.resolve(pos - before.nodeSize);
  }
}
function pointsAtCell($pos) {
  return $pos.parent.type.spec.tableRole == "row" && !!$pos.nodeAfter;
}
function moveCellForward($pos) {
  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);
}
function inSameTable($cellA, $cellB) {
  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);
}
function nextCell($pos, axis, dir) {
  const table = $pos.node(-1);
  const map22 = TableMap.get(table);
  const tableStart = $pos.start(-1);
  const moved = map22.nextCell($pos.pos - tableStart, axis, dir);
  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);
}
function removeColSpan(attrs, pos, n = 1) {
  const result = { ...attrs, colspan: attrs.colspan - n };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    result.colwidth.splice(pos, n);
    if (!result.colwidth.some((w2) => w2 > 0)) result.colwidth = null;
  }
  return result;
}
function addColSpan(attrs, pos, n = 1) {
  const result = { ...attrs, colspan: attrs.colspan + n };
  if (result.colwidth) {
    result.colwidth = result.colwidth.slice();
    for (let i = 0; i < n; i++) result.colwidth.splice(pos, 0, 0);
  }
  return result;
}
function columnIsHeader(map22, table, col) {
  const headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (let row = 0; row < map22.height; row++)
    if (table.nodeAt(map22.map[col + row * map22.width]).type != headerCell)
      return false;
  return true;
}
var CellSelection = class _CellSelection extends Selection {
  // A table selection is identified by its anchor and head cells. The
  // positions given to this constructor should point _before_ two
  // cells in the same table. They may be the same, to select a single
  // cell.
  constructor($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map22 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const rect = map22.rectBetween(
      $anchorCell.pos - tableStart,
      $headCell.pos - tableStart
    );
    const doc2 = $anchorCell.node(0);
    const cells = map22.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);
    cells.unshift($headCell.pos - tableStart);
    const ranges = cells.map((pos) => {
      const cell = table.nodeAt(pos);
      if (!cell) {
        throw RangeError(`No cell with offset ${pos} found`);
      }
      const from2 = tableStart + pos + 1;
      return new SelectionRange(
        doc2.resolve(from2),
        doc2.resolve(from2 + cell.content.size)
      );
    });
    super(ranges[0].$from, ranges[0].$to, ranges);
    this.$anchorCell = $anchorCell;
    this.$headCell = $headCell;
  }
  map(doc2, mapping) {
    const $anchorCell = doc2.resolve(mapping.map(this.$anchorCell.pos));
    const $headCell = doc2.resolve(mapping.map(this.$headCell.pos));
    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {
      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);
      if (tableChanged && this.isRowSelection())
        return _CellSelection.rowSelection($anchorCell, $headCell);
      else if (tableChanged && this.isColSelection())
        return _CellSelection.colSelection($anchorCell, $headCell);
      else return new _CellSelection($anchorCell, $headCell);
    }
    return TextSelection$1.between($anchorCell, $headCell);
  }
  // Returns a rectangular slice of table rows containing the selected
  // cells.
  content() {
    const table = this.$anchorCell.node(-1);
    const map22 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const rect = map22.rectBetween(
      this.$anchorCell.pos - tableStart,
      this.$headCell.pos - tableStart
    );
    const seen = {};
    const rows = [];
    for (let row = rect.top; row < rect.bottom; row++) {
      const rowContent = [];
      for (let index2 = row * map22.width + rect.left, col = rect.left; col < rect.right; col++, index2++) {
        const pos = map22.map[index2];
        if (seen[pos]) continue;
        seen[pos] = true;
        const cellRect = map22.findCell(pos);
        let cell = table.nodeAt(pos);
        if (!cell) {
          throw RangeError(`No cell with offset ${pos} found`);
        }
        const extraLeft = rect.left - cellRect.left;
        const extraRight = cellRect.right - rect.right;
        if (extraLeft > 0 || extraRight > 0) {
          let attrs = cell.attrs;
          if (extraLeft > 0) {
            attrs = removeColSpan(attrs, 0, extraLeft);
          }
          if (extraRight > 0) {
            attrs = removeColSpan(
              attrs,
              attrs.colspan - extraRight,
              extraRight
            );
          }
          if (cellRect.left < rect.left) {
            cell = cell.type.createAndFill(attrs);
            if (!cell) {
              throw RangeError(
                `Could not create cell with attrs ${JSON.stringify(attrs)}`
              );
            }
          } else {
            cell = cell.type.create(attrs, cell.content);
          }
        }
        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {
          const attrs = {
            ...cell.attrs,
            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)
          };
          if (cellRect.top < rect.top) {
            cell = cell.type.createAndFill(attrs);
          } else {
            cell = cell.type.create(attrs, cell.content);
          }
        }
        rowContent.push(cell);
      }
      rows.push(table.child(row).copy(Fragment.from(rowContent)));
    }
    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;
    return new Slice(Fragment.from(fragment), 1, 1);
  }
  replace(tr, content = Slice.empty) {
    const mapFrom = tr.steps.length, ranges = this.ranges;
    for (let i = 0; i < ranges.length; i++) {
      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);
      tr.replace(
        mapping.map($from.pos),
        mapping.map($to.pos),
        i ? Slice.empty : content
      );
    }
    const sel = Selection.findFrom(
      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),
      -1
    );
    if (sel) tr.setSelection(sel);
  }
  replaceWith(tr, node2) {
    this.replace(tr, new Slice(Fragment.from(node2), 0, 0));
  }
  forEachCell(f) {
    const table = this.$anchorCell.node(-1);
    const map22 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const cells = map22.cellsInRect(
      map22.rectBetween(
        this.$anchorCell.pos - tableStart,
        this.$headCell.pos - tableStart
      )
    );
    for (let i = 0; i < cells.length; i++) {
      f(table.nodeAt(cells[i]), tableStart + cells[i]);
    }
  }
  // True if this selection goes all the way from the top to the
  // bottom of the table.
  isColSelection() {
    const anchorTop = this.$anchorCell.index(-1);
    const headTop = this.$headCell.index(-1);
    if (Math.min(anchorTop, headTop) > 0) return false;
    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;
    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;
    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;
  }
  // Returns the smallest column selection that covers the given anchor
  // and head cell.
  static colSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map22 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map22.findCell($anchorCell.pos - tableStart);
    const headRect = map22.findCell($headCell.pos - tableStart);
    const doc2 = $anchorCell.node(0);
    if (anchorRect.top <= headRect.top) {
      if (anchorRect.top > 0)
        $anchorCell = doc2.resolve(tableStart + map22.map[anchorRect.left]);
      if (headRect.bottom < map22.height)
        $headCell = doc2.resolve(
          tableStart + map22.map[map22.width * (map22.height - 1) + headRect.right - 1]
        );
    } else {
      if (headRect.top > 0)
        $headCell = doc2.resolve(tableStart + map22.map[headRect.left]);
      if (anchorRect.bottom < map22.height)
        $anchorCell = doc2.resolve(
          tableStart + map22.map[map22.width * (map22.height - 1) + anchorRect.right - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  // True if this selection goes all the way from the left to the
  // right of the table.
  isRowSelection() {
    const table = this.$anchorCell.node(-1);
    const map22 = TableMap.get(table);
    const tableStart = this.$anchorCell.start(-1);
    const anchorLeft = map22.colCount(this.$anchorCell.pos - tableStart);
    const headLeft = map22.colCount(this.$headCell.pos - tableStart);
    if (Math.min(anchorLeft, headLeft) > 0) return false;
    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;
    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;
    return Math.max(anchorRight, headRight) == map22.width;
  }
  eq(other) {
    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;
  }
  // Returns the smallest row selection that covers the given anchor
  // and head cell.
  static rowSelection($anchorCell, $headCell = $anchorCell) {
    const table = $anchorCell.node(-1);
    const map22 = TableMap.get(table);
    const tableStart = $anchorCell.start(-1);
    const anchorRect = map22.findCell($anchorCell.pos - tableStart);
    const headRect = map22.findCell($headCell.pos - tableStart);
    const doc2 = $anchorCell.node(0);
    if (anchorRect.left <= headRect.left) {
      if (anchorRect.left > 0)
        $anchorCell = doc2.resolve(
          tableStart + map22.map[anchorRect.top * map22.width]
        );
      if (headRect.right < map22.width)
        $headCell = doc2.resolve(
          tableStart + map22.map[map22.width * (headRect.top + 1) - 1]
        );
    } else {
      if (headRect.left > 0)
        $headCell = doc2.resolve(tableStart + map22.map[headRect.top * map22.width]);
      if (anchorRect.right < map22.width)
        $anchorCell = doc2.resolve(
          tableStart + map22.map[map22.width * (anchorRect.top + 1) - 1]
        );
    }
    return new _CellSelection($anchorCell, $headCell);
  }
  toJSON() {
    return {
      type: "cell",
      anchor: this.$anchorCell.pos,
      head: this.$headCell.pos
    };
  }
  static fromJSON(doc2, json) {
    return new _CellSelection(doc2.resolve(json.anchor), doc2.resolve(json.head));
  }
  static create(doc2, anchorCell, headCell = anchorCell) {
    return new _CellSelection(doc2.resolve(anchorCell), doc2.resolve(headCell));
  }
  getBookmark() {
    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);
  }
};
CellSelection.prototype.visible = false;
Selection.jsonID("cell", CellSelection);
var CellBookmark = class _CellBookmark {
  constructor(anchor, head) {
    this.anchor = anchor;
    this.head = head;
  }
  map(mapping) {
    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));
  }
  resolve(doc2) {
    const $anchorCell = doc2.resolve(this.anchor), $headCell = doc2.resolve(this.head);
    if ($anchorCell.parent.type.spec.tableRole == "row" && $headCell.parent.type.spec.tableRole == "row" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))
      return new CellSelection($anchorCell, $headCell);
    else return Selection.near($headCell, 1);
  }
};
function drawCellSelection(state2) {
  if (!(state2.selection instanceof CellSelection)) return null;
  const cells = [];
  state2.selection.forEachCell((node2, pos) => {
    cells.push(
      Decoration.node(pos, pos + node2.nodeSize, { class: "selectedCell" })
    );
  });
  return DecorationSet.create(state2.doc, cells);
}
function isCellBoundarySelection({ $from, $to }) {
  if ($from.pos == $to.pos || $from.pos < $to.pos - 6) return false;
  let afterFrom = $from.pos;
  let beforeTo = $to.pos;
  let depth = $from.depth;
  for (; depth >= 0; depth--, afterFrom++)
    if ($from.after(depth + 1) < $from.end(depth)) break;
  for (let d2 = $to.depth; d2 >= 0; d2--, beforeTo--)
    if ($to.before(d2 + 1) > $to.start(d2)) break;
  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);
}
function isTextSelectionAcrossCells({ $from, $to }) {
  let fromCellBoundaryNode;
  let toCellBoundaryNode;
  for (let i = $from.depth; i > 0; i--) {
    const node2 = $from.node(i);
    if (node2.type.spec.tableRole === "cell" || node2.type.spec.tableRole === "header_cell") {
      fromCellBoundaryNode = node2;
      break;
    }
  }
  for (let i = $to.depth; i > 0; i--) {
    const node2 = $to.node(i);
    if (node2.type.spec.tableRole === "cell" || node2.type.spec.tableRole === "header_cell") {
      toCellBoundaryNode = node2;
      break;
    }
  }
  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;
}
function normalizeSelection(state2, tr, allowTableNodeSelection) {
  const sel = (tr || state2).selection;
  const doc2 = (tr || state2).doc;
  let normalize2;
  let role;
  if (sel instanceof NodeSelection && (role = sel.node.type.spec.tableRole)) {
    if (role == "cell" || role == "header_cell") {
      normalize2 = CellSelection.create(doc2, sel.from);
    } else if (role == "row") {
      const $cell = doc2.resolve(sel.from + 1);
      normalize2 = CellSelection.rowSelection($cell, $cell);
    } else if (!allowTableNodeSelection) {
      const map22 = TableMap.get(sel.node);
      const start2 = sel.from + 1;
      const lastCell = start2 + map22.map[map22.width * map22.height - 1];
      normalize2 = CellSelection.create(doc2, start2 + 1, lastCell);
    }
  } else if (sel instanceof TextSelection$1 && isCellBoundarySelection(sel)) {
    normalize2 = TextSelection$1.create(doc2, sel.from);
  } else if (sel instanceof TextSelection$1 && isTextSelectionAcrossCells(sel)) {
    normalize2 = TextSelection$1.create(doc2, sel.$from.start(), sel.$from.end());
  }
  if (normalize2) (tr || (tr = state2.tr)).setSelection(normalize2);
  return tr;
}
var fixTablesKey = new PluginKey("fix-tables");
function changedDescendants(old, cur, offset2, f) {
  const oldSize = old.childCount, curSize = cur.childCount;
  outer: for (let i = 0, j2 = 0; i < curSize; i++) {
    const child = cur.child(i);
    for (let scan = j2, e = Math.min(oldSize, i + 3); scan < e; scan++) {
      if (old.child(scan) == child) {
        j2 = scan + 1;
        offset2 += child.nodeSize;
        continue outer;
      }
    }
    f(child, offset2);
    if (j2 < oldSize && old.child(j2).sameMarkup(child))
      changedDescendants(old.child(j2), child, offset2 + 1, f);
    else child.nodesBetween(0, child.content.size, f, offset2 + 1);
    offset2 += child.nodeSize;
  }
}
function fixTables(state2, oldState) {
  let tr;
  const check = (node2, pos) => {
    if (node2.type.spec.tableRole == "table")
      tr = fixTable(state2, node2, pos, tr);
  };
  if (!oldState) state2.doc.descendants(check);
  else if (oldState.doc != state2.doc)
    changedDescendants(oldState.doc, state2.doc, 0, check);
  return tr;
}
function fixTable(state2, table, tablePos, tr) {
  const map22 = TableMap.get(table);
  if (!map22.problems) return tr;
  if (!tr) tr = state2.tr;
  const mustAdd = [];
  for (let i = 0; i < map22.height; i++) mustAdd.push(0);
  for (let i = 0; i < map22.problems.length; i++) {
    const prob = map22.problems[i];
    if (prob.type == "collision") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      const attrs = cell.attrs;
      for (let j2 = 0; j2 < attrs.rowspan; j2++) mustAdd[prob.row + j2] += prob.n;
      tr.setNodeMarkup(
        tr.mapping.map(tablePos + 1 + prob.pos),
        null,
        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)
      );
    } else if (prob.type == "missing") {
      mustAdd[prob.row] += prob.n;
    } else if (prob.type == "overlong_rowspan") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        rowspan: cell.attrs.rowspan - prob.n
      });
    } else if (prob.type == "colwidth mismatch") {
      const cell = table.nodeAt(prob.pos);
      if (!cell) continue;
      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {
        ...cell.attrs,
        colwidth: prob.colwidth
      });
    } else if (prob.type == "zero_sized") {
      const pos = tr.mapping.map(tablePos);
      tr.delete(pos, pos + table.nodeSize);
    }
  }
  let first2, last;
  for (let i = 0; i < mustAdd.length; i++)
    if (mustAdd[i]) {
      if (first2 == null) first2 = i;
      last = i;
    }
  for (let i = 0, pos = tablePos + 1; i < map22.height; i++) {
    const row = table.child(i);
    const end2 = pos + row.nodeSize;
    const add = mustAdd[i];
    if (add > 0) {
      let role = "cell";
      if (row.firstChild) {
        role = row.firstChild.type.spec.tableRole;
      }
      const nodes = [];
      for (let j2 = 0; j2 < add; j2++) {
        const node2 = tableNodeTypes(state2.schema)[role].createAndFill();
        if (node2) nodes.push(node2);
      }
      const side = (i == 0 || first2 == i - 1) && last == i ? pos + 1 : end2 - 1;
      tr.insert(tr.mapping.map(side), nodes);
    }
    pos = end2;
  }
  return tr.setMeta(fixTablesKey, { fixTables: true });
}
function selectedRect(state2) {
  const sel = state2.selection;
  const $pos = selectionCell(state2);
  const table = $pos.node(-1);
  const tableStart = $pos.start(-1);
  const map22 = TableMap.get(table);
  const rect = sel instanceof CellSelection ? map22.rectBetween(
    sel.$anchorCell.pos - tableStart,
    sel.$headCell.pos - tableStart
  ) : map22.findCell($pos.pos - tableStart);
  return { ...rect, tableStart, map: map22, table };
}
function addColumn(tr, { map: map22, tableStart, table }, col) {
  let refColumn = col > 0 ? -1 : 0;
  if (columnIsHeader(map22, table, col + refColumn)) {
    refColumn = col == 0 || col == map22.width ? null : 0;
  }
  for (let row = 0; row < map22.height; row++) {
    const index2 = row * map22.width + col;
    if (col > 0 && col < map22.width && map22.map[index2 - 1] == map22.map[index2]) {
      const pos = map22.map[index2];
      const cell = table.nodeAt(pos);
      tr.setNodeMarkup(
        tr.mapping.map(tableStart + pos),
        null,
        addColSpan(cell.attrs, col - map22.colCount(pos))
      );
      row += cell.attrs.rowspan - 1;
    } else {
      const type2 = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map22.map[index2 + refColumn]).type;
      const pos = map22.positionAt(row, col, table);
      tr.insert(tr.mapping.map(tableStart + pos), type2.createAndFill());
    }
  }
  return tr;
}
function addColumnBefore(state2, dispatch) {
  if (!isInTable(state2)) return false;
  if (dispatch) {
    const rect = selectedRect(state2);
    dispatch(addColumn(state2.tr, rect, rect.left));
  }
  return true;
}
function addColumnAfter(state2, dispatch) {
  if (!isInTable(state2)) return false;
  if (dispatch) {
    const rect = selectedRect(state2);
    dispatch(addColumn(state2.tr, rect, rect.right));
  }
  return true;
}
function removeColumn(tr, { map: map22, table, tableStart }, col) {
  const mapStart = tr.mapping.maps.length;
  for (let row = 0; row < map22.height; ) {
    const index2 = row * map22.width + col;
    const pos = map22.map[index2];
    const cell = table.nodeAt(pos);
    const attrs = cell.attrs;
    if (col > 0 && map22.map[index2 - 1] == pos || col < map22.width - 1 && map22.map[index2 + 1] == pos) {
      tr.setNodeMarkup(
        tr.mapping.slice(mapStart).map(tableStart + pos),
        null,
        removeColSpan(attrs, col - map22.colCount(pos))
      );
    } else {
      const start2 = tr.mapping.slice(mapStart).map(tableStart + pos);
      tr.delete(start2, start2 + cell.nodeSize);
    }
    row += attrs.rowspan;
  }
}
function deleteColumn(state2, dispatch) {
  if (!isInTable(state2)) return false;
  if (dispatch) {
    const rect = selectedRect(state2);
    const tr = state2.tr;
    if (rect.left == 0 && rect.right == rect.map.width) return false;
    for (let i = rect.right - 1; ; i--) {
      removeColumn(tr, rect, i);
      if (i == rect.left) break;
      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(table);
    }
    dispatch(tr);
  }
  return true;
}
function rowIsHeader(map22, table, row) {
  var _a2;
  const headerCell = tableNodeTypes(table.type.schema).header_cell;
  for (let col = 0; col < map22.width; col++)
    if (((_a2 = table.nodeAt(map22.map[col + row * map22.width])) == null ? void 0 : _a2.type) != headerCell)
      return false;
  return true;
}
function addRow(tr, { map: map22, tableStart, table }, row) {
  var _a2;
  let rowPos = tableStart;
  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;
  const cells = [];
  let refRow = row > 0 ? -1 : 0;
  if (rowIsHeader(map22, table, row + refRow))
    refRow = row == 0 || row == map22.height ? null : 0;
  for (let col = 0, index2 = map22.width * row; col < map22.width; col++, index2++) {
    if (row > 0 && row < map22.height && map22.map[index2] == map22.map[index2 - map22.width]) {
      const pos = map22.map[index2];
      const attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tableStart + pos, null, {
        ...attrs,
        rowspan: attrs.rowspan + 1
      });
      col += attrs.colspan - 1;
    } else {
      const type2 = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a2 = table.nodeAt(map22.map[index2 + refRow * map22.width])) == null ? void 0 : _a2.type;
      const node2 = type2 == null ? void 0 : type2.createAndFill();
      if (node2) cells.push(node2);
    }
  }
  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));
  return tr;
}
function addRowBefore(state2, dispatch) {
  if (!isInTable(state2)) return false;
  if (dispatch) {
    const rect = selectedRect(state2);
    dispatch(addRow(state2.tr, rect, rect.top));
  }
  return true;
}
function addRowAfter(state2, dispatch) {
  if (!isInTable(state2)) return false;
  if (dispatch) {
    const rect = selectedRect(state2);
    dispatch(addRow(state2.tr, rect, rect.bottom));
  }
  return true;
}
function removeRow(tr, { map: map22, table, tableStart }, row) {
  let rowPos = 0;
  for (let i = 0; i < row; i++) rowPos += table.child(i).nodeSize;
  const nextRow = rowPos + table.child(row).nodeSize;
  const mapFrom = tr.mapping.maps.length;
  tr.delete(rowPos + tableStart, nextRow + tableStart);
  const seen = /* @__PURE__ */ new Set();
  for (let col = 0, index2 = row * map22.width; col < map22.width; col++, index2++) {
    const pos = map22.map[index2];
    if (seen.has(pos)) continue;
    seen.add(pos);
    if (row > 0 && pos == map22.map[index2 - map22.width]) {
      const attrs = table.nodeAt(pos).attrs;
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {
        ...attrs,
        rowspan: attrs.rowspan - 1
      });
      col += attrs.colspan - 1;
    } else if (row < map22.height && pos == map22.map[index2 + map22.width]) {
      const cell = table.nodeAt(pos);
      const attrs = cell.attrs;
      const copy2 = cell.type.create(
        { ...attrs, rowspan: cell.attrs.rowspan - 1 },
        cell.content
      );
      const newPos = map22.positionAt(row + 1, col, table);
      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy2);
      col += attrs.colspan - 1;
    }
  }
}
function deleteRow(state2, dispatch) {
  if (!isInTable(state2)) return false;
  if (dispatch) {
    const rect = selectedRect(state2), tr = state2.tr;
    if (rect.top == 0 && rect.bottom == rect.map.height) return false;
    for (let i = rect.bottom - 1; ; i--) {
      removeRow(tr, rect, i);
      if (i == rect.top) break;
      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;
      if (!table) {
        throw RangeError("No table found");
      }
      rect.table = table;
      rect.map = TableMap.get(rect.table);
    }
    dispatch(tr);
  }
  return true;
}
function isEmpty(cell) {
  const c2 = cell.content;
  return c2.childCount == 1 && c2.child(0).isTextblock && c2.child(0).childCount == 0;
}
function cellsOverlapRectangle({ width, height, map: map22 }, rect) {
  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;
  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);
  for (let i = rect.top; i < rect.bottom; i++) {
    if (rect.left > 0 && map22[indexLeft] == map22[indexLeft - 1] || rect.right < width && map22[indexRight] == map22[indexRight + 1])
      return true;
    indexLeft += width;
    indexRight += width;
  }
  for (let i = rect.left; i < rect.right; i++) {
    if (rect.top > 0 && map22[indexTop] == map22[indexTop - width] || rect.bottom < height && map22[indexBottom] == map22[indexBottom + width])
      return true;
    indexTop++;
    indexBottom++;
  }
  return false;
}
function mergeCells(state2, dispatch) {
  const sel = state2.selection;
  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)
    return false;
  const rect = selectedRect(state2), { map: map22 } = rect;
  if (cellsOverlapRectangle(map22, rect)) return false;
  if (dispatch) {
    const tr = state2.tr;
    const seen = {};
    let content = Fragment.empty;
    let mergedPos;
    let mergedCell;
    for (let row = rect.top; row < rect.bottom; row++) {
      for (let col = rect.left; col < rect.right; col++) {
        const cellPos = map22.map[row * map22.width + col];
        const cell = rect.table.nodeAt(cellPos);
        if (seen[cellPos] || !cell) continue;
        seen[cellPos] = true;
        if (mergedPos == null) {
          mergedPos = cellPos;
          mergedCell = cell;
        } else {
          if (!isEmpty(cell)) content = content.append(cell.content);
          const mapped = tr.mapping.map(cellPos + rect.tableStart);
          tr.delete(mapped, mapped + cell.nodeSize);
        }
      }
    }
    if (mergedPos == null || mergedCell == null) {
      return true;
    }
    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {
      ...addColSpan(
        mergedCell.attrs,
        mergedCell.attrs.colspan,
        rect.right - rect.left - mergedCell.attrs.colspan
      ),
      rowspan: rect.bottom - rect.top
    });
    if (content.size) {
      const end2 = mergedPos + 1 + mergedCell.content.size;
      const start2 = isEmpty(mergedCell) ? mergedPos + 1 : end2;
      tr.replaceWith(start2 + rect.tableStart, end2 + rect.tableStart, content);
    }
    tr.setSelection(
      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))
    );
    dispatch(tr);
  }
  return true;
}
function splitCell(state2, dispatch) {
  const nodeTypes = tableNodeTypes(state2.schema);
  return splitCellWithType(({ node: node2 }) => {
    return nodeTypes[node2.type.spec.tableRole];
  })(state2, dispatch);
}
function splitCellWithType(getCellType2) {
  return (state2, dispatch) => {
    var _a2;
    const sel = state2.selection;
    let cellNode;
    let cellPos;
    if (!(sel instanceof CellSelection)) {
      cellNode = cellWrapping$1(sel.$from);
      if (!cellNode) return false;
      cellPos = (_a2 = cellAround$1(sel.$from)) == null ? void 0 : _a2.pos;
    } else {
      if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
      cellNode = sel.$anchorCell.nodeAfter;
      cellPos = sel.$anchorCell.pos;
    }
    if (cellNode == null || cellPos == null) {
      return false;
    }
    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {
      return false;
    }
    if (dispatch) {
      let baseAttrs = cellNode.attrs;
      const attrs = [];
      const colwidth = baseAttrs.colwidth;
      if (baseAttrs.rowspan > 1) baseAttrs = { ...baseAttrs, rowspan: 1 };
      if (baseAttrs.colspan > 1) baseAttrs = { ...baseAttrs, colspan: 1 };
      const rect = selectedRect(state2), tr = state2.tr;
      for (let i = 0; i < rect.right - rect.left; i++)
        attrs.push(
          colwidth ? {
            ...baseAttrs,
            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null
          } : baseAttrs
        );
      let lastCell;
      for (let row = rect.top; row < rect.bottom; row++) {
        let pos = rect.map.positionAt(row, rect.left, rect.table);
        if (row == rect.top) pos += cellNode.nodeSize;
        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {
          if (col == rect.left && row == rect.top) continue;
          tr.insert(
            lastCell = tr.mapping.map(pos + rect.tableStart, 1),
            getCellType2({ node: cellNode, row, col }).createAndFill(attrs[i])
          );
        }
      }
      tr.setNodeMarkup(
        cellPos,
        getCellType2({ node: cellNode, row: rect.top, col: rect.left }),
        attrs[0]
      );
      if (sel instanceof CellSelection)
        tr.setSelection(
          new CellSelection(
            tr.doc.resolve(sel.$anchorCell.pos),
            lastCell ? tr.doc.resolve(lastCell) : void 0
          )
        );
      dispatch(tr);
    }
    return true;
  };
}
function setCellAttr(name, value) {
  return function(state2, dispatch) {
    if (!isInTable(state2)) return false;
    const $cell = selectionCell(state2);
    if ($cell.nodeAfter.attrs[name] === value) return false;
    if (dispatch) {
      const tr = state2.tr;
      if (state2.selection instanceof CellSelection)
        state2.selection.forEachCell((node2, pos) => {
          if (node2.attrs[name] !== value)
            tr.setNodeMarkup(pos, null, {
              ...node2.attrs,
              [name]: value
            });
        });
      else
        tr.setNodeMarkup($cell.pos, null, {
          ...$cell.nodeAfter.attrs,
          [name]: value
        });
      dispatch(tr);
    }
    return true;
  };
}
function deprecated_toggleHeader(type2) {
  return function(state2, dispatch) {
    if (!isInTable(state2)) return false;
    if (dispatch) {
      const types2 = tableNodeTypes(state2.schema);
      const rect = selectedRect(state2), tr = state2.tr;
      const cells = rect.map.cellsInRect(
        type2 == "column" ? {
          left: rect.left,
          top: 0,
          right: rect.right,
          bottom: rect.map.height
        } : type2 == "row" ? {
          left: 0,
          top: rect.top,
          right: rect.map.width,
          bottom: rect.bottom
        } : rect
      );
      const nodes = cells.map((pos) => rect.table.nodeAt(pos));
      for (let i = 0; i < cells.length; i++)
        if (nodes[i].type == types2.header_cell)
          tr.setNodeMarkup(
            rect.tableStart + cells[i],
            types2.cell,
            nodes[i].attrs
          );
      if (tr.steps.length == 0)
        for (let i = 0; i < cells.length; i++)
          tr.setNodeMarkup(
            rect.tableStart + cells[i],
            types2.header_cell,
            nodes[i].attrs
          );
      dispatch(tr);
    }
    return true;
  };
}
function isHeaderEnabledByType(type2, rect, types2) {
  const cellPositions = rect.map.cellsInRect({
    left: 0,
    top: 0,
    right: type2 == "row" ? rect.map.width : 1,
    bottom: type2 == "column" ? rect.map.height : 1
  });
  for (let i = 0; i < cellPositions.length; i++) {
    const cell = rect.table.nodeAt(cellPositions[i]);
    if (cell && cell.type !== types2.header_cell) {
      return false;
    }
  }
  return true;
}
function toggleHeader(type2, options) {
  options = options || { useDeprecatedLogic: false };
  if (options.useDeprecatedLogic) return deprecated_toggleHeader(type2);
  return function(state2, dispatch) {
    if (!isInTable(state2)) return false;
    if (dispatch) {
      const types2 = tableNodeTypes(state2.schema);
      const rect = selectedRect(state2), tr = state2.tr;
      const isHeaderRowEnabled = isHeaderEnabledByType("row", rect, types2);
      const isHeaderColumnEnabled = isHeaderEnabledByType(
        "column",
        rect,
        types2
      );
      const isHeaderEnabled = type2 === "column" ? isHeaderRowEnabled : type2 === "row" ? isHeaderColumnEnabled : false;
      const selectionStartsAt = isHeaderEnabled ? 1 : 0;
      const cellsRect = type2 == "column" ? {
        left: 0,
        top: selectionStartsAt,
        right: 1,
        bottom: rect.map.height
      } : type2 == "row" ? {
        left: selectionStartsAt,
        top: 0,
        right: rect.map.width,
        bottom: 1
      } : rect;
      const newType = type2 == "column" ? isHeaderColumnEnabled ? types2.cell : types2.header_cell : type2 == "row" ? isHeaderRowEnabled ? types2.cell : types2.header_cell : types2.cell;
      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {
        const cellPos = relativeCellPos + rect.tableStart;
        const cell = tr.doc.nodeAt(cellPos);
        if (cell) {
          tr.setNodeMarkup(cellPos, newType, cell.attrs);
        }
      });
      dispatch(tr);
    }
    return true;
  };
}
toggleHeader("row", {
  useDeprecatedLogic: true
});
toggleHeader("column", {
  useDeprecatedLogic: true
});
var toggleHeaderCell = toggleHeader("cell", {
  useDeprecatedLogic: true
});
function findNextCell($cell, dir) {
  if (dir < 0) {
    const before = $cell.nodeBefore;
    if (before) return $cell.pos - before.nodeSize;
    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {
      const rowNode = $cell.node(-1).child(row);
      const lastChild = rowNode.lastChild;
      if (lastChild) {
        return rowEnd - 1 - lastChild.nodeSize;
      }
      rowEnd -= rowNode.nodeSize;
    }
  } else {
    if ($cell.index() < $cell.parent.childCount - 1) {
      return $cell.pos + $cell.nodeAfter.nodeSize;
    }
    const table = $cell.node(-1);
    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {
      const rowNode = table.child(row);
      if (rowNode.childCount) return rowStart + 1;
      rowStart += rowNode.nodeSize;
    }
  }
  return null;
}
function goToNextCell(direction) {
  return function(state2, dispatch) {
    if (!isInTable(state2)) return false;
    const cell = findNextCell(selectionCell(state2), direction);
    if (cell == null) return false;
    if (dispatch) {
      const $cell = state2.doc.resolve(cell);
      dispatch(
        state2.tr.setSelection(TextSelection$1.between($cell, moveCellForward($cell))).scrollIntoView()
      );
    }
    return true;
  };
}
function deleteTable(state2, dispatch) {
  const $pos = state2.selection.$anchor;
  for (let d2 = $pos.depth; d2 > 0; d2--) {
    const node2 = $pos.node(d2);
    if (node2.type.spec.tableRole == "table") {
      if (dispatch)
        dispatch(
          state2.tr.delete($pos.before(d2), $pos.after(d2)).scrollIntoView()
        );
      return true;
    }
  }
  return false;
}
function deleteCellSelection(state2, dispatch) {
  const sel = state2.selection;
  if (!(sel instanceof CellSelection)) return false;
  if (dispatch) {
    const tr = state2.tr;
    const baseContent = tableNodeTypes(state2.schema).cell.createAndFill().content;
    sel.forEachCell((cell, pos) => {
      if (!cell.content.eq(baseContent))
        tr.replace(
          tr.mapping.map(pos + 1),
          tr.mapping.map(pos + cell.nodeSize - 1),
          new Slice(baseContent, 0, 0)
        );
    });
    if (tr.docChanged) dispatch(tr);
  }
  return true;
}
function pastedCells(slice2) {
  if (!slice2.size) return null;
  let { content, openStart, openEnd } = slice2;
  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == "table")) {
    openStart--;
    openEnd--;
    content = content.child(0).content;
  }
  const first2 = content.child(0);
  const role = first2.type.spec.tableRole;
  const schema = first2.type.schema, rows = [];
  if (role == "row") {
    for (let i = 0; i < content.childCount; i++) {
      let cells = content.child(i).content;
      const left2 = i ? 0 : Math.max(0, openStart - 1);
      const right2 = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);
      if (left2 || right2)
        cells = fitSlice(
          tableNodeTypes(schema).row,
          new Slice(cells, left2, right2)
        ).content;
      rows.push(cells);
    }
  } else if (role == "cell" || role == "header_cell") {
    rows.push(
      openStart || openEnd ? fitSlice(
        tableNodeTypes(schema).row,
        new Slice(content, openStart, openEnd)
      ).content : content
    );
  } else {
    return null;
  }
  return ensureRectangular(schema, rows);
}
function ensureRectangular(schema, rows) {
  const widths = [];
  for (let i = 0; i < rows.length; i++) {
    const row = rows[i];
    for (let j2 = row.childCount - 1; j2 >= 0; j2--) {
      const { rowspan, colspan } = row.child(j2).attrs;
      for (let r2 = i; r2 < i + rowspan; r2++)
        widths[r2] = (widths[r2] || 0) + colspan;
    }
  }
  let width = 0;
  for (let r2 = 0; r2 < widths.length; r2++) width = Math.max(width, widths[r2]);
  for (let r2 = 0; r2 < widths.length; r2++) {
    if (r2 >= rows.length) rows.push(Fragment.empty);
    if (widths[r2] < width) {
      const empty2 = tableNodeTypes(schema).cell.createAndFill();
      const cells = [];
      for (let i = widths[r2]; i < width; i++) {
        cells.push(empty2);
      }
      rows[r2] = rows[r2].append(Fragment.from(cells));
    }
  }
  return { height: rows.length, width, rows };
}
function fitSlice(nodeType, slice2) {
  const node2 = nodeType.createAndFill();
  const tr = new Transform(node2).replace(0, node2.content.size, slice2);
  return tr.doc;
}
function clipCells({ width, height, rows }, newWidth, newHeight) {
  if (width != newWidth) {
    const added = [];
    const newRows = [];
    for (let row = 0; row < rows.length; row++) {
      const frag = rows[row], cells = [];
      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {
        let cell = frag.child(i % frag.childCount);
        if (col + cell.attrs.colspan > newWidth)
          cell = cell.type.createChecked(
            removeColSpan(
              cell.attrs,
              cell.attrs.colspan,
              col + cell.attrs.colspan - newWidth
            ),
            cell.content
          );
        cells.push(cell);
        col += cell.attrs.colspan;
        for (let j2 = 1; j2 < cell.attrs.rowspan; j2++)
          added[row + j2] = (added[row + j2] || 0) + cell.attrs.colspan;
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    width = newWidth;
  }
  if (height != newHeight) {
    const newRows = [];
    for (let row = 0, i = 0; row < newHeight; row++, i++) {
      const cells = [], source = rows[i % height];
      for (let j2 = 0; j2 < source.childCount; j2++) {
        let cell = source.child(j2);
        if (row + cell.attrs.rowspan > newHeight)
          cell = cell.type.create(
            {
              ...cell.attrs,
              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)
            },
            cell.content
          );
        cells.push(cell);
      }
      newRows.push(Fragment.from(cells));
    }
    rows = newRows;
    height = newHeight;
  }
  return { width, height, rows };
}
function growTable(tr, map22, table, start2, width, height, mapFrom) {
  const schema = tr.doc.type.schema;
  const types2 = tableNodeTypes(schema);
  let empty2;
  let emptyHead;
  if (width > map22.width) {
    for (let row = 0, rowEnd = 0; row < map22.height; row++) {
      const rowNode = table.child(row);
      rowEnd += rowNode.nodeSize;
      const cells = [];
      let add;
      if (rowNode.lastChild == null || rowNode.lastChild.type == types2.cell)
        add = empty2 || (empty2 = types2.cell.createAndFill());
      else add = emptyHead || (emptyHead = types2.header_cell.createAndFill());
      for (let i = map22.width; i < width; i++) cells.push(add);
      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start2), cells);
    }
  }
  if (height > map22.height) {
    const cells = [];
    for (let i = 0, start22 = (map22.height - 1) * map22.width; i < Math.max(map22.width, width); i++) {
      const header = i >= map22.width ? false : table.nodeAt(map22.map[start22 + i]).type == types2.header_cell;
      cells.push(
        header ? emptyHead || (emptyHead = types2.header_cell.createAndFill()) : empty2 || (empty2 = types2.cell.createAndFill())
      );
    }
    const emptyRow = types2.row.create(null, Fragment.from(cells)), rows = [];
    for (let i = map22.height; i < height; i++) rows.push(emptyRow);
    tr.insert(tr.mapping.slice(mapFrom).map(start2 + table.nodeSize - 2), rows);
  }
  return !!(empty2 || emptyHead);
}
function isolateHorizontal(tr, map22, table, start2, left2, right2, top2, mapFrom) {
  if (top2 == 0 || top2 == map22.height) return false;
  let found2 = false;
  for (let col = left2; col < right2; col++) {
    const index2 = top2 * map22.width + col, pos = map22.map[index2];
    if (map22.map[index2 - map22.width] == pos) {
      found2 = true;
      const cell = table.nodeAt(pos);
      const { top: cellTop, left: cellLeft } = map22.findCell(pos);
      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start2), null, {
        ...cell.attrs,
        rowspan: top2 - cellTop
      });
      tr.insert(
        tr.mapping.slice(mapFrom).map(map22.positionAt(top2, cellLeft, table)),
        cell.type.createAndFill({
          ...cell.attrs,
          rowspan: cellTop + cell.attrs.rowspan - top2
        })
      );
      col += cell.attrs.colspan - 1;
    }
  }
  return found2;
}
function isolateVertical(tr, map22, table, start2, top2, bottom2, left2, mapFrom) {
  if (left2 == 0 || left2 == map22.width) return false;
  let found2 = false;
  for (let row = top2; row < bottom2; row++) {
    const index2 = row * map22.width + left2, pos = map22.map[index2];
    if (map22.map[index2 - 1] == pos) {
      found2 = true;
      const cell = table.nodeAt(pos);
      const cellLeft = map22.colCount(pos);
      const updatePos = tr.mapping.slice(mapFrom).map(pos + start2);
      tr.setNodeMarkup(
        updatePos,
        null,
        removeColSpan(
          cell.attrs,
          left2 - cellLeft,
          cell.attrs.colspan - (left2 - cellLeft)
        )
      );
      tr.insert(
        updatePos + cell.nodeSize,
        cell.type.createAndFill(
          removeColSpan(cell.attrs, 0, left2 - cellLeft)
        )
      );
      row += cell.attrs.rowspan - 1;
    }
  }
  return found2;
}
function insertCells(state2, dispatch, tableStart, rect, cells) {
  let table = tableStart ? state2.doc.nodeAt(tableStart - 1) : state2.doc;
  if (!table) {
    throw new Error("No table found");
  }
  let map22 = TableMap.get(table);
  const { top: top2, left: left2 } = rect;
  const right2 = left2 + cells.width, bottom2 = top2 + cells.height;
  const tr = state2.tr;
  let mapFrom = 0;
  function recomp() {
    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;
    if (!table) {
      throw new Error("No table found");
    }
    map22 = TableMap.get(table);
    mapFrom = tr.mapping.maps.length;
  }
  if (growTable(tr, map22, table, tableStart, right2, bottom2, mapFrom)) recomp();
  if (isolateHorizontal(tr, map22, table, tableStart, left2, right2, top2, mapFrom))
    recomp();
  if (isolateHorizontal(tr, map22, table, tableStart, left2, right2, bottom2, mapFrom))
    recomp();
  if (isolateVertical(tr, map22, table, tableStart, top2, bottom2, left2, mapFrom))
    recomp();
  if (isolateVertical(tr, map22, table, tableStart, top2, bottom2, right2, mapFrom))
    recomp();
  for (let row = top2; row < bottom2; row++) {
    const from2 = map22.positionAt(row, left2, table), to = map22.positionAt(row, right2, table);
    tr.replace(
      tr.mapping.slice(mapFrom).map(from2 + tableStart),
      tr.mapping.slice(mapFrom).map(to + tableStart),
      new Slice(cells.rows[row - top2], 0, 0)
    );
  }
  recomp();
  tr.setSelection(
    new CellSelection(
      tr.doc.resolve(tableStart + map22.positionAt(top2, left2, table)),
      tr.doc.resolve(tableStart + map22.positionAt(bottom2 - 1, right2 - 1, table))
    )
  );
  dispatch(tr);
}
var handleKeyDown = keydownHandler({
  ArrowLeft: arrow$2("horiz", -1),
  ArrowRight: arrow$2("horiz", 1),
  ArrowUp: arrow$2("vert", -1),
  ArrowDown: arrow$2("vert", 1),
  "Shift-ArrowLeft": shiftArrow("horiz", -1),
  "Shift-ArrowRight": shiftArrow("horiz", 1),
  "Shift-ArrowUp": shiftArrow("vert", -1),
  "Shift-ArrowDown": shiftArrow("vert", 1),
  Backspace: deleteCellSelection,
  "Mod-Backspace": deleteCellSelection,
  Delete: deleteCellSelection,
  "Mod-Delete": deleteCellSelection
});
function maybeSetSelection(state2, dispatch, selection) {
  if (selection.eq(state2.selection)) return false;
  if (dispatch) dispatch(state2.tr.setSelection(selection).scrollIntoView());
  return true;
}
function arrow$2(axis, dir) {
  return (state2, dispatch, view) => {
    if (!view) return false;
    const sel = state2.selection;
    if (sel instanceof CellSelection) {
      return maybeSetSelection(
        state2,
        dispatch,
        Selection.near(sel.$headCell, dir)
      );
    }
    if (axis != "horiz" && !sel.empty) return false;
    const end2 = atEndOfCell(view, axis, dir);
    if (end2 == null) return false;
    if (axis == "horiz") {
      return maybeSetSelection(
        state2,
        dispatch,
        Selection.near(state2.doc.resolve(sel.head + dir), dir)
      );
    } else {
      const $cell = state2.doc.resolve(end2);
      const $next = nextCell($cell, axis, dir);
      let newSel;
      if ($next) newSel = Selection.near($next, 1);
      else if (dir < 0)
        newSel = Selection.near(state2.doc.resolve($cell.before(-1)), -1);
      else newSel = Selection.near(state2.doc.resolve($cell.after(-1)), 1);
      return maybeSetSelection(state2, dispatch, newSel);
    }
  };
}
function shiftArrow(axis, dir) {
  return (state2, dispatch, view) => {
    if (!view) return false;
    const sel = state2.selection;
    let cellSel;
    if (sel instanceof CellSelection) {
      cellSel = sel;
    } else {
      const end2 = atEndOfCell(view, axis, dir);
      if (end2 == null) return false;
      cellSel = new CellSelection(state2.doc.resolve(end2));
    }
    const $head = nextCell(cellSel.$headCell, axis, dir);
    if (!$head) return false;
    return maybeSetSelection(
      state2,
      dispatch,
      new CellSelection(cellSel.$anchorCell, $head)
    );
  };
}
function handleTripleClick(view, pos) {
  const doc2 = view.state.doc, $cell = cellAround$1(doc2.resolve(pos));
  if (!$cell) return false;
  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));
  return true;
}
function handlePaste(view, _2, slice2) {
  if (!isInTable(view.state)) return false;
  let cells = pastedCells(slice2);
  const sel = view.state.selection;
  if (sel instanceof CellSelection) {
    if (!cells)
      cells = {
        width: 1,
        height: 1,
        rows: [
          Fragment.from(
            fitSlice(tableNodeTypes(view.state.schema).cell, slice2)
          )
        ]
      };
    const table = sel.$anchorCell.node(-1);
    const start2 = sel.$anchorCell.start(-1);
    const rect = TableMap.get(table).rectBetween(
      sel.$anchorCell.pos - start2,
      sel.$headCell.pos - start2
    );
    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);
    insertCells(view.state, view.dispatch, start2, rect, cells);
    return true;
  } else if (cells) {
    const $cell = selectionCell(view.state);
    const start2 = $cell.start(-1);
    insertCells(
      view.state,
      view.dispatch,
      start2,
      TableMap.get($cell.node(-1)).findCell($cell.pos - start2),
      cells
    );
    return true;
  } else {
    return false;
  }
}
function handleMouseDown(view, startEvent) {
  var _a2;
  if (startEvent.ctrlKey || startEvent.metaKey) return;
  const startDOMCell = domInCell(view, startEvent.target);
  let $anchor;
  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {
    setCellSelection(view.state.selection.$anchorCell, startEvent);
    startEvent.preventDefault();
  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround$1(view.state.selection.$anchor)) != null && ((_a2 = cellUnderMouse(view, startEvent)) == null ? void 0 : _a2.pos) != $anchor.pos) {
    setCellSelection($anchor, startEvent);
    startEvent.preventDefault();
  } else if (!startDOMCell) {
    return;
  }
  function setCellSelection($anchor2, event) {
    let $head = cellUnderMouse(view, event);
    const starting = tableEditingKey.getState(view.state) == null;
    if (!$head || !inSameTable($anchor2, $head)) {
      if (starting) $head = $anchor2;
      else return;
    }
    const selection = new CellSelection($anchor2, $head);
    if (starting || !view.state.selection.eq(selection)) {
      const tr = view.state.tr.setSelection(selection);
      if (starting) tr.setMeta(tableEditingKey, $anchor2.pos);
      view.dispatch(tr);
    }
  }
  function stop() {
    view.root.removeEventListener("mouseup", stop);
    view.root.removeEventListener("dragstart", stop);
    view.root.removeEventListener("mousemove", move2);
    if (tableEditingKey.getState(view.state) != null)
      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));
  }
  function move2(_event) {
    const event = _event;
    const anchor = tableEditingKey.getState(view.state);
    let $anchor2;
    if (anchor != null) {
      $anchor2 = view.state.doc.resolve(anchor);
    } else if (domInCell(view, event.target) != startDOMCell) {
      $anchor2 = cellUnderMouse(view, startEvent);
      if (!$anchor2) return stop();
    }
    if ($anchor2) setCellSelection($anchor2, event);
  }
  view.root.addEventListener("mouseup", stop);
  view.root.addEventListener("dragstart", stop);
  view.root.addEventListener("mousemove", move2);
}
function atEndOfCell(view, axis, dir) {
  if (!(view.state.selection instanceof TextSelection$1)) return null;
  const { $head } = view.state.selection;
  for (let d2 = $head.depth - 1; d2 >= 0; d2--) {
    const parent = $head.node(d2), index2 = dir < 0 ? $head.index(d2) : $head.indexAfter(d2);
    if (index2 != (dir < 0 ? 0 : parent.childCount)) return null;
    if (parent.type.spec.tableRole == "cell" || parent.type.spec.tableRole == "header_cell") {
      const cellPos = $head.before(d2);
      const dirStr = axis == "vert" ? dir > 0 ? "down" : "up" : dir > 0 ? "right" : "left";
      return view.endOfTextblock(dirStr) ? cellPos : null;
    }
  }
  return null;
}
function domInCell(view, dom) {
  for (; dom && dom != view.dom; dom = dom.parentNode) {
    if (dom.nodeName == "TD" || dom.nodeName == "TH") {
      return dom;
    }
  }
  return null;
}
function cellUnderMouse(view, event) {
  const mousePos = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (!mousePos) return null;
  return mousePos ? cellAround$1(view.state.doc.resolve(mousePos.pos)) : null;
}
var TableView = class {
  constructor(node2, defaultCellMinWidth) {
    this.node = node2;
    this.defaultCellMinWidth = defaultCellMinWidth;
    this.dom = document.createElement("div");
    this.dom.className = "tableWrapper";
    this.table = this.dom.appendChild(document.createElement("table"));
    this.table.style.setProperty(
      "--default-cell-min-width",
      `${defaultCellMinWidth}px`
    );
    this.colgroup = this.table.appendChild(document.createElement("colgroup"));
    updateColumnsOnResize(node2, this.colgroup, this.table, defaultCellMinWidth);
    this.contentDOM = this.table.appendChild(document.createElement("tbody"));
  }
  update(node2) {
    if (node2.type != this.node.type) return false;
    this.node = node2;
    updateColumnsOnResize(
      node2,
      this.colgroup,
      this.table,
      this.defaultCellMinWidth
    );
    return true;
  }
  ignoreMutation(record) {
    return record.type == "attributes" && (record.target == this.table || this.colgroup.contains(record.target));
  }
};
function updateColumnsOnResize(node2, colgroup, table, defaultCellMinWidth, overrideCol, overrideValue) {
  var _a2;
  let totalWidth = 0;
  let fixedWidth = true;
  let nextDOM = colgroup.firstChild;
  const row = node2.firstChild;
  if (!row) return;
  for (let i = 0, col = 0; i < row.childCount; i++) {
    const { colspan, colwidth } = row.child(i).attrs;
    for (let j2 = 0; j2 < colspan; j2++, col++) {
      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j2];
      const cssWidth = hasWidth ? hasWidth + "px" : "";
      totalWidth += hasWidth || defaultCellMinWidth;
      if (!hasWidth) fixedWidth = false;
      if (!nextDOM) {
        const col2 = document.createElement("col");
        col2.style.width = cssWidth;
        colgroup.appendChild(col2);
      } else {
        if (nextDOM.style.width != cssWidth) {
          nextDOM.style.width = cssWidth;
        }
        nextDOM = nextDOM.nextSibling;
      }
    }
  }
  while (nextDOM) {
    const after = nextDOM.nextSibling;
    (_a2 = nextDOM.parentNode) == null ? void 0 : _a2.removeChild(nextDOM);
    nextDOM = after;
  }
  if (fixedWidth) {
    table.style.width = totalWidth + "px";
    table.style.minWidth = "";
  } else {
    table.style.width = "";
    table.style.minWidth = totalWidth + "px";
  }
}
var columnResizingPluginKey = new PluginKey(
  "tableColumnResizing"
);
function columnResizing({
  handleWidth = 5,
  cellMinWidth = 25,
  defaultCellMinWidth = 100,
  View = TableView,
  lastColumnResizable = true
} = {}) {
  const plugin2 = new Plugin({
    key: columnResizingPluginKey,
    state: {
      init(_2, state2) {
        var _a2, _b;
        const nodeViews = (_b = (_a2 = plugin2.spec) == null ? void 0 : _a2.props) == null ? void 0 : _b.nodeViews;
        const tableName = tableNodeTypes(state2.schema).table.name;
        if (View && nodeViews) {
          nodeViews[tableName] = (node2, view) => {
            return new View(node2, defaultCellMinWidth, view);
          };
        }
        return new ResizeState(-1, false);
      },
      apply(tr, prev) {
        return prev.apply(tr);
      }
    },
    props: {
      attributes: (state2) => {
        const pluginState = columnResizingPluginKey.getState(state2);
        return pluginState && pluginState.activeHandle > -1 ? { class: "resize-cursor" } : {};
      },
      handleDOMEvents: {
        mousemove: (view, event) => {
          handleMouseMove(view, event, handleWidth, lastColumnResizable);
        },
        mouseleave: (view) => {
          handleMouseLeave(view);
        },
        mousedown: (view, event) => {
          handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth);
        }
      },
      decorations: (state2) => {
        const pluginState = columnResizingPluginKey.getState(state2);
        if (pluginState && pluginState.activeHandle > -1) {
          return handleDecorations(state2, pluginState.activeHandle);
        }
      },
      nodeViews: {}
    }
  });
  return plugin2;
}
var ResizeState = class _ResizeState {
  constructor(activeHandle, dragging) {
    this.activeHandle = activeHandle;
    this.dragging = dragging;
  }
  apply(tr) {
    const state2 = this;
    const action = tr.getMeta(columnResizingPluginKey);
    if (action && action.setHandle != null)
      return new _ResizeState(action.setHandle, false);
    if (action && action.setDragging !== void 0)
      return new _ResizeState(state2.activeHandle, action.setDragging);
    if (state2.activeHandle > -1 && tr.docChanged) {
      let handle = tr.mapping.map(state2.activeHandle, -1);
      if (!pointsAtCell(tr.doc.resolve(handle))) {
        handle = -1;
      }
      return new _ResizeState(handle, state2.dragging);
    }
    return state2;
  }
};
function handleMouseMove(view, event, handleWidth, lastColumnResizable) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState) return;
  if (!pluginState.dragging) {
    const target = domCellAround(event.target);
    let cell = -1;
    if (target) {
      const { left: left2, right: right2 } = target.getBoundingClientRect();
      if (event.clientX - left2 <= handleWidth)
        cell = edgeCell(view, event, "left", handleWidth);
      else if (right2 - event.clientX <= handleWidth)
        cell = edgeCell(view, event, "right", handleWidth);
    }
    if (cell != pluginState.activeHandle) {
      if (!lastColumnResizable && cell !== -1) {
        const $cell = view.state.doc.resolve(cell);
        const table = $cell.node(-1);
        const map22 = TableMap.get(table);
        const tableStart = $cell.start(-1);
        const col = map22.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;
        if (col == map22.width - 1) {
          return;
        }
      }
      updateHandle(view, cell);
    }
  }
}
function handleMouseLeave(view) {
  if (!view.editable) return;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)
    updateHandle(view, -1);
}
function handleMouseDown2(view, event, cellMinWidth, defaultCellMinWidth) {
  var _a2;
  if (!view.editable) return false;
  const win = (_a2 = view.dom.ownerDocument.defaultView) != null ? _a2 : window;
  const pluginState = columnResizingPluginKey.getState(view.state);
  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)
    return false;
  const cell = view.state.doc.nodeAt(pluginState.activeHandle);
  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, {
      setDragging: { startX: event.clientX, startWidth: width }
    })
  );
  function finish(event2) {
    win.removeEventListener("mouseup", finish);
    win.removeEventListener("mousemove", move2);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (pluginState2 == null ? void 0 : pluginState2.dragging) {
      updateColumnWidth(
        view,
        pluginState2.activeHandle,
        draggedWidth(pluginState2.dragging, event2, cellMinWidth)
      );
      view.dispatch(
        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })
      );
    }
  }
  function move2(event2) {
    if (!event2.which) return finish(event2);
    const pluginState2 = columnResizingPluginKey.getState(view.state);
    if (!pluginState2) return;
    if (pluginState2.dragging) {
      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);
      displayColumnWidth(
        view,
        pluginState2.activeHandle,
        dragged,
        defaultCellMinWidth
      );
    }
  }
  displayColumnWidth(
    view,
    pluginState.activeHandle,
    width,
    defaultCellMinWidth
  );
  win.addEventListener("mouseup", finish);
  win.addEventListener("mousemove", move2);
  event.preventDefault();
  return true;
}
function currentColWidth(view, cellPos, { colspan, colwidth }) {
  const width = colwidth && colwidth[colwidth.length - 1];
  if (width) return width;
  const dom = view.domAtPos(cellPos);
  const node2 = dom.node.childNodes[dom.offset];
  let domWidth = node2.offsetWidth, parts = colspan;
  if (colwidth) {
    for (let i = 0; i < colspan; i++)
      if (colwidth[i]) {
        domWidth -= colwidth[i];
        parts--;
      }
  }
  return domWidth / parts;
}
function domCellAround(target) {
  while (target && target.nodeName != "TD" && target.nodeName != "TH")
    target = target.classList && target.classList.contains("ProseMirror") ? null : target.parentNode;
  return target;
}
function edgeCell(view, event, side, handleWidth) {
  const offset2 = side == "right" ? -handleWidth : handleWidth;
  const found2 = view.posAtCoords({
    left: event.clientX + offset2,
    top: event.clientY
  });
  if (!found2) return -1;
  const { pos } = found2;
  const $cell = cellAround$1(view.state.doc.resolve(pos));
  if (!$cell) return -1;
  if (side == "right") return $cell.pos;
  const map22 = TableMap.get($cell.node(-1)), start2 = $cell.start(-1);
  const index2 = map22.map.indexOf($cell.pos - start2);
  return index2 % map22.width == 0 ? -1 : start2 + map22.map[index2 - 1];
}
function draggedWidth(dragging, event, resizeMinWidth) {
  const offset2 = event.clientX - dragging.startX;
  return Math.max(resizeMinWidth, dragging.startWidth + offset2);
}
function updateHandle(view, value) {
  view.dispatch(
    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })
  );
}
function updateColumnWidth(view, cell, width) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), map22 = TableMap.get(table), start2 = $cell.start(-1);
  const col = map22.colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  const tr = view.state.tr;
  for (let row = 0; row < map22.height; row++) {
    const mapIndex = row * map22.width + col;
    if (row && map22.map[mapIndex] == map22.map[mapIndex - map22.width]) continue;
    const pos = map22.map[mapIndex];
    const attrs = table.nodeAt(pos).attrs;
    const index2 = attrs.colspan == 1 ? 0 : col - map22.colCount(pos);
    if (attrs.colwidth && attrs.colwidth[index2] == width) continue;
    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);
    colwidth[index2] = width;
    tr.setNodeMarkup(start2 + pos, null, { ...attrs, colwidth });
  }
  if (tr.docChanged) view.dispatch(tr);
}
function displayColumnWidth(view, cell, width, defaultCellMinWidth) {
  const $cell = view.state.doc.resolve(cell);
  const table = $cell.node(-1), start2 = $cell.start(-1);
  const col = TableMap.get(table).colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  let dom = view.domAtPos($cell.start(-1)).node;
  while (dom && dom.nodeName != "TABLE") {
    dom = dom.parentNode;
  }
  if (!dom) return;
  updateColumnsOnResize(
    table,
    dom.firstChild,
    dom,
    defaultCellMinWidth,
    col,
    width
  );
}
function zeroes(n) {
  return Array(n).fill(0);
}
function handleDecorations(state2, cell) {
  var _a2;
  const decorations = [];
  const $cell = state2.doc.resolve(cell);
  const table = $cell.node(-1);
  if (!table) {
    return DecorationSet.empty;
  }
  const map22 = TableMap.get(table);
  const start2 = $cell.start(-1);
  const col = map22.colCount($cell.pos - start2) + $cell.nodeAfter.attrs.colspan - 1;
  for (let row = 0; row < map22.height; row++) {
    const index2 = col + row * map22.width;
    if ((col == map22.width - 1 || map22.map[index2] != map22.map[index2 + 1]) && (row == 0 || map22.map[index2] != map22.map[index2 - map22.width])) {
      const cellPos = map22.map[index2];
      const pos = start2 + cellPos + table.nodeAt(cellPos).nodeSize - 1;
      const dom = document.createElement("div");
      dom.className = "column-resize-handle";
      if ((_a2 = columnResizingPluginKey.getState(state2)) == null ? void 0 : _a2.dragging) {
        decorations.push(
          Decoration.node(
            start2 + cellPos,
            start2 + cellPos + table.nodeAt(cellPos).nodeSize,
            {
              class: "column-resize-dragging"
            }
          )
        );
      }
      decorations.push(Decoration.widget(pos, dom));
    }
  }
  return DecorationSet.create(state2.doc, decorations);
}
function tableEditing({
  allowTableNodeSelection = false
} = {}) {
  return new Plugin({
    key: tableEditingKey,
    // This piece of state is used to remember when a mouse-drag
    // cell-selection is happening, so that it can continue even as
    // transactions (which might move its anchor cell) come in.
    state: {
      init() {
        return null;
      },
      apply(tr, cur) {
        const set = tr.getMeta(tableEditingKey);
        if (set != null) return set == -1 ? null : set;
        if (cur == null || !tr.docChanged) return cur;
        const { deleted, pos } = tr.mapping.mapResult(cur);
        return deleted ? null : pos;
      }
    },
    props: {
      decorations: drawCellSelection,
      handleDOMEvents: {
        mousedown: handleMouseDown
      },
      createSelectionBetween(view) {
        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;
      },
      handleTripleClick,
      handleKeyDown,
      handlePaste
    },
    appendTransaction(_2, oldState, state2) {
      return normalizeSelection(
        state2,
        fixTables(state2, oldState),
        allowTableNodeSelection
      );
    }
  });
}
const isCellSelection = (value) => value instanceof CellSelection;
const deleteTableWhenSelected = ({ editor }) => {
  const { selection } = editor.state;
  if (!isCellSelection(selection)) return false;
  let cellCount = 0;
  const table = findParentNodeClosestToPos(selection.ranges[0].$from, (node2) => {
    return node2.type.name === "table";
  });
  table?.node.descendants((node2) => {
    if (node2.type.name === "table") return false;
    if (["tableCell", "tableHeader"].includes(node2.type.name)) {
      cellCount += 1;
    }
  });
  const allCellsSelected = cellCount === selection.ranges.length;
  if (!allCellsSelected) {
    return false;
  }
  editor.commands.deleteTable();
  return true;
};
const createCellBorders = ({ size: size2 = 0.66665, color = "#000000" } = {}) => {
  return {
    top: { size: size2, color },
    left: { size: size2, color },
    bottom: { size: size2, color },
    right: { size: size2, color }
  };
};
function cellAround($pos) {
  for (let d2 = $pos.depth - 1; d2 > 0; d2--)
    if ($pos.node(d2).type.spec.tableRole == "row") return $pos.node(0).resolve($pos.before(d2 + 1));
  return null;
}
function cellWrapping($pos) {
  for (let d2 = $pos.depth; d2 > 0; d2--) {
    const role = $pos.node(d2).type.spec.tableRole;
    if (role === "cell" || role === "header_cell") return $pos.node(d2);
  }
  return null;
}
const Table = Node$1.create({
  name: "table",
  content: "tableRow+",
  group: "block",
  isolating: true,
  tableRole: "table",
  /**
   * Table extension options
   * @category Options
   * @typedef {Object} TableOptions
   * @property {Object} [htmlAttributes={'aria-label': 'Table node'}] - Default HTML attributes for all tables
   * @property {boolean} [resizable=true] - Enable column resizing functionality
   * @property {number} [handleWidth=5] - Width of resize handles in pixels
   * @property {number} [cellMinWidth=10] - Minimum cell width constraint in pixels
   * @property {boolean} [lastColumnResizable=true] - Allow resizing of the last column
   * @property {boolean} [allowTableNodeSelection=false] - Enable selecting the entire table node
   */
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table node"
      },
      resizable: true,
      handleWidth: 5,
      cellMinWidth: 10,
      lastColumnResizable: true,
      allowTableNodeSelection: false
    };
  },
  addAttributes() {
    return {
      /* tableWidth: {
        renderDOM: ({ tableWidth }) => {
          if (!tableWidth) return {};
          const { width, type = 'auto' } = tableWidth;
          return { 
            style: `width: ${width}px` 
          };
        },
      }, */
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking ID (not user-configurable)
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      /**
       * @category Attribute
       * @param {TableIndent} [tableIndent] - Table indentation configuration
       */
      tableIndent: {
        renderDOM: ({ tableIndent }) => {
          if (!tableIndent) return {};
          const { width } = tableIndent;
          let style2 = "";
          if (width) style2 += `margin-left: ${width}px`;
          return {
            style: style2
          };
        }
      },
      /**
       * @category Attribute
       * @param {import("./tableHelpers/createTableBorders.js").TableBorders} [borders] - Border styling for this table
       */
      borders: {
        default: {},
        renderDOM({ borders }) {
          if (!borders) return {};
          const style2 = Object.entries(borders).reduce((acc, [key, { size: size2, color }]) => {
            return `${acc}border-${key}: ${Math.ceil(size2)}px solid ${color || "black"};`;
          }, "");
          return {
            style: style2
          };
        }
      },
      /**
       * @category Attribute
       * @param {string} [borderCollapse='collapse'] - CSS border-collapse property
       */
      borderCollapse: {
        default: null,
        renderDOM({ borderCollapse }) {
          return {
            style: `border-collapse: ${borderCollapse || "collapse"}`
          };
        }
      },
      /**
       * @category Attribute
       * @param {string} [justification] - Table alignment ('left', 'center', 'right')
       */
      justification: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.justification) return {};
          if (attrs.justification === "center") {
            return { style: `margin: 0 auto` };
          }
          if (attrs.justification === "right") {
            return { style: `margin-left: auto` };
          }
          return {};
        }
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [tableStyleId] - Internal reference to table style (not user-configurable)
       */
      tableStyleId: {
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [tableLayout] - CSS table-layout property (advanced usage)
       */
      tableLayout: {
        rendered: false
      },
      /**
       * @category Attribute
       * @param {number} [tableCellSpacing] - Cell spacing in pixels for this table
       */
      tableCellSpacing: {
        default: null,
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: "table" }];
  },
  renderDOM({ node: node2, htmlAttributes }) {
    const { colgroup, tableWidth, tableMinWidth } = createColGroup(node2, this.options.cellMinWidth);
    const attrs = Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes, {
      style: tableWidth ? `width: ${tableWidth}` : `min-width: ${tableMinWidth}`
    });
    const table = ["table", attrs, colgroup, ["tbody", 0]];
    return table;
  },
  addCommands() {
    return {
      /**
       * Insert a new table into the document
       * @category Command
       * @param {TableConfig} [config] - Table configuration options
       * @returns {Function} Command
       * @example
       * // Using default values
       * insertTable() // Creates 3x3 table without header
       *
       * // Using custom values
       * insertTable({ rows: 3, cols: 3, withHeaderRow: true })
       *
       */
      insertTable: ({ rows = 3, cols = 3, withHeaderRow = false } = {}) => ({ tr, dispatch, editor }) => {
        const node2 = createTable(editor.schema, rows, cols, withHeaderRow);
        if (dispatch) {
          const offset2 = tr.selection.from + 1;
          tr.replaceSelectionWith(node2).scrollIntoView().setSelection(TextSelection$1.near(tr.doc.resolve(offset2)));
        }
        return true;
      },
      /**
       * Delete the entire table containing the cursor
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteTable()
       */
      deleteTable: () => ({ state: state2, dispatch }) => {
        return deleteTable(state2, dispatch);
      },
      /**
       * Add a column before the current column
       * @category Command
       * @returns {Function} Command
       * @example
       * addColumnBefore()
       * @note Preserves cell attributes from current column
       */
      addColumnBefore: () => ({ state: state2, dispatch, chain }) => {
        if (!addColumnBefore(state2)) return false;
        let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state2);
        return chain().command(() => addColumnBefore(state2, dispatch)).command(({ tr }) => {
          let table = tr.doc.nodeAt(rect.tableStart - 1);
          if (!table) return false;
          let updatedMap = TableMap.get(table);
          let newColumnIndex = rect.left;
          if (newColumnIndex < 0 || newColumnIndex >= updatedMap.width) {
            return false;
          }
          for (let row = 0; row < updatedMap.height; row++) {
            let cellIndex = row * updatedMap.width + newColumnIndex;
            let cellPos = updatedMap.map[cellIndex];
            let cellAbsolutePos = rect.tableStart + cellPos;
            let cell = tr.doc.nodeAt(cellAbsolutePos);
            if (cell) {
              let attrs = {
                ...currentCellAttrs,
                colspan: cell.attrs.colspan,
                rowspan: cell.attrs.rowspan,
                colwidth: cell.attrs.colwidth
              };
              tr.setNodeMarkup(cellAbsolutePos, null, attrs);
            }
          }
          return true;
        }).run();
      },
      /**
       * Add a column after the current column
       * @category Command
       * @returns {Function} Command
       * @example
       * addColumnAfter()
       * @note Preserves cell attributes from current column
       */
      addColumnAfter: () => ({ state: state2, dispatch, chain }) => {
        if (!addColumnAfter(state2)) return false;
        let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state2);
        return chain().command(() => addColumnAfter(state2, dispatch)).command(({ tr }) => {
          let table = tr.doc.nodeAt(rect.tableStart - 1);
          if (!table) return false;
          let updatedMap = TableMap.get(table);
          let newColumnIndex = rect.left + 1;
          if (newColumnIndex < 0 || newColumnIndex >= updatedMap.width) {
            return false;
          }
          for (let row = 0; row < updatedMap.height; row++) {
            let cellIndex = row * updatedMap.width + newColumnIndex;
            let cellPos = updatedMap.map[cellIndex];
            let cellAbsolutePos = rect.tableStart + cellPos;
            let cell = tr.doc.nodeAt(cellAbsolutePos);
            if (cell) {
              let attrs = {
                ...currentCellAttrs,
                colspan: cell.attrs.colspan,
                rowspan: cell.attrs.rowspan,
                colwidth: cell.attrs.colwidth
              };
              tr.setNodeMarkup(cellAbsolutePos, null, attrs);
            }
          }
          return true;
        }).run();
      },
      /**
       * Delete the column containing the cursor
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteColumn()
       */
      deleteColumn: () => ({ state: state2, dispatch }) => {
        return deleteColumn(state2, dispatch);
      },
      /**
       * Add a row before the current row
       * @category Command
       * @returns {Function} Command
       * @example
       * addRowBefore()
       * @note Preserves cell attributes from current row
       */
      addRowBefore: () => ({ state: state2, dispatch, chain }) => {
        if (!addRowBefore(state2)) return false;
        let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state2);
        return chain().command(() => addRowBefore(state2, dispatch)).command(({ tr }) => {
          let table = tr.doc.nodeAt(rect.tableStart - 1);
          if (!table) return false;
          let updatedMap = TableMap.get(table);
          let newRowIndex = rect.top;
          if (newRowIndex < 0 || newRowIndex >= updatedMap.height) {
            return false;
          }
          for (let col = 0; col < updatedMap.width; col++) {
            let cellIndex = newRowIndex * updatedMap.width + col;
            let cellPos = updatedMap.map[cellIndex];
            let cellAbsolutePos = rect.tableStart + cellPos;
            let cell = tr.doc.nodeAt(cellAbsolutePos);
            if (cell) {
              let attrs = {
                ...currentCellAttrs,
                colspan: cell.attrs.colspan,
                rowspan: cell.attrs.rowspan,
                colwidth: cell.attrs.colwidth
              };
              tr.setNodeMarkup(cellAbsolutePos, null, attrs);
            }
          }
          return true;
        }).run();
      },
      /**
       * Add a row after the current row
       * @category Command
       * @returns {Function} Command
       * @example
       * addRowAfter()
       * @note Preserves cell attributes from current row
       */
      addRowAfter: () => ({ state: state2, dispatch, chain }) => {
        if (!addRowAfter(state2)) return false;
        let { rect, attrs: currentCellAttrs } = getCurrentCellAttrs(state2);
        return chain().command(() => addRowAfter(state2, dispatch)).command(({ tr }) => {
          let table = tr.doc.nodeAt(rect.tableStart - 1);
          if (!table) return false;
          let updatedMap = TableMap.get(table);
          let newRowIndex = rect.top + 1;
          if (newRowIndex >= updatedMap.height) return false;
          for (let col = 0; col < updatedMap.width; col++) {
            let cellIndex = newRowIndex * updatedMap.width + col;
            let cellPos = updatedMap.map[cellIndex];
            let cellAbsolutePos = rect.tableStart + cellPos;
            let cell = tr.doc.nodeAt(cellAbsolutePos);
            if (cell) {
              let attrs = {
                ...currentCellAttrs,
                colspan: cell.attrs.colspan,
                rowspan: cell.attrs.rowspan,
                colwidth: cell.attrs.colwidth
              };
              tr.setNodeMarkup(cellAbsolutePos, null, attrs);
            }
          }
          return true;
        }).run();
      },
      /**
       * Delete the row containing the cursor
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteRow()
       */
      deleteRow: () => ({ state: state2, dispatch }) => {
        return deleteRow(state2, dispatch);
      },
      /**
       * Merge selected cells into one
       * @category Command
       * @returns {Function} Command
       * @example
       * mergeCells()
       * @note Content from all cells is preserved
       */
      mergeCells: () => ({ state: state2, dispatch }) => {
        return mergeCells(state2, dispatch);
      },
      /**
       * Split a merged cell back into individual cells
       * @category Command
       * @returns {Function} Command - true if split, false if position invalid
       * @example
       * splitCell()
       */
      splitCell: () => ({ state: state2, dispatch, commands: commands2 }) => {
        if (splitCell(state2, dispatch)) {
          return true;
        }
        return commands2.splitSingleCell();
      },
      /**
       * Split a single unmerged cell into two cells horizontally
       * @category Command
       * @returns {Function} Command - true if split, false if position invalid
       * @example
       * splitSingleCell()
       * @note This command splits a single cell (not merged) into two cells by:
       * - Dividing the cell width in half
       * - Inserting a new cell to the right
       * - Adjusting colspan for cells in other rows that span this column
       * - Only works on cells with colspan=1 and rowspan=1
       * @note Different from splitCell which splits merged cells back to original cells
       */
      splitSingleCell: () => ({ state: state2, dispatch, tr }) => {
        const sel = state2.selection;
        let cellNode;
        let cellPos;
        if (!(sel instanceof CellSelection)) {
          cellNode = cellWrapping(sel.$from);
          if (!cellNode) return false;
          cellPos = cellAround(sel.$from)?.pos;
        } else {
          if (sel.$anchorCell.pos != sel.$headCell.pos) return false;
          cellNode = sel.$anchorCell.nodeAfter;
          cellPos = sel.$anchorCell.pos;
        }
        if (cellNode == null || cellPos == null) {
          return false;
        }
        if (cellNode.attrs.colspan != 1 || cellNode.attrs.rowspan != 1) {
          return false;
        }
        if (dispatch) {
          let rect = selectedRect(state2);
          let currentRow = rect.top;
          let currentCol = rect.left;
          let baseAttrs = { ...cellNode.attrs };
          let currentColWidth2 = baseAttrs.colwidth;
          let newCellWidth = null;
          if (currentColWidth2 && currentColWidth2[0]) {
            newCellWidth = Math.ceil(currentColWidth2[0] / 2);
          }
          if (newCellWidth) {
            tr.setNodeMarkup(tr.mapping.map(cellPos, 1), null, { ...baseAttrs, colwidth: [newCellWidth] });
          }
          const newCellAttrs = { ...baseAttrs, colwidth: newCellWidth ? [newCellWidth] : null };
          const newCell = getCellType({ node: cellNode, state: state2 }).createAndFill(newCellAttrs);
          tr.insert(tr.mapping.map(cellPos + cellNode.nodeSize, 1), newCell);
          for (let row = 0; row < rect.map.height; row++) {
            if (row === currentRow) continue;
            let rowCells = /* @__PURE__ */ new Set();
            for (let col = 0; col < rect.map.width; col++) {
              let cellIndex = rect.map.map[row * rect.map.width + col];
              if (cellIndex != null) rowCells.add(cellIndex);
            }
            [...rowCells].forEach((cellIndex) => {
              let cellRect = rect.map.findCell(cellIndex);
              if (cellRect.left <= currentCol && cellRect.right > currentCol) {
                let cellPos2 = tr.mapping.map(rect.tableStart + cellIndex, 1);
                let cell = tr.doc.nodeAt(cellPos2);
                if (cell) {
                  let newColspan = (cell.attrs.colspan || 1) + 1;
                  let updatedColwidth = cell.attrs.colwidth;
                  if (updatedColwidth && newCellWidth) {
                    let originalColIndex = currentCol - cellRect.left;
                    updatedColwidth = [
                      ...updatedColwidth.slice(0, originalColIndex),
                      newCellWidth,
                      // current cell width
                      newCellWidth,
                      // new cell width
                      ...updatedColwidth.slice(originalColIndex + 1)
                    ];
                  }
                  let cellAttrs = { ...cell.attrs, colspan: newColspan, colwidth: updatedColwidth };
                  tr.setNodeMarkup(cellPos2, null, cellAttrs);
                }
              }
            });
          }
        }
        return true;
      },
      /**
       * Toggle between merge and split cells based on selection
       * @category Command
       * @returns {Function} Command
       * @example
       * mergeOrSplit()
       * @note Merges if multiple cells selected, splits if merged cell selected
       */
      mergeOrSplit: () => ({ state: state2, dispatch, commands: commands2 }) => {
        if (mergeCells(state2, dispatch)) {
          return true;
        }
        return commands2.splitCell();
      },
      /**
       * Toggle the first column as header column
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderColumn()
       */
      toggleHeaderColumn: () => ({ state: state2, dispatch }) => {
        return toggleHeader("column")(state2, dispatch);
      },
      /**
       * Toggle the first row as header row
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderRow()
       */
      toggleHeaderRow: () => ({ state: state2, dispatch }) => {
        return toggleHeader("row")(state2, dispatch);
      },
      /**
       * Toggle current cell as header cell
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHeaderCell()
       */
      toggleHeaderCell: () => ({ state: state2, dispatch }) => {
        return toggleHeaderCell(state2, dispatch);
      },
      /**
       * Set an attribute on selected cells
       * @category Command
       * @param {string} name - Attribute name
       * @param {*} value - Attribute value
       * @returns {Function} Command
       * @example
       * setCellAttr('background', { color: 'ff0000' })
       * setCellAttr('verticalAlign', 'middle')
       */
      setCellAttr: (name, value) => ({ state: state2, dispatch }) => {
        return setCellAttr(name, value)(state2, dispatch);
      },
      /**
       * Navigate to the next cell (Tab behavior)
       * @category Command
       * @returns {Function} Command
       * @example
       * goToNextCell()
       */
      goToNextCell: () => ({ state: state2, dispatch }) => {
        return goToNextCell(1)(state2, dispatch);
      },
      /**
       * Navigate to the previous cell (Shift+Tab behavior)
       * @category Command
       * @returns {Function} Command
       * @example
       * goToPreviousCell()
       */
      goToPreviousCell: () => ({ state: state2, dispatch }) => {
        return goToNextCell(-1)(state2, dispatch);
      },
      /**
       * Fix table structure inconsistencies
       * @category Command
       * @returns {Function} Command
       * @example
       * fixTables()
       * @note Repairs malformed tables and normalizes structure
       */
      fixTables: () => ({ state: state2, dispatch }) => {
        if (dispatch) {
          fixTables(state2);
        }
        return true;
      },
      /**
       * Set cell selection programmatically
       * @category Command
       * @param {CellSelectionPosition} pos - Cell selection coordinates
       * @returns {Function} Command
       * @example
       * setCellSelection({ anchorCell: 10, headCell: 15 })
       */
      setCellSelection: (pos) => ({ tr, dispatch }) => {
        if (dispatch) {
          tr.setSelection(CellSelection.create(tr.doc, pos.anchorCell, pos.headCell));
        }
        return true;
      },
      /**
       * Set background color for selected cells
       * @category Command
       * @param {string} value - Color value (hex with or without #)
       * @returns {Function} Command
       * @example
       * setCellBackground('#ff0000')
       * setCellBackground('ff0000')
       */
      setCellBackground: (value) => ({ editor, commands: commands2, dispatch }) => {
        const { selection } = editor.state;
        if (!isCellSelection(selection)) {
          return false;
        }
        const color = value?.startsWith("#") ? value.slice(1) : value;
        if (dispatch) {
          return commands2.setCellAttr("background", { color });
        }
        return true;
      },
      /**
       * Remove all borders from table and its cells
       * @category Command
       * @returns {Function} Command
       * @example
       * deleteCellAndTableBorders()
       * @note Sets all border sizes to 0
       */
      deleteCellAndTableBorders: () => ({ state: state2, tr }) => {
        if (!isInTable$1(state2)) {
          return false;
        }
        const table = findParentNode((node2) => node2.type.name === this.name)(state2.selection);
        if (!table) {
          return false;
        }
        const from2 = table.pos;
        const to = table.pos + table.node.nodeSize;
        state2.doc.nodesBetween(from2, to, (node2, pos) => {
          if (["tableCell", "tableHeader"].includes(node2.type.name)) {
            tr.setNodeMarkup(pos, void 0, {
              ...node2.attrs,
              borders: createCellBorders({ size: 0 })
            });
          }
        });
        tr.setNodeMarkup(table.pos, void 0, {
          ...table.node.attrs,
          borders: createTableBorders({ size: 0 })
        });
        return true;
      }
    };
  },
  addShortcuts() {
    return {
      Tab: () => {
        if (this.editor.commands.goToNextCell()) {
          return true;
        }
        if (!this.editor.can().addRowAfter()) {
          return false;
        }
        return this.editor.chain().addRowAfter().goToNextCell().run();
      },
      "Shift-Tab": () => this.editor.commands.goToPreviousCell(),
      Backspace: deleteTableWhenSelected,
      "Mod-Backspace": deleteTableWhenSelected,
      Delete: deleteTableWhenSelected,
      "Mod-Delete": deleteTableWhenSelected
    };
  },
  addPmPlugins() {
    const resizable = this.options.resizable && this.editor.isEditable;
    return [
      ...resizable ? [
        columnResizing({
          handleWidth: this.options.handleWidth,
          cellMinWidth: this.options.cellMinWidth,
          defaultCellMinWidth: this.options.cellMinWidth,
          lastColumnResizable: this.options.lastColumnResizable,
          View: createTableView({
            editor: this.editor
          })
        })
      ] : [],
      tableEditing({
        allowTableNodeSelection: this.options.allowTableNodeSelection
      })
    ];
  },
  extendNodeSchema(extension) {
    return {
      tableRole: callOrGet(
        getExtensionConfigField(extension, "tableRole", {
          name: extension.name,
          options: extension.options,
          storage: extension.storage
        })
      )
    };
  }
});
function getCellType({ node: node2, state: state2 }) {
  const nodeTypes = tableNodeTypes(state2.schema);
  return nodeTypes[node2.type.spec.tableRole];
}
function copyCellAttrs(node2) {
  const { colspan, rowspan, colwidth, ...attrs } = node2.attrs;
  return attrs;
}
function getCurrentCellAttrs(state2) {
  let rect = selectedRect(state2);
  let index2 = rect.top * rect.map.width + rect.left;
  let pos = rect.map.map[index2];
  let cell = rect.table.nodeAt(pos);
  let attrs = copyCellAttrs(cell);
  return { rect, cell, attrs };
}
const TableHeader = Node$1.create({
  name: "tableHeader",
  content: "block+",
  tableRole: "header_cell",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table head node"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {number} [colspan=1] - Number of columns this header spans
       */
      colspan: {
        default: 1
      },
      /**
       * @category Attribute
       * @param {number} [rowspan=1] - Number of rows this header spans
       */
      rowspan: {
        default: 1
      },
      /**
       * @category Attribute
       * @param {number[]} [colwidth] - Column widths array in pixels
       */
      colwidth: {
        default: null,
        parseDOM: (element) => {
          const colwidth = element.getAttribute("data-colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        },
        renderDOM: (attrs) => {
          if (!attrs.colwidth) return {};
          return {
            "data-colwidth": attrs.colwidth.join(",")
          };
        }
      }
    };
  },
  parseDOM() {
    return [{ tag: "th" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["th", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const TableRow = Node$1.create({
  name: "tableRow",
  content: "(tableCell | tableHeader)*",
  tableRole: "row",
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table row node"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {number} [rowHeight] - Fixed row height in pixels
       */
      rowHeight: {
        renderDOM({ rowHeight }) {
          if (!rowHeight) return {};
          const style2 = `height: ${rowHeight}px`;
          return { style: style2 };
        }
      }
    };
  },
  parseDOM() {
    return [{ tag: "tr" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["tr", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const TableCell = Node$1.create({
  name: "tableCell",
  content: "block+",
  tableRole: "cell",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        "aria-label": "Table cell node"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {number} [colspan=1] - Number of columns this cell spans
       */
      colspan: {
        default: 1
      },
      /**
       * @category Attribute
       * @param {number} [rowspan=1] - Number of rows this cell spans
       */
      rowspan: {
        default: 1
      },
      /**
       * @category Attribute
       * @param {number[]} [colwidth=[100]] - Column widths array in pixels
       */
      colwidth: {
        default: [100],
        parseDOM: (elem) => {
          const colwidth = elem.getAttribute("data-colwidth");
          const value = colwidth ? colwidth.split(",").map((width) => parseInt(width, 10)) : null;
          return value;
        },
        renderDOM: (attrs) => {
          if (!attrs.colwidth) return {};
          return {
            "data-colwidth": attrs.colwidth.join(",")
          };
        }
      },
      /**
       * @category Attribute
       * @param {CellBackground} [background] - Cell background color configuration
       */
      background: {
        renderDOM({ background }) {
          if (!background) return {};
          const { color } = background || {};
          const style2 = `background-color: ${color ? `#${color}` : "transparent"}`;
          return { style: style2 };
        }
      },
      /**
       * @category Attribute
       * @param {string} [verticalAlign] - Vertical content alignment (top, middle, bottom)
       */
      verticalAlign: {
        renderDOM({ verticalAlign }) {
          if (!verticalAlign) return {};
          const style2 = `vertical-align: ${verticalAlign}`;
          return { style: style2 };
        }
      },
      /**
       * @category Attribute
       * @param {CellMargins} [cellMargins] - Internal cell padding
       */
      cellMargins: {
        renderDOM({ cellMargins }) {
          if (!cellMargins) return {};
          const sides2 = ["top", "right", "bottom", "left"];
          const style2 = sides2.map((side) => {
            const margin = cellMargins?.[side];
            if (margin) return `padding-${side}: ${margin}px;`;
            return "";
          }).join(" ");
          return { style: style2 };
        }
      },
      /**
       * @category Attribute
       * @param {CellBorders} [borders] - Cell border configuration
       */
      borders: {
        default: () => createCellBorders(),
        renderDOM({ borders }) {
          if (!borders) return {};
          const sides2 = ["top", "right", "bottom", "left"];
          const style2 = sides2.map((side) => {
            const border = borders?.[side];
            if (border && border.val === "none") return `border-${side}: ${border.val};`;
            if (border) return `border-${side}: ${Math.ceil(border.size)}px solid ${border.color || "black"};`;
            return "";
          }).join(" ");
          return { style: style2 };
        }
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [widthType='auto'] - Internal width type
       */
      widthType: {
        default: "auto",
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {string} [widthUnit='px'] - Internal width unit
       */
      widthUnit: {
        default: "px",
        rendered: false
      }
    };
  },
  parseDOM() {
    return [{ tag: "td" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["td", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
class FieldAnnotationView {
  constructor(options) {
    __privateAdd$1(this, _FieldAnnotationView_instances);
    __publicField$1(this, "editor");
    __publicField$1(this, "node");
    __publicField$1(this, "decorations");
    __publicField$1(this, "getPos");
    __publicField$1(this, "htmlAttributes");
    __publicField$1(this, "dom");
    __publicField$1(this, "annotationClass");
    __publicField$1(this, "annotationContentClass");
    __publicField$1(this, "borderColor");
    this.editor = options.editor;
    this.node = options.node;
    this.decorations = options.decorations;
    this.getPos = options.getPos;
    this.htmlAttributes = options.htmlAttributes;
    this.annotationClass = options.annotationClass;
    this.annotationContentClass = options.annotationContentClass;
    this.borderColor = options.borderColor;
    this.handleAnnotationClick = this.handleAnnotationClick.bind(this);
    this.handleAnnotationDoubleClick = this.handleAnnotationDoubleClick.bind(this);
    this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);
    this.buildView();
    this.attachEventListeners();
  }
  buildView() {
    let { type: type2 } = this.node.attrs;
    let handlers2 = {
      text: (...args) => this.buildTextView(...args),
      image: (...args) => this.buildImageView(...args),
      signature: (...args) => this.buildSignatureView(...args),
      checkbox: (...args) => this.buildCheckboxView(...args),
      html: (...args) => this.buildHTMLView(...args),
      link: (...args) => this.buildLinkView(...args),
      default: (...args) => this.buildTextView(...args)
    };
    let buildHandler = handlers2[type2] ?? handlers2.default;
    buildHandler();
  }
  buildTextView() {
    let { displayLabel } = this.node.attrs;
    let { annotation } = __privateMethod$1(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this, {
      displayLabel
    });
    this.dom = annotation;
  }
  buildImageView() {
    let { displayLabel, imageSrc } = this.node.attrs;
    let { annotation, content } = __privateMethod$1(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (imageSrc) {
      let img = document.createElement("img");
      img.src = imageSrc;
      img.alt = displayLabel;
      img.style.height = "auto";
      img.style.maxWidth = "100%";
      img.style.pointerEvents = "none";
      img.style.verticalAlign = "middle";
      content.append(img);
      annotation.style.display = "inline-block";
      content.style.display = "inline-block";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildSignatureView() {
    let { displayLabel, imageSrc } = this.node.attrs;
    displayLabel = displayLabel || "Signature";
    let { annotation, content } = __privateMethod$1(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (imageSrc) {
      let img = document.createElement("img");
      img.src = imageSrc;
      img.alt = displayLabel;
      img.style.height = "auto";
      img.style.maxWidth = "100%";
      img.style.maxHeight = "28px";
      img.style.pointerEvents = "none";
      img.style.verticalAlign = "middle";
      content.append(img);
      annotation.style.display = "inline-block";
      content.style.display = "inline-block";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildCheckboxView() {
    let { displayLabel } = this.node.attrs;
    let { annotation } = __privateMethod$1(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this, {
      displayLabel
    });
    this.dom = annotation;
  }
  buildHTMLView() {
    let { displayLabel, rawHtml } = this.node.attrs;
    if (!this.editor.options.isHeadless && !!rawHtml) {
      try {
        const tempDiv = document.createElement("div");
        const childEditor = this.editor.createChildEditor({
          element: tempDiv,
          html: rawHtml
        });
        rawHtml = childEditor.view.dom.innerHTML;
      } catch (error) {
        console.warn("Error parsing HTML in FieldAnnotationView:", error);
      }
    }
    let { annotation, content } = __privateMethod$1(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (rawHtml) {
      content.innerHTML = rawHtml.trim();
      annotation.style.display = "inline-block";
      content.style.display = "inline-block";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  buildLinkView() {
    let { displayLabel, linkUrl } = this.node.attrs;
    let { annotation, content } = __privateMethod$1(this, _FieldAnnotationView_instances, createAnnotation_fn).call(this);
    if (linkUrl) {
      let link = document.createElement("a");
      link.href = linkUrl;
      link.target = "_blank";
      link.textContent = linkUrl;
      link.style.textDecoration = "none";
      content.append(link);
      content.style.pointerEvents = "all";
    } else {
      content.textContent = displayLabel;
    }
    this.dom = annotation;
  }
  attachEventListeners() {
    this.dom.addEventListener("click", this.handleAnnotationClick);
    this.dom.addEventListener("dblclick", this.handleAnnotationDoubleClick);
    this.editor.on("selectionUpdate", this.handleSelectionUpdate);
  }
  removeEventListeners() {
    this.dom.removeEventListener("click", this.handleAnnotationClick);
    this.dom.removeEventListener("dblclick", this.handleAnnotationDoubleClick);
    this.editor.off("selectionUpdate", this.handleSelectionUpdate);
  }
  handleSelectionUpdate({ editor }) {
    if (!this.editor.isEditable) {
      return;
    }
    let { selection } = editor.state;
    if (selection instanceof NodeSelection) {
      let currentNode = selection.node;
      if (this.node.eq(currentNode)) {
        this.editor.emit("fieldAnnotationSelected", {
          editor: this.editor,
          node: this.node,
          nodePos: this.getPos(),
          target: this.dom
        });
      }
    }
  }
  handleAnnotationClick(event) {
    if (!this.editor.isEditable) {
      return;
    }
    this.editor.emit("fieldAnnotationClicked", {
      editor: this.editor,
      node: this.node,
      nodePos: this.getPos(),
      event,
      currentTarget: event.currentTarget
    });
  }
  handleAnnotationDoubleClick(event) {
    if (!this.editor.isEditable) {
      return;
    }
    this.editor.emit("fieldAnnotationDoubleClicked", {
      editor: this.editor,
      node: this.node,
      nodePos: this.getPos(),
      event,
      currentTarget: event.currentTarget
    });
  }
  stopEvent(event) {
    if (!this.editor.isEditable) {
      event.preventDefault();
      return true;
    }
    return false;
  }
  // Can be used to manually update the NodeView.
  // Otherwise the NodeView is recreated.
  update() {
    return false;
  }
  ignoreMutation() {
    return true;
  }
  destroy() {
    this.removeEventListeners();
  }
  updateAttributes(attributes) {
    this.editor.commands.command(({ tr }) => {
      tr.setNodeMarkup(this.getPos(), void 0, {
        ...this.node.attrs,
        ...attributes
      });
      return true;
    });
  }
}
_FieldAnnotationView_instances = /* @__PURE__ */ new WeakSet();
createAnnotation_fn = function({ displayLabel } = {}) {
  let { highlighted } = this.node.attrs;
  let annotation = document.createElement("span");
  annotation.classList.add(this.annotationClass);
  let content = document.createElement("span");
  content.classList.add(this.annotationContentClass);
  content.style.pointerEvents = "none";
  content.contentEditable = "false";
  if (displayLabel) {
    content.textContent = displayLabel;
  }
  annotation.append(content);
  let omitHighlight = highlighted === false;
  let styles = [
    `border: 2px solid ${this.borderColor}`,
    `border-radius: 2px`,
    `padding: 1px 2px`,
    `box-sizing: border-box`
  ];
  let annotationStyle = styles.join("; ");
  let mergedAttrs = Attribute2.mergeAttributes(this.htmlAttributes, {
    style: omitHighlight ? "" : annotationStyle
  });
  for (let [key, value] of Object.entries(mergedAttrs)) {
    if (key === "style") {
      annotation.style.cssText = value;
    } else {
      annotation.setAttribute(key, value);
    }
  }
  return {
    annotation,
    content
  };
};
const FieldAnnotationPlugin = (options = {}) => {
  let { editor, annotationClass: annotationClass2 } = options;
  return new Plugin({
    key: new PluginKey("fieldAnnotation"),
    state: {
      init() {
        return null;
      },
      apply(tr, prevState) {
        trackFieldAnnotationsDeletion(editor, tr);
        return prevState;
      }
    },
    props: {
      handleDrop(view, event, slice2, moved) {
        if (moved) return false;
        let fieldAnnotation = event?.dataTransfer.getData("fieldAnnotation");
        if (fieldAnnotation) {
          if (options.handleDropOutside) {
            handleDropOutside({
              fieldAnnotation,
              editor,
              view,
              event
            });
          } else {
            let annotationAttrs;
            try {
              let fieldAnnotationObj = JSON.parse(fieldAnnotation);
              annotationAttrs = fieldAnnotationObj.attributes;
            } catch {
              return false;
            }
            const coordinates = view.posAtCoords({
              left: event.clientX,
              top: event.clientY
            });
            if (coordinates) {
              editor.commands.addFieldAnnotation(coordinates.pos, {
                ...annotationAttrs
              });
            }
          }
          return true;
        }
        return false;
      },
      handlePaste(view, event, slice2) {
        const content = slice2.content.content.filter((item) => item.type.name === "fieldAnnotation");
        if (content.length) {
          editor.emit("fieldAnnotationPaste", {
            content,
            editor
          });
        }
        return false;
      },
      handleDOMEvents: {
        dragstart: (view, event) => {
          if (!event.target) return false;
          let { target } = event;
          let isAnnotationField = target.classList?.contains(annotationClass2);
          if (isAnnotationField) {
            event.dataTransfer?.setDragImage(target, 0, 0);
          }
          return false;
        }
        // drop: (view, event) => {
        //   console.log({ view, event });
        // },
      }
    },
    /// For y-prosemirror support.
    appendTransaction: (transactions, oldState, newState) => {
      let docChanges = transactions.some((tr2) => tr2.docChanged) && !oldState.doc.eq(newState.doc);
      if (!docChanges) {
        return;
      }
      let { tr } = newState;
      let changed = false;
      let annotations = getAllFieldAnnotations(newState);
      if (!annotations.length) {
        return;
      }
      annotations.forEach(({ node: node2, pos }) => {
        let { marks } = node2;
        let currentNode = tr.doc.nodeAt(pos);
        if (marks.length > 0 && node2.eq(currentNode)) {
          tr.removeMark(pos, pos + node2.nodeSize, null);
          changed = true;
        }
      });
      return changed ? tr : null;
    }
    ///
  });
};
function handleDropOutside({ fieldAnnotation, editor, view, event }) {
  let sourceField;
  try {
    let fieldAnnotationObj = JSON.parse(fieldAnnotation);
    sourceField = fieldAnnotationObj.sourceField;
  } catch {
    return;
  }
  let coordinates = view.posAtCoords({
    left: event.clientX,
    top: event.clientY
  });
  if (coordinates) {
    editor.emit("fieldAnnotationDropped", {
      sourceField,
      editor,
      coordinates,
      pos: coordinates.pos
    });
  }
}
function guard(low, high, value) {
  return Math.min(Math.max(low, value), high);
}
class ColorError extends Error {
  constructor(color) {
    super(`Failed to parse color: "${color}"`);
  }
}
var ColorError$1 = ColorError;
function parseToRgba(color) {
  if (typeof color !== "string") throw new ColorError$1(color);
  if (color.trim().toLowerCase() === "transparent") return [0, 0, 0, 0];
  let normalizedColor = color.trim();
  normalizedColor = namedColorRegex.test(color) ? nameToHex(color) : color;
  const reducedHexMatch = reducedHexRegex.exec(normalizedColor);
  if (reducedHexMatch) {
    const arr = Array.from(reducedHexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(r(x, 2), 16)), parseInt(r(arr[3] || "f", 2), 16) / 255];
  }
  const hexMatch = hexRegex$1.exec(normalizedColor);
  if (hexMatch) {
    const arr = Array.from(hexMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 16)), parseInt(arr[3] || "ff", 16) / 255];
  }
  const rgbaMatch = rgbaRegex$1.exec(normalizedColor);
  if (rgbaMatch) {
    const arr = Array.from(rgbaMatch).slice(1);
    return [...arr.slice(0, 3).map((x) => parseInt(x, 10)), parseFloat(arr[3] || "1")];
  }
  const hslaMatch = hslaRegex$1.exec(normalizedColor);
  if (hslaMatch) {
    const [h2, s, l3, a] = Array.from(hslaMatch).slice(1).map(parseFloat);
    if (guard(0, 100, s) !== s) throw new ColorError$1(color);
    if (guard(0, 100, l3) !== l3) throw new ColorError$1(color);
    return [...hslToRgb(h2, s, l3), Number.isNaN(a) ? 1 : a];
  }
  throw new ColorError$1(color);
}
function hash$2(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i) {
    hash2 = hash2 * 33 ^ str.charCodeAt(--i);
  }
  return (hash2 >>> 0) % 2341;
}
const colorToInt = (x) => parseInt(x.replace(/_/g, ""), 36);
const compressedColorMap = "1q29ehhb 1n09sgk7 1kl1ekf_ _yl4zsno 16z9eiv3 1p29lhp8 _bd9zg04 17u0____ _iw9zhe5 _to73___ _r45e31e _7l6g016 _jh8ouiv _zn3qba8 1jy4zshs 11u87k0u 1ro9yvyo 1aj3xael 1gz9zjz0 _3w8l4xo 1bf1ekf_ _ke3v___ _4rrkb__ 13j776yz _646mbhl _nrjr4__ _le6mbhl 1n37ehkb _m75f91n _qj3bzfz 1939yygw 11i5z6x8 _1k5f8xs 1509441m 15t5lwgf _ae2th1n _tg1ugcv 1lp1ugcv 16e14up_ _h55rw7n _ny9yavn _7a11xb_ 1ih442g9 _pv442g9 1mv16xof 14e6y7tu 1oo9zkds 17d1cisi _4v9y70f _y98m8kc 1019pq0v 12o9zda8 _348j4f4 1et50i2o _8epa8__ _ts6senj 1o350i2o 1mi9eiuo 1259yrp0 1ln80gnw _632xcoy 1cn9zldc _f29edu4 1n490c8q _9f9ziet 1b94vk74 _m49zkct 1kz6s73a 1eu9dtog _q58s1rz 1dy9sjiq __u89jo3 _aj5nkwg _ld89jo3 13h9z6wx _qa9z2ii _l119xgq _bs5arju 1hj4nwk9 1qt4nwk9 1ge6wau6 14j9zlcw 11p1edc_ _ms1zcxe _439shk6 _jt9y70f _754zsow 1la40eju _oq5p___ _x279qkz 1fa5r3rv _yd2d9ip _424tcku _8y1di2_ _zi2uabw _yy7rn9h 12yz980_ __39ljp6 1b59zg0x _n39zfzp 1fy9zest _b33k___ _hp9wq92 1il50hz4 _io472ub _lj9z3eo 19z9ykg0 _8t8iu3a 12b9bl4a 1ak5yw0o _896v4ku _tb8k8lv _s59zi6t _c09ze0p 1lg80oqn 1id9z8wb _238nba5 1kq6wgdi _154zssg _tn3zk49 _da9y6tc 1sg7cv4f _r12jvtt 1gq5fmkz 1cs9rvci _lp9jn1c _xw1tdnb 13f9zje6 16f6973h _vo7ir40 _bt5arjf _rc45e4t _hr4e100 10v4e100 _hc9zke2 _w91egv_ _sj2r1kk 13c87yx8 _vqpds__ _ni8ggk8 _tj9yqfb 1ia2j4r4 _7x9b10u 1fc9ld4j 1eq9zldr _5j9lhpx _ez9zl6o _md61fzm".split(" ").reduce((acc, next) => {
  const key = colorToInt(next.substring(0, 3));
  const hex2 = colorToInt(next.substring(3)).toString(16);
  let prefix2 = "";
  for (let i = 0; i < 6 - hex2.length; i++) {
    prefix2 += "0";
  }
  acc[key] = `${prefix2}${hex2}`;
  return acc;
}, {});
function nameToHex(color) {
  const normalizedColorName = color.toLowerCase().trim();
  const result = compressedColorMap[hash$2(normalizedColorName)];
  if (!result) throw new ColorError$1(color);
  return `#${result}`;
}
const r = (str, amount) => Array.from(Array(amount)).map(() => str).join("");
const reducedHexRegex = new RegExp(`^#${r("([a-f0-9])", 3)}([a-f0-9])?$`, "i");
const hexRegex$1 = new RegExp(`^#${r("([a-f0-9]{2})", 3)}([a-f0-9]{2})?$`, "i");
const rgbaRegex$1 = new RegExp(`^rgba?\\(\\s*(\\d+)\\s*${r(",\\s*(\\d+)\\s*", 2)}(?:,\\s*([\\d.]+))?\\s*\\)$`, "i");
const hslaRegex$1 = /^hsla?\(\s*([\d.]+)\s*,\s*([\d.]+)%\s*,\s*([\d.]+)%(?:\s*,\s*([\d.]+))?\s*\)$/i;
const namedColorRegex = /^[a-z]+$/i;
const roundColor = (color) => {
  return Math.round(color * 255);
};
const hslToRgb = (hue, saturation, lightness) => {
  let l3 = lightness / 100;
  if (saturation === 0) {
    return [l3, l3, l3].map(roundColor);
  }
  const huePrime = (hue % 360 + 360) % 360 / 60;
  const chroma = (1 - Math.abs(2 * l3 - 1)) * (saturation / 100);
  const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
  let red = 0;
  let green = 0;
  let blue = 0;
  if (huePrime >= 0 && huePrime < 1) {
    red = chroma;
    green = secondComponent;
  } else if (huePrime >= 1 && huePrime < 2) {
    red = secondComponent;
    green = chroma;
  } else if (huePrime >= 2 && huePrime < 3) {
    green = chroma;
    blue = secondComponent;
  } else if (huePrime >= 3 && huePrime < 4) {
    green = secondComponent;
    blue = chroma;
  } else if (huePrime >= 4 && huePrime < 5) {
    red = secondComponent;
    blue = chroma;
  } else if (huePrime >= 5 && huePrime < 6) {
    red = chroma;
    blue = secondComponent;
  }
  const lightnessModification = l3 - chroma / 2;
  const finalRed = red + lightnessModification;
  const finalGreen = green + lightnessModification;
  const finalBlue = blue + lightnessModification;
  return [finalRed, finalGreen, finalBlue].map(roundColor);
};
function toHex(color) {
  const [r2, g, b2, a] = parseToRgba(color);
  let hex2 = (x) => {
    const h2 = guard(0, 255, x).toString(16);
    return h2.length === 1 ? `0${h2}` : h2;
  };
  return `#${hex2(r2)}${hex2(g)}${hex2(b2)}${a < 1 ? hex2(Math.round(a * 255)) : ""}`;
}
const cleanUpListsWithAnnotations = (fieldsToDelete = []) => ({ dispatch, tr, state: state2 }) => {
  if (!dispatch) return true;
  if (!Array.isArray(fieldsToDelete)) fieldsToDelete = [fieldsToDelete];
  const { doc: doc2 } = state2;
  const docxAnnotations = getAllFieldAnnotations(state2) || [];
  const nodesToDelete = [];
  fieldsToDelete.forEach((fieldId) => {
    const matched = docxAnnotations.find((a) => a.node.attrs.fieldId === fieldId);
    if (!matched) return;
    const listItem = findParentNodeClosestToPos(doc2.resolve(matched.pos), (node22) => node22.type.name === "listItem");
    if (!listItem) return;
    let remainingNodes = 0;
    listItem.node.descendants((node22) => {
      if (node22.type.name === "fieldAnnotation") {
        remainingNodes += 1;
      }
    });
    let matchingNodesFound = 0;
    let hasOtherNodes = false;
    listItem.node.children.forEach((child) => {
      const { type: type2 } = child;
      if (type2.name !== "paragraph" && type2.name !== "fieldAnnotation") return;
      child.children.forEach((inline) => {
        const isFieldToDelete = fieldsToDelete.includes(inline.attrs.fieldId);
        const isFieldType = inline.type.name === "fieldAnnotation";
        const isMatchingField = isFieldType && isFieldToDelete;
        if (!isFieldType && !isMatchingField) hasOtherNodes = true;
        if (isMatchingField) matchingNodesFound += 1;
      });
    });
    if (!hasOtherNodes && matchingNodesFound > 0) {
      remainingNodes -= matchingNodesFound;
    }
    if (remainingNodes > 0) {
      return;
    }
    let { pos, node: node2, depth } = listItem;
    let $pos = doc2.resolve(pos);
    while (depth > 0) {
      const parent = $pos.node(depth - 1);
      if (parent.childCount === 1) {
        depth -= 1;
        pos = $pos.before(depth);
        node2 = parent;
        $pos = doc2.resolve(pos);
      } else {
        break;
      }
    }
    if (!nodesToDelete.some((n) => n.pos === pos)) {
      nodesToDelete.push({ pos, node: node2 });
    }
  });
  if (!nodesToDelete.length) return true;
  nodesToDelete.sort((a, b2) => b2.pos - a.pos).forEach(({ pos, node: node2 }) => {
    tr.delete(pos, pos + node2.nodeSize);
  });
  tr.setMeta("updateListSync", true);
  return true;
};
const cleanUpListsCommands = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cleanUpListsWithAnnotations
}, Symbol.toStringTag, { value: "Module" }));
const cleanUpParagraphWithAnnotations = (fieldsToDelete = []) => ({ dispatch, tr, state: state2 }) => {
  if (!dispatch) return true;
  const annotations = (typeof findFieldAnnotationsByFieldId === "function" ? findFieldAnnotationsByFieldId(fieldsToDelete, state2) : []) || [];
  const toDelete = /* @__PURE__ */ new Map();
  const sizeOf = (doc2) => doc2.content.size;
  const inRange = (doc2, pos) => Number.isInteger(pos) && pos >= 0 && pos <= sizeOf(doc2);
  for (const annotation of annotations) {
    const origPos = annotation && annotation.pos;
    if (!Number.isInteger(origPos)) continue;
    const mappedPos = tr.mapping.map(origPos, 1);
    if (!inRange(tr.doc, mappedPos)) continue;
    let $pos;
    try {
      $pos = tr.doc.resolve(mappedPos);
    } catch {
      continue;
    }
    const parent = $pos.parent;
    if (!parent) continue;
    if (parent.childCount >= 2) continue;
    const currentNode = tr.doc.nodeAt(mappedPos);
    const annotatedNode = annotation && annotation.node;
    if (!currentNode) continue;
    if (annotatedNode && !annotatedNode.sameMarkup?.(currentNode) && annotatedNode.type !== currentNode.type) {
      continue;
    }
    const parentPos = $pos.before();
    if (!inRange(tr.doc, parentPos)) continue;
    toDelete.set(parentPos, true);
  }
  if (toDelete.size === 0) return true;
  const sorted = [...toDelete.keys()].sort((a, b2) => b2 - a);
  let changed = false;
  for (const originalParentPos of sorted) {
    const mappedParentPos = tr.mapping.map(originalParentPos, -1);
    if (!inRange(tr.doc, mappedParentPos)) continue;
    const targetNode = tr.doc.nodeAt(mappedParentPos);
    if (!targetNode) continue;
    const from2 = mappedParentPos;
    const to = mappedParentPos + targetNode.nodeSize;
    if (!inRange(tr.doc, from2) || !inRange(tr.doc, to) || to <= from2) continue;
    try {
      tr.delete(from2, to);
      changed = true;
    } catch {
      continue;
    }
  }
  if (changed) dispatch(tr);
  return true;
};
const cleanUpParagraphCommands = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cleanUpParagraphWithAnnotations
}, Symbol.toStringTag, { value: "Module" }));
const commands = {
  ...cleanUpListsCommands,
  ...cleanUpParagraphCommands
};
const annotationClass = "annotation";
const annotationContentClass = "annotation-content";
const FieldAnnotation = Node$1.create({
  name: "fieldAnnotation",
  group: "inline",
  inline: true,
  atom: true,
  draggable: true,
  selectable: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: annotationClass,
        "aria-label": "Field annotation node"
      },
      annotationClass,
      annotationContentClass,
      types: ["text", "image", "signature", "checkbox", "html", "link"],
      // annotation types
      defaultType: "text",
      borderColor: "#b015b3",
      visibilityOptions: ["visible", "hidden"],
      handleDropOutside: true,
      /// for y-prosemirror support
      toggleFormatNames: ["bold", "italic", "underline"]
    };
  },
  addAttributes() {
    return {
      type: {
        default: this.options.defaultType,
        parseDOM: (elem) => elem.getAttribute("data-type"),
        renderDOM: (attrs) => {
          if (!attrs.type) return {};
          return {
            "data-type": attrs.type
          };
        }
      },
      defaultDisplayLabel: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-default-display-label"),
        renderDOM: (attrs) => {
          if (!attrs.defaultDisplayLabel) return {};
          return {
            "data-default-display-label": attrs.defaultDisplayLabel
          };
        }
      },
      displayLabel: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-display-label"),
        renderDOM: (attrs) => {
          if (!attrs.displayLabel) return {};
          return {
            "data-display-label": attrs.displayLabel
          };
        }
      },
      imageSrc: {
        default: null,
        rendered: false,
        parseDOM: (elem) => {
          let img = elem.querySelector("img");
          return img?.getAttribute("src") || null;
        }
      },
      rawHtml: {
        default: null,
        parseDOM: (elem) => {
          try {
            const isHtmlType = elem.getAttribute("data-type") === "html";
            if (!isHtmlType) return null;
            return JSON.parse(elem.getAttribute("data-raw-html"));
          } catch (e) {
            console.warn("Paste parse error", e);
          }
          return null;
        },
        renderDOM: (attrs) => {
          if (!attrs.rawHtml) return {};
          return {
            "data-raw-html": JSON.stringify(attrs.rawHtml)
          };
        }
      },
      linkUrl: {
        default: null,
        rendered: false,
        parseDOM: (elem) => {
          let link = elem.querySelector("a");
          return link?.getAttribute("href") || null;
        }
      },
      fieldId: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-field-id"),
        renderDOM: (attrs) => {
          if (!attrs.fieldId) return {};
          return {
            "data-field-id": attrs.fieldId
          };
        }
      },
      fieldType: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-field-type"),
        renderDOM: (attrs) => {
          if (!attrs.fieldType) return {};
          return {
            "data-field-type": attrs.fieldType
          };
        }
      },
      fieldColor: {
        default: "#980043",
        parseDOM: (elem) => elem.getAttribute("data-field-color") || elem.style.backgroundColor || null,
        renderDOM: (attrs) => {
          if (!attrs.fieldColor || attrs.fieldColor == "None") return {};
          let hexColor = toHex(attrs.fieldColor);
          let isSixValueSyntax = hexColor.slice(1).length === 6;
          if (isSixValueSyntax) {
            hexColor = `${hexColor}33`;
          }
          let omitHighlight = attrs.highlighted === false;
          if (omitHighlight) {
            return {
              "data-field-color": hexColor
            };
          }
          return {
            "data-field-color": hexColor,
            style: `background-color: ${hexColor}`
          };
        }
      },
      hidden: {
        default: false,
        parseDOM: (elem) => {
          let hasHiddenAttr = elem.hasAttribute("hidden");
          let hasDisplayNoneStyle = elem.style.display === "none";
          let isHidden2 = hasHiddenAttr || hasDisplayNoneStyle;
          return isHidden2;
        },
        renderDOM: (attrs) => {
          if (!attrs.hidden) return {};
          return {
            style: "display: none"
          };
        }
      },
      visibility: {
        default: "visible",
        parseDOM: (el) => {
          let visibility = el.style.visibility || "visible";
          let containsVisibility = this.options.visibilityOptions.includes(visibility);
          return containsVisibility ? visibility : "visible";
        },
        renderDOM: (attrs) => {
          if (!attrs.visibility || attrs.visibility === "visible") return {};
          return { style: `visibility: ${attrs.visibility}` };
        }
      },
      highlighted: {
        default: true,
        rendered: false
      },
      multipleImage: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-multiple-image"),
        renderDOM: (attrs) => {
          if (!attrs.multipleImage) return {};
          return {
            "data-multiple-image": attrs.multipleImage
          };
        }
      },
      size: {
        default: null,
        renderDOM: ({ size: size2 }) => {
          if (!size2 || !size2.width) return {};
          const style2 = `width: ${size2.width}px; height: ${size2.height}px; overflow: hidden;`;
          return { style: style2 };
        }
      },
      extras: {
        default: {},
        rendered: false
      },
      /// Formatting attrs for y-prosemirror support.
      bold: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-bold") === "true",
        renderDOM: (attrs) => {
          if (!attrs.bold) return {};
          return {
            "data-bold": "true",
            style: "font-weight: bold"
          };
        }
      },
      italic: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-italic") === "true",
        renderDOM: (attrs) => {
          if (!attrs.italic) return {};
          return {
            "data-italic": "true",
            style: "font-style: italic"
          };
        }
      },
      underline: {
        default: false,
        parseDOM: (elem) => elem.getAttribute("data-underline") === "true",
        renderDOM: (attrs) => {
          if (!attrs.underline) return {};
          return {
            "data-underline": "true",
            style: "text-decoration: underline"
          };
        }
      },
      fontFamily: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-font-family") || elem.style.fontFamily || null,
        renderDOM: (attrs) => {
          if (!attrs.fontFamily) return {};
          return {
            "data-font-family": attrs.fontFamily,
            style: `font-family: ${attrs.fontFamily}`
          };
        }
      },
      fontSize: {
        default: null,
        parseDOM: (elem) => elem.getAttribute("data-font-size") || elem.style.fontSize || null,
        renderDOM: (attrs) => {
          if (!attrs.fontSize) return {};
          let [value, unit] = parseSizeUnit(attrs.fontSize);
          if (Number.isNaN(value)) return {};
          unit = unit ? unit : "pt";
          let fontSize2 = `${value}${unit}`;
          return {
            "data-font-size": fontSize2,
            style: `font-size: ${fontSize2}`
          };
        }
      },
      textHighlight: {
        default: null,
        parseDOM: (element) => element.getAttribute("data-text-highlight"),
        renderDOM: (attrs) => {
          if (!attrs.textHighlight) return {};
          return {
            "data-text-highlight": attrs.textHighlight,
            // takes precedence over the fieldColor.
            style: `background-color: ${attrs.textHighlight} !important`
          };
        }
      },
      textColor: {
        default: null,
        parseDOM: (element) => element.getAttribute("data-text-color"),
        renderDOM: (attrs) => {
          if (!attrs.textColor) return {};
          return {
            "data-text-color": attrs.textColor,
            style: `color: ${attrs.textColor}`
          };
        }
      },
      /// Formatting attrs - end.
      generatorIndex: {
        rendered: false,
        default: null
      },
      hash: {
        rendered: false,
        default: null
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `span.${this.options.annotationClass}`,
        priority: 60
      }
    ];
  },
  renderDOM({ node: node2, htmlAttributes }) {
    let { type: type2, displayLabel, imageSrc, linkUrl } = node2.attrs;
    let textRenderer = () => {
      return [
        "span",
        Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          "span",
          {
            class: `${this.options.annotationContentClass}`
          },
          displayLabel
        ]
      ];
    };
    let imageRenderer = () => {
      let contentRenderer = () => {
        if (!imageSrc) return displayLabel;
        return [
          "img",
          {
            src: imageSrc,
            alt: displayLabel
          }
        ];
      };
      return [
        "span",
        Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          "span",
          {
            class: `${this.options.annotationContentClass}`
          },
          contentRenderer()
        ]
      ];
    };
    let linkRenderer = () => {
      let contentRenderer = () => {
        if (!linkUrl) return displayLabel;
        return [
          "a",
          {
            href: linkUrl,
            target: "_blank"
          },
          linkUrl
        ];
      };
      return [
        "span",
        Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes),
        [
          "span",
          {
            class: `${this.options.annotationContentClass}`
          },
          contentRenderer()
        ]
      ];
    };
    let renderers = {
      text: () => textRenderer(),
      image: () => imageRenderer(),
      signature: () => imageRenderer(),
      checkbox: () => textRenderer(),
      html: () => textRenderer(),
      link: () => linkRenderer(),
      default: () => textRenderer()
    };
    let renderer = renderers[type2] ?? renderers.default;
    return renderer();
  },
  addCommands() {
    const annotationTypes = this.options.types;
    return {
      /**
       * Add field annotation.
       * @param pos The position in the doc.
       * @param attrs The attributes.
       * @example
       * editor.commands.addFieldAnnotation(0, {
       *  displayLabel: 'Enter your info',
       *  fieldId: `123`,
       *  fieldType: 'TEXTINPUT',
       *  fieldColor: '#980043',
       * })
       */
      addFieldAnnotation: (pos, attrs = {}, editorFocus = false) => ({ editor, dispatch, state: state2, tr }) => {
        if (dispatch) {
          let { schema } = editor;
          let newPos = tr.mapping.map(pos);
          let $pos = state2.doc.resolve(newPos);
          let currentMarks = $pos.marks();
          currentMarks = currentMarks.length ? [...currentMarks] : null;
          let formatAttrs = getFormatAttrsFromMarks(currentMarks);
          let defaultDisplayLabel = attrs.defaultDisplayLabel ? attrs.defaultDisplayLabel : attrs.displayLabel || "";
          let node2 = schema.nodes[this.name].create(
            {
              ...attrs,
              ...formatAttrs,
              defaultDisplayLabel,
              hash: attrs.hash || generateDocxRandomId(4)
            },
            null,
            null
          );
          state2.tr.insert(newPos, node2).setSelection(Selection.near(tr.doc.resolve(newPos + node2.nodeSize)));
          if (editorFocus) {
            this.editor.view.focus();
          }
        }
        return true;
      },
      addFieldAnnotationAtSelection: (attrs = {}, editorFocus = false) => ({ state: state2, commands: commands2 }) => {
        const { from: from2 } = state2.selection;
        return commands2.addFieldAnnotation(from2, attrs, editorFocus);
      },
      /**
       * Replace field annotation.
       * @param fieldsArray array of fields with attrs to add as annotation.
       * @example
       * editor.commands.replaceWithFieldAnnotation([
       *  from: 20,
       *  to: 45,
       *  attrs: {
       *    fieldType: 'TEXTINPUT'
       *    fieldColor: '#980043'
       *  }
       * ])
       */
      replaceWithFieldAnnotation: (fieldsArray) => ({ editor, dispatch, tr }) => {
        if (!dispatch) return true;
        fieldsArray.forEach((annotation) => {
          let { from: from2, to, attrs } = annotation;
          let { schema } = editor;
          let newPosFrom = tr.mapping.map(from2);
          let newPosTo = tr.mapping.map(to);
          let defaultDisplayLabel = attrs.defaultDisplayLabel ? attrs.defaultDisplayLabel : attrs.displayLabel || "";
          attrs.hash = generateDocxRandomId(4);
          let node2 = schema.nodes[this.name].create(
            {
              ...attrs,
              defaultDisplayLabel,
              hash: attrs.hash || generateDocxRandomId(4)
            },
            null,
            null
          );
          tr.replaceWith(newPosFrom, newPosTo, node2);
        });
        return true;
      },
      /**
       * Replace annotations with a label (as text node) in selection.
       * @param options Additional options.
       * @example
       * editor.commands.replaceFieldAnnotationsWithLabelInSelection()
       */
      replaceFieldAnnotationsWithLabelInSelection: (options = {}) => ({ commands: commands2 }) => {
        return commands2.replaceFieldAnnotationsWithLabel(null, {
          ...options,
          isInSelection: true
        });
      },
      /**
       * Replace annotations with a label (as text node).
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param options.isInSelection Find in selection instead of field IDs.
       * @param options.addToHistory Add to history or not.
       * @param options.types Annotation types to replace.
       * @example
       * editor.commands.replaceFieldAnnotationsWithLabel(['1', '2'])
       */
      replaceFieldAnnotationsWithLabel: (fieldIdOrArray, { isInSelection = false, addToHistory = false, types: types2 = annotationTypes } = {}) => ({ dispatch, state: state2, tr }) => {
        let { from: from2, to } = state2.selection;
        let annotations = isInSelection ? findFieldAnnotationsBetween(from2, to, state2.doc) : findFieldAnnotationsByFieldId(fieldIdOrArray, state2);
        annotations = types2.length ? annotations.filter(({ node: node2 }) => types2.includes(node2.attrs.type)) : annotations;
        if (!annotations.length) {
          return true;
        }
        if (!addToHistory) {
          tr.setMeta("addToHistory", false);
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            let { pos, node: node2 } = annotation;
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node2.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            let nodeEqual = node2.attrs.fieldId === currentNode?.attrs?.fieldId;
            let $newPosFrom = tr.doc.resolve(newPosFrom);
            let currentMarks = $newPosFrom.marks();
            currentMarks = currentMarks.length ? [...currentMarks] : null;
            if (nodeEqual) {
              let label = node2.attrs.displayLabel || " ";
              let textNode = state2.schema.text(label, currentMarks);
              tr.replaceWith(newPosFrom, newPosTo, textNode);
            }
          });
        }
        return true;
      },
      /**
       * Resets all annotations to default values.
       * @example
       * editor.commands.resetFieldAnnotations()
       */
      resetFieldAnnotations: () => ({ dispatch, state: state2, tr }) => {
        let annotations = getAllFieldAnnotations(state2);
        if (!annotations.length) {
          return true;
        }
        tr.setMeta("fieldAnnotationUpdate", true);
        if (dispatch) {
          annotations.forEach(({ pos, node: node2 }) => {
            let newPos = tr.mapping.map(pos);
            let currentNode = tr.doc.nodeAt(newPos);
            let nodeEqual = node2.attrs.fieldId === currentNode?.attrs?.fieldId;
            if (nodeEqual) {
              let displayLabel = node2.attrs.defaultDisplayLabel || node2.attrs.displayLabel || "";
              tr.setNodeMarkup(newPos, void 0, {
                ...node2.attrs,
                // reset displayLabel to default.
                displayLabel,
                // reset attrs for specific types.
                imageSrc: null,
                rawHtml: null,
                linkUrl: null,
                hash: null
              });
            }
          });
        }
        return true;
      },
      /**
       * Update annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param attrs The attributes.
       * @example
       * editor.commands.updateFieldAnnotations('123', {
       *  displayLabel: 'Updated!',
       * })
       * @example
       * editor.commands.updateFieldAnnotations(['123', '456'], {
       *  displayLabel: 'Updated!',
       * })
       */
      updateFieldAnnotations: (fieldIdOrArray, attrs = {}) => ({ dispatch, state: state2, commands: commands2 }) => {
        let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state2);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          return commands2.updateFieldAnnotationsAttributes(annotations, attrs);
        }
        return true;
      },
      /**
       * Update particular annotation's attributes.
       * @param annotation field annotation node to be updated.
       * @param attrs The attributes.
       *
       * Used for a case when multiple annotations for one input presented
       */
      updateFieldAnnotation: (annotation, attrs = {}) => ({ dispatch, commands: commands2 }) => {
        if (!annotation) {
          return true;
        }
        if (dispatch) {
          commands2.updateFieldAnnotationsAttributes([annotation], attrs);
          if (this.editor.options.pagination) {
            setTimeout(() => {
              const newTr = this.editor.view.state.tr;
              newTr.setMeta("forceUpdatePagination", true);
              this.editor.view.dispatch(newTr);
            }, 50);
          }
          return true;
        }
        return true;
      },
      /**
       * Update the attributes of annotations.
       * @param annotations The annotations array [{pos, node}].
       * @param attrs The attributes object.
       */
      updateFieldAnnotationsAttributes: (annotations, attrs = {}) => ({ dispatch, tr }) => {
        if (!dispatch) return true;
        tr.setMeta("fieldAnnotationUpdate", true);
        annotations.forEach((annotation) => {
          let { pos, node: node2 } = annotation;
          let newPos = tr.mapping.map(pos);
          let currentNode = tr.doc.nodeAt(newPos);
          let nodeEqual = node2.attrs.fieldId === currentNode?.attrs?.fieldId;
          if (nodeEqual) {
            tr.setNodeMarkup(newPos, void 0, {
              ...node2.attrs,
              ...attrs
            });
          }
        });
        return true;
      },
      /**
       * Delete annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @example
       * editor.commands.deleteFieldAnnotations('123')
       * @example
       * editor.commands.deleteFieldAnnotations(['123', '456'])
       */
      deleteFieldAnnotations: (fieldIdOrArray) => ({ dispatch, state: state2, tr }) => {
        let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state2);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            let { pos, node: node2 } = annotation;
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node2.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            if (node2.eq(currentNode)) {
              tr.delete(newPosFrom, newPosTo);
            }
          });
        }
        return true;
      },
      deleteFieldAnnotationsByNode: (annotations) => ({ dispatch, tr }) => {
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            let { pos, node: node2 } = annotation;
            let newPosFrom = tr.mapping.map(pos);
            let newPosTo = tr.mapping.map(pos + node2.nodeSize);
            let currentNode = tr.doc.nodeAt(newPosFrom);
            if (node2.eq(currentNode)) {
              tr.delete(newPosFrom, newPosTo);
            }
          });
        }
        return true;
      },
      deleteFieldAnnotation: (annotation) => ({ dispatch, tr }) => {
        if (!annotation) {
          return true;
        }
        if (dispatch) {
          let { pos, node: node2 } = annotation;
          let newPosFrom = tr.mapping.map(pos);
          let newPosTo = tr.mapping.map(pos + node2.nodeSize);
          let currentNode = tr.doc.nodeAt(newPosFrom);
          if (node2.eq(currentNode)) {
            tr.delete(newPosFrom, newPosTo);
          }
        }
        return true;
      },
      /**
       * Delete a portion of annotations associated with a field.
       * @param fieldIdOrArray The field ID or array of field IDs.
       * @param end index at which to end extraction
       * @example
       * editor.commands.sliceFieldAnnotations('123', 5) - will remove a portion of annotations array starting from index 6
       * @example
       * editor.commands.sliceFieldAnnotations(['123', '456'], 5)
       */
      sliceFieldAnnotations: (fieldIdOrArray, end2) => ({ dispatch, state: state2, tr }) => {
        let annotations = findFieldAnnotationsByFieldId(fieldIdOrArray, state2);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation, index2) => {
            if (index2 >= end2) {
              let { pos, node: node2 } = annotation;
              let newPosFrom = tr.mapping.map(pos);
              let newPosTo = tr.mapping.map(pos + node2.nodeSize);
              let currentNode = tr.doc.nodeAt(newPosFrom);
              if (node2.eq(currentNode)) {
                tr.delete(newPosFrom, newPosTo);
              }
            }
          });
        }
        return true;
      },
      /**
       * Set `hidden` for annotations matching predicate.
       * Other annotations become unhidden.
       * @param predicate The predicate function.
       * @param unsetFromOthers If should unset hidden from other annotations.
       * @example
       * editor.commands.setFieldAnnotationsHiddenByCondition((node) => {
       *   let ids = ['111', '222', '333'];
       *   return ids.includes(node.attrs.fieldId);
       * })
       */
      setFieldAnnotationsHiddenByCondition: (predicate = () => false, unsetFromOthers = false) => ({ dispatch, state: state2, chain }) => {
        let annotations = getAllFieldAnnotations(state2);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          let otherAnnotations = [];
          let matchedAnnotations = annotations.filter((annotation) => {
            if (predicate(annotation.node)) return annotation;
            else otherAnnotations.push(annotation);
          });
          if (unsetFromOthers) {
            return chain().updateFieldAnnotationsAttributes(matchedAnnotations, { hidden: true }).updateFieldAnnotationsAttributes(otherAnnotations, { hidden: false }).run();
          } else {
            return chain().updateFieldAnnotationsAttributes(matchedAnnotations, { hidden: true }).run();
          }
        }
        return true;
      },
      /**
       * Unset `hidden` for all annotations.
       * @example
       * editor.commands.unsetFieldAnnotationsHidden()
       */
      unsetFieldAnnotationsHidden: () => ({ dispatch, state: state2, commands: commands2 }) => {
        let annotations = getAllFieldAnnotations(state2);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          return commands2.updateFieldAnnotationsAttributes(annotations, { hidden: false });
        }
        return true;
      },
      /**
       * Set `visibility` for all annotations (without changing the layout).
       * @param visibility The visibility value (visible, hidden).
       * @example
       * editor.commands.setFieldAnnotationsVisibility('visible');
       * @example
       * editor.commands.setFieldAnnotationsVisibility('hidden');
       */
      setFieldAnnotationsVisibility: (visibility = "visible") => ({ dispatch, state: state2, commands: commands2 }) => {
        let annotations = getAllFieldAnnotations(state2);
        if (!annotations.length) {
          return true;
        }
        let containsVisibility = this.options.visibilityOptions.includes(visibility);
        if (!containsVisibility) {
          return false;
        }
        if (dispatch) {
          return commands2.updateFieldAnnotationsAttributes(annotations, {
            visibility
          });
        }
        return true;
      },
      /**
       * Set `highlighted` for annotations matching predicate.
       * @param predicate The predicate function.
       * @param highlighted The highlighted attribute.
       * @example
       * editor.commands.setFieldAnnotationsHighlighted((node) => {
       *   let ids = ['111', '222', '333'];
       *   return ids.includes(node.attrs.fieldId);
       * }, false)
       * @example Set for all annotations.
       * editor.commands.setFieldAnnotationsHighlighted(() => true, false)
       * editor.commands.setFieldAnnotationsHighlighted(() => true, true)
       */
      setFieldAnnotationsHighlighted: (predicate = () => false, highlighted = true) => ({ dispatch, state: state2, commands: commands2 }) => {
        let annotations = getAllFieldAnnotations(state2);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          let matchedAnnotations = annotations.filter((annotation) => {
            if (predicate(annotation.node)) return annotation;
          });
          return commands2.updateFieldAnnotationsAttributes(matchedAnnotations, {
            highlighted
          });
        }
        return true;
      },
      /// Formatting commands for y-prosemirror support.
      toggleFieldAnnotationsFormat: (name, setSelection = false) => ({ dispatch, tr, state: state2, commands: commands2 }) => {
        let formats = this.options.toggleFormatNames;
        if (!formats.includes(name)) {
          return false;
        }
        let { from: from2, to, node: node2 } = state2.selection;
        let annotations = findFieldAnnotationsBetween(from2, to, state2.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              [name]: !annotation.node.attrs[name]
            });
          });
          if (setSelection && node2?.type.name === this.name) {
            tr.setSelection(NodeSelection.create(tr.doc, from2));
          }
        }
        return true;
      },
      setFieldAnnotationsFontFamily: (fontFamily2, setSelection = false) => ({ dispatch, tr, state: state2, commands: commands2 }) => {
        let { from: from2, to, node: node2 } = state2.selection;
        let annotations = findFieldAnnotationsBetween(from2, to, state2.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              fontFamily: fontFamily2
            });
          });
          if (setSelection && node2?.type.name === this.name) {
            tr.setSelection(NodeSelection.create(tr.doc, from2));
          }
        }
        return true;
      },
      setFieldAnnotationsFontSize: (fontSize2, setSelection = false) => ({ dispatch, tr, state: state2, commands: commands2 }) => {
        let { from: from2, to, node: node2 } = state2.selection;
        let annotations = findFieldAnnotationsBetween(from2, to, state2.doc);
        if (!annotations.length) {
          return true;
        }
        let [value, unit] = parseSizeUnit(fontSize2);
        let min2 = 8, max2 = 96, defaultUnit = "pt";
        if (Number.isNaN(value)) {
          return false;
        }
        value = minMax(value, min2, max2);
        unit = unit ? unit : defaultUnit;
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              fontSize: `${value}${unit}`
            });
          });
          if (setSelection && node2?.type.name === this.name) {
            tr.setSelection(NodeSelection.create(tr.doc, from2));
          }
        }
        return true;
      },
      setFieldAnnotationsTextHighlight: (color, setSelection = false) => ({ dispatch, tr, state: state2, commands: commands2 }) => {
        let { from: from2, to, node: node2 } = state2.selection;
        let annotations = findFieldAnnotationsBetween(from2, to, state2.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              textHighlight: color
            });
          });
          if (setSelection && node2?.type.name === this.name) {
            tr.setSelection(NodeSelection.create(tr.doc, from2));
          }
        }
        return true;
      },
      setFieldAnnotationsTextColor: (color, setSelection = false) => ({ dispatch, tr, state: state2, commands: commands2 }) => {
        let { from: from2, to, node: node2 } = state2.selection;
        let annotations = findFieldAnnotationsBetween(from2, to, state2.doc);
        if (!annotations.length) {
          return true;
        }
        if (dispatch) {
          annotations.forEach((annotation) => {
            commands2.updateFieldAnnotationsAttributes([annotation], {
              textColor: color
            });
          });
          if (setSelection && node2?.type.name === this.name) {
            tr.setSelection(NodeSelection.create(tr.doc, from2));
          }
        }
        return true;
      },
      /// Formatting commands - end.
      // Clean up commands (after field deletion)
      ...commands
    };
  },
  addNodeView() {
    return (props) => {
      return new FieldAnnotationView({
        ...props,
        annotationClass: this.options.annotationClass,
        annotationContentClass: this.options.annotationContentClass,
        borderColor: this.options.borderColor
      });
    };
  },
  addPmPlugins() {
    return [
      FieldAnnotationPlugin({
        editor: this.editor,
        annotationClass: this.options.annotationClass,
        handleDropOutside: this.options.handleDropOutside
      })
    ];
  }
});
function getFormatAttrsFromMarks(marks) {
  if (!marks) {
    return {};
  }
  let formatAttrs = {
    bold: false,
    italic: false,
    underline: false,
    fontFamily: null,
    fontSize: null
  };
  if (marks && marks.length) {
    formatAttrs.bold = marks.some((mark) => mark.type.name === "bold");
    formatAttrs.italic = marks.some((mark) => mark.type.name === "italic");
    formatAttrs.underline = marks.some((mark) => mark.type.name === "underline");
    let textStyle = marks.find((mark) => mark.type.name === "textStyle");
    if (textStyle) {
      formatAttrs.fontFamily = textStyle.attrs.fontFamily ?? null;
      formatAttrs.fontSize = textStyle.attrs.fontSize ?? null;
    }
  }
  return formatAttrs;
}
const ImagePlaceholderPluginKey = new PluginKey("ImagePlaceholder");
const ImagePlaceholderPlugin = () => {
  return new Plugin({
    key: ImagePlaceholderPluginKey,
    state: {
      init() {
        return DecorationSet.empty;
      },
      apply(tr, set) {
        set = set.map(tr.mapping, tr.doc);
        let action = tr.getMeta(ImagePlaceholderPluginKey);
        if (action?.type === "add") {
          let widget = document.createElement("placeholder");
          let deco = Decoration.widget(action.pos, widget, {
            id: action.id
          });
          set = set.add(tr.doc, [deco]);
        } else if (action?.type === "remove") {
          set = set.remove(set.find(null, null, (spec) => spec.id == action.id));
        }
        return set;
      }
    },
    props: {
      decorations(state2) {
        return this.getState(state2);
      }
    }
  });
};
const findPlaceholder = (state2, id) => {
  let decos = ImagePlaceholderPluginKey.getState(state2);
  let found2 = decos?.find(null, null, (spec) => spec.id === id);
  return found2?.length ? found2[0].from : null;
};
const ImagePositionPluginKey = new PluginKey("ImagePosition");
const ImagePositionPlugin = ({ editor }) => {
  const { view } = editor;
  let shouldUpdate = false;
  return new Plugin({
    name: "ImagePositionPlugin",
    key: ImagePositionPluginKey,
    state: {
      init() {
        return DecorationSet.empty;
      },
      apply(tr, oldDecorationSet, oldState, newState) {
        if (!tr.docChanged) return oldDecorationSet;
        const decorations = getImagePositionDecorations(newState, view);
        return DecorationSet.create(newState.doc, decorations);
      }
    },
    view: () => {
      return {
        update: (view2, lastState) => {
          const pagination = PaginationPluginKey.getState(lastState);
          if (shouldUpdate) {
            shouldUpdate = false;
            const decorations = getImagePositionDecorations(lastState, view2);
            const updateTransaction = view2.state.tr.setMeta(ImagePositionPluginKey, { decorations });
            view2.dispatch(updateTransaction);
          }
          if (pagination?.isReadyToInit) {
            shouldUpdate = true;
          }
        }
      };
    },
    props: {
      decorations(state2) {
        return this.getState(state2);
      }
    }
  });
};
const getImagePositionDecorations = (state2, view) => {
  let decorations = [];
  state2.doc.descendants((node2, pos) => {
    if (node2.attrs.anchorData) {
      let style2 = "";
      let className = "";
      const { vRelativeFrom, alignH } = node2.attrs.anchorData;
      const { size: size2, padding, marginOffset } = node2.attrs;
      const pageBreak = findPreviousDomNodeWithClass(view, pos, "pagination-break-wrapper");
      if (pageBreak) {
        switch (alignH) {
          case "left":
            style2 += "float: left; left: 0; margin-left: 0; ";
            break;
          case "right":
            style2 += "float: right; right: 0; margin-right: 0; ";
            break;
          case "center":
            style2 += "display: block; margin-left: auto; margin-right: auto; ";
            break;
        }
        const topPos = marginOffset.top !== void 0 ? marginOffset.top : pageBreak?.offsetTop + pageBreak?.offsetHeight;
        style2 += vRelativeFrom === "margin" ? `position: absolute; top: ${topPos}px; ` : "";
        if (vRelativeFrom === "margin") {
          const nextPos = view.posAtDOM(pageBreak, 1);
          if (nextPos < 0) {
            const $pos = view.state.doc.resolve(pos);
            decorations.push(
              Decoration.node(pos - 1, pos + $pos.parent.nodeSize - 1, {
                style: `height: ${size2.height + parseInt(padding.top) + parseInt(padding.bottom)}px`
              })
            );
          }
          const imageBlock = document.createElement("div");
          imageBlock.className = "anchor-image-placeholder";
          imageBlock.style.float = alignH;
          imageBlock.style.width = size2.width + parseInt(padding[alignH]) + "px";
          imageBlock.style.height = size2.height + parseInt(padding.top) + parseInt(padding.bottom) + "px";
          decorations.push(Decoration.widget(nextPos, imageBlock, { key: "stable-key" }));
        }
      }
      decorations.push(Decoration.inline(pos, pos + node2.nodeSize, { style: style2, class: className }));
    }
  });
  return decorations;
};
const findPreviousDomNodeWithClass = (view, pos, className) => {
  let { node: node2 } = view.domAtPos(pos);
  if (node2.nodeType === 3) {
    node2 = node2.parentNode;
  }
  while (node2) {
    if (node2.classList && node2.classList.contains(className)) {
      return node2;
    }
    if (node2.previousSibling) {
      node2 = node2.previousSibling;
      while (node2 && node2.lastChild) {
        node2 = node2.lastChild;
      }
    } else {
      node2 = node2.parentNode;
    }
  }
  return null;
};
const Image = Node$1.create({
  name: "image",
  group: "inline",
  inline: true,
  draggable: true,
  addOptions() {
    return {
      allowBase64: true,
      htmlAttributes: {
        style: "display: inline-block;",
        "aria-label": "Image node"
      }
    };
  },
  addStorage() {
    return {
      media: {}
    };
  },
  addAttributes() {
    return {
      src: {
        default: null,
        renderDOM: ({ src }) => {
          return {
            src: this.storage.media[src] ?? src
          };
        }
      },
      alt: {
        default: "Uploaded picture"
      },
      id: { rendered: false },
      title: {
        default: null
      },
      rId: {
        default: null,
        rendered: false
      },
      originalPadding: {
        default: null,
        rendered: false
      },
      originalAttributes: { rendered: false },
      wrapTopAndBottom: { rendered: false },
      anchorData: {
        default: null,
        rendered: false
      },
      isAnchor: { rendered: false },
      simplePos: { rendered: false },
      wrapText: { rendered: false },
      size: {
        default: {},
        renderDOM: ({ size: size2 }) => {
          let style2 = "";
          const { width, height } = size2 ?? {};
          if (width) style2 += `width: ${width}px;`;
          if (height) style2 += "height: auto;";
          return { style: style2 };
        }
      },
      padding: {
        default: {},
        renderDOM: ({ padding, marginOffset }) => {
          const { left: left2 = 0, top: top2 = 0, bottom: bottom2 = 0, right: right2 = 0 } = padding ?? {};
          let style2 = "";
          if (left2 && !marginOffset?.left) style2 += `margin-left: ${left2}px;`;
          if (top2 && !marginOffset?.top) style2 += `margin-top: ${top2}px;`;
          if (bottom2) style2 += `margin-bottom: ${bottom2}px;`;
          if (right2) style2 += `margin-right: ${right2}px;`;
          return { style: style2 };
        }
      },
      marginOffset: {
        default: {},
        renderDOM: ({ marginOffset, anchorData }) => {
          const relativeFromPageV = anchorData?.vRelativeFrom === "page";
          const maxMarginV = 500;
          const { left: left2 = 0, top: top2 = 0 } = marginOffset ?? {};
          let style2 = "";
          if (left2) style2 += `margin-left: ${left2}px;`;
          if (top2) {
            if (relativeFromPageV && top2 >= maxMarginV) style2 += `margin-top: ${maxMarginV}px;`;
            else style2 += `margin-top: ${top2}px;`;
          }
          return { style: style2 };
        }
      },
      style: {
        default: null,
        rendered: true,
        renderDOM: ({ style: style2 }) => {
          if (!style2) return {};
          return { style: style2 };
        }
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: this.options.allowBase64 ? "img[src]" : 'img[src]:not([src^="data:"])'
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["img", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      setImage: (options) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: options
        });
      }
    };
  },
  addPmPlugins() {
    return [ImagePlaceholderPlugin(), ImagePositionPlugin({ editor: this.editor })];
  }
});
const ACCEPT_IMAGE_TYPES = [".jpg", ".jpeg", ".png", "image/jpeg", "image/png"];
const getFileOpener = () => {
  let fileInput = document.createElement("input");
  fileInput.type = "file";
  let acceptTypes = ACCEPT_IMAGE_TYPES;
  fileInput.accept = acceptTypes.join(",");
  const openFile = () => {
    return new Promise((resolve, reject) => {
      fileInput.onchange = async () => {
        const files = fileInput.files;
        if (!files) return resolve(null);
        const file = files.item(0);
        if (!file) return resolve(null);
        return resolve({ file });
      };
      fileInput.oncancel = () => resolve(null);
      fileInput.onerror = reject;
      fileInput.click();
    });
  };
  return openFile;
};
const handleImageUpload = (file) => {
  return new Promise((resolve, reject) => {
    let reader = new FileReader();
    reader.onload = (event) => resolve(event.target.result);
    reader.onerror = reject;
    setTimeout(() => reader.readAsDataURL(file), 250);
  });
};
const processUploadedImage = (fileData, editor) => {
  return new Promise((resolve, reject) => {
    const img = new window.Image();
    img.onload = () => {
      const canvas = document.createElement("canvas");
      const { width: logicalWidth, height: logicalHeight } = getAllowedImageDimensions(img.width, img.height, editor);
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx2 = canvas.getContext("2d");
      if (ctx2) {
        ctx2.imageSmoothingEnabled = true;
        try {
          ctx2.imageSmoothingQuality = "high";
        } catch {
        }
      }
      ctx2.drawImage(img, 0, 0, img.width, img.height);
      const dpr = typeof window !== "undefined" && window.devicePixelRatio ? window.devicePixelRatio : 1;
      const targetPixelWidth = Math.round(logicalWidth * dpr);
      const targetPixelHeight = Math.round(logicalHeight * dpr);
      const finalTargetWidth = Math.min(targetPixelWidth, img.width);
      const finalTargetHeight = Math.min(targetPixelHeight, img.height);
      const resizeNeeded = finalTargetWidth !== img.width || finalTargetHeight !== img.height;
      if (resizeNeeded) {
        multiStepResize(canvas, finalTargetWidth, finalTargetHeight);
      }
      if (typeof fileData === "string") {
        const resizedBase64 = canvas.toDataURL();
        resolve(resizedBase64);
      } else {
        canvas.toBlob((blob) => {
          const updatedFile = new File([blob], fileData.name, {
            type: fileData.type,
            lastModified: Date.now()
          });
          resolve({ file: updatedFile, width: logicalWidth, height: logicalHeight });
        });
      }
    };
    img.onerror = (error) => reject(error);
    img.src = typeof fileData === "string" ? fileData : URL.createObjectURL(fileData);
  });
};
const getAllowedImageDimensions = (width, height, editor) => {
  const { width: maxWidth, height: maxHeight } = editor.getMaxContentSize();
  if (!maxWidth || !maxHeight) return { width, height };
  let adjustedWidth = width;
  let adjustedHeight = height;
  const aspectRatio = width / height;
  if (height > maxHeight) {
    adjustedHeight = maxHeight;
    adjustedWidth = Math.round(maxHeight * aspectRatio);
  }
  if (adjustedWidth > maxWidth) {
    adjustedWidth = maxWidth;
    adjustedHeight = Math.round(maxWidth / aspectRatio);
  }
  return { width: adjustedWidth, height: adjustedHeight };
};
function resample_high_quality(canvas, width, height, resize_canvas) {
  var width_source = canvas.width;
  var height_source = canvas.height;
  width = Math.round(width);
  height = Math.round(height);
  var ratio_w = width_source / width;
  var ratio_h = height_source / height;
  var ratio_w_half = Math.ceil(ratio_w / 2);
  var ratio_h_half = Math.ceil(ratio_h / 2);
  var ctx2 = canvas.getContext("2d");
  var img = ctx2.getImageData(0, 0, width_source, height_source);
  var img2 = ctx2.createImageData(width, height);
  var data = img.data;
  var data2 = img2.data;
  for (var j2 = 0; j2 < height; j2++) {
    for (var i = 0; i < width; i++) {
      var x2 = (i + j2 * width) * 4;
      var weight = 0;
      var weights = 0;
      var weights_alpha = 0;
      var gx_r = 0;
      var gx_g = 0;
      var gx_b = 0;
      var gx_a = 0;
      var center_y = (j2 + 0.5) * ratio_h;
      var yy_start = Math.floor(j2 * ratio_h);
      var yy_stop = Math.ceil((j2 + 1) * ratio_h);
      for (var yy = yy_start; yy < yy_stop; yy++) {
        var dy = Math.abs(center_y - (yy + 0.5)) / ratio_h_half;
        var center_x = (i + 0.5) * ratio_w;
        var w0 = dy * dy;
        var xx_start = Math.floor(i * ratio_w);
        var xx_stop = Math.ceil((i + 1) * ratio_w);
        for (var xx = xx_start; xx < xx_stop; xx++) {
          var dx = Math.abs(center_x - (xx + 0.5)) / ratio_w_half;
          var w2 = Math.sqrt(w0 + dx * dx);
          if (w2 >= 1) {
            continue;
          }
          weight = 2 * w2 * w2 * w2 - 3 * w2 * w2 + 1;
          var pos_x = 4 * (xx + yy * width_source);
          gx_a += weight * data[pos_x + 3];
          weights_alpha += weight;
          if (data[pos_x + 3] < 255) weight = weight * data[pos_x + 3] / 250;
          gx_r += weight * data[pos_x];
          gx_g += weight * data[pos_x + 1];
          gx_b += weight * data[pos_x + 2];
          weights += weight;
        }
      }
      data2[x2] = gx_r / weights;
      data2[x2 + 1] = gx_g / weights;
      data2[x2 + 2] = gx_b / weights;
      data2[x2 + 3] = gx_a / weights_alpha;
    }
  }
  {
    canvas.width = width;
    canvas.height = height;
  }
  ctx2.putImageData(img2, 0, 0);
}
function multiStepResize(canvas, targetWidth, targetHeight) {
  const originalWidth = canvas.width;
  const originalHeight = canvas.height;
  const scaleX = targetWidth / originalWidth;
  const scaleY = targetHeight / originalHeight;
  const scaleFactor = Math.min(scaleX, scaleY);
  if (scaleFactor < 0.5) {
    let currentWidth = originalWidth;
    let currentHeight = originalHeight;
    while (currentWidth > targetWidth * 2 || currentHeight > targetHeight * 2) {
      const nextWidth = Math.round(currentWidth / 2);
      const nextHeight = Math.round(currentHeight / 2);
      resample_high_quality(canvas, nextWidth, nextHeight);
      currentWidth = nextWidth;
      currentHeight = nextHeight;
    }
    if (currentWidth !== targetWidth || currentHeight !== targetHeight) {
      resample_high_quality(canvas, targetWidth, targetHeight);
    }
  } else {
    resample_high_quality(canvas, targetWidth, targetHeight);
  }
}
const startImageUpload = async ({ editor, view, file }) => {
  const imageUploadHandler = typeof editor.options.handleImageUpload === "function" ? editor.options.handleImageUpload : handleImageUpload;
  let fileSizeMb = Number((file.size / (1024 * 1024)).toFixed(4));
  if (fileSizeMb > 5) {
    window.alert("Image size must be less than 5MB");
    return;
  }
  let width;
  let height;
  try {
    const processedImageResult = await processUploadedImage(file, editor);
    width = processedImageResult.width;
    height = processedImageResult.height;
    file = processedImageResult.file;
  } catch (err) {
    console.warn("Error processing image:", err);
    return;
  }
  await uploadImage({
    editor,
    view,
    file,
    size: { width, height },
    uploadHandler: imageUploadHandler
  });
};
async function uploadImage({ editor, view, file, size: size2, uploadHandler }) {
  let id = {};
  let { tr, schema } = view.state;
  let { selection } = tr;
  if (editor.options.isHeaderOrFooter) {
    selection = editor.options.lastSelection;
  }
  if (!selection.empty && !editor.options.isHeaderOrFooter) {
    tr.deleteSelection();
  }
  let imageMeta = {
    type: "add",
    pos: selection.from,
    id
  };
  tr.setMeta(ImagePlaceholderPluginKey, imageMeta);
  view.dispatch(tr);
  try {
    let url = await uploadHandler(file);
    let fileName = file.name.replace(" ", "_");
    let placeholderPos = findPlaceholder(view.state, id);
    if (placeholderPos == null) {
      return;
    }
    let removeMeta = { type: "remove", id };
    let mediaPath = `word/media/${fileName}`;
    let rId = null;
    if (editor.options.mode === "docx") {
      const [, path] = mediaPath.split("word/");
      const id2 = addImageRelationship({ editor, path });
      if (id2) rId = id2;
    }
    let imageNode = schema.nodes.image.create({
      src: mediaPath,
      size: size2,
      rId
    });
    editor.storage.image.media = Object.assign(editor.storage.image.media, { [mediaPath]: url });
    if (editor.options.ydoc) {
      editor.commands.addImageToCollaboration({ mediaPath, fileData: url });
    }
    view.dispatch(
      view.state.tr.replaceWith(placeholderPos, placeholderPos, imageNode).setMeta(ImagePlaceholderPluginKey, removeMeta)
    );
  } catch {
    let removeMeta = { type: "remove", id };
    view.dispatch(tr.setMeta(ImagePlaceholderPluginKey, removeMeta));
  }
}
function addImageRelationship({ editor, path }) {
  const target = path;
  const type2 = "image";
  try {
    const id = insertNewRelationship(target, type2, editor);
    return id;
  } catch {
    return null;
  }
}
const BookmarkStart = Node$1.create({
  name: "bookmarkStart",
  group: "inline",
  content: "inline*",
  inline: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} BookmarkOptions
       * @category Options
       * @property {Object} [htmlAttributes] - HTML attributes for the bookmark element
       */
      htmlAttributes: {
        style: "height: 0; width: 0;",
        "aria-label": "Bookmark start node",
        role: "link"
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [name] - Bookmark name for cross-references and navigation
       */
      name: {
        default: null,
        renderDOM: ({ name }) => {
          if (name) return { name };
          return {};
        }
      },
      /**
       * @category Attribute
       * @param {string} [id] - Unique identifier for the bookmark
       */
      id: {
        default: null,
        renderDOM: ({ id }) => {
          if (id) return { id };
          return {};
        }
      }
    };
  },
  renderDOM({ htmlAttributes }) {
    return ["a", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      /**
       * Insert a bookmark at the current position
       * @category Command
       * @param {BookmarkConfig} config - Bookmark configuration
       * @returns {Function} Command function
       * @example
       * // Insert a named bookmark
       * insertBookmark({ name: 'chapter1' })
       *
       * // Insert with ID
       * insertBookmark({ name: 'introduction', id: 'intro-001' })
       * @note Bookmarks are invisible markers for navigation and cross-references
       */
      insertBookmark: (config) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: config
        });
      },
      /**
       * Navigate to a bookmark by name
       * @category Command
       * @param {string} name - Bookmark name to navigate to
       * @returns {Function} Command function
       * @example
       * goToBookmark('chapter1')
       * @note Scrolls the document to the bookmark position
       */
      goToBookmark: (name) => ({ editor, tr }) => {
        const { doc: doc2 } = tr;
        let targetPos = null;
        doc2.descendants((node2, pos) => {
          if (node2.type.name === "bookmarkStart" && node2.attrs.name === name) {
            targetPos = pos;
            return false;
          }
        });
        if (targetPos !== null) {
          editor.commands.focus(targetPos);
          return true;
        }
        return false;
      }
    };
  }
});
const Mention = Node$1.create({
  name: "mention",
  group: "inline",
  inline: true,
  selectable: false,
  atom: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-mention",
        "aria-label": "Mention node"
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `span[data-type="${this.name || this.email}"]`,
        getAttrs: (node2) => ({
          name: node2.getAttribute("name") || null,
          email: node2.getAttribute("email") || null
        })
      }
    ];
  },
  renderDOM({ node: node2, htmlAttributes }) {
    const { name, email } = node2.attrs;
    return [
      "span",
      Attribute2.mergeAttributes({ "data-type": this.name || this.email }, this.options.htmlAttributes, htmlAttributes),
      `@${name ? name : email}`
    ];
  },
  addAttributes() {
    return {
      name: { default: null },
      email: { default: null }
    };
  }
});
const PageNumber = Node$1.create({
  name: "page-number",
  group: "inline",
  inline: true,
  atom: true,
  draggable: false,
  selectable: false,
  defining: true,
  content: "",
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
        "data-id": "auto-page-number",
        "aria-label": "Page number node"
      }
    };
  },
  addAttributes() {
    return {
      marksAsAttrs: {
        default: null,
        rendered: false
      }
    };
  },
  addNodeView() {
    return ({ node: node2, editor, getPos, decorations }) => {
      const htmlAttributes = this.options.htmlAttributes;
      return new AutoPageNumberNodeView(node2, getPos, decorations, editor, htmlAttributes);
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-id="auto-page-number"' }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes)];
  },
  addCommands() {
    return {
      addAutoPageNumber: () => ({ tr, dispatch, state: state2, editor }) => {
        const { options } = editor;
        if (!options.isHeaderOrFooter) return false;
        const { schema } = state2;
        const pageNumberType = schema?.nodes?.["page-number"];
        if (!pageNumberType) return false;
        const pageNumberNodeJSON = { type: "page-number" };
        const pageNumberNode = schema.nodeFromJSON(pageNumberNodeJSON);
        if (dispatch) {
          tr.replaceSelectionWith(pageNumberNode, false);
          tr.setMeta("forceUpdatePagination", true);
        }
        return true;
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-alt-p": () => this.editor.commands.addAutoPageNumber()
    };
  }
});
const TotalPageCount = Node$1.create({
  name: "total-page-number",
  group: "inline",
  inline: true,
  atom: true,
  draggable: false,
  selectable: false,
  content: "text*",
  addOptions() {
    return {
      htmlAttributes: {
        contenteditable: false,
        "data-id": "auto-total-pages",
        "aria-label": "Total page count node",
        class: "sd-editor-auto-total-pages"
      }
    };
  },
  addAttributes() {
    return {
      marksAsAttrs: {
        default: null,
        rendered: false
      }
    };
  },
  addNodeView() {
    return ({ node: node2, editor, getPos, decorations }) => {
      const htmlAttributes = this.options.htmlAttributes;
      return new AutoPageNumberNodeView(node2, getPos, decorations, editor, htmlAttributes);
    };
  },
  parseDOM() {
    return [{ tag: 'span[data-id="auto-total-pages"' }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      addTotalPageCount: () => ({ tr, dispatch, state: state2, editor }) => {
        const { options } = editor;
        if (!options.isHeaderOrFooter) return false;
        const { schema } = state2;
        const pageNumberType = schema.nodes?.["total-page-number"];
        if (!pageNumberType) return false;
        const currentPages = editor?.options?.parentEditor?.currentTotalPages || 1;
        const pageNumberNode = {
          type: "total-page-number",
          content: [{ type: "text", text: String(currentPages) }]
        };
        const pageNode = schema.nodeFromJSON(pageNumberNode);
        if (dispatch) {
          tr.replaceSelectionWith(pageNode, false);
        }
        return true;
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-alt-c": () => this.editor.commands.addTotalPageCount()
    };
  }
});
const getNodeAttributes = (nodeName, editor) => {
  switch (nodeName) {
    case "page-number":
      return {
        text: editor.options.currentPageNumber || "1",
        className: "sd-editor-auto-page-number",
        dataId: "auto-page-number",
        ariaLabel: "Page number node"
      };
    case "total-page-number":
      return {
        text: editor.options.parentEditor?.currentTotalPages || "1",
        className: "sd-editor-auto-total-pages",
        dataId: "auto-total-pages",
        ariaLabel: "Total page count node"
      };
    default:
      return {};
  }
};
class AutoPageNumberNodeView {
  constructor(node2, getPos, decorations, editor, htmlAttributes = {}) {
    __privateAdd$1(this, _AutoPageNumberNodeView_instances);
    this.node = node2;
    this.editor = editor;
    this.view = editor.view;
    this.getPos = getPos;
    this.editor = editor;
    this.dom = __privateMethod$1(this, _AutoPageNumberNodeView_instances, renderDom_fn).call(this, node2, htmlAttributes);
  }
  update(node2) {
    if (node2.type !== this.node.type) return false;
    this.node = node2;
    return true;
  }
}
_AutoPageNumberNodeView_instances = /* @__PURE__ */ new WeakSet();
renderDom_fn = function(node2, htmlAttributes) {
  const attrs = getNodeAttributes(this.node.type.name, this.editor);
  const content = document.createTextNode(String(attrs.text));
  const nodeContent = document.createElement("span");
  nodeContent.className = attrs.className;
  nodeContent.setAttribute("data-id", attrs.dataId);
  nodeContent.setAttribute("aria-label", attrs.ariaLabel);
  const currentPos = this.getPos();
  const { styles, marks } = getMarksFromNeighbors(currentPos, this.view);
  __privateMethod$1(this, _AutoPageNumberNodeView_instances, scheduleUpdateNodeStyle_fn).call(this, currentPos, marks);
  Object.assign(nodeContent.style, styles);
  nodeContent.appendChild(content);
  Object.entries(htmlAttributes).forEach(([key, value]) => {
    if (value) nodeContent.setAttribute(key, value);
  });
  return nodeContent;
};
scheduleUpdateNodeStyle_fn = function(pos, marks) {
  setTimeout(() => {
    const { state: state2 } = this.editor;
    const { dispatch } = this.view;
    const node2 = state2.doc.nodeAt(pos);
    if (!node2 || node2.isText) return;
    const currentMarks = node2.attrs.marksAsAttrs || [];
    const newMarks = marks.map((m2) => ({ type: m2.type.name, attrs: m2.attrs }));
    const isEqual = JSON.stringify(currentMarks) === JSON.stringify(newMarks);
    if (isEqual) return;
    const newAttrs = {
      ...node2.attrs,
      marksAsAttrs: newMarks
    };
    const tr = state2.tr.setNodeMarkup(pos, void 0, newAttrs);
    dispatch(tr);
  }, 0);
};
const getMarksFromNeighbors = (currentPos, view) => {
  const $pos = view.state.doc.resolve(currentPos);
  const styles = {};
  const marks = [];
  const before = $pos.nodeBefore;
  if (before) {
    Object.assign(styles, processMarks(before.marks));
    marks.push(...before.marks);
  }
  const after = $pos.nodeAfter;
  if (after) {
    Object.assign(styles, { ...styles, ...processMarks(after.marks) });
    marks.push(...after.marks);
  }
  return {
    styles,
    marks
  };
};
const processMarks = (marks) => {
  const styles = {};
  marks.forEach((mark) => {
    const { type: type2, attrs } = mark;
    switch (type2.name) {
      case "textStyle":
        if (attrs.fontFamily) styles["font-family"] = attrs.fontFamily;
        if (attrs.fontSize) styles["font-size"] = attrs.fontSize;
        if (attrs.color) styles["color"] = attrs.color;
        if (attrs.backgroundColor) styles["background-color"] = attrs.backgroundColor;
        break;
      case "bold":
        styles["font-weight"] = "bold";
        break;
      case "italic":
        styles["font-style"] = "italic";
        break;
      case "underline":
        styles["text-decoration"] = (styles["text-decoration"] || "") + " underline";
        break;
      case "strike":
        styles["text-decoration"] = (styles["text-decoration"] || "") + " line-through";
        break;
      default:
        if (attrs?.style) {
          Object.entries(attrs.style).forEach(([key, value]) => {
            styles[key] = value;
          });
        }
        break;
    }
  });
  return styles;
};
const ShapeContainer = Node$1.create({
  name: "shapeContainer",
  group: "block",
  content: "block+",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-shape-container",
        "aria-label": "Shape container node"
      }
    };
  },
  addAttributes() {
    return {
      fillcolor: {
        renderDOM: (attrs) => {
          if (!attrs.fillcolor) return {};
          return {
            style: `background-color: ${attrs.fillcolor}`
          };
        }
      },
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      style: {
        renderDOM: (attrs) => {
          if (!attrs.style) return {};
          return {
            style: attrs.style
          };
        }
      },
      wrapAttributes: {
        rendered: false
      },
      attributes: {
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return [
      "div",
      Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { "data-type": this.name }),
      0
    ];
  }
});
const ShapeTextbox = Node$1.create({
  name: "shapeTextbox",
  group: "block",
  content: "paragraph* block*",
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-editor-shape-textbox",
        "aria-label": "Shape textbox node"
      }
    };
  },
  addAttributes() {
    return {
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      attributes: {
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return [
      "div",
      Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { "data-type": this.name }),
      0
    ];
  }
});
const ContentBlock = Node$1.create({
  name: "contentBlock",
  group: "inline",
  content: "",
  isolating: true,
  atom: true,
  inline: true,
  addOptions() {
    return {
      /**
       * @typedef {Object} ContentBlockOptions
       * @category Options
       * @property {Object} [htmlAttributes] - HTML attributes for the block element
       */
      htmlAttributes: {
        contenteditable: false
      }
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {boolean} [horizontalRule=false] - Whether this block is a horizontal rule
       */
      horizontalRule: {
        default: false,
        renderDOM: ({ horizontalRule }) => {
          if (!horizontalRule) return {};
          return { "data-horizontal-rule": "true" };
        }
      },
      /**
       * @category Attribute
       * @param {ContentBlockSize} [size] - Size and position of the content block
       */
      size: {
        default: null,
        renderDOM: ({ size: size2 }) => {
          if (!size2) return {};
          let style2 = "";
          if (size2.top) style2 += `top: ${size2.top}px; `;
          if (size2.left) style2 += `left: ${size2.left}px; `;
          if (size2.width) style2 += `width: ${size2.width.toString().endsWith("%") ? size2.width : `${size2.width}px`}; `;
          if (size2.height)
            style2 += `height: ${size2.height.toString().endsWith("%") ? size2.height : `${size2.height}px`}; `;
          return { style: style2 };
        }
      },
      /**
       * @category Attribute
       * @param {string} [background] - Background color for the block
       */
      background: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.background) return {};
          return {
            style: `background-color: ${attrs.background}`
          };
        }
      },
      /**
       * @private
       * @category Attribute
       * @param {Object} [drawingContent] - Internal drawing data
       */
      drawingContent: {
        rendered: false
      },
      /**
       * @private
       * @category Attribute
       * @param {Object} [attributes] - Additional internal attributes
       */
      attributes: {
        rendered: false
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: `div[data-type="${this.name}"]`
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return [
      "div",
      Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes, { "data-type": this.name }),
      0
    ];
  },
  addCommands() {
    return {
      /**
       * Insert a horizontal rule
       * @category Command
       * @returns {Function} Command function
       * @example
       * insertHorizontalRule()
       * @note Creates a visual separator between content sections
       */
      insertHorizontalRule: () => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: {
            horizontalRule: true,
            size: { width: "100%", height: 2 },
            background: "#e5e7eb"
          }
        });
      },
      /**
       * Insert a content block
       * @category Command
       * @param {ContentBlockConfig} config - Block configuration
       * @returns {Function} Command function
       * @example
       * // Insert a spacer block
       * insertContentBlock({ size: { height: 20 } })
       *
       * // Insert a colored divider
       * insertContentBlock({
       *   size: { width: '50%', height: 3 },
       *   background: '#3b82f6'
       * })
       * @note Used for spacing, dividers, and special inline content
       */
      insertContentBlock: (config) => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: this.name,
          attrs: config
        });
      }
    };
  }
});
const StructuredContent = Node$1.create({
  name: "structuredContent",
  group: "inline",
  inline: true,
  content: "inline*",
  addOptions() {
    return {
      structuredContentClass: "sd-structured-content-tag",
      htmlAttributes: {
        "aria-label": "Structured content node"
      }
    };
  },
  parseDOM() {
    return [{ tag: `span.${this.options.structuredContentClass}` }];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      sdtPr: {
        rendered: false
      }
    };
  }
});
const StructuredContentBlock = Node$1.create({
  name: "structuredContentBlock",
  group: "block",
  content: "block*",
  addOptions() {
    return {
      structuredContentClass: "sd-structured-content-tag",
      htmlAttributes: {
        "aria-label": "Structured content block node"
      }
    };
  },
  parseDOM() {
    return [{ tag: `div.${this.options.structuredContentClass}` }];
  },
  renderDOM({ htmlAttributes }) {
    return ["div", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      sdtPr: {
        rendered: false
      }
    };
  }
});
class DocumentSectionView {
  constructor(node2, getPos, decorations, editor) {
    __privateAdd$1(this, _DocumentSectionView_instances);
    this.node = node2;
    this.editor = editor;
    this.decorations = decorations;
    this.view = editor.view;
    this.getPos = getPos;
    __privateMethod$1(this, _DocumentSectionView_instances, init_fn3).call(this);
  }
}
_DocumentSectionView_instances = /* @__PURE__ */ new WeakSet();
init_fn3 = function() {
  const { attrs } = this.node;
  const { id, title, description } = attrs;
  this.dom = document.createElement("div");
  this.dom.className = "sd-document-section-block";
  this.dom.setAttribute("data-id", id);
  this.dom.setAttribute("data-title", title);
  this.dom.setAttribute("data-description", description);
  this.dom.setAttribute("aria-label", "Document section");
  __privateMethod$1(this, _DocumentSectionView_instances, addToolTip_fn).call(this);
  this.contentDOM = document.createElement("div");
  this.contentDOM.className = "sd-document-section-block-content";
  this.contentDOM.setAttribute("contenteditable", "true");
  this.dom.appendChild(this.contentDOM);
};
addToolTip_fn = function() {
  const { title } = this.node.attrs;
  this.infoDiv = document.createElement("div");
  this.infoDiv.className = "sd-document-section-block-info";
  const textSpan = document.createElement("span");
  textSpan.textContent = title || "Document section";
  this.infoDiv.appendChild(textSpan);
  this.infoDiv.setAttribute("contenteditable", "false");
  this.dom.appendChild(this.infoDiv);
};
const getAllSections = (editor) => {
  if (!editor) return [];
  const type2 = editor.schema.nodes.documentSection;
  if (!type2) return [];
  const sections = [];
  const { state: state2 } = editor;
  state2.doc.descendants((node2, pos) => {
    if (node2.type.name === type2.name) {
      sections.push({ node: node2, pos });
    }
  });
  return sections;
};
const exportSectionsToHTML = (editor) => {
  const sections = getAllSections(editor);
  const processedSections = /* @__PURE__ */ new Set();
  const result = [];
  sections.forEach(({ node: node2 }) => {
    const { attrs } = node2;
    const { id, title, description } = attrs;
    if (processedSections.has(id)) return;
    processedSections.add(id);
    const html = getHTMLFromNode(node2, editor);
    result.push({
      id,
      title,
      description,
      html
    });
  });
  return result;
};
const getHTMLFromNode = (node2, editor) => {
  const tempDocument = document.implementation.createHTMLDocument();
  const container = tempDocument.createElement("div");
  const fragment = DOMSerializer.fromSchema(editor.schema).serializeFragment(node2.content);
  container.appendChild(fragment);
  let html = container.innerHTML;
  return html;
};
const exportSectionsToJSON = (editor) => {
  const sections = getAllSections(editor);
  const processedSections = /* @__PURE__ */ new Set();
  const result = [];
  sections.forEach(({ node: node2 }) => {
    const { attrs } = node2;
    const { id, title, description } = attrs;
    if (processedSections.has(id)) return;
    processedSections.add(id);
    result.push({
      id,
      title,
      description,
      content: node2.toJSON()
    });
  });
  return result;
};
const getLinkedSectionEditor = (id, options, editor) => {
  const sections = getAllSections(editor);
  const section = sections.find((s) => s.node.attrs.id === id);
  if (!section) return null;
  const child = editor.createChildEditor({
    ...options,
    onUpdate: ({ editor: childEditor, transaction }) => {
      const isFromtLinkedParent = transaction.getMeta("fromLinkedParent");
      if (isFromtLinkedParent) return;
      const updatedContent = childEditor.state.doc.content;
      const sectionNode = getAllSections(editor)?.find((s) => s.node.attrs.id === id);
      if (!sectionNode) return;
      const { pos, node: node2 } = sectionNode;
      const newNode = node2.type.create(node2.attrs, updatedContent, node2.marks);
      const tr = editor.state.tr.replaceWith(pos, pos + node2.nodeSize, newNode);
      tr.setMeta("fromLinkedChild", true);
      editor.view.dispatch(tr);
    }
  });
  editor.on("update", ({ transaction }) => {
    const isFromLinkedChild = transaction.getMeta("fromLinkedChild");
    if (isFromLinkedChild) return;
    const sectionNode = getAllSections(editor)?.find((s) => s.node.attrs.id === id);
    if (!sectionNode) return;
    const sectionContent = sectionNode.node.content;
    const json = {
      type: "doc",
      content: sectionContent.content.map((node2) => node2.toJSON())
    };
    const childTr = child.state.tr;
    childTr.setMeta("fromLinkedParent", true);
    childTr.replaceWith(0, child.state.doc.content.size, child.schema.nodeFromJSON(json));
    child.view.dispatch(childTr);
  });
  return child;
};
const SectionHelpers = {
  getAllSections,
  exportSectionsToHTML,
  exportSectionsToJSON,
  getLinkedSectionEditor
};
const DocumentSection = Node$1.create({
  name: "documentSection",
  group: "block",
  content: "block*",
  atom: true,
  isolating: true,
  addOptions() {
    return {
      htmlAttributes: {
        class: "sd-document-section-block",
        "aria-label": "Structured content block"
      }
    };
  },
  parseDOM() {
    return [
      {
        tag: "div.sd-document-section-block",
        priority: 60
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["div", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {number} [id] - Unique section identifier
       */
      id: {},
      /**
       * @private
       * @category Attribute
       * @param {string} [sdBlockId] - Internal block tracking
       */
      sdBlockId: {
        default: null,
        keepOnSplit: false,
        parseDOM: (elem) => elem.getAttribute("data-sd-block-id"),
        renderDOM: (attrs) => {
          return attrs.sdBlockId ? { "data-sd-block-id": attrs.sdBlockId } : {};
        }
      },
      /**
       * @category Attribute
       * @param {string} [title] - Section display label
       */
      title: {},
      /**
       * @category Attribute
       * @param {string} [description] - Section metadata
       */
      description: {},
      /**
       * @category Attribute
       * @param {string} [sectionType] - Business classification (e.g., 'legal', 'pricing')
       */
      sectionType: {},
      /**
       * @category Attribute
       * @param {boolean} [isLocked=false] - Lock state preventing edits
       */
      isLocked: { default: false }
    };
  },
  addNodeView() {
    return ({ node: node2, editor, getPos, decorations }) => {
      return new DocumentSectionView(node2, getPos, decorations, editor);
    };
  },
  addCommands() {
    return {
      /**
       * Create a lockable content section
       * @category Command
       * @param {SectionCreate} [options={}] - Section configuration
       * @returns {Function} Command - true if created, false if position invalid
       * @example
       * createDocumentSection({
       *   id: 'legal-1',
       *   title: 'Terms & Conditions',
       *   isLocked: true,
       *   html: '<p>Legal content...</p>'
       * })
       */
      createDocumentSection: (options = {}) => ({ tr, state: state2, dispatch, editor }) => {
        const { selection } = state2;
        let { from: from2, to } = selection;
        let content = selection.content().content;
        const { html: optionsHTML, json: optionsJSON } = options;
        if (optionsHTML) {
          const html = htmlHandler(optionsHTML, this.editor);
          const doc2 = DOMParser$1.fromSchema(this.editor.schema).parse(html);
          content = doc2.content;
        }
        if (optionsJSON) {
          content = this.editor.schema.nodeFromJSON(optionsJSON);
        }
        if (!content?.content?.length) {
          content = this.editor.schema.nodeFromJSON({ type: "paragraph", content: [] });
        }
        if (!options.id) {
          const allSections = SectionHelpers.getAllSections(editor);
          options.id = allSections.length + 1;
        }
        if (!options.title) {
          options.title = "Document section";
        }
        const node2 = this.type.createAndFill(options, content);
        if (!node2) return false;
        const isAlreadyInSdtBlock = findParentNode((node22) => node22.type.name === "documentSection")(selection);
        if (isAlreadyInSdtBlock && isAlreadyInSdtBlock.node) {
          const insertPos2 = isAlreadyInSdtBlock.pos + isAlreadyInSdtBlock.node.nodeSize;
          from2 = insertPos2;
          to = insertPos2;
        }
        tr.replaceRangeWith(from2, to, node2);
        const nodeEnd = from2 + node2.nodeSize;
        let shouldInsertParagraph = true;
        let insertPos = nodeEnd;
        if (nodeEnd >= tr.doc.content.size) {
          insertPos = tr.doc.content.size;
          if (insertPos > 0) {
            const $endPos = tr.doc.resolve(insertPos);
            if ($endPos.nodeBefore && $endPos.nodeBefore.type.name === "paragraph") {
              shouldInsertParagraph = false;
            }
          }
        }
        if (shouldInsertParagraph) {
          const emptyParagraph = tr.doc.type.schema.nodes.paragraph.create();
          tr.insert(insertPos, emptyParagraph);
        }
        if (dispatch) {
          tr.setMeta("documentSection", { action: "create" });
          dispatch(tr);
          setTimeout(() => {
            try {
              const currentState = editor.state;
              const docSize = currentState.doc.content.size;
              let targetPos = from2 + node2.nodeSize;
              if (shouldInsertParagraph) {
                targetPos += 1;
              }
              targetPos = Math.min(targetPos, docSize);
              if (targetPos < docSize && targetPos > 0) {
                const newSelection = Selection.near(currentState.doc.resolve(targetPos));
                const newTr = currentState.tr.setSelection(newSelection);
                editor.view.dispatch(newTr);
              }
            } catch (e) {
              console.warn("Could not set delayed selection:", e);
            }
          }, 0);
        }
        return true;
      },
      /**
       * Remove section wrapper at cursor, preserving its content
       * @category Command
       * @returns {Function} Command - true if removed, false if no section at position
       * @example
       * removeSectionAtSelection()
       * @note Content stays in document, only section wrapper is removed
       */
      removeSectionAtSelection: () => ({ tr, dispatch }) => {
        const sdtNode = findParentNode((node22) => node22.type.name === "documentSection")(tr.selection);
        if (!sdtNode) return false;
        const { node: node2, pos } = sdtNode;
        const nodeStart = pos;
        const nodeEnd = nodeStart + node2.nodeSize;
        const contentToPreserve = node2.content;
        tr.delete(nodeStart, nodeEnd);
        if (contentToPreserve.size > 0) {
          tr.insert(nodeStart, contentToPreserve);
        }
        const newPos = Math.min(nodeStart, tr.doc.content.size);
        tr.setSelection(Selection.near(tr.doc.resolve(newPos)));
        if (dispatch) {
          tr.setMeta("documentSection", { action: "delete" });
          dispatch(tr);
        }
        return true;
      },
      /**
       * Delete section and all its content
       * @category Command
       * @param {number} id - Section to delete
       * @returns {Function} Command - true if deleted, false if ID doesn't exist
       * @example
       * removeSectionById(123)
       */
      removeSectionById: (id) => ({ tr, dispatch }) => {
        const sections = SectionHelpers.getAllSections(this.editor);
        const sectionToRemove = sections.find(({ node: node22 }) => node22.attrs.id === id);
        if (!sectionToRemove) return false;
        const { pos, node: node2 } = sectionToRemove;
        const nodeStart = pos;
        const nodeEnd = nodeStart + node2.nodeSize;
        tr.delete(nodeStart, nodeEnd);
        if (dispatch) {
          tr.setMeta("documentSection", { action: "delete", id });
          dispatch(tr);
        }
        return true;
      },
      /**
       * Lock section against edits
       * @category Command
       * @param {number} id - Section to lock
       * @returns {Function} Command - true if locked, false if ID doesn't exist
       * @example
       * lockSectionById(123)
       */
      lockSectionById: (id) => ({ tr, dispatch }) => {
        const sections = SectionHelpers.getAllSections(this.editor);
        const sectionToLock = sections.find(({ node: node2 }) => node2.attrs.id === id);
        if (!sectionToLock) return false;
        tr.setNodeMarkup(sectionToLock.pos, null, { ...sectionToLock.node.attrs, isLocked: true });
        if (dispatch) {
          tr.setMeta("documentSection", { action: "lock", id });
          dispatch(tr);
        }
        return true;
      },
      /**
       * Modify section attributes or content
       * @category Command
       * @param {SectionUpdate} options - Changes to apply
       * @returns {Function} Command - true if updated, false if ID doesn't exist
       * @example
       * // Toggle lock
       * updateSectionById({ id: 123, attrs: { isLocked: false } })
       *
       * // Replace content
       * updateSectionById({ id: 123, html: '<p>New content</p>' })
       *
       * // Both
       * updateSectionById({
       *   id: 123,
       *   html: '<p>Updated</p>',
       *   attrs: { title: 'New Title' }
       * })
       */
      updateSectionById: ({ id, html, json, attrs }) => ({ tr, dispatch, editor }) => {
        const sections = SectionHelpers.getAllSections(editor || this.editor);
        const sectionToUpdate = sections.find(({ node: node22 }) => node22.attrs.id === id);
        if (!sectionToUpdate) return false;
        const { pos, node: node2 } = sectionToUpdate;
        let newContent = null;
        if (html) {
          const htmlDoc = htmlHandler(html, editor || this.editor);
          const doc2 = DOMParser$1.fromSchema((editor || this.editor).schema).parse(htmlDoc);
          newContent = doc2.content;
        }
        if (json) {
          newContent = (editor || this.editor).schema.nodeFromJSON(json);
        }
        if (!newContent) {
          newContent = node2.content;
        }
        const updatedNode = node2.type.create({ ...node2.attrs, ...attrs }, newContent, node2.marks);
        tr.replaceWith(pos, pos + node2.nodeSize, updatedNode);
        if (dispatch) {
          tr.setMeta("documentSection", { action: "update", id, attrs });
          dispatch(tr);
        }
        return true;
      }
    };
  },
  addHelpers() {
    return {
      ...SectionHelpers
    };
  }
});
const { findChildren } = helpers;
const SD_BLOCK_ID_ATTRIBUTE_NAME = "sdBlockId";
const BlockNodePluginKey = new PluginKey("blockNodePlugin");
const BlockNode = Extension.create({
  name: "blockNode",
  addCommands() {
    return {
      replaceBlockNodeById: (id, contentNode) => ({ dispatch, tr }) => {
        const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
        if (!blockNode || blockNode.length > 1) {
          return false;
        }
        if (dispatch) {
          let { pos, node: node2 } = blockNode[0];
          let newPosFrom = tr.mapping.map(pos);
          let newPosTo = tr.mapping.map(pos + node2.nodeSize);
          let currentNode = tr.doc.nodeAt(newPosFrom);
          if (node2.eq(currentNode)) {
            tr.replaceWith(newPosFrom, newPosTo, contentNode);
          }
        }
        return true;
      },
      deleteBlockNodeById: (id) => ({ dispatch, tr }) => {
        const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
        if (!blockNode || blockNode.length > 1) {
          return false;
        }
        if (dispatch) {
          let { pos, node: node2 } = blockNode[0];
          let newPosFrom = tr.mapping.map(pos);
          let newPosTo = tr.mapping.map(pos + node2.nodeSize);
          let currentNode = tr.doc.nodeAt(newPosFrom);
          if (node2.eq(currentNode)) {
            tr.delete(newPosFrom, newPosTo);
          }
        }
        return true;
      },
      updateBlockNodeAttributes: (id, attrs = {}) => ({ dispatch, tr }) => {
        const blockNode = this.editor.helpers.blockNode.getBlockNodeById(id);
        if (!blockNode || blockNode.length > 1) {
          return false;
        }
        if (dispatch) {
          let { pos, node: node2 } = blockNode[0];
          let newPos = tr.mapping.map(pos);
          let currentNode = tr.doc.nodeAt(newPos);
          if (node2.eq(currentNode)) {
            tr.setNodeMarkup(newPos, void 0, {
              ...node2.attrs,
              ...attrs
            });
          }
          return true;
        }
      }
    };
  },
  addHelpers() {
    return {
      getBlockNodes: () => {
        return findChildren(this.editor.state.doc, (node2) => nodeAllowsSdBlockIdAttr(node2));
      },
      getBlockNodeById: (id) => {
        return findChildren(this.editor.state.doc, (node2) => node2.attrs.sdBlockId === id);
      },
      getBlockNodesByType: (type2) => {
        return findChildren(this.editor.state.doc, (node2) => node2.type.name === type2);
      },
      getBlockNodesInRange: (from2, to) => {
        let blockNodes = [];
        this.editor.state.doc.nodesBetween(from2, to, (node2, pos) => {
          if (nodeAllowsSdBlockIdAttr(node2)) {
            blockNodes.push({
              node: node2,
              pos
            });
          }
        });
        return blockNodes;
      }
    };
  },
  addPmPlugins() {
    let hasInitialized = false;
    return [
      new Plugin({
        key: BlockNodePluginKey,
        appendTransaction: (transactions, _oldState, newState) => {
          if (hasInitialized && !transactions.some((tr2) => tr2.docChanged)) return null;
          if (hasInitialized && !checkForNewBlockNodesInTrs(transactions)) return null;
          let tr = null;
          let changed = false;
          newState.doc.descendants((node2, pos) => {
            if (!nodeAllowsSdBlockIdAttr(node2) || !nodeNeedsSdBlockId(node2)) return null;
            tr = tr ?? newState.tr;
            tr.setNodeMarkup(
              pos,
              void 0,
              {
                ...node2.attrs,
                sdBlockId: v4()
              },
              node2.marks
            );
            changed = true;
          });
          if (changed && !hasInitialized) hasInitialized = true;
          return changed ? tr : null;
        }
      })
    ];
  }
});
const nodeAllowsSdBlockIdAttr = (node2) => {
  return !!(node2?.isBlock && node2?.type?.spec?.attrs?.[SD_BLOCK_ID_ATTRIBUTE_NAME]);
};
const nodeNeedsSdBlockId = (node2) => {
  const currentId = node2?.attrs?.[SD_BLOCK_ID_ATTRIBUTE_NAME];
  return !currentId;
};
const checkForNewBlockNodesInTrs = (transactions) => {
  return transactions.some((tr) => {
    return tr.steps.some((step) => {
      const hasValidSdBlockNodes = step.slice?.content?.content?.some((node2) => nodeAllowsSdBlockIdAttr(node2));
      return step instanceof ReplaceStep && hasValidSdBlockNodes;
    });
  });
};
const TextStyle = Mark2.create({
  name: "textStyle",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  parseDOM() {
    return [
      {
        tag: "span",
        getAttrs: (el) => {
          const hasStyles = el.hasAttribute("style");
          const isAnnotation = el.classList.contains(annotationClass) || el.classList.contains(annotationContentClass);
          if (!hasStyles || isAnnotation) return false;
          return {};
        }
      }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      styleId: {}
    };
  },
  addCommands() {
    return {
      /**
       * Remove empty text style marks
       * @category Command
       * @returns {Function} Command - Removes mark if no attributes present
       * @example
       * removeEmptyTextStyle()
       * @note Cleanup utility to prevent empty span elements
       */
      removeEmptyTextStyle: () => ({ state: state2, commands: commands2 }) => {
        const attributes = Attribute2.getMarkAttributes(state2, this.type);
        const hasStyles = Object.entries(attributes).some(([, value]) => !!value);
        if (hasStyles) return true;
        return commands2.unsetMark(this.name);
      }
    };
  }
});
const Bold = Mark2.create({
  name: "bold",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [value] - Bold weight value ('0' renders as normal)
       */
      value: {
        default: null,
        renderDOM: (attrs) => {
          if (!attrs.value) return {};
          if (attrs.value === "0") {
            return { style: "font-weight: normal" };
          }
          return {};
        }
      }
    };
  },
  parseDOM() {
    return [
      { tag: "strong" },
      { tag: "b", getAttrs: (node2) => node2.style.fontWeight != "normal" && null },
      { style: "font-weight=400", clearMark: (m2) => m2.type.name == "strong" },
      { style: "font-weight", getAttrs: (value) => /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["strong", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Apply bold formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * setBold()
       * @note '0' renders as normal weight
       */
      setBold: () => ({ commands: commands2 }) => commands2.setMark(this.name),
      /**
       * Remove bold formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetBold()
       */
      unsetBold: () => ({ commands: commands2 }) => commands2.unsetMark(this.name),
      /**
       * Toggle bold formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleBold()
       */
      toggleBold: () => ({ commands: commands2 }) => commands2.toggleMark(this.name)
    };
  },
  addShortcuts() {
    return {
      "Mod-b": () => this.editor.commands.toggleBold(),
      "Mod-B": () => this.editor.commands.toggleBold()
    };
  }
});
const Italic = Mark2.create({
  name: "italic",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  parseDOM() {
    return [
      { tag: "i" },
      { tag: "em" },
      { style: "font-style=italic" },
      { style: "font-style=normal", clearMark: (m2) => m2.type.name == "em" }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["em", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Apply italic formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * setItalic()
       */
      setItalic: () => ({ commands: commands2 }) => commands2.setMark(this.name),
      /**
       * Remove italic formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetItalic()
       */
      unsetItalic: () => ({ commands: commands2 }) => commands2.unsetMark(this.name),
      /**
       * Toggle italic formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleItalic()
       */
      toggleItalic: () => ({ commands: commands2 }) => commands2.toggleMark(this.name)
    };
  },
  addShortcuts() {
    return {
      "Mod-i": () => this.editor.commands.toggleItalic(),
      "Mod-I": () => this.editor.commands.toggleItalic()
    };
  }
});
const Underline = Mark2.create({
  name: "underline",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  parseDOM() {
    return [
      { tag: "u" },
      { style: "text-decoration=underline" },
      { style: "text-decoration=auto", clearMark: (m2) => m2.type.name == "u" }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["u", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {UnderlineConfig} [underlineType='single'] - Style of underline
       */
      underlineType: {
        default: "single"
      }
    };
  },
  addCommands() {
    return {
      /**
       * Apply underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * setUnderline()
       */
      setUnderline: () => ({ commands: commands2 }) => commands2.setMark(this.name),
      /**
       * Remove underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetUnderline()
       */
      unsetUnderline: () => ({ commands: commands2 }) => commands2.unsetMark(this.name),
      /**
       * Toggle underline formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleUnderline()
       */
      toggleUnderline: () => ({ commands: commands2 }) => commands2.toggleMark(this.name)
    };
  },
  addShortcuts() {
    return {
      "Mod-u": () => this.editor.commands.toggleUnderline(),
      "Mod-U": () => this.editor.commands.toggleUnderline()
    };
  }
});
const Highlight = Mark2.create({
  name: "highlight",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [color] - Background color (CSS color value)
       */
      color: {
        default: null,
        parseDOM: (element) => element.getAttribute("data-color") || element.style.backgroundColor,
        renderDOM: (attributes) => {
          if (!attributes.color) {
            return {};
          }
          return {
            "data-color": attributes.color,
            style: `background-color: ${attributes.color}; color: inherit`
          };
        }
      }
    };
  },
  parseDOM() {
    return [{ tag: "mark" }];
  },
  renderDOM({ htmlAttributes }) {
    return ["mark", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Apply highlight with specified color
       * @category Command
       * @param {string} color - CSS color value
       * @returns {Function} Command
       * @example
       * setHighlight('#FFEB3B')
       * setHighlight('rgba(255, 235, 59, 0.5)')
       */
      setHighlight: (color) => ({ commands: commands2 }) => commands2.setMark(this.name, { color }),
      /**
       * Remove highlight formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetHighlight()
       */
      unsetHighlight: () => ({ commands: commands2 }) => commands2.unsetMark(this.name),
      /**
       * Toggle highlight formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleHighlight()
       */
      toggleHighlight: () => ({ commands: commands2 }) => commands2.toggleMark(this.name)
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-h": () => this.editor.commands.toggleHighlight()
    };
  }
});
const Strike = Mark2.create({
  name: "strike",
  addOptions() {
    return {
      htmlAttributes: {}
    };
  },
  parseDOM() {
    return [
      { tag: "s" },
      { style: "text-decoration=line-through" },
      { style: "text-decoration=auto", clearMark: (m2) => m2.type.name == "s" }
    ];
  },
  renderDOM({ htmlAttributes }) {
    return ["s", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addCommands() {
    return {
      /**
       * Apply strikethrough formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * setStrike()
       */
      setStrike: () => ({ commands: commands2 }) => {
        return commands2.setMark(this.name);
      },
      /**
       * Remove strikethrough formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * unsetStrike()
       */
      unsetStrike: () => ({ commands: commands2 }) => {
        return commands2.unsetMark(this.name);
      },
      /**
       * Toggle strikethrough formatting
       * @category Command
       * @returns {Function} Command
       * @example
       * toggleStrike()
       */
      toggleStrike: () => ({ commands: commands2 }) => {
        return commands2.toggleMark(this.name);
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Shift-s": () => this.editor.commands.toggleStrike()
    };
  }
});
const Link = Mark2.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: false,
  inclusive: false,
  addOptions() {
    return {
      /**
       * Allowed URL protocols
       * @type {string[]}
       * @default ['http', 'https']
       */
      protocols: ["http", "https"],
      htmlAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      }
    };
  },
  parseDOM() {
    return [{ tag: "a" }];
  },
  renderDOM({ htmlAttributes }) {
    if (!isAllowedUri(htmlAttributes.href, this.options.protocols)) {
      return ["a", Attribute2.mergeAttributes(this.options.htmlAttributes, { ...htmlAttributes, href: "" }), 0];
    }
    return ["a", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  },
  addAttributes() {
    return {
      /**
       * @category Attribute
       * @param {string} [href] - URL or anchor reference
       */
      href: {
        default: null,
        renderDOM: ({ href, name }) => {
          if (href && isAllowedUri(href, this.options.protocols)) return { href };
          else if (name) return { href: `#${name}` };
          return {};
        }
      },
      /**
       * @category Attribute
       * @param {string} [target='_blank'] - Link target window
       */
      target: { default: this.options.htmlAttributes.target },
      /**
       * @category Attribute
       * @param {string} [rel='noopener noreferrer nofollow'] - Relationship attributes
       */
      rel: { default: this.options.htmlAttributes.rel },
      /**
       * @private
       * @category Attribute
       * @param {string} [rId] - Word relationship ID for internal links
       */
      rId: { default: this.options.htmlAttributes.rId || null },
      /**
       * @category Attribute
       * @param {string} [text] - Display text for the link
       */
      text: { default: null },
      /**
       * @category Attribute
       * @param {string} [name] - Anchor name for internal references
       */
      name: { default: null }
    };
  },
  addCommands() {
    return {
      /**
       * Create or update a link
       * @category Command
       * @param {Object} options - Link configuration
       * @param {string} [options.href] - URL for the link
       * @param {string} [options.text] - Display text (uses selection if omitted)
       * @returns {Function} Command - Creates link with underline
       * @example
       * // Link selected text
       * setLink({ href: 'https://example.com' })
       *
       * // Link with custom text
       * setLink({
       *   href: 'https://example.com',
       *   text: 'Visit Example'
       * })
       * @note Automatically adds underline formatting and trims whitespace from link boundaries
       */
      setLink: ({ href, text } = {}) => ({ state: state2, dispatch, editor }) => {
        const { selection } = state2;
        const linkMarkType = editor.schema.marks.link;
        const underlineMarkType = editor.schema.marks.underline;
        let from2 = selection.from;
        let to = selection.to;
        if (selection.empty) {
          const range2 = getMarkRange(selection.$from, linkMarkType);
          if (range2) {
            from2 = range2.from;
            to = range2.to;
          }
        } else {
          const fromLinkRange = getMarkRange(selection.$from, linkMarkType);
          const toLinkRange = getMarkRange(selection.$to, linkMarkType);
          if (fromLinkRange || toLinkRange) {
            const linkRange = fromLinkRange || toLinkRange;
            from2 = linkRange.from;
            to = linkRange.to;
          }
        }
        ({ from: from2, to } = trimRange(state2.doc, from2, to));
        const currentText = state2.doc.textBetween(from2, to);
        const computedText = text ?? currentText;
        const finalText = computedText && computedText.length > 0 ? computedText : href || "";
        let tr = state2.tr;
        if (finalText && currentText !== finalText) {
          tr = tr.insertText(finalText, from2, to);
          to = from2 + finalText.length;
        }
        if (linkMarkType) tr = tr.removeMark(from2, to, linkMarkType);
        if (underlineMarkType) tr = tr.removeMark(from2, to, underlineMarkType);
        if (underlineMarkType) tr = tr.addMark(from2, to, underlineMarkType.create());
        let rId = null;
        if (editor.options.mode === "docx") {
          const id = addLinkRelationship({ editor, href });
          if (id) rId = id;
        }
        const newLinkMarkType = linkMarkType.create({ href, text: finalText, rId });
        tr = tr.addMark(from2, to, newLinkMarkType);
        dispatch(tr.scrollIntoView());
        return true;
      },
      /**
       * Remove link and associated formatting
       * @category Command
       * @returns {Function} Command - Removes link, underline, and color
       * @example
       * unsetLink()
       * @note Also removes underline and text color
       */
      unsetLink: () => ({ chain }) => {
        return chain().unsetMark("underline", { extendEmptyMarkRange: true }).unsetColor().unsetMark("link", { extendEmptyMarkRange: true }).run();
      },
      /**
       * Toggle link on selection
       * @category Command
       * @param {Object} [options] - Link configuration
       * @param {string} [options.href] - URL for the link
       * @param {string} [options.text] - Display text
       * @returns {Function} Command - Creates link if href provided, removes otherwise
       * @example
       * // Add link
       * toggleLink({ href: 'https://example.com' })
       *
       * // Remove link
       * toggleLink()
       */
      toggleLink: ({ href, text } = {}) => ({ commands: commands2 }) => {
        if (!href) return commands2.unsetLink();
        return commands2.setLink({ href, text });
      }
    };
  }
});
const ATTR_WHITESPACE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g;
function isAllowedUri(uri2, protocols) {
  const allowedProtocols = ["http", "https", "mailto"];
  if (protocols) {
    protocols.forEach((protocol) => {
      const nextProtocol = typeof protocol === "string" ? protocol : protocol.scheme;
      if (nextProtocol) {
        allowedProtocols.push(nextProtocol);
      }
    });
  }
  return !uri2 || uri2.replace(ATTR_WHITESPACE, "").match(new RegExp(`^(?:(?:${allowedProtocols.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`, "i"));
}
const trimRange = (doc2, from2, to) => {
  while (from2 < to && doc2.textBetween(from2, from2 + 1, "") === "") {
    from2 += 1;
  }
  while (to > from2 && doc2.textBetween(to - 1, to, "") === "") {
    to -= 1;
  }
  return { from: from2, to };
};
function addLinkRelationship({ editor, href }) {
  const target = href;
  const type2 = "hyperlink";
  try {
    const id = insertNewRelationship(target, type2, editor);
    return id;
  } catch {
    return null;
  }
}
const trackInsertClass = "track-insert";
const TrackInsert = Mark2.create({
  name: TrackInsertMarkName,
  group: "track",
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackInsertClass
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-id"),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            "data-id": attrs.id
          };
        }
      },
      author: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-author"),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            "data-author": attrs.author
          };
        }
      },
      authorEmail: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authoremail"),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            "data-authoremail": attrs.authorEmail
          };
        }
      },
      date: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-date"),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            "data-date": attrs.date
          };
        }
      },
      importedAuthor: {
        default: "",
        rendered: false
      }
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const trackDeleteClass = "track-delete";
const TrackDelete = Mark2.create({
  name: TrackDeleteMarkName,
  group: "track",
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackDeleteClass
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-id"),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            "data-id": attrs.id
          };
        }
      },
      author: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-author"),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            "data-author": attrs.author
          };
        }
      },
      authorEmail: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authoremail"),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            "data-authoremail": attrs.authorEmail
          };
        }
      },
      date: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-date"),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            "data-date": attrs.date
          };
        }
      },
      importedAuthor: {
        default: "",
        rendered: false
      }
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const replaceAroundStep = () => {
};
const markWrapping = () => {
};
const parseFormatList = (str) => {
  if (!str) return [];
  let formatList;
  try {
    formatList = JSON.parse(str);
  } catch {
    return [];
  }
  if (!Array.isArray(formatList)) {
    return [];
  }
  return formatList.filter((format) => Object.hasOwn(format, "type") && Object.hasOwn(format, "attrs"));
};
const index = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addMarkStep,
  documentHelpers,
  findTrackedMarkBetween,
  getTrackChanges,
  markDeletion,
  markInsertion,
  markWrapping,
  parseFormatList,
  removeMarkStep,
  replaceAroundStep,
  replaceStep,
  trackedTransaction
}, Symbol.toStringTag, { value: "Module" }));
const trackFormatClass = "track-format";
const TrackFormat = Mark2.create({
  name: TrackFormatMarkName,
  group: "track",
  inclusive: false,
  addOptions() {
    return {
      htmlAttributes: {
        class: trackFormatClass
      }
    };
  },
  addAttributes() {
    return {
      id: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-id"),
        renderDOM: (attrs) => {
          if (!attrs.id) return {};
          return {
            "data-id": attrs.id
          };
        }
      },
      author: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-author"),
        renderDOM: (attrs) => {
          if (!attrs.author) return {};
          return {
            "data-author": attrs.author
          };
        }
      },
      authorEmail: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-authoremail"),
        renderDOM: (attrs) => {
          if (!attrs.authorEmail) return {};
          return {
            "data-authoremail": attrs.authorEmail
          };
        }
      },
      date: {
        default: "",
        parseDOM: (elem) => elem.getAttribute("data-date"),
        renderDOM: (attrs) => {
          if (!attrs.date) return {};
          return {
            "data-date": attrs.date
          };
        }
      },
      // {
      //   type: string, // the mark name
      //   attrs: object, // the mark attrs
      // }
      before: {
        default: [],
        parseDOM: (elem) => {
          return parseFormatList(elem.getAttribute("data-before"));
        },
        renderDOM: (attrs) => {
          if (!attrs.before) return {};
          return {
            "data-before": JSON.stringify(attrs.before)
          };
        }
      },
      // {
      //   type: string, // the mark name
      //   attrs: object, // the mark attrs
      // }
      after: {
        default: [],
        parseDOM: (elem) => {
          return parseFormatList(elem.getAttribute("data-after"));
        },
        renderDOM: (attrs) => {
          if (!attrs.after) return {};
          return {
            "data-after": JSON.stringify(attrs.after)
          };
        }
      },
      importedAuthor: {
        default: "",
        rendered: false
      }
    };
  },
  parseDOM() {
    return false;
  },
  renderDOM({ htmlAttributes }) {
    return ["span", Attribute2.mergeAttributes(this.options.htmlAttributes, htmlAttributes), 0];
  }
});
const TrackChanges = Extension.create({
  name: "trackChanges",
  addCommands() {
    return {
      acceptTrackedChangesBetween: (from2, to) => ({ state: state2, dispatch }) => {
        let { tr, doc: doc2 } = state2;
        tr.setMeta("acceptReject", true);
        const map22 = new Mapping();
        doc2.nodesBetween(from2, to, (node2, pos) => {
          if (node2.marks && node2.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
            const deletionStep = new ReplaceStep(
              map22.map(Math.max(pos, from2)),
              map22.map(Math.min(pos + node2.nodeSize, to)),
              Slice.empty
            );
            tr.step(deletionStep);
            map22.appendMap(deletionStep.getMap());
          } else if (node2.marks && node2.marks.find((mark) => mark.type.name === TrackInsertMarkName)) {
            const insertionMark = node2.marks.find((mark) => mark.type.name === TrackInsertMarkName);
            tr.step(
              new RemoveMarkStep(
                map22.map(Math.max(pos, from2)),
                map22.map(Math.min(pos + node2.nodeSize, to)),
                insertionMark
              )
            );
          } else if (node2.marks && node2.marks.find((mark) => mark.type.name === TrackFormatMarkName)) {
            const formatChangeMark = node2.marks.find((mark) => mark.type.name === TrackFormatMarkName);
            tr.step(
              new RemoveMarkStep(
                map22.map(Math.max(pos, from2)),
                map22.map(Math.min(pos + node2.nodeSize, to)),
                formatChangeMark
              )
            );
          }
        });
        if (tr.steps.length) {
          dispatch(tr);
        }
        return true;
      },
      rejectTrackedChangesBetween: (from2, to) => ({ state: state2, dispatch }) => {
        const { tr, doc: doc2 } = state2;
        tr.setMeta("acceptReject", true);
        const map22 = new Mapping();
        doc2.nodesBetween(from2, to, (node2, pos) => {
          if (node2.marks && node2.marks.find((mark) => mark.type.name === TrackDeleteMarkName)) {
            const deletionMark = node2.marks.find((mark) => mark.type.name === TrackDeleteMarkName);
            tr.step(
              new RemoveMarkStep(
                map22.map(Math.max(pos, from2)),
                map22.map(Math.min(pos + node2.nodeSize, to)),
                deletionMark
              )
            );
          } else if (node2.marks && node2.marks.find((mark) => mark.type.name === TrackInsertMarkName)) {
            const deletionStep = new ReplaceStep(
              map22.map(Math.max(pos, from2)),
              map22.map(Math.min(pos + node2.nodeSize, to)),
              Slice.empty
            );
            tr.step(deletionStep);
            map22.appendMap(deletionStep.getMap());
          } else if (node2.marks && node2.marks.find((mark) => mark.type.name === TrackFormatMarkName)) {
            const formatChangeMark = node2.marks.find((mark) => mark.type.name === TrackFormatMarkName);
            formatChangeMark.attrs.before.forEach((oldMark) => {
              tr.step(
                new AddMarkStep(
                  map22.map(Math.max(pos, from2)),
                  map22.map(Math.min(pos + node2.nodeSize, to)),
                  state2.schema.marks[oldMark.type].create(oldMark.attrs)
                )
              );
            });
            formatChangeMark.attrs.after.forEach((newMark) => {
              tr.step(
                new RemoveMarkStep(
                  map22.map(Math.max(pos, from2)),
                  map22.map(Math.min(pos + node2.nodeSize, to)),
                  node2.marks.find((mark) => mark.type.name === newMark.type)
                )
              );
            });
            tr.step(
              new RemoveMarkStep(
                map22.map(Math.max(pos, from2)),
                map22.map(Math.min(pos + node2.nodeSize, to)),
                formatChangeMark
              )
            );
          }
        });
        if (tr.steps.length) {
          dispatch(tr);
        }
        return true;
      },
      acceptTrackedChange: ({ trackedChange }) => ({ commands: commands2 }) => {
        const { start: from2, end: to } = trackedChange;
        return commands2.acceptTrackedChangesBetween(from2, to);
      },
      acceptTrackedChangeBySelection: () => ({ state: state2, commands: commands2 }) => {
        const { from: from2, to } = state2.selection;
        return commands2.acceptTrackedChangesBetween(from2, to);
      },
      acceptTrackedChangeById: (id) => ({ state: state2, tr, commands: commands2 }) => {
        const toResolve = getChangesByIdToResolve(state2, id) || [];
        return toResolve.map(({ from: from2, to }) => {
          let mappedFrom = tr.mapping.map(from2);
          let mappedTo = tr.mapping.map(to);
          return commands2.acceptTrackedChangesBetween(mappedFrom, mappedTo);
        }).every((result) => result);
      },
      acceptAllTrackedChanges: () => ({ state: state2, commands: commands2 }) => {
        const from2 = 0, to = state2.doc.content.size;
        return commands2.acceptTrackedChangesBetween(from2, to);
      },
      rejectTrackedChangeById: (id) => ({ state: state2, tr, commands: commands2 }) => {
        const toReject = getChangesByIdToResolve(state2, id) || [];
        return toReject.map(({ from: from2, to }) => {
          let mappedFrom = tr.mapping.map(from2);
          let mappedTo = tr.mapping.map(to);
          return commands2.rejectTrackedChangesBetween(mappedFrom, mappedTo);
        }).every((result) => result);
      },
      rejectTrackedChange: ({ trackedChange }) => ({ commands: commands2 }) => {
        const { start: from2, end: to } = trackedChange;
        return commands2.rejectTrackedChangesBetween(from2, to);
      },
      rejectTrackedChangeOnSelection: () => ({ state: state2, commands: commands2 }) => {
        const { from: from2, to } = state2.selection;
        return commands2.rejectTrackedChangesBetween(from2, to);
      },
      rejectAllTrackedChanges: () => ({ state: state2, commands: commands2 }) => {
        const from2 = 0, to = state2.doc.content.size;
        return commands2.rejectTrackedChangesBetween(from2, to);
      },
      toggleTrackChanges: () => ({ state: state2 }) => {
        const trackChangeState = TrackChangesBasePluginKey.getState(state2);
        if (trackChangeState === void 0) return false;
        state2.tr.setMeta(TrackChangesBasePluginKey, {
          type: "TRACK_CHANGES_ENABLE",
          value: !trackChangeState.isTrackChangesActive
        });
        return true;
      },
      enableTrackChanges: () => ({ state: state2 }) => {
        state2.tr.setMeta(TrackChangesBasePluginKey, {
          type: "TRACK_CHANGES_ENABLE",
          value: true
        });
        return true;
      },
      disableTrackChanges: () => ({ state: state2 }) => {
        state2.tr.setMeta(TrackChangesBasePluginKey, {
          type: "TRACK_CHANGES_ENABLE",
          value: false
        });
        return true;
      },
      toggleTrackChangesShowOriginal: () => ({ state: state2 }) => {
        const trackChangeState = TrackChangesBasePluginKey.getState(state2);
        if (trackChangeState === void 0) return false;
        state2.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_ORIGINAL",
          value: !trackChangeState.onlyOriginalShown
        });
        return true;
      },
      enableTrackChangesShowOriginal: () => ({ state: state2 }) => {
        state2.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_ORIGINAL",
          value: true
        });
        return true;
      },
      disableTrackChangesShowOriginal: () => ({ state: state2 }) => {
        state2.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_ORIGINAL",
          value: false
        });
        return true;
      },
      toggleTrackChangesShowFinal: () => ({ state: state2 }) => {
        const trackChangeState = TrackChangesBasePluginKey.getState(state2);
        if (trackChangeState === void 0) return false;
        state2.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_MODIFIED",
          value: !trackChangeState.onlyModifiedShown
        });
        return true;
      },
      enableTrackChangesShowFinal: () => ({ state: state2 }) => {
        state2.tr.setMeta(TrackChangesBasePluginKey, {
          type: "SHOW_ONLY_MODIFIED",
          value: true
        });
        return true;
      }
    };
  },
  addPmPlugins() {
    return [TrackChangesBasePlugin()];
  }
});
const getChangesByIdToResolve = (state2, id) => {
  const trackedChanges = getTrackChanges(state2);
  const changeIndex = trackedChanges.findIndex(({ mark }) => mark.attrs.id === id);
  if (changeIndex === -1) return;
  const matchingChange = trackedChanges[changeIndex];
  const prev = trackedChanges[changeIndex - 1];
  const next = trackedChanges[changeIndex + 1];
  let linkedChange;
  if (prev && matchingChange.start === prev.end) {
    linkedChange = prev;
  } else if (next && matchingChange.end === next.start) {
    linkedChange = next;
  }
  return [matchingChange, linkedChange].filter(Boolean);
};
const TextTransform = Extension.create({
  name: "textTransform",
  addOptions() {
    return {
      types: ["textStyle"]
    };
  },
  addGlobalAttributes() {
    return [
      {
        types: this.options.types,
        attributes: {
          textTransform: {
            default: null,
            renderDOM: (attrs) => {
              if (!attrs.textCase) return {};
              return {
                style: `text-transform: ${attrs.textCase}`
              };
            }
          }
        }
      }
    ];
  }
});
const Placeholder = Extension.create({
  name: "placeholder",
  addOptions() {
    return {
      placeholder: "Type something..."
    };
  },
  addPmPlugins() {
    const applyDecoration = (state2) => {
      const plainText = state2.doc.textBetween(0, state2.doc.content.size, " ", " ");
      if (plainText !== "") return DecorationSet.empty;
      const { $from } = state2.selection;
      const decoration = Decoration.node($from.before(), $from.after(), {
        "data-placeholder": this.options.placeholder,
        class: "sd-editor-placeholder"
      });
      return DecorationSet.create(state2.doc, [decoration]);
    };
    const placeholderPlugin = new Plugin({
      key: new PluginKey("placeholder"),
      state: {
        init: (_2, state2) => {
          return applyDecoration(state2);
        },
        apply: (tr, oldValue, oldState, newState) => {
          return applyDecoration(newState);
        }
      },
      props: {
        decorations(state2) {
          return this.getState(state2);
        }
      }
    });
    return [placeholderPlugin];
  }
});
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];
function getNodeName$1(element) {
  return element ? (element.nodeName || "").toLowerCase() : null;
}
function getWindow$1(node2) {
  if (node2 == null) {
    return window;
  }
  if (node2.toString() !== "[object Window]") {
    var ownerDocument = node2.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node2;
}
function isElement$2(node2) {
  var OwnElement = getWindow$1(node2).Element;
  return node2 instanceof OwnElement || node2 instanceof Element;
}
function isHTMLElement$1(node2) {
  var OwnElement = getWindow$1(node2).HTMLElement;
  return node2 instanceof OwnElement || node2 instanceof HTMLElement;
}
function isShadowRoot$1(node2) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow$1(node2).ShadowRoot;
  return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
}
function applyStyles(_ref) {
  var state2 = _ref.state;
  Object.keys(state2.elements).forEach(function(name) {
    var style2 = state2.styles[name] || {};
    var attributes = state2.attributes[name] || {};
    var element = state2.elements[name];
    if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
      return;
    }
    Object.assign(element.style, style2);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element.removeAttribute(name2);
      } else {
        element.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect$2(_ref2) {
  var state2 = _ref2.state;
  var initialStyles = {
    popper: {
      position: state2.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state2.elements.popper.style, initialStyles.popper);
  state2.styles = initialStyles;
  if (state2.elements.arrow) {
    Object.assign(state2.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state2.elements).forEach(function(name) {
      var element = state2.elements[name];
      var attributes = state2.attributes[name] || {};
      var styleProperties = Object.keys(state2.styles.hasOwnProperty(name) ? state2.styles[name] : initialStyles[name]);
      var style2 = styleProperties.reduce(function(style22, property2) {
        style22[property2] = "";
        return style22;
      }, {});
      if (!isHTMLElement$1(element) || !getNodeName$1(element)) {
        return;
      }
      Object.assign(element.style, style2);
      Object.keys(attributes).forEach(function(attribute) {
        element.removeAttribute(attribute);
      });
    });
  };
}
const applyStyles$1 = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect: effect$2,
  requires: ["computeStyles"]
};
function getBasePlacement$1(placement) {
  return placement.split("-")[0];
}
var max$1 = Math.max;
var min$1 = Math.min;
var round$1 = Math.round;
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}
function getBoundingClientRect$1(element, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect2 = element.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement$1(element)) {
    scaleX = element.offsetWidth > 0 ? round$1(clientRect2.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round$1(clientRect2.height) / element.offsetHeight || 1 : 1;
  }
  var _ref = isElement$2(element) ? getWindow$1(element) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect2.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y2 = (clientRect2.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect2.width / scaleX;
  var height = clientRect2.height / scaleY;
  return {
    width,
    height,
    top: y2,
    right: x + width,
    bottom: y2 + height,
    left: x,
    x,
    y: y2
  };
}
function getLayoutRect(element) {
  var clientRect2 = getBoundingClientRect$1(element);
  var width = element.offsetWidth;
  var height = element.offsetHeight;
  if (Math.abs(clientRect2.width - width) <= 1) {
    width = clientRect2.width;
  }
  if (Math.abs(clientRect2.height - height) <= 1) {
    height = clientRect2.height;
  }
  return {
    x: element.offsetLeft,
    y: element.offsetTop,
    width,
    height
  };
}
function contains$1(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot$1(rootNode)) {
    var next = child;
    do {
      if (next && parent.isSameNode(next)) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getComputedStyle$2(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function isTableElement$1(element) {
  return ["table", "td", "th"].indexOf(getNodeName$1(element)) >= 0;
}
function getDocumentElement$1(element) {
  return ((isElement$2(element) ? element.ownerDocument : (
    // $FlowFixMe[prop-missing]
    element.document
  )) || window.document).documentElement;
}
function getParentNode$1(element) {
  if (getNodeName$1(element) === "html") {
    return element;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // $FlowFixMe[incompatible-return]
    // $FlowFixMe[prop-missing]
    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    element.parentNode || // DOM Element detected
    (isShadowRoot$1(element) ? element.host : null) || // ShadowRoot detected
    // $FlowFixMe[incompatible-call]: HTMLElement is a Node
    getDocumentElement$1(element)
  );
}
function getTrueOffsetParent$1(element) {
  if (!isHTMLElement$1(element) || // https://github.com/popperjs/popper-core/issues/837
  getComputedStyle$2(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock$1(element) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement$1(element)) {
    var elementCss = getComputedStyle$2(element);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode$1(element);
  if (isShadowRoot$1(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement$1(currentNode) && ["html", "body"].indexOf(getNodeName$1(currentNode)) < 0) {
    var css = getComputedStyle$2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent$1(element) {
  var window2 = getWindow$1(element);
  var offsetParent = getTrueOffsetParent$1(element);
  while (offsetParent && isTableElement$1(offsetParent) && getComputedStyle$2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent$1(offsetParent);
  }
  if (offsetParent && (getNodeName$1(offsetParent) === "html" || getNodeName$1(offsetParent) === "body" && getComputedStyle$2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock$1(element) || window2;
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}
function within(min2, value, max2) {
  return max$1(min2, min$1(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v2 = within(min2, value, max2);
  return v2 > max2 ? max2 : v2;
}
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}
function expandToHashMap(value, keys2) {
  return keys2.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}
var toPaddingObject = function toPaddingObject2(padding, state2) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state2 = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state2.elements.arrow;
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement$1(state2.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state2);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state2.rects.reference[len] + state2.rects.reference[axis] - popperOffsets2[axis] - state2.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state2.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent$1(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state2.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect$1(_ref2) {
  var state2 = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state2.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (!contains$1(state2.elements.popper, arrowElement)) {
    return;
  }
  state2.elements.arrow = arrowElement;
}
const arrow$1 = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect$1,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};
function getVariation(placement) {
  return placement.split("-")[1];
}
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref, win) {
  var x = _ref.x, y2 = _ref.y;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round$1(x * dpr) / dpr || 0,
    y: round$1(y2 * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y2 = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y: y2
  }) : {
    x,
    y: y2
  };
  x = _ref3.x;
  y2 = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent$1(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow$1(popper2)) {
      offsetParent = getDocumentElement$1(popper2);
      if (getComputedStyle$2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
        // $FlowFixMe[prop-missing]
        offsetParent[heightProp]
      );
      y2 -= offsetY - popperRect.height;
      y2 *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
        // $FlowFixMe[prop-missing]
        offsetParent[widthProp]
      );
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y: y2
  }, getWindow$1(popper2)) : {
    x,
    y: y2
  };
  x = _ref4.x;
  y2 = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y2 + "px)" : "translate3d(" + x + "px, " + y2 + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y2 + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state2 = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  var commonStyles = {
    placement: getBasePlacement$1(state2.placement),
    variation: getVariation(state2.placement),
    popper: state2.elements.popper,
    popperRect: state2.rects.popper,
    gpuAcceleration,
    isFixed: state2.options.strategy === "fixed"
  };
  if (state2.modifiersData.popperOffsets != null) {
    state2.styles.popper = Object.assign({}, state2.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.popperOffsets,
      position: state2.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state2.modifiersData.arrow != null) {
    state2.styles.arrow = Object.assign({}, state2.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state2.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-placement": state2.placement
  });
}
const computeStyles$1 = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};
var passive = {
  passive: true
};
function effect(_ref) {
  var state2 = _ref.state, instance = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow$1(state2.elements.popper);
  var scrollParents = [].concat(state2.scrollParents.reference, state2.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance.update, passive);
    }
  };
}
const eventListeners = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect,
  data: {}
};
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash$1[matched];
  });
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash[matched];
  });
}
function getWindowScroll(node2) {
  var win = getWindow$1(node2);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}
function getWindowScrollBarX$1(element) {
  return getBoundingClientRect$1(getDocumentElement$1(element)).left + getWindowScroll(element).scrollLeft;
}
function getViewportRect$1(element, strategy) {
  var win = getWindow$1(element);
  var html = getDocumentElement$1(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX$1(element),
    y: y2
  };
}
function getDocumentRect$1(element) {
  var _element$ownerDocumen;
  var html = getDocumentElement$1(element);
  var winScroll = getWindowScroll(element);
  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max$1(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max$1(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX$1(element);
  var y2 = -winScroll.scrollTop;
  if (getComputedStyle$2(body || html).direction === "rtl") {
    x += max$1(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
function isScrollParent(element) {
  var _getComputedStyle = getComputedStyle$2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function getScrollParent$1(node2) {
  if (["html", "body", "#document"].indexOf(getNodeName$1(node2)) >= 0) {
    return node2.ownerDocument.body;
  }
  if (isHTMLElement$1(node2) && isScrollParent(node2)) {
    return node2;
  }
  return getScrollParent$1(getParentNode$1(node2));
}
function listScrollParents(element, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent$1(element);
  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow$1(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : (
    // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
    updatedList.concat(listScrollParents(getParentNode$1(target)))
  );
}
function rectToClientRect$1(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}
function getInnerBoundingClientRect$1(element, strategy) {
  var rect = getBoundingClientRect$1(element, false, strategy === "fixed");
  rect.top = rect.top + element.clientTop;
  rect.left = rect.left + element.clientLeft;
  rect.bottom = rect.top + element.clientHeight;
  rect.right = rect.left + element.clientWidth;
  rect.width = element.clientWidth;
  rect.height = element.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect$1(getViewportRect$1(element, strategy)) : isElement$2(clippingParent) ? getInnerBoundingClientRect$1(clippingParent, strategy) : rectToClientRect$1(getDocumentRect$1(getDocumentElement$1(element)));
}
function getClippingParents(element) {
  var clippingParents2 = listScrollParents(getParentNode$1(element));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle$2(element).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement$1(element) ? getOffsetParent$1(element) : element;
  if (!isElement$2(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement$2(clippingParent) && contains$1(clippingParent, clipperElement) && getNodeName$1(clippingParent) !== "body";
  });
}
function getClippingRect$1(element, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element, clippingParent, strategy);
    accRect.top = max$1(rect.top, accRect.top);
    accRect.right = min$1(rect.right, accRect.right);
    accRect.bottom = min$1(rect.bottom, accRect.bottom);
    accRect.left = max$1(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement$1(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
        break;
    }
  }
  return offsets;
}
function detectOverflow$1(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state2.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state2.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state2.rects.popper;
  var element = state2.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect$1(isElement$2(element) ? element : element.contextElement || getDocumentElement$1(state2.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect$1(state2.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    placement
  });
  var popperClientRect = rectToClientRect$1(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state2.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}
function computeAutoPlacement(state2, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements$1.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements$1;
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow$1(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement$1(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b2) {
    return overflows[a] - overflows[b2];
  });
}
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement$1(placement) === auto) {
    return [];
  }
  var oppositePlacement2 = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement2, getOppositeVariationPlacement(oppositePlacement2)];
}
function flip(_ref) {
  var state2 = _ref.state, options = _ref.options, name = _ref.name;
  if (state2.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state2.options.placement;
  var basePlacement = getBasePlacement$1(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement$1(placement2) === auto ? computeAutoPlacement(state2, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement$1(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow$1(state2, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break") break;
    }
  }
  if (state2.placement !== firstFittingPlacement) {
    state2.modifiersData[name]._skip = true;
    state2.placement = firstFittingPlacement;
    state2.reset = true;
  }
}
const flip$1 = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};
function getSideOffsets$1(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped$1(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide$2(_ref) {
  var state2 = _ref.state, name = _ref.name;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var preventedOffsets = state2.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow$1(state2, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow$1(state2, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets$1(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets$1(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped$1(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped$1(popperEscapeOffsets);
  state2.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state2.attributes.popper = Object.assign({}, state2.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
const hide$3 = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide$2
};
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement$1(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state2 = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state2.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state2.placement], x = _data$state$placement.x, y2 = _data$state$placement.y;
  if (state2.modifiersData.popperOffsets != null) {
    state2.modifiersData.popperOffsets.x += x;
    state2.modifiersData.popperOffsets.y += y2;
  }
  state2.modifiersData[name] = data;
}
const offset$1 = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};
function popperOffsets(_ref) {
  var state2 = _ref.state, name = _ref.name;
  state2.modifiersData[name] = computeOffsets({
    reference: state2.rects.reference,
    element: state2.rects.popper,
    placement: state2.placement
  });
}
const popperOffsets$1 = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function preventOverflow(_ref) {
  var state2 = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow$1(state2, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement$1(state2.placement);
  var variation = getVariation(state2.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state2.modifiersData.popperOffsets;
  var referenceRect = state2.rects.reference;
  var popperRect = state2.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state2.rects, {
    placement: state2.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state2.modifiersData.offset ? state2.modifiersData.offset[state2.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state2.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state2.modifiersData["arrow#persistent"] ? state2.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state2.elements.arrow && getOffsetParent$1(state2.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min$1(min2, tetherMin) : min2, offset2, tether ? max$1(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state2.modifiersData[name] = data;
}
const preventOverflow$1 = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};
function getHTMLElementScroll(element) {
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getNodeScroll$1(node2) {
  if (node2 === getWindow$1(node2) || !isHTMLElement$1(node2)) {
    return getWindowScroll(node2);
  } else {
    return getHTMLElementScroll(node2);
  }
}
function isElementScaled(element) {
  var rect = element.getBoundingClientRect();
  var scaleX = round$1(rect.width) / element.offsetWidth || 1;
  var scaleY = round$1(rect.height) / element.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  var offsetParentIsScaled = isHTMLElement$1(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement$1(offsetParent);
  var rect = getBoundingClientRect$1(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName$1(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
    isScrollParent(documentElement)) {
      scroll = getNodeScroll$1(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      offsets = getBoundingClientRect$1(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX$1(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function order(modifiers2) {
  var map22 = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers2.forEach(function(modifier) {
    map22.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map22.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers2.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers2) {
  var orderedModifiers = order(modifiers2);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}
function debounce$1(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}
function mergeByName(modifiers2) {
  var merged = modifiers2.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element) {
    return !(element && typeof element.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state2 = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance = {
      state: state2,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state2.options) : setOptionsAction;
        cleanupModifierEffects();
        state2.options = Object.assign({}, defaultOptions, state2.options, options2);
        state2.scrollParents = {
          reference: isElement$2(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state2.options.modifiers)));
        state2.orderedModifiers = orderedModifiers.filter(function(m2) {
          return m2.enabled;
        });
        runModifierEffects();
        return instance.update();
      },
      // Sync update – it will always be executed, even if not necessary. This
      // is useful for low frequency updates where sync behavior simplifies the
      // logic.
      // For high frequency updates (e.g. `resize` and `scroll` events), always
      // prefer the async Popper#update method
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state2.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          return;
        }
        state2.rects = {
          reference: getCompositeRect(reference3, getOffsetParent$1(popper3), state2.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state2.reset = false;
        state2.placement = state2.options.placement;
        state2.orderedModifiers.forEach(function(modifier) {
          return state2.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        for (var index2 = 0; index2 < state2.orderedModifiers.length; index2++) {
          if (state2.reset === true) {
            state2.reset = false;
            index2 = -1;
            continue;
          }
          var _state$orderedModifie = state2.orderedModifiers[index2], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state2 = fn2({
              state: state2,
              options: _options,
              name,
              instance
            }) || state2;
          }
        }
      },
      // Async and optimistically optimized update – it will not be executed if
      // not necessary (debounced to run at most once-per-tick)
      update: debounce$1(function() {
        return new Promise(function(resolve) {
          instance.forceUpdate();
          resolve(state2);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      return instance;
    }
    instance.setOptions(options).then(function(state22) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state22);
      }
    });
    function runModifierEffects() {
      state2.orderedModifiers.forEach(function(_ref) {
        var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect3 = _ref.effect;
        if (typeof effect3 === "function") {
          var cleanupFn = effect3({
            state: state2,
            name,
            instance,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance;
  };
}
var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$3];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});
var BOX_CLASS = "tippy-box";
var CONTENT_CLASS = "tippy-content";
var BACKDROP_CLASS = "tippy-backdrop";
var ARROW_CLASS = "tippy-arrow";
var SVG_ARROW_CLASS = "tippy-svg-arrow";
var TOUCH_OPTIONS = {
  passive: true,
  capture: true
};
var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO2() {
  return document.body;
};
function hasOwnProperty$c(obj, key) {
  return {}.hasOwnProperty.call(obj, key);
}
function getValueAtIndexOrReturn(value, index2, defaultValue) {
  if (Array.isArray(value)) {
    var v2 = value[index2];
    return v2 == null ? Array.isArray(defaultValue) ? defaultValue[index2] : defaultValue : v2;
  }
  return value;
}
function isType(value, type2) {
  var str = {}.toString.call(value);
  return str.indexOf("[object") === 0 && str.indexOf(type2 + "]") > -1;
}
function invokeWithArgsOrReturn(value, args) {
  return typeof value === "function" ? value.apply(void 0, args) : value;
}
function debounce(fn2, ms) {
  if (ms === 0) {
    return fn2;
  }
  var timeout2;
  return function(arg) {
    clearTimeout(timeout2);
    timeout2 = setTimeout(function() {
      fn2(arg);
    }, ms);
  };
}
function removeProperties(obj, keys2) {
  var clone = Object.assign({}, obj);
  keys2.forEach(function(key) {
    delete clone[key];
  });
  return clone;
}
function splitBySpaces(value) {
  return value.split(/\s+/).filter(Boolean);
}
function normalizeToArray(value) {
  return [].concat(value);
}
function pushIfUnique(arr, value) {
  if (arr.indexOf(value) === -1) {
    arr.push(value);
  }
}
function unique(arr) {
  return arr.filter(function(item, index2) {
    return arr.indexOf(item) === index2;
  });
}
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function arrayFrom(value) {
  return [].slice.call(value);
}
function removeUndefinedProps(obj) {
  return Object.keys(obj).reduce(function(acc, key) {
    if (obj[key] !== void 0) {
      acc[key] = obj[key];
    }
    return acc;
  }, {});
}
function div() {
  return document.createElement("div");
}
function isElement$1(value) {
  return ["Element", "Fragment"].some(function(type2) {
    return isType(value, type2);
  });
}
function isNodeList(value) {
  return isType(value, "NodeList");
}
function isMouseEvent(value) {
  return isType(value, "MouseEvent");
}
function isReferenceElement(value) {
  return !!(value && value._tippy && value._tippy.reference === value);
}
function getArrayOfElements(value) {
  if (isElement$1(value)) {
    return [value];
  }
  if (isNodeList(value)) {
    return arrayFrom(value);
  }
  if (Array.isArray(value)) {
    return value;
  }
  return arrayFrom(document.querySelectorAll(value));
}
function setTransitionDuration(els, value) {
  els.forEach(function(el) {
    if (el) {
      el.style.transitionDuration = value + "ms";
    }
  });
}
function setVisibilityState(els, state2) {
  els.forEach(function(el) {
    if (el) {
      el.setAttribute("data-state", state2);
    }
  });
}
function getOwnerDocument(elementOrElements) {
  var _element$ownerDocumen;
  var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
}
function isCursorOutsideInteractiveBorder(popperTreeData, event) {
  var clientX = event.clientX, clientY = event.clientY;
  return popperTreeData.every(function(_ref) {
    var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
    var interactiveBorder = props.interactiveBorder;
    var basePlacement = getBasePlacement(popperState.placement);
    var offsetData = popperState.modifiersData.offset;
    if (!offsetData) {
      return true;
    }
    var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
    var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
    var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
    var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
  });
}
function updateTransitionEndListener(box, action, listener) {
  var method = action + "EventListener";
  ["transitionend", "webkitTransitionEnd"].forEach(function(event) {
    box[method](event, listener);
  });
}
function actualContains(parent, child) {
  var target = child;
  while (target) {
    var _target$getRootNode;
    if (parent.contains(target)) {
      return true;
    }
    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
  }
  return false;
}
var currentInput = {
  isTouch: false
};
var lastMouseMoveTime = 0;
function onDocumentTouchStart() {
  if (currentInput.isTouch) {
    return;
  }
  currentInput.isTouch = true;
  if (window.performance) {
    document.addEventListener("mousemove", onDocumentMouseMove);
  }
}
function onDocumentMouseMove() {
  var now = performance.now();
  if (now - lastMouseMoveTime < 20) {
    currentInput.isTouch = false;
    document.removeEventListener("mousemove", onDocumentMouseMove);
  }
  lastMouseMoveTime = now;
}
function onWindowBlur() {
  var activeElement = document.activeElement;
  if (isReferenceElement(activeElement)) {
    var instance = activeElement._tippy;
    if (activeElement.blur && !instance.state.isVisible) {
      activeElement.blur();
    }
  }
}
function bindGlobalEventListeners() {
  document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
  window.addEventListener("blur", onWindowBlur);
}
var isBrowser$3 = typeof window !== "undefined" && typeof document !== "undefined";
var isIE11 = isBrowser$3 ? (
  // @ts-ignore
  !!window.msCrypto
) : false;
function createMemoryLeakWarning(method) {
  var txt = method === "destroy" ? "n already-" : " ";
  return [method + "() was called on a" + txt + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ");
}
function clean(value) {
  var spacesAndTabs = /[ \t]{2,}/g;
  var lineStartWithSpaces = /^[ \t]*/gm;
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
}
function getDevMessage(message) {
  return clean("\n  %ctippy.js\n\n  %c" + clean(message) + "\n\n  %c👷‍ This is a development-only message. It will be removed in production.\n  ");
}
function getFormattedMessage(message) {
  return [
    getDevMessage(message),
    // title
    "color: #00C584; font-size: 1.3em; font-weight: bold;",
    // message
    "line-height: 1.5",
    // footer
    "color: #a6a095;"
  ];
}
var visitedMessages;
if (process$1$1.env.NODE_ENV !== "production") {
  resetVisitedMessages();
}
function resetVisitedMessages() {
  visitedMessages = /* @__PURE__ */ new Set();
}
function warnWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console;
    visitedMessages.add(message);
    (_console = console).warn.apply(_console, getFormattedMessage(message));
  }
}
function errorWhen(condition, message) {
  if (condition && !visitedMessages.has(message)) {
    var _console2;
    visitedMessages.add(message);
    (_console2 = console).error.apply(_console2, getFormattedMessage(message));
  }
}
function validateTargets(targets) {
  var didPassFalsyValue = !targets;
  var didPassPlainObject = Object.prototype.toString.call(targets) === "[object Object]" && !targets.addEventListener;
  errorWhen(didPassFalsyValue, ["tippy() was passed", "`" + String(targets) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" "));
  errorWhen(didPassPlainObject, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" "));
}
var pluginProps = {
  animateFill: false,
  followCursor: false,
  inlinePositioning: false,
  sticky: false
};
var renderProps = {
  allowHTML: false,
  animation: "fade",
  arrow: true,
  content: "",
  inertia: false,
  maxWidth: 350,
  role: "tooltip",
  theme: "",
  zIndex: 9999
};
var defaultProps = Object.assign({
  appendTo: TIPPY_DEFAULT_APPEND_TO,
  aria: {
    content: "auto",
    expanded: "auto"
  },
  delay: 0,
  duration: [300, 250],
  getReferenceClientRect: null,
  hideOnClick: true,
  ignoreAttributes: false,
  interactive: false,
  interactiveBorder: 2,
  interactiveDebounce: 0,
  moveTransition: "",
  offset: [0, 10],
  onAfterUpdate: function onAfterUpdate() {
  },
  onBeforeUpdate: function onBeforeUpdate() {
  },
  onCreate: function onCreate() {
  },
  onDestroy: function onDestroy() {
  },
  onHidden: function onHidden() {
  },
  onHide: function onHide() {
  },
  onMount: function onMount() {
  },
  onShow: function onShow() {
  },
  onShown: function onShown() {
  },
  onTrigger: function onTrigger() {
  },
  onUntrigger: function onUntrigger() {
  },
  onClickOutside: function onClickOutside() {
  },
  placement: "top",
  plugins: [],
  popperOptions: {},
  render: null,
  showOnCreate: false,
  touch: true,
  trigger: "mouseenter focus",
  triggerTarget: null
}, pluginProps, renderProps);
var defaultKeys = Object.keys(defaultProps);
var setDefaultProps = function setDefaultProps2(partialProps) {
  if (process$1$1.env.NODE_ENV !== "production") {
    validateProps(partialProps, []);
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(key) {
    defaultProps[key] = partialProps[key];
  });
};
function getExtendedPassedProps(passedProps) {
  var plugins = passedProps.plugins || [];
  var pluginProps2 = plugins.reduce(function(acc, plugin2) {
    var name = plugin2.name, defaultValue = plugin2.defaultValue;
    if (name) {
      var _name;
      acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
    }
    return acc;
  }, {});
  return Object.assign({}, passedProps, pluginProps2);
}
function getDataAttributeProps(reference2, plugins) {
  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
    plugins
  }))) : defaultKeys;
  var props = propKeys.reduce(function(acc, key) {
    var valueAsString = (reference2.getAttribute("data-tippy-" + key) || "").trim();
    if (!valueAsString) {
      return acc;
    }
    if (key === "content") {
      acc[key] = valueAsString;
    } else {
      try {
        acc[key] = JSON.parse(valueAsString);
      } catch (e) {
        acc[key] = valueAsString;
      }
    }
    return acc;
  }, {});
  return props;
}
function evaluateProps(reference2, props) {
  var out = Object.assign({}, props, {
    content: invokeWithArgsOrReturn(props.content, [reference2])
  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference2, props.plugins));
  out.aria = Object.assign({}, defaultProps.aria, out.aria);
  out.aria = {
    expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
    content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
  };
  return out;
}
function validateProps(partialProps, plugins) {
  if (partialProps === void 0) {
    partialProps = {};
  }
  if (plugins === void 0) {
    plugins = [];
  }
  var keys2 = Object.keys(partialProps);
  keys2.forEach(function(prop) {
    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));
    var didPassUnknownProp = !hasOwnProperty$c(nonPluginProps, prop);
    if (didPassUnknownProp) {
      didPassUnknownProp = plugins.filter(function(plugin2) {
        return plugin2.name === prop;
      }).length === 0;
    }
    warnWhen(didPassUnknownProp, ["`" + prop + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" "));
  });
}
var innerHTML = function innerHTML2() {
  return "innerHTML";
};
function dangerouslySetInnerHTML(element, html) {
  element[innerHTML()] = html;
}
function createArrowElement(value) {
  var arrow2 = div();
  if (value === true) {
    arrow2.className = ARROW_CLASS;
  } else {
    arrow2.className = SVG_ARROW_CLASS;
    if (isElement$1(value)) {
      arrow2.appendChild(value);
    } else {
      dangerouslySetInnerHTML(arrow2, value);
    }
  }
  return arrow2;
}
function setContent(content, props) {
  if (isElement$1(props.content)) {
    dangerouslySetInnerHTML(content, "");
    content.appendChild(props.content);
  } else if (typeof props.content !== "function") {
    if (props.allowHTML) {
      dangerouslySetInnerHTML(content, props.content);
    } else {
      content.textContent = props.content;
    }
  }
}
function getChildren(popper2) {
  var box = popper2.firstElementChild;
  var boxChildren = arrayFrom(box.children);
  return {
    box,
    content: boxChildren.find(function(node2) {
      return node2.classList.contains(CONTENT_CLASS);
    }),
    arrow: boxChildren.find(function(node2) {
      return node2.classList.contains(ARROW_CLASS) || node2.classList.contains(SVG_ARROW_CLASS);
    }),
    backdrop: boxChildren.find(function(node2) {
      return node2.classList.contains(BACKDROP_CLASS);
    })
  };
}
function render$2(instance) {
  var popper2 = div();
  var box = div();
  box.className = BOX_CLASS;
  box.setAttribute("data-state", "hidden");
  box.setAttribute("tabindex", "-1");
  var content = div();
  content.className = CONTENT_CLASS;
  content.setAttribute("data-state", "hidden");
  setContent(content, instance.props);
  popper2.appendChild(box);
  box.appendChild(content);
  onUpdate(instance.props, instance.props);
  function onUpdate(prevProps, nextProps) {
    var _getChildren = getChildren(popper2), box2 = _getChildren.box, content2 = _getChildren.content, arrow2 = _getChildren.arrow;
    if (nextProps.theme) {
      box2.setAttribute("data-theme", nextProps.theme);
    } else {
      box2.removeAttribute("data-theme");
    }
    if (typeof nextProps.animation === "string") {
      box2.setAttribute("data-animation", nextProps.animation);
    } else {
      box2.removeAttribute("data-animation");
    }
    if (nextProps.inertia) {
      box2.setAttribute("data-inertia", "");
    } else {
      box2.removeAttribute("data-inertia");
    }
    box2.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
    if (nextProps.role) {
      box2.setAttribute("role", nextProps.role);
    } else {
      box2.removeAttribute("role");
    }
    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {
      setContent(content2, instance.props);
    }
    if (nextProps.arrow) {
      if (!arrow2) {
        box2.appendChild(createArrowElement(nextProps.arrow));
      } else if (prevProps.arrow !== nextProps.arrow) {
        box2.removeChild(arrow2);
        box2.appendChild(createArrowElement(nextProps.arrow));
      }
    } else if (arrow2) {
      box2.removeChild(arrow2);
    }
  }
  return {
    popper: popper2,
    onUpdate
  };
}
render$2.$$tippy = true;
var idCounter = 1;
var mouseMoveListeners = [];
var mountedInstances = [];
function createTippy(reference2, passedProps) {
  var props = evaluateProps(reference2, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
  var showTimeout;
  var hideTimeout;
  var scheduleHideAnimationFrame;
  var isVisibleFromClick = false;
  var didHideDueToDocumentMouseDown = false;
  var didTouchMove = false;
  var ignoreOnFirstUpdate = false;
  var lastTriggerEvent;
  var currentTransitionEndListener;
  var onFirstUpdate;
  var listeners = [];
  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);
  var currentTarget;
  var id = idCounter++;
  var popperInstance = null;
  var plugins = unique(props.plugins);
  var state2 = {
    // Is the instance currently enabled?
    isEnabled: true,
    // Is the tippy currently showing and not transitioning out?
    isVisible: false,
    // Has the instance been destroyed?
    isDestroyed: false,
    // Is the tippy currently mounted to the DOM?
    isMounted: false,
    // Has the tippy finished transitioning in?
    isShown: false
  };
  var instance = {
    // properties
    id,
    reference: reference2,
    popper: div(),
    popperInstance,
    props,
    state: state2,
    plugins,
    // methods
    clearDelayTimeouts,
    setProps,
    setContent: setContent2,
    show,
    hide: hide2,
    hideWithInteractivity,
    enable,
    disable,
    unmount: unmount2,
    destroy
  };
  if (!props.render) {
    if (process$1$1.env.NODE_ENV !== "production") {
      errorWhen(true, "render() function has not been supplied.");
    }
    return instance;
  }
  var _props$render = props.render(instance), popper2 = _props$render.popper, onUpdate = _props$render.onUpdate;
  popper2.setAttribute("data-tippy-root", "");
  popper2.id = "tippy-" + instance.id;
  instance.popper = popper2;
  reference2._tippy = instance;
  popper2._tippy = instance;
  var pluginsHooks = plugins.map(function(plugin2) {
    return plugin2.fn(instance);
  });
  var hasAriaExpanded = reference2.hasAttribute("aria-expanded");
  addListeners();
  handleAriaExpandedAttribute();
  handleStyles();
  invokeHook("onCreate", [instance]);
  if (props.showOnCreate) {
    scheduleShow();
  }
  popper2.addEventListener("mouseenter", function() {
    if (instance.props.interactive && instance.state.isVisible) {
      instance.clearDelayTimeouts();
    }
  });
  popper2.addEventListener("mouseleave", function() {
    if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) {
      getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    }
  });
  return instance;
  function getNormalizedTouchSettings() {
    var touch = instance.props.touch;
    return Array.isArray(touch) ? touch : [touch, 0];
  }
  function getIsCustomTouchBehavior() {
    return getNormalizedTouchSettings()[0] === "hold";
  }
  function getIsDefaultRenderFn() {
    var _instance$props$rende;
    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
  }
  function getCurrentTarget() {
    return currentTarget || reference2;
  }
  function getDocument() {
    var parent = getCurrentTarget().parentNode;
    return parent ? getOwnerDocument(parent) : document;
  }
  function getDefaultTemplateChildren() {
    return getChildren(popper2);
  }
  function getDelay(isShow) {
    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") {
      return 0;
    }
    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
  }
  function handleStyles(fromHide) {
    if (fromHide === void 0) {
      fromHide = false;
    }
    popper2.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
    popper2.style.zIndex = "" + instance.props.zIndex;
  }
  function invokeHook(hook, args, shouldInvokePropsHook) {
    if (shouldInvokePropsHook === void 0) {
      shouldInvokePropsHook = true;
    }
    pluginsHooks.forEach(function(pluginHooks) {
      if (pluginHooks[hook]) {
        pluginHooks[hook].apply(pluginHooks, args);
      }
    });
    if (shouldInvokePropsHook) {
      var _instance$props;
      (_instance$props = instance.props)[hook].apply(_instance$props, args);
    }
  }
  function handleAriaContentAttribute() {
    var aria = instance.props.aria;
    if (!aria.content) {
      return;
    }
    var attr = "aria-" + aria.content;
    var id2 = popper2.id;
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node2) {
      var currentValue = node2.getAttribute(attr);
      if (instance.state.isVisible) {
        node2.setAttribute(attr, currentValue ? currentValue + " " + id2 : id2);
      } else {
        var nextValue = currentValue && currentValue.replace(id2, "").trim();
        if (nextValue) {
          node2.setAttribute(attr, nextValue);
        } else {
          node2.removeAttribute(attr);
        }
      }
    });
  }
  function handleAriaExpandedAttribute() {
    if (hasAriaExpanded || !instance.props.aria.expanded) {
      return;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node2) {
      if (instance.props.interactive) {
        node2.setAttribute("aria-expanded", instance.state.isVisible && node2 === getCurrentTarget() ? "true" : "false");
      } else {
        node2.removeAttribute("aria-expanded");
      }
    });
  }
  function cleanupInteractiveMouseListeners() {
    getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
    mouseMoveListeners = mouseMoveListeners.filter(function(listener) {
      return listener !== debouncedOnMouseMove;
    });
  }
  function onDocumentPress(event) {
    if (currentInput.isTouch) {
      if (didTouchMove || event.type === "mousedown") {
        return;
      }
    }
    var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
    if (instance.props.interactive && actualContains(popper2, actualTarget)) {
      return;
    }
    if (normalizeToArray(instance.props.triggerTarget || reference2).some(function(el) {
      return actualContains(el, actualTarget);
    })) {
      if (currentInput.isTouch) {
        return;
      }
      if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) {
        return;
      }
    } else {
      invokeHook("onClickOutside", [instance, event]);
    }
    if (instance.props.hideOnClick === true) {
      instance.clearDelayTimeouts();
      instance.hide();
      didHideDueToDocumentMouseDown = true;
      setTimeout(function() {
        didHideDueToDocumentMouseDown = false;
      });
      if (!instance.state.isMounted) {
        removeDocumentPress();
      }
    }
  }
  function onTouchMove() {
    didTouchMove = true;
  }
  function onTouchStart() {
    didTouchMove = false;
  }
  function addDocumentPress() {
    var doc2 = getDocument();
    doc2.addEventListener("mousedown", onDocumentPress, true);
    doc2.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function removeDocumentPress() {
    var doc2 = getDocument();
    doc2.removeEventListener("mousedown", onDocumentPress, true);
    doc2.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
    doc2.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
    doc2.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
  }
  function onTransitionedOut(duration, callback) {
    onTransitionEnd(duration, function() {
      if (!instance.state.isVisible && popper2.parentNode && popper2.parentNode.contains(popper2)) {
        callback();
      }
    });
  }
  function onTransitionedIn(duration, callback) {
    onTransitionEnd(duration, callback);
  }
  function onTransitionEnd(duration, callback) {
    var box = getDefaultTemplateChildren().box;
    function listener(event) {
      if (event.target === box) {
        updateTransitionEndListener(box, "remove", listener);
        callback();
      }
    }
    if (duration === 0) {
      return callback();
    }
    updateTransitionEndListener(box, "remove", currentTransitionEndListener);
    updateTransitionEndListener(box, "add", listener);
    currentTransitionEndListener = listener;
  }
  function on2(eventType, handler, options) {
    if (options === void 0) {
      options = false;
    }
    var nodes = normalizeToArray(instance.props.triggerTarget || reference2);
    nodes.forEach(function(node2) {
      node2.addEventListener(eventType, handler, options);
      listeners.push({
        node: node2,
        eventType,
        handler,
        options
      });
    });
  }
  function addListeners() {
    if (getIsCustomTouchBehavior()) {
      on2("touchstart", onTrigger2, {
        passive: true
      });
      on2("touchend", onMouseLeave, {
        passive: true
      });
    }
    splitBySpaces(instance.props.trigger).forEach(function(eventType) {
      if (eventType === "manual") {
        return;
      }
      on2(eventType, onTrigger2);
      switch (eventType) {
        case "mouseenter":
          on2("mouseleave", onMouseLeave);
          break;
        case "focus":
          on2(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
          break;
        case "focusin":
          on2("focusout", onBlurOrFocusOut);
          break;
      }
    });
  }
  function removeListeners() {
    listeners.forEach(function(_ref) {
      var node2 = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
      node2.removeEventListener(eventType, handler, options);
    });
    listeners = [];
  }
  function onTrigger2(event) {
    var _lastTriggerEvent;
    var shouldScheduleClickHide = false;
    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {
      return;
    }
    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
    lastTriggerEvent = event;
    currentTarget = event.currentTarget;
    handleAriaExpandedAttribute();
    if (!instance.state.isVisible && isMouseEvent(event)) {
      mouseMoveListeners.forEach(function(listener) {
        return listener(event);
      });
    }
    if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {
      shouldScheduleClickHide = true;
    } else {
      scheduleShow(event);
    }
    if (event.type === "click") {
      isVisibleFromClick = !shouldScheduleClickHide;
    }
    if (shouldScheduleClickHide && !wasFocused) {
      scheduleHide(event);
    }
  }
  function onMouseMove(event) {
    var target = event.target;
    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper2.contains(target);
    if (event.type === "mousemove" && isCursorOverReferenceOrPopper) {
      return;
    }
    var popperTreeData = getNestedPopperTree().concat(popper2).map(function(popper3) {
      var _instance$popperInsta;
      var instance2 = popper3._tippy;
      var state22 = (_instance$popperInsta = instance2.popperInstance) == null ? void 0 : _instance$popperInsta.state;
      if (state22) {
        return {
          popperRect: popper3.getBoundingClientRect(),
          popperState: state22,
          props
        };
      }
      return null;
    }).filter(Boolean);
    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
      cleanupInteractiveMouseListeners();
      scheduleHide(event);
    }
  }
  function onMouseLeave(event) {
    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
    if (shouldBail) {
      return;
    }
    if (instance.props.interactive) {
      instance.hideWithInteractivity(event);
      return;
    }
    scheduleHide(event);
  }
  function onBlurOrFocusOut(event) {
    if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) {
      return;
    }
    if (instance.props.interactive && event.relatedTarget && popper2.contains(event.relatedTarget)) {
      return;
    }
    scheduleHide(event);
  }
  function isEventListenerStopped(event) {
    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
  }
  function createPopperInstance() {
    destroyPopperInstance();
    var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset2 = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
    var arrow2 = getIsDefaultRenderFn() ? getChildren(popper2).arrow : null;
    var computedReference = getReferenceClientRect ? {
      getBoundingClientRect: getReferenceClientRect,
      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
    } : reference2;
    var tippyModifier = {
      name: "$$tippy",
      enabled: true,
      phase: "beforeWrite",
      requires: ["computeStyles"],
      fn: function fn2(_ref2) {
        var state22 = _ref2.state;
        if (getIsDefaultRenderFn()) {
          var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
          ["placement", "reference-hidden", "escaped"].forEach(function(attr) {
            if (attr === "placement") {
              box.setAttribute("data-placement", state22.placement);
            } else {
              if (state22.attributes.popper["data-popper-" + attr]) {
                box.setAttribute("data-" + attr, "");
              } else {
                box.removeAttribute("data-" + attr);
              }
            }
          });
          state22.attributes.popper = {};
        }
      }
    };
    var modifiers2 = [{
      name: "offset",
      options: {
        offset: offset2
      }
    }, {
      name: "preventOverflow",
      options: {
        padding: {
          top: 2,
          bottom: 2,
          left: 5,
          right: 5
        }
      }
    }, {
      name: "flip",
      options: {
        padding: 5
      }
    }, {
      name: "computeStyles",
      options: {
        adaptive: !moveTransition
      }
    }, tippyModifier];
    if (getIsDefaultRenderFn() && arrow2) {
      modifiers2.push({
        name: "arrow",
        options: {
          element: arrow2,
          padding: 3
        }
      });
    }
    modifiers2.push.apply(modifiers2, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
    instance.popperInstance = createPopper(computedReference, popper2, Object.assign({}, popperOptions, {
      placement,
      onFirstUpdate,
      modifiers: modifiers2
    }));
  }
  function destroyPopperInstance() {
    if (instance.popperInstance) {
      instance.popperInstance.destroy();
      instance.popperInstance = null;
    }
  }
  function mount2() {
    var appendTo = instance.props.appendTo;
    var parentNode2;
    var node2 = getCurrentTarget();
    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") {
      parentNode2 = node2.parentNode;
    } else {
      parentNode2 = invokeWithArgsOrReturn(appendTo, [node2]);
    }
    if (!parentNode2.contains(popper2)) {
      parentNode2.appendChild(popper2);
    }
    instance.state.isMounted = true;
    createPopperInstance();
    if (process$1$1.env.NODE_ENV !== "production") {
      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node2.nextElementSibling !== popper2, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" "));
    }
  }
  function getNestedPopperTree() {
    return arrayFrom(popper2.querySelectorAll("[data-tippy-root]"));
  }
  function scheduleShow(event) {
    instance.clearDelayTimeouts();
    if (event) {
      invokeHook("onTrigger", [instance, event]);
    }
    addDocumentPress();
    var delay = getDelay(true);
    var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
    if (currentInput.isTouch && touchValue === "hold" && touchDelay) {
      delay = touchDelay;
    }
    if (delay) {
      showTimeout = setTimeout(function() {
        instance.show();
      }, delay);
    } else {
      instance.show();
    }
  }
  function scheduleHide(event) {
    instance.clearDelayTimeouts();
    invokeHook("onUntrigger", [instance, event]);
    if (!instance.state.isVisible) {
      removeDocumentPress();
      return;
    }
    if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(event.type) >= 0 && isVisibleFromClick) {
      return;
    }
    var delay = getDelay(false);
    if (delay) {
      hideTimeout = setTimeout(function() {
        if (instance.state.isVisible) {
          instance.hide();
        }
      }, delay);
    } else {
      scheduleHideAnimationFrame = requestAnimationFrame(function() {
        instance.hide();
      });
    }
  }
  function enable() {
    instance.state.isEnabled = true;
  }
  function disable() {
    instance.hide();
    instance.state.isEnabled = false;
  }
  function clearDelayTimeouts() {
    clearTimeout(showTimeout);
    clearTimeout(hideTimeout);
    cancelAnimationFrame(scheduleHideAnimationFrame);
  }
  function setProps(partialProps) {
    if (process$1$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("setProps"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    invokeHook("onBeforeUpdate", [instance, partialProps]);
    removeListeners();
    var prevProps = instance.props;
    var nextProps = evaluateProps(reference2, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
      ignoreAttributes: true
    }));
    instance.props = nextProps;
    addListeners();
    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
      cleanupInteractiveMouseListeners();
      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);
    }
    if (prevProps.triggerTarget && !nextProps.triggerTarget) {
      normalizeToArray(prevProps.triggerTarget).forEach(function(node2) {
        node2.removeAttribute("aria-expanded");
      });
    } else if (nextProps.triggerTarget) {
      reference2.removeAttribute("aria-expanded");
    }
    handleAriaExpandedAttribute();
    handleStyles();
    if (onUpdate) {
      onUpdate(prevProps, nextProps);
    }
    if (instance.popperInstance) {
      createPopperInstance();
      getNestedPopperTree().forEach(function(nestedPopper) {
        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
      });
    }
    invokeHook("onAfterUpdate", [instance, partialProps]);
  }
  function setContent2(content) {
    instance.setProps({
      content
    });
  }
  function show() {
    if (process$1$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("show"));
    }
    var isAlreadyVisible = instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled2 = !instance.state.isEnabled;
    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
    if (isAlreadyVisible || isDestroyed || isDisabled2 || isTouchAndTouchDisabled) {
      return;
    }
    if (getCurrentTarget().hasAttribute("disabled")) {
      return;
    }
    invokeHook("onShow", [instance], false);
    if (instance.props.onShow(instance) === false) {
      return;
    }
    instance.state.isVisible = true;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "visible";
    }
    handleStyles();
    addDocumentPress();
    if (!instance.state.isMounted) {
      popper2.style.transition = "none";
    }
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
      setTransitionDuration([box, content], 0);
    }
    onFirstUpdate = function onFirstUpdate2() {
      var _instance$popperInsta2;
      if (!instance.state.isVisible || ignoreOnFirstUpdate) {
        return;
      }
      ignoreOnFirstUpdate = true;
      void popper2.offsetHeight;
      popper2.style.transition = instance.props.moveTransition;
      if (getIsDefaultRenderFn() && instance.props.animation) {
        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
        setTransitionDuration([_box, _content], duration);
        setVisibilityState([_box, _content], "visible");
      }
      handleAriaContentAttribute();
      handleAriaExpandedAttribute();
      pushIfUnique(mountedInstances, instance);
      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
      invokeHook("onMount", [instance]);
      if (instance.props.animation && getIsDefaultRenderFn()) {
        onTransitionedIn(duration, function() {
          instance.state.isShown = true;
          invokeHook("onShown", [instance]);
        });
      }
    };
    mount2();
  }
  function hide2() {
    if (process$1$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hide"));
    }
    var isAlreadyHidden = !instance.state.isVisible;
    var isDestroyed = instance.state.isDestroyed;
    var isDisabled2 = !instance.state.isEnabled;
    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
    if (isAlreadyHidden || isDestroyed || isDisabled2) {
      return;
    }
    invokeHook("onHide", [instance], false);
    if (instance.props.onHide(instance) === false) {
      return;
    }
    instance.state.isVisible = false;
    instance.state.isShown = false;
    ignoreOnFirstUpdate = false;
    isVisibleFromClick = false;
    if (getIsDefaultRenderFn()) {
      popper2.style.visibility = "hidden";
    }
    cleanupInteractiveMouseListeners();
    removeDocumentPress();
    handleStyles(true);
    if (getIsDefaultRenderFn()) {
      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
      if (instance.props.animation) {
        setTransitionDuration([box, content], duration);
        setVisibilityState([box, content], "hidden");
      }
    }
    handleAriaContentAttribute();
    handleAriaExpandedAttribute();
    if (instance.props.animation) {
      if (getIsDefaultRenderFn()) {
        onTransitionedOut(duration, instance.unmount);
      }
    } else {
      instance.unmount();
    }
  }
  function hideWithInteractivity(event) {
    if (process$1$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("hideWithInteractivity"));
    }
    getDocument().addEventListener("mousemove", debouncedOnMouseMove);
    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
    debouncedOnMouseMove(event);
  }
  function unmount2() {
    if (process$1$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("unmount"));
    }
    if (instance.state.isVisible) {
      instance.hide();
    }
    if (!instance.state.isMounted) {
      return;
    }
    destroyPopperInstance();
    getNestedPopperTree().forEach(function(nestedPopper) {
      nestedPopper._tippy.unmount();
    });
    if (popper2.parentNode) {
      popper2.parentNode.removeChild(popper2);
    }
    mountedInstances = mountedInstances.filter(function(i) {
      return i !== instance;
    });
    instance.state.isMounted = false;
    invokeHook("onHidden", [instance]);
  }
  function destroy() {
    if (process$1$1.env.NODE_ENV !== "production") {
      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning("destroy"));
    }
    if (instance.state.isDestroyed) {
      return;
    }
    instance.clearDelayTimeouts();
    instance.unmount();
    removeListeners();
    delete reference2._tippy;
    instance.state.isDestroyed = true;
    invokeHook("onDestroy", [instance]);
  }
}
function tippy(targets, optionalProps) {
  if (optionalProps === void 0) {
    optionalProps = {};
  }
  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
  if (process$1$1.env.NODE_ENV !== "production") {
    validateTargets(targets);
    validateProps(optionalProps, plugins);
  }
  bindGlobalEventListeners();
  var passedProps = Object.assign({}, optionalProps, {
    plugins
  });
  var elements = getArrayOfElements(targets);
  if (process$1$1.env.NODE_ENV !== "production") {
    var isSingleContentElement = isElement$1(passedProps.content);
    var isMoreThanOneReferenceElement = elements.length > 1;
    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" "));
  }
  var instances = elements.reduce(function(acc, reference2) {
    var instance = reference2 && createTippy(reference2, passedProps);
    if (instance) {
      acc.push(instance);
    }
    return acc;
  }, []);
  return isElement$1(targets) ? instances[0] : instances;
}
tippy.defaultProps = defaultProps;
tippy.setDefaultProps = setDefaultProps;
tippy.currentInput = currentInput;
Object.assign({}, applyStyles$1, {
  effect: function effect2(_ref) {
    var state2 = _ref.state;
    var initialStyles = {
      popper: {
        position: state2.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state2.elements.popper.style, initialStyles.popper);
    state2.styles = initialStyles;
    if (state2.elements.arrow) {
      Object.assign(state2.elements.arrow.style, initialStyles.arrow);
    }
  }
});
tippy.setDefaultProps({
  render: render$2
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _hoisted_1$f = ["onClick", "onMouseenter"];
const _hoisted_2$c = { key: 0 };
const _hoisted_3$a = { key: 0 };
const _hoisted_4$6 = { key: 1 };
const _hoisted_5$5 = { key: 1 };
const _sfc_main$g = {
  __name: "Mentions",
  props: {
    users: {
      type: Array,
      required: true
    },
    mention: {
      type: String,
      default: ""
    },
    inserMention: {
      type: Function,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const container = vue.ref(null);
    const activeUserIndex = vue.ref(null);
    const getFilteredUsers = vue.computed(() => {
      const mention = props.mention.slice(1)?.toLowerCase();
      const filtered = props.users.filter((user) => {
        const isViewer = user.role === "viewer";
        const userMatch = user.name?.toLowerCase().startsWith(mention);
        const emailMatch = user.email?.toLowerCase().startsWith(mention);
        return !isViewer && (userMatch || emailMatch);
      }) || [];
      return filtered;
    });
    const handleClick2 = (user) => {
      props.inserMention(user);
    };
    const handleKeydown = (event) => {
      if (event.key === "ArrowDown") {
        activeUserIndex.value += 1;
        if (activeUserIndex.value === getFilteredUsers.value.length) {
          activeUserIndex.value = 0;
        }
      } else if (event.key === "ArrowUp") {
        activeUserIndex.value -= 1;
        if (activeUserIndex.value < 0) {
          activeUserIndex.value = getFilteredUsers.value.length - 1;
        }
      } else if (event.key === "Enter") {
        const user = getFilteredUsers.value[activeUserIndex.value];
        if (user) {
          props.inserMention(user);
        }
      }
    };
    const handleFocus = () => {
      activeUserIndex.value = 0;
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: "mentions-container",
        ref_key: "container",
        ref: container,
        onKeydown: vue.withModifiers(handleKeydown, ["prevent"]),
        onFocus: vue.withModifiers(handleFocus, ["stop", "prevent"]),
        tabindex: "0"
      }, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(getFilteredUsers.value, (user, index2) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            onClick: vue.withModifiers(($event) => handleClick2(user), ["stop", "prevent"]),
            onMouseenter: ($event) => activeUserIndex.value = index2,
            onMouseleave: _cache[0] || (_cache[0] = ($event) => activeUserIndex.value = null),
            key: user.email,
            class: vue.normalizeClass(["user-row", { selected: activeUserIndex.value === index2 }])
          }, [
            user.name ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$c, [
              user.name ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_3$a, vue.toDisplayString(user.name), 1)) : vue.createCommentVNode("", true),
              user.name && user.email ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_4$6, " (" + vue.toDisplayString(user.email) + ")", 1)) : vue.createCommentVNode("", true)
            ])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_5$5, [
              vue.createBaseVNode("span", null, vue.toDisplayString(user.email), 1)
            ]))
          ], 42, _hoisted_1$f);
        }), 128))
      ], 544);
    };
  }
};
const Mentions = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["__scopeId", "data-v-bcae18cf"]]);
const popoverPluginKey = new PluginKey("popoverPlugin");
const PopoverPlugin = Extension.create({
  name: "popoverPlugin",
  addPmPlugins() {
    const popover = new Plugin({
      key: popoverPluginKey,
      state: {
        init: () => {
          return {};
        },
        apply: (tr, value) => {
          let newValue = { ...value };
          if (tr.docChanged) {
            newValue.shouldUpdate = true;
          } else {
            newValue.shouldUpdate = false;
          }
          return newValue;
        }
      },
      view: (view) => {
        const popover2 = new Popover(view, this.editor);
        return {
          update: (view2, lastState) => {
            const pluginState = popoverPluginKey.getState(view2.state);
            if (!pluginState.shouldUpdate) return;
            popover2.update(view2, lastState);
          },
          destroy: () => {
            popover2.destroy();
          }
        };
      }
    });
    return [popover];
  }
});
class Popover {
  constructor(view, editor) {
    __publicField$1(this, "handleKeyDown", (event) => {
      const isArrow = event.key === "ArrowDown" || event.key === "ArrowUp";
      if (this.tippyInstance.state.isVisible && isArrow) {
        event.preventDefault();
        this.popover.firstChild.focus();
      }
    });
    this.editor = editor;
    this.view = view;
    this.popover = document.createElement("div");
    this.popover.className = "sd-editor-popover";
    document.body.appendChild(this.popover);
    this.tippyInstance = tippy(this.popover, {
      trigger: "manual",
      placement: "bottom-start",
      interactive: true,
      appendTo: document.body,
      arrow: false,
      onShow: (instance) => {
        instance.setProps({ getReferenceClientRect: () => this.popoverRect });
        this.bindKeyDownEvents();
      },
      onHide: () => {
        this.unbindKeyDownEvents();
      },
      theme: "sd-editor-popover"
    });
  }
  bindKeyDownEvents() {
    this.view.dom.addEventListener("keydown", this.handleKeyDown);
  }
  unbindKeyDownEvents() {
    this.view.dom.removeEventListener("keydown", this.handleKeyDown);
  }
  mountVueComponent(component, props = {}) {
    if (this.app) this.app.unmount();
    this.app = vue.createApp(component, props);
    this.app.mount(this.popover);
    this.tippyInstance.setContent(this.popover);
  }
  update(view) {
    this.state = view.state;
    const showPopover = this.isShowMentions;
    let popoverContent = { component: null, props: null };
    if (this.isShowMentions) {
      const { from: from2 } = this.state.selection;
      const atMention = this.getMentionText(from2);
      popoverContent = {
        component: Mentions,
        props: {
          users: this.editor.users,
          mention: atMention,
          inserMention: (user) => {
            const { $from } = this.state.selection;
            const length2 = atMention.length;
            const attributes = { ...user };
            const mentionNode = this.editor.schema.nodes.mention.create(attributes);
            const tr = this.state.tr.replaceWith($from.pos - length2, $from.pos, mentionNode);
            this.editor.view.dispatch(tr);
            this.editor.view.focus();
          }
        }
      };
    }
    if (showPopover && popoverContent.component) {
      const { to } = this.state.selection;
      const { component, props } = popoverContent;
      this.mountVueComponent(component, props);
      this.showPopoverAtPosition(to);
    } else this.tippyInstance.hide();
  }
  showPopoverAtPosition(pos) {
    const end2 = this.view.coordsAtPos(pos);
    this.popoverRect = {
      width: 0,
      height: 0,
      top: end2.bottom,
      left: end2.left,
      bottom: end2.bottom,
      right: end2.left
    };
    this.tippyInstance.show();
  }
  getMentionText(from2) {
    const maxLookBehind = 20;
    const startPos = Math.max(0, from2 - maxLookBehind);
    const textBefore = this.state.doc.textBetween(startPos, from2, "\n", "\0");
    const atIndex = textBefore.lastIndexOf("@");
    if (atIndex !== -1) return textBefore.substring(atIndex);
    return "";
  }
  get isShowMentions() {
    const { from: from2 } = this.state.selection;
    if (from2 < 1) return false;
    const textBefore = this.getMentionText(from2);
    const mentionPattern = /(?:^|\s)@[\w]*$/;
    const match = textBefore.match(mentionPattern);
    return match && this.state.selection.empty;
  }
  destroy() {
    this.tippyInstance.destroy();
    this.popover.remove();
  }
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x,
    right: x + width,
    bottom: y2 + height,
    x,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference: reference2,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference2.x + reference2.width / 2 - floating.width / 2;
  const commonY = reference2.y + reference2.height / 2 - floating.height / 2;
  const commonAlign = reference2[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference2.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case "right":
      coords = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference2.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference2.x,
        y: reference2.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference2, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference: reference2,
    floating,
    strategy
  });
  let {
    x,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference: reference2,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference: reference2,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$1 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state2) {
      const {
        rects
      } = state2;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state2);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state2, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement$3(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement$2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e2) {
      return false;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
const containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit2 = isWebKit();
  const css = isElement$3(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit2 && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit2 && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode$2(element);
  while (isHTMLElement$2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode$2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node2) {
  return lastTraversableNodeNames.has(getNodeName(node2));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement$3(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode$2(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode2 = getParentNode$2(node2);
  if (isLastTraversableNode(parentNode2)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement$2(parentNode2) && isOverflowElement(parentNode2)) {
    return parentNode2;
  }
  return getNearestOverflowAncestor(parentNode2);
}
function getOverflowAncestors(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement$3(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect2 = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement$3(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect2.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect2.top + visualOffsets.y) / scale.y;
  let width = clientRect2.width / scale.x;
  let height = clientRect2.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement$3(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left2;
      y2 += top2;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y2 = htmlRect.top + scroll.scrollTop;
  return {
    x,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement$2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
const SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc2 = html.ownerDocument;
    const body = doc2.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc2.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x,
    y: y2
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect2 = getBoundingClientRect(element, true, strategy === "fixed");
  const top2 = clientRect2.top + element.clientTop;
  const left2 = clientRect2.left + element.clientLeft;
  const scale = isHTMLElement$2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left2 * scale.x;
  const y2 = top2 * scale.y;
  return {
    width,
    height,
    x,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement$3(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode2 = getParentNode$2(element);
  if (parentNode2 === stopNode || !isElement$3(parentNode2) || isLastTraversableNode(parentNode2)) {
    return false;
  }
  return getComputedStyle$1(parentNode2).position === "fixed" || hasFixedPositionAncestor(parentNode2, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult2 = cache2.get(element);
  if (cachedResult2) {
    return cachedResult2;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement$3(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode$2(element) : element;
  while (isElement$3(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode$2(currentNode);
  }
  cache2.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement$2(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement$2(element)) {
    let svgOffsetParent = getParentNode$2(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement$3(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode$2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement$3,
  isRTL
};
function rectsAreEqual(a, b2) {
  return a.x === b2.x && a.y === b2.y && a.width === b2.width && a.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left: left2,
      top: top2,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top2);
    const insetRight = floor(root2.clientWidth - (left2 + width));
    const insetBottom = floor(root2.clientHeight - (top2 + height));
    const insetLeft = floor(left2);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (_e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference2, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference2);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference2) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference2);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const hide = hide$1;
const computePosition = (reference2, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference2, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
const SEPARATOR_CLASS = "pagination-separator";
const SEPARATOR_FLOATING_CLASS = "pagination-separator-floating";
const isDebugging = false;
const cleanupFunctions = /* @__PURE__ */ new Set();
const Pagination = Extension.create({
  name: "pagination",
  priority: 500,
  addStorage() {
    return {
      height: 0,
      sectionData: null,
      headerFooterEditors: /* @__PURE__ */ new Map()
    };
  },
  addCommands() {
    return {
      insertPageBreak: () => ({ commands: commands2 }) => {
        return commands2.insertContent({
          type: "hardBreak"
        });
      },
      /**
       * Toggle pagination on/off
       * @returns {void}
       */
      togglePagination: () => ({ tr, state: state2, dispatch, editor }) => {
        const isEnabled = PaginationPluginKey.getState(state2)?.isEnabled;
        tr.setMeta(PaginationPluginKey, { isEnabled: !isEnabled });
        if (dispatch) {
          dispatch(tr);
          editor.initDefaultStyles(editor.element, !isEnabled);
          return true;
        }
      }
    };
  },
  addShortcuts() {
    return {
      "Mod-Enter": () => this.editor.commands.insertPageBreak()
    };
  },
  /**
   * The pagination plugin is responsible for calculating page breaks, and redering them using decorations.
   */
  addPmPlugins() {
    const editor = this.editor;
    let isUpdating = false;
    let shouldUpdate = false;
    let hasInitialized = false;
    let shouldInitialize = false;
    const paginationPlugin = new Plugin({
      key: PaginationPluginKey,
      state: {
        isReadyToInit: false,
        init() {
          return {
            isReadyToInit: false,
            decorations: DecorationSet.empty,
            isDebugging,
            isEnabled: editor.options.pagination
          };
        },
        apply(tr, oldState, prevEditorState, newEditorState) {
          const meta = tr.getMeta(PaginationPluginKey);
          if (meta && "isEnabled" in meta) {
            const newEnabled = meta.isEnabled;
            if (newEnabled) shouldUpdate = true;
            return {
              ...oldState,
              decorations: newEnabled ? oldState.decorations : DecorationSet.empty,
              isEnabled: newEnabled
            };
          }
          if (meta && meta.isReadyToInit) {
            shouldUpdate = true;
            shouldInitialize = meta.isReadyToInit;
          }
          const syncMeta = tr.getMeta("y-sync$");
          const listSyncMeta = tr.getMeta("orderedListSync");
          if (syncMeta && syncMeta.isChangeOrigin || listSyncMeta) {
            return { ...oldState };
          }
          const imagePluginTransaction = tr.getMeta(ImagePlaceholderPluginKey);
          if (imagePluginTransaction) {
            if (imagePluginTransaction.type === "remove") {
              onImageLoad(editor);
            }
            return { ...oldState };
          }
          const isAnnotationUpdate = tr.getMeta("fieldAnnotationUpdate");
          if (isAnnotationUpdate) {
            return { ...oldState };
          }
          if (!shouldInitialize && !oldState.isReadyToInit) {
            return { ...oldState };
          }
          if (meta && meta.decorations) {
            shouldUpdate = true;
            return {
              ...oldState,
              decorations: meta.decorations.map(tr.mapping, tr.doc)
            };
          }
          const isForceUpdate = tr.getMeta("forceUpdatePagination");
          if (!isForceUpdate && prevEditorState.doc.eq(newEditorState.doc) && hasInitialized) {
            shouldUpdate = false;
            return { ...oldState };
          }
          shouldUpdate = true;
          if (isForceUpdate) shouldUpdate = true;
          return {
            ...oldState,
            decorations: meta?.decorations?.map(tr.mapping, tr.doc) || DecorationSet.empty,
            isReadyToInit: shouldInitialize
          };
        }
      },
      /* The view method is the most important part of the plugin */
      view: () => {
        let previousDecorations = DecorationSet.empty;
        return {
          update: (view) => {
            if (!PaginationPluginKey.getState(view.state)?.isEnabled) return;
            if (!shouldUpdate || isUpdating) return;
            isUpdating = true;
            hasInitialized = true;
            performUpdate(editor, view, previousDecorations);
            isUpdating = false;
            shouldUpdate = false;
          }
        };
      },
      props: {
        decorations(state2) {
          const pluginState = PaginationPluginKey.getState(state2);
          return pluginState.isEnabled ? pluginState.decorations : DecorationSet.empty;
        }
      }
    });
    return [paginationPlugin];
  },
  onDestroy() {
    cleanupFloatingSeparators();
    const { headerFooterEditors } = this.editor.storage.pagination;
    if (headerFooterEditors) {
      headerFooterEditors.clear();
    }
  }
});
const getHeaderFooterId = (currentPageNumber, sectionType, editor, node2 = null) => {
  const { alternateHeaders } = editor.converter.pageStyles;
  const sectionIds = editor.converter[sectionType];
  if (node2 && node2.attrs?.paragraphProperties?.sectPr) {
    const sectPr = node2.attrs?.paragraphProperties?.sectPr;
    if (currentPageNumber === 1) {
      if (sectionType === "headerIds") {
        const sectionData = sectPr?.elements?.find(
          (el) => el.name === "w:headerReference" && el.attributes?.["w:type"] === "first"
        );
        const newId = sectionData?.attributes?.["r:id"];
        return newId;
      } else if (sectionType === "footerIds") {
        const sectionData = sectPr?.elements?.find(
          (el) => el.name === "w:footerReference" && el.attributes?.["w:type"] === "first"
        );
        const newId = sectionData?.attributes?.["r:id"];
        return newId;
      }
    }
  }
  if (sectionIds?.titlePg && !sectionIds.first && currentPageNumber === 1) return null;
  const even = sectionIds.even;
  const odd = sectionIds.odd;
  const first2 = sectionIds.first;
  const defaultHeader = sectionIds.default;
  if (sectionIds?.titlePg && first2 && currentPageNumber === 1) return first2;
  let sectionId = sectionIds.default;
  if (currentPageNumber === 1) sectionId = defaultHeader;
  if (alternateHeaders) {
    if (currentPageNumber === 1) sectionId = first2;
    if (currentPageNumber % 2 === 0) sectionId = even || defaultHeader;
    else sectionId = odd || defaultHeader;
  }
  return sectionId;
};
const performUpdate = (editor, view, previousDecorations) => {
  const sectionData = editor.storage.pagination.sectionData;
  const newDecorations = calculatePageBreaks(view, editor, sectionData);
  const editorElement = editor.options.element;
  if (!previousDecorations.eq(newDecorations)) {
    const updateTransaction = view.state.tr.setMeta(PaginationPluginKey, { decorations: newDecorations });
    view.dispatch(updateTransaction);
    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        cleanupFloatingSeparators();
        const separators = [...editorElement.querySelectorAll(`.${SEPARATOR_CLASS}--table`)];
        separators.forEach((separator) => {
          const { cleanup } = createFloatingSeparator(separator, editor);
          cleanupFunctions.add(cleanup);
        });
      });
    });
  }
  editor.emit("paginationUpdate");
};
const calculatePageBreaks = (view, editor, sectionData) => {
  if (!editor.converter) return DecorationSet.empty;
  const pageSize = editor.converter.pageStyles?.pageSize;
  if (!pageSize) return DecorationSet.empty;
  const { width, height } = pageSize;
  if (!width || !height) return DecorationSet.empty;
  const ignorePlugins = [CollaborationPluginKey, PaginationPluginKey];
  const { state: state2 } = view;
  const cleanState = EditorState.create({
    schema: state2.schema,
    doc: state2.doc,
    plugins: state2.plugins.filter((plugin2) => ignorePlugins.includes(plugin2.key))
  });
  const tempContainer = editor.options.element.cloneNode();
  if (!tempContainer) return [];
  tempContainer.className = "temp-container super-editor";
  const HIDDEN_EDITOR_OFFSET_TOP = 0;
  const HIDDEN_EDITOR_OFFSET_LEFT = 0;
  tempContainer.style.left = HIDDEN_EDITOR_OFFSET_TOP + "px";
  tempContainer.style.top = HIDDEN_EDITOR_OFFSET_LEFT + "px";
  tempContainer.style.position = "fixed";
  tempContainer.style.visibility = "hidden";
  document.body.appendChild(tempContainer);
  const tempView = new EditorView(tempContainer, {
    state: cleanState,
    dispatchTransaction: () => {
    }
  });
  editor.initDefaultStyles(tempContainer);
  const decorations = generateInternalPageBreaks(cleanState.doc, tempView, editor, sectionData);
  tempView.destroy();
  document.body.removeChild(tempContainer);
  return DecorationSet.create(view.state.doc, decorations);
};
function generateInternalPageBreaks(doc2, view, editor, sectionData) {
  const decorations = [];
  const { pageSize, pageMargins } = editor.converter.pageStyles;
  const pageHeight = pageSize.height * 96;
  let currentPageNumber = 1;
  let pageHeightThreshold = pageHeight;
  let footer = null, header = null;
  const firstHeaderId = getHeaderFooterId(currentPageNumber, "headerIds", editor);
  const isFirstHeader = true;
  const firstHeader = createHeader(
    pageMargins,
    pageSize,
    sectionData,
    firstHeaderId,
    editor,
    currentPageNumber,
    isFirstHeader
  );
  const pageBreak = createPageBreak({ editor, header: firstHeader, isFirstHeader: true });
  decorations.push(Decoration.widget(0, pageBreak, { key: "stable-key" }));
  const lastFooterId = getHeaderFooterId(currentPageNumber, "footerIds", editor);
  const isLastFooter = true;
  const lastFooter = createFooter(
    pageMargins,
    pageSize,
    sectionData,
    lastFooterId,
    editor,
    currentPageNumber,
    isLastFooter
  );
  pageHeightThreshold -= firstHeader.headerHeight + lastFooter.footerHeight;
  let coords = view?.coordsAtPos(doc2.content.size);
  if (!coords) return [];
  doc2.descendants((node2, pos) => {
    let currentNode = node2;
    let currentPos = pos;
    coords = view?.coordsAtPos(currentPos);
    if (!coords) return;
    let isHardBreakNode = currentNode.type.name === "hardBreak";
    let isListItemNode = currentNode.type.name === "listItem";
    const endPos = currentPos + currentNode.nodeSize;
    const endCoords = view.coordsAtPos(endPos);
    let shouldAddPageBreak = currentNode.isBlock && isListItemNode ? endCoords && endCoords.bottom > pageHeightThreshold : coords.bottom > pageHeightThreshold;
    const paragraphSectPrBreak = currentNode.attrs?.pageBreakSource;
    if (paragraphSectPrBreak === "sectPr") {
      const nextNode = doc2.nodeAt(currentPos + currentNode.nodeSize);
      const nextNodeSectPr = nextNode?.attrs?.pageBreakSource === "sectPr";
      if (!nextNodeSectPr) isHardBreakNode = true;
      if (currentPageNumber === 1) {
        const headerId2 = getHeaderFooterId(currentPageNumber, "headerIds", editor, currentNode);
        decorations.pop();
        const isFirstHeader2 = true;
        const newFirstHeader = createHeader(
          pageMargins,
          pageSize,
          sectionData,
          headerId2,
          editor,
          currentPageNumber,
          isFirstHeader2
        );
        const pageBreak2 = createPageBreak({ editor, header: newFirstHeader, isFirstHeader: true });
        decorations.push(Decoration.widget(0, pageBreak2, { key: "stable-key" }));
      }
    }
    if (currentNode.type.name === "paragraph" && currentNode.attrs.styleId) {
      const linkedStyles = LinkedStylesPluginKey.getState(editor.state)?.styles;
      const style2 = linkedStyles?.find((style22) => style22.id === currentNode.attrs.styleId);
      if (style2) {
        const { definition = {} } = style2;
        const { pageBreakBefore, pageBreakAfter } = definition.attrs || {};
        if (pageBreakBefore || pageBreakAfter) shouldAddPageBreak = true;
      }
    }
    if (isHardBreakNode || shouldAddPageBreak) {
      const $currentPos = view.state.doc.resolve(currentPos);
      const table = findParentNodeClosestToPos($currentPos, (node22) => node22.type.name === "table");
      const tableRow = findParentNodeClosestToPos($currentPos, (node22) => node22.type.name === "tableRow");
      let isInTable2 = table || tableRow ? true : false;
      let {
        top: actualBreakTop,
        bottom: actualBreakBottom,
        pos: breakPos
      } = getActualBreakCoords(view, currentPos, pageHeightThreshold);
      const $breakPos = view.state.doc.resolve(breakPos);
      if ($breakPos.parent.type.name === "listItem") {
        breakPos = $breakPos.before($breakPos.depth);
      }
      const footerId2 = getHeaderFooterId(currentPageNumber, "footerIds", editor, currentNode);
      currentPageNumber++;
      const headerId2 = getHeaderFooterId(currentPageNumber, "headerIds", editor);
      header = createHeader(pageMargins, pageSize, sectionData, headerId2, editor, currentPageNumber - 1);
      footer = createFooter(pageMargins, pageSize, sectionData, footerId2, editor, currentPageNumber - 1);
      const bufferHeight2 = pageHeightThreshold - actualBreakBottom;
      const { node: spacingNode2 } = createFinalPagePadding(bufferHeight2);
      const pageSpacer2 = Decoration.widget(breakPos, spacingNode2, { key: "stable-key" });
      decorations.push(pageSpacer2);
      const pageBreak2 = createPageBreak({ editor, header, footer, isInTable: isInTable2 });
      decorations.push(Decoration.widget(breakPos, pageBreak2, { key: "stable-key" }));
      pageHeightThreshold = actualBreakBottom + (pageHeight - header.headerHeight - footer.footerHeight);
    }
  });
  let finalPos = doc2.content.size;
  const lastNodeCoords = view.coordsAtPos(finalPos);
  const headerId = getHeaderFooterId(currentPageNumber, "headerIds", editor);
  const footerId = getHeaderFooterId(currentPageNumber, "footerIds", editor);
  header = createHeader(pageMargins, pageSize, sectionData, headerId, editor, currentPageNumber);
  footer = createFooter(pageMargins, pageSize, sectionData, footerId, editor, currentPageNumber);
  const bufferHeight = pageHeightThreshold - lastNodeCoords.bottom;
  const { node: spacingNode } = createFinalPagePadding(bufferHeight);
  const pageSpacer = Decoration.widget(doc2.content.size, spacingNode, { key: "stable-key" });
  decorations.push(pageSpacer);
  const footerBreak = createPageBreak({ editor, footer, isLastFooter: true });
  decorations.push(Decoration.widget(doc2.content.size, footerBreak, { key: "stable-key" }));
  decorations.forEach((decoration) => {
    const sectionContainer = decoration.type.toDOM;
    const totalPageNumber = sectionContainer?.querySelector('span[data-id="auto-total-pages"]');
    if (totalPageNumber) {
      const fontSize2 = totalPageNumber.previousElementSibling?.style?.fontSize || totalPageNumber.nextElementSibling?.style?.fontSize;
      if (fontSize2) totalPageNumber.style.fontSize = fontSize2;
      totalPageNumber.innerText = currentPageNumber;
    }
  });
  editor.currentTotalPages = currentPageNumber;
  return decorations;
}
function createFinalPagePadding(bufferHeight) {
  const div2 = document.createElement("div");
  div2.className = "pagination-page-spacer";
  div2.style.userSelect = "none";
  div2.style.pointerEvents = "none";
  div2.style.height = bufferHeight + "px";
  return { nodeHeight: bufferHeight, node: div2 };
}
function createHeader(pageMargins, pageSize, sectionData, headerId, editor, currentPageNumber, isFirstHeader = false) {
  const headerDef = sectionData?.headers?.[headerId];
  const minHeaderHeight = pageMargins.top * 96;
  const headerMargin = pageMargins.header * 96;
  const hasHeaderOffset = headerDef?.height > minHeaderHeight - headerMargin;
  const headerOffset = hasHeaderOffset ? headerMargin : 0;
  const headerHeight = Math.max(headerDef?.height || 0, minHeaderHeight) + headerOffset;
  const availableHeight = headerHeight - headerMargin;
  let editorContainer = document.createElement("div");
  if (!headerId && !editor?.converter?.headerIds?.["default"]) {
    headerId = "rId" + generateDocxRandomId();
    editor.converter.headerIds["default"] = headerId;
  }
  if (!editor.converter.headers[headerId]) {
    editor.converter.headers[headerId] = {
      type: "doc",
      content: [{ type: "paragraph", content: [] }]
    };
  }
  const data = editor.converter.headers[headerId];
  const pageNumberIndex = currentPageNumber - 1;
  const editorKey = getHeaderFooterEditorKey({ pageNumber: pageNumberIndex, isHeader: true, isFirstHeader });
  let editorSection = null;
  const { headerFooterEditors } = editor.storage.pagination;
  if (headerFooterEditors.has(editorKey) && editor.converter.headerEditors[pageNumberIndex]) {
    const editorData = headerFooterEditors.get(editorKey);
    editorSection = editorData.editor;
    editorContainer = editorSection.element;
  } else {
    editorSection = createHeaderFooterEditor({
      editor,
      data,
      editorContainer,
      appendToBody: false,
      sectionId: headerId,
      type: "header",
      availableHeight,
      currentPageNumber
    });
    editor.converter.headerEditors.push({ id: headerId, editor: editorSection });
    headerFooterEditors.set(editorKey, { editor: editorSection });
    broadcastEditorEvents(editor, editorSection);
  }
  editorSection.setEditable(false, false);
  editorContainer.classList.add("pagination-section-header");
  editorContainer.style.paddingTop = headerMargin + "px";
  editorContainer.style.paddingLeft = pageMargins.left * 96 + "px";
  editorContainer.style.paddingRight = pageMargins.right * 96 + "px";
  editorContainer.style.height = headerHeight + "px";
  editorContainer.style.width = pageSize.width * 96 + "px";
  editorContainer.style.position = "static";
  editorContainer.addEventListener("dblclick", () => onHeaderFooterDblClick(editor, editorSection));
  return {
    section: editorContainer,
    headerHeight
  };
}
function createFooter(pageMargins, pageSize, sectionData, footerId, editor, currentPageNumber, isLastFooter = false) {
  const footerDef = sectionData?.footers?.[footerId];
  const minFooterHeight = pageMargins.bottom * 96;
  const footerPaddingFromEdge = pageMargins.footer * 96;
  const footerHeight = Math.max(footerDef?.height || 0, minFooterHeight - footerPaddingFromEdge);
  let editorContainer = document.createElement("div");
  if (!footerId && !editor.converter.footerIds["default"]) {
    footerId = "rId" + generateDocxRandomId();
    editor.converter.footerIds["default"] = footerId;
  }
  if (!editor.converter.footers[footerId]) {
    editor.converter.footers[footerId] = {
      type: "doc",
      content: [{ type: "paragraph", content: [] }]
    };
  }
  const data = editor.converter.footers[footerId];
  const pageNumberIndex = currentPageNumber - 1;
  const editorKey = getHeaderFooterEditorKey({ pageNumber: pageNumberIndex, isFooter: true, isLastFooter });
  let editorSection = null;
  const { headerFooterEditors } = editor.storage.pagination;
  if (headerFooterEditors.has(editorKey) && editor.converter.footerEditors[pageNumberIndex]) {
    const editorData = headerFooterEditors.get(editorKey);
    editorSection = editorData.editor;
    editorContainer = editorSection.element;
  } else {
    editorSection = createHeaderFooterEditor({
      editor,
      data,
      editorContainer,
      appendToBody: false,
      sectionId: footerId,
      type: "footer",
      availableHeight: footerHeight,
      currentPageNumber
    });
    editor.converter.footerEditors.push({ id: footerId, editor: editorSection });
    headerFooterEditors.set(editorKey, { editor: editorSection });
    broadcastEditorEvents(editor, editorSection);
  }
  editorSection.setEditable(false, false);
  editorContainer.classList.add("pagination-section-footer");
  editorContainer.style.height = footerHeight + "px";
  editorContainer.style.marginBottom = footerPaddingFromEdge + "px";
  editorContainer.style.paddingLeft = pageMargins.left * 96 + "px";
  editorContainer.style.paddingRight = pageMargins.right * 96 + "px";
  editorContainer.style.width = pageSize.width * 96 + "px";
  editorContainer.style.position = "static";
  editorContainer.addEventListener("dblclick", () => onHeaderFooterDblClick(editor, editorSection));
  return {
    section: editorContainer,
    footerHeight: footerHeight + footerPaddingFromEdge
  };
}
const getHeaderFooterEditorKey = ({ pageNumber, isHeader, isFooter, isFirstHeader = false, isLastFooter = false }) => {
  if (isFirstHeader) return `first-header-${pageNumber}`;
  if (isLastFooter) return `last-footer-${pageNumber}`;
  if (isHeader) return `header-${pageNumber}`;
  if (isFooter) return `footer-${pageNumber}`;
  return void 0;
};
const onHeaderFooterDblClick = (editor, currentFocusedSectionEditor) => {
  if (editor.options.documentMode !== "editing") return;
  editor.setEditable(false, false);
  toggleHeaderFooterEditMode({
    editor,
    focusedSectionEditor: currentFocusedSectionEditor,
    isEditMode: true,
    documentMode: editor.options.documentMode
  });
};
function createPageBreak({
  editor,
  header,
  footer,
  footerBottom = null,
  isFirstHeader,
  isLastFooter,
  isInTable: isInTable2 = false
}) {
  const { pageSize, pageMargins } = editor.converter.pageStyles;
  let sectionHeight = 0;
  const paginationDiv = document.createElement("div");
  paginationDiv.className = "pagination-break-wrapper";
  const innerDiv = document.createElement("div");
  innerDiv.className = "pagination-inner";
  innerDiv.style.width = pageSize.width * 96 - 1 + "px";
  if (isFirstHeader) innerDiv.style.borderRadius = "8px 8px 0 0";
  else if (isLastFooter) innerDiv.style.borderRadius = "0 0 8px 8px";
  paginationDiv.appendChild(innerDiv);
  if (footer) {
    innerDiv.appendChild(footer.section);
    sectionHeight += footer.footerHeight;
  }
  if (header && footer) {
    const separatorHeight = 20;
    sectionHeight += separatorHeight;
    const separator = document.createElement("div");
    separator.classList.add(SEPARATOR_CLASS);
    if (isInTable2) {
      separator.classList.add(`${SEPARATOR_CLASS}--table`);
    }
    innerDiv.appendChild(separator);
  }
  if (header) {
    innerDiv.appendChild(header.section);
    sectionHeight += header.headerHeight;
  }
  paginationDiv.style.height = sectionHeight + "px";
  paginationDiv.style.minHeight = sectionHeight + "px";
  paginationDiv.style.maxHeight = sectionHeight + "px";
  innerDiv.style.height = sectionHeight + "px";
  paginationDiv.style.width = "100px";
  paginationDiv.style.marginLeft = pageMargins.left * -96 + "px";
  if (footerBottom !== null) {
    paginationDiv.style.position = "absolute";
    paginationDiv.style.bottom = footerBottom + "px";
  }
  return paginationDiv;
}
function getActualBreakCoords(view, pos, calculatedThreshold) {
  let currentPos = pos - 1;
  const actualBreak = { top: 0, bottom: 0, pos: 0 };
  while (currentPos > 0) {
    const { top: top2, bottom: bottom2 } = view.coordsAtPos(currentPos);
    if (bottom2 < calculatedThreshold) {
      Object.assign(actualBreak, { top: top2, bottom: bottom2, pos: currentPos + 1 });
      break;
    }
    currentPos--;
  }
  return actualBreak;
}
const onImageLoad = (editor) => {
  requestAnimationFrame(() => {
    const newTr = editor.view.state.tr;
    newTr.setMeta("forceUpdatePagination", true);
    editor.view.dispatch(newTr);
  });
};
function createFloatingSeparator(separator, editor) {
  const floatingSeparator = document.createElement("div");
  floatingSeparator.classList.add(SEPARATOR_FLOATING_CLASS);
  floatingSeparator.dataset.floatingSeparator = "";
  const editorElement = editor.options.element;
  editorElement.append(floatingSeparator);
  const updatePosition2 = () => {
    computePosition(separator, floatingSeparator, {
      strategy: "absolute",
      placement: "top-start",
      middleware: [
        hide(),
        {
          name: "copy",
          fn: ({ elements }) => {
            const rect = elements.reference.getBoundingClientRect();
            const containerRect = editorElement.getBoundingClientRect();
            const scaleFactor = getScaleFactor(editorElement);
            const x = Math.round((rect.left - containerRect.left) / scaleFactor);
            const y2 = Math.round((rect.top - containerRect.top) / scaleFactor);
            const width = Math.round(rect.width / scaleFactor);
            const height = Math.round(rect.height / scaleFactor);
            return {
              x,
              y: y2,
              data: { width, height }
            };
          }
        }
      ]
    }).then(({ x, y: y2, middlewareData }) => {
      Object.assign(floatingSeparator.style, {
        top: `${y2}px`,
        left: `${x}px`,
        width: `${middlewareData.copy.width}px`,
        height: `${middlewareData.copy.height}px`,
        visibility: middlewareData.hide?.referenceHidden ? "hidden" : "visible"
      });
    });
  };
  const cleanup = autoUpdate(separator, floatingSeparator, updatePosition2);
  const extendedCleanup = () => {
    floatingSeparator?.remove();
    cleanup();
  };
  return {
    cleanup: extendedCleanup,
    updatePosition: updatePosition2
  };
}
function cleanupFloatingSeparators() {
  cleanupFunctions.forEach((cleanup) => cleanup());
  cleanupFunctions.clear();
}
function getScaleFactor(element) {
  let scale = 1;
  let currentElement = element;
  while (currentElement && currentElement !== document.documentElement) {
    let zoomStyle = currentElement.style.zoom;
    if (zoomStyle) {
      let zoom = parseFloat(zoomStyle) || 1;
      scale *= zoom;
    }
    let transformStyle = currentElement.style.transform;
    if (transformStyle) {
      let scaleMatch = transformStyle.match(/scale\(([^)]+)\)/);
      if (scaleMatch) {
        let scaleValue = parseFloat(scaleMatch[1]) || 1;
        scale *= scaleValue;
      }
    }
    currentElement = currentElement.parentElement;
  }
  return scale;
}
class SearchQuery {
  /**
  Create a query object.
  */
  constructor(config) {
    this.search = config.search;
    this.caseSensitive = !!config.caseSensitive;
    this.literal = !!config.literal;
    this.regexp = !!config.regexp;
    this.replace = config.replace || "";
    this.valid = !!this.search && !(this.regexp && !validRegExp(this.search));
    this.wholeWord = !!config.wholeWord;
    this.filter = config.filter || null;
    this.impl = !this.valid ? nullQuery : this.regexp ? new RegExpQuery(this) : new StringQuery(this);
  }
  /**
  Compare this query to another query.
  */
  eq(other) {
    return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp && this.wholeWord == other.wholeWord;
  }
  /**
  Find the next occurrence of this query in the given range.
  */
  findNext(state2, from2 = 0, to = state2.doc.content.size) {
    for (; ; ) {
      if (from2 >= to)
        return null;
      let result = this.impl.findNext(state2, from2, to);
      if (!result || this.checkResult(state2, result))
        return result;
      from2 = result.from + 1;
    }
  }
  /**
  Find the previous occurrence of this query in the given range.
  Note that, if `to` is given, it should be _less_ than `from`.
  */
  findPrev(state2, from2 = state2.doc.content.size, to = 0) {
    for (; ; ) {
      if (from2 <= to)
        return null;
      let result = this.impl.findPrev(state2, from2, to);
      if (!result || this.checkResult(state2, result))
        return result;
      from2 = result.to - 1;
    }
  }
  /**
  @internal
  */
  checkResult(state2, result) {
    return (!this.wholeWord || checkWordBoundary(state2, result.from) && checkWordBoundary(state2, result.to)) && (!this.filter || this.filter(state2, result));
  }
  /**
  @internal
  */
  unquote(string) {
    return this.literal ? string : string.replace(/\\([nrt\\])/g, (_2, ch) => ch == "n" ? "\n" : ch == "r" ? "\r" : ch == "t" ? "	" : "\\");
  }
  /**
  Get the ranges that should be replaced for this result. This can
  return multiple ranges when `this.replace` contains
  `$1`/`$&`-style placeholders, in which case the preserved
  content is skipped by the replacements.
  
  Ranges are sorted by position, and `from`/`to` positions all
  refer to positions in `state.doc`. When applying these, you'll
  want to either apply them from back to front, or map these
  positions through your transaction's current mapping.
  */
  getReplacements(state2, result) {
    let $from = state2.doc.resolve(result.from);
    let marks = $from.marksAcross(state2.doc.resolve(result.to));
    let ranges = [];
    let frag = Fragment.empty, pos = result.from, { match } = result;
    let groups = match ? getGroupIndices(match) : [[0, result.to - result.from]];
    let replParts = parseReplacement(this.unquote(this.replace)), groupSpan;
    for (let part of replParts) {
      if (typeof part == "string") {
        frag = frag.addToEnd(state2.schema.text(part, marks));
      } else if (groupSpan = groups[part.group]) {
        let from2 = result.matchStart + groupSpan[0], to = result.matchStart + groupSpan[1];
        if (part.copy) {
          frag = frag.append(state2.doc.slice(from2, to).content);
        } else {
          if (frag != Fragment.empty || from2 > pos) {
            ranges.push({ from: pos, to: from2, insert: new Slice(frag, 0, 0) });
            frag = Fragment.empty;
          }
          pos = to;
        }
      }
    }
    if (frag != Fragment.empty || pos < result.to)
      ranges.push({ from: pos, to: result.to, insert: new Slice(frag, 0, 0) });
    return ranges;
  }
}
const nullQuery = new class {
  findNext() {
    return null;
  }
  findPrev() {
    return null;
  }
}();
class StringQuery {
  constructor(query) {
    this.query = query;
    let string = query.unquote(query.search);
    if (!query.caseSensitive)
      string = string.toLowerCase();
    this.string = string;
  }
  findNext(state2, from2, to) {
    return scanTextblocks(state2.doc, from2, to, (node2, start2) => {
      let off2 = Math.max(from2, start2);
      let content = textContent(node2).slice(off2 - start2, Math.min(node2.content.size, to - start2));
      let index2 = (this.query.caseSensitive ? content : content.toLowerCase()).indexOf(this.string);
      return index2 < 0 ? null : { from: off2 + index2, to: off2 + index2 + this.string.length, match: null, matchStart: start2 };
    });
  }
  findPrev(state2, from2, to) {
    return scanTextblocks(state2.doc, from2, to, (node2, start2) => {
      let off2 = Math.max(start2, to);
      let content = textContent(node2).slice(off2 - start2, Math.min(node2.content.size, from2 - start2));
      if (!this.query.caseSensitive)
        content = content.toLowerCase();
      let index2 = content.lastIndexOf(this.string);
      return index2 < 0 ? null : { from: off2 + index2, to: off2 + index2 + this.string.length, match: null, matchStart: start2 };
    });
  }
}
const baseFlags = "g" + (/x/.unicode == null ? "" : "u") + (/x/.hasIndices == null ? "" : "d");
class RegExpQuery {
  constructor(query) {
    this.query = query;
    this.regexp = new RegExp(query.search, baseFlags + (query.caseSensitive ? "" : "i"));
  }
  findNext(state2, from2, to) {
    return scanTextblocks(state2.doc, from2, to, (node2, start2) => {
      let content = textContent(node2).slice(0, Math.min(node2.content.size, to - start2));
      this.regexp.lastIndex = from2 - start2;
      let match = this.regexp.exec(content);
      return match ? { from: start2 + match.index, to: start2 + match.index + match[0].length, match, matchStart: start2 } : null;
    });
  }
  findPrev(state2, from2, to) {
    return scanTextblocks(state2.doc, from2, to, (node2, start2) => {
      let content = textContent(node2).slice(0, Math.min(node2.content.size, from2 - start2));
      let match;
      for (let off2 = 0; ; ) {
        this.regexp.lastIndex = off2;
        let next = this.regexp.exec(content);
        if (!next)
          break;
        match = next;
        off2 = next.index + 1;
      }
      return match ? { from: start2 + match.index, to: start2 + match.index + match[0].length, match, matchStart: start2 } : null;
    });
  }
}
function getGroupIndices(match) {
  if (match.indices)
    return match.indices;
  let result = [[0, match[0].length]];
  for (let i = 1, pos = 0; i < match.length; i++) {
    let found2 = match[i] ? match[0].indexOf(match[i], pos) : -1;
    result.push(found2 < 0 ? void 0 : [found2, pos = found2 + match[i].length]);
  }
  return result;
}
function parseReplacement(text) {
  let result = [], highestSeen = -1;
  function add(text2) {
    let last = result.length - 1;
    if (last > -1 && typeof result[last] == "string")
      result[last] += text2;
    else
      result.push(text2);
  }
  while (text.length) {
    let m2 = /\$([$&\d+])/.exec(text);
    if (!m2) {
      add(text);
      return result;
    }
    if (m2.index > 0)
      add(text.slice(0, m2.index + (m2[1] == "$" ? 1 : 0)));
    if (m2[1] != "$") {
      let n = m2[1] == "&" ? 0 : +m2[1];
      if (highestSeen >= n) {
        result.push({ group: n, copy: true });
      } else {
        highestSeen = n || 1e3;
        result.push({ group: n, copy: false });
      }
    }
    text = text.slice(m2.index + m2[0].length);
  }
  return result;
}
function validRegExp(source) {
  try {
    new RegExp(source, baseFlags);
    return true;
  } catch (_a2) {
    return false;
  }
}
const TextContentCache = /* @__PURE__ */ new WeakMap();
function textContent(node2) {
  let cached = TextContentCache.get(node2);
  if (cached)
    return cached;
  let content = "";
  for (let i = 0; i < node2.childCount; i++) {
    let child = node2.child(i);
    if (child.isText)
      content += child.text;
    else if (child.isLeaf)
      content += "￼";
    else
      content += " " + textContent(child) + " ";
  }
  TextContentCache.set(node2, content);
  return content;
}
function scanTextblocks(node2, from2, to, f, nodeStart = 0) {
  if (node2.inlineContent) {
    return f(node2, nodeStart);
  } else if (!node2.isLeaf) {
    if (from2 > to) {
      for (let i = node2.childCount - 1, pos = nodeStart + node2.content.size; i >= 0 && pos > to; i--) {
        let child = node2.child(i);
        pos -= child.nodeSize;
        if (pos < from2) {
          let result = scanTextblocks(child, from2, to, f, pos + 1);
          if (result != null)
            return result;
        }
      }
    } else {
      for (let i = 0, pos = nodeStart; i < node2.childCount && pos < to; i++) {
        let child = node2.child(i), start2 = pos;
        pos += child.nodeSize;
        if (pos > from2) {
          let result = scanTextblocks(child, from2, to, f, start2 + 1);
          if (result != null)
            return result;
        }
      }
    }
  }
  return null;
}
function checkWordBoundary(state2, pos) {
  let $pos = state2.doc.resolve(pos);
  let before = $pos.nodeBefore, after = $pos.nodeAfter;
  if (!before || !after || !before.isText || !after.isText)
    return true;
  return !/\p{L}$/u.test(before.text) || !/^\p{L}/u.test(after.text);
}
class SearchState {
  constructor(query, range2, deco) {
    this.query = query;
    this.range = range2;
    this.deco = deco;
  }
}
function buildMatchDeco(state2, query, range2) {
  if (!query.valid)
    return DecorationSet.empty;
  let deco = [];
  let sel = state2.selection;
  for (let pos = range2 ? range2.from : 0, end2 = range2 ? range2.to : state2.doc.content.size; ; ) {
    let next = query.findNext(state2, pos, end2);
    if (!next)
      break;
    let cls = next.from == sel.from && next.to == sel.to ? "ProseMirror-active-search-match" : "ProseMirror-search-match";
    deco.push(Decoration.inline(next.from, next.to, { class: cls }));
    pos = next.to;
  }
  return DecorationSet.create(state2.doc, deco);
}
const searchKey = new PluginKey("search");
function search(options = {}) {
  return new Plugin({
    key: searchKey,
    state: {
      init(_config, state2) {
        let query = options.initialQuery || new SearchQuery({ search: "" });
        let range2 = options.initialRange || null;
        return new SearchState(query, range2, buildMatchDeco(state2, query, range2));
      },
      apply(tr, search2, _oldState, state2) {
        let set = tr.getMeta(searchKey);
        if (set)
          return new SearchState(set.query, set.range, buildMatchDeco(state2, set.query, set.range));
        if (tr.docChanged || tr.selectionSet) {
          let range2 = search2.range;
          if (range2) {
            let from2 = tr.mapping.map(range2.from, 1);
            let to = tr.mapping.map(range2.to, -1);
            range2 = from2 < to ? { from: from2, to } : null;
          }
          search2 = new SearchState(search2.query, range2, buildMatchDeco(state2, search2.query, range2));
        }
        return search2;
      }
    },
    props: {
      decorations: (state2) => searchKey.getState(state2).deco
    }
  });
}
function getMatchHighlights(state2) {
  let search2 = searchKey.getState(state2);
  return search2 ? search2.deco : DecorationSet.empty;
}
function setSearchState(tr, query, range2 = null) {
  return tr.setMeta(searchKey, { query, range: range2 });
}
const Search = Extension.create({
  addStorage() {
    return {
      searchResults: []
    };
  },
  addPmPlugins() {
    const editor = this.editor;
    const storage = this.storage;
    const searchHighlightWithIdPlugin = new Plugin({
      key: new PluginKey("customSearchHighlights"),
      props: {
        decorations(state2) {
          if (!editor) return null;
          const matches2 = storage?.searchResults;
          if (!matches2?.length) return null;
          const decorations = matches2.map(
            (match) => Decoration.inline(match.from, match.to, {
              id: `search-match-${match.id}`
            })
          );
          return DecorationSet.create(state2.doc, decorations);
        }
      }
    });
    return [search(), searchHighlightWithIdPlugin];
  },
  addCommands() {
    return {
      goToFirstMatch: () => ({ state: state2, editor }) => {
        const highlights = getMatchHighlights(state2);
        if (!highlights || !highlights.children?.length) return;
        const match = highlights.children.find((item) => item.local);
        const firstSearchItemPosition = highlights.children[0] + match.local[0].from + 1;
        editor.view.domAtPos(firstSearchItemPosition)?.node?.scrollIntoView(true);
      },
      search: (patternInput) => ({ state: state2, dispatch }) => {
        let pattern;
        let caseSensitive = false;
        let regexp = false;
        const wholeWord = false;
        if (patternInput instanceof RegExp) {
          regexp = true;
          pattern = patternInput.source;
          caseSensitive = !patternInput.flags.includes("i");
        } else if (typeof patternInput === "string" && /^\/(.+)\/([gimsuy]*)$/.test(patternInput)) {
          const [, body, flags] = patternInput.match(/^\/(.+)\/([gimsuy]*)$/);
          regexp = true;
          pattern = body;
          caseSensitive = !flags.includes("i");
        } else {
          pattern = String(patternInput);
        }
        const query = new SearchQuery({
          search: pattern,
          caseSensitive,
          regexp,
          wholeWord
        });
        const tr = setSearchState(state2.tr, query);
        dispatch(tr);
        const newState = state2.apply(tr);
        const decoSet = getMatchHighlights(newState);
        const matches2 = decoSet ? decoSet.find() : [];
        const resultMatches = matches2.map((d2) => ({
          from: d2.from,
          to: d2.to,
          text: newState.doc.textBetween(d2.from, d2.to),
          id: v4()
        }));
        this.storage.searchResults = resultMatches;
        return resultMatches;
      },
      goToSearchResult: (match) => ({ state: state2, dispatch, editor }) => {
        const { from: from2, to } = match;
        editor.view.focus();
        const tr = state2.tr.setSelection(TextSelection$1.create(state2.doc, from2, to)).scrollIntoView();
        dispatch(tr);
        const { node: node2 } = editor.view.domAtPos(from2);
        if (node2?.scrollIntoView) {
          node2.scrollIntoView({ block: "center", inline: "nearest" });
        }
        return true;
      }
    };
  }
});
const NodeResizerKey = new PluginKey("node-resizer");
const nodeResizer = (nodeNames = ["image"], editor) => {
  let resizeState = {
    dragging: false,
    startX: 0,
    startWidth: 0,
    handle: null,
    pos: null,
    resizableElement: null,
    aspectRatio: 1
  };
  let resizeContainer = null;
  let editorView = null;
  let globalClickHandler = null;
  let globalMousedownHandler = null;
  let scrollHandler = null;
  let currentWrapper = null;
  return new Plugin({
    key: NodeResizerKey,
    state: {
      init() {
        return DecorationSet.empty;
      },
      apply(tr, oldState, _2, newState) {
        if (tr.getMeta(NodeResizerKey)) {
          return oldState;
        }
        if (typeof document === "undefined" || editor.options.isHeadless) return oldState;
        const { selection } = newState;
        const node2 = selection.node;
        if (!node2 || !nodeNames.includes(node2.type.name)) {
          return DecorationSet.empty;
        }
        const decorations = [];
        if (nodeNames.includes(selection.node?.type.name)) {
          decorations.push(
            Decoration.node(selection.from, selection.to, {
              nodeName: "span",
              class: "sd-editor-resizable-wrapper",
              "data-pos": selection.from
            })
          );
        }
        return DecorationSet.create(newState.doc, decorations);
      }
    },
    props: {
      decorations(state2) {
        return this.getState(state2);
      }
    },
    view(view) {
      editorView = view;
      globalClickHandler = (event) => {
        if (!event.target.closest(".sd-editor-resizable-wrapper") && !event.target.closest(".sd-editor-resize-container")) {
          hideResizeHandles();
        }
      };
      document.addEventListener("click", globalClickHandler);
      globalMousedownHandler = (event) => {
        if (event.target.closest(".sd-editor-resize-handle")) {
          event.preventDefault();
          event.stopPropagation();
          startResize(editorView, event, event.target);
          return true;
        }
      };
      document.addEventListener("mousedown", globalMousedownHandler);
      scrollHandler = () => {
        if (currentWrapper && resizeContainer) {
          updateHandlePositions(currentWrapper.firstElementChild);
        }
      };
      window.addEventListener("scroll", scrollHandler, true);
      return {
        update(view2, prevState) {
          const { selection } = view2.state;
          const prevSelection = prevState.selection;
          if (selection.from !== prevSelection.from || selection.to !== prevSelection.to) {
            setTimeout(() => {
              const selectedResizableWrapper = document.querySelector(".sd-editor-resizable-wrapper");
              if (selectedResizableWrapper) {
                showResizeHandles(view2, selectedResizableWrapper);
              } else {
                hideResizeHandles();
              }
            }, 10);
          }
        },
        destroy() {
          hideResizeHandles();
          cleanupEventListeners();
          if (globalClickHandler) {
            document.removeEventListener("click", globalClickHandler);
            globalClickHandler = null;
          }
          if (globalMousedownHandler) {
            document.removeEventListener("mousedown", globalMousedownHandler);
            globalMousedownHandler = null;
          }
          if (scrollHandler) {
            window.removeEventListener("scroll", scrollHandler, true);
            scrollHandler = null;
          }
          editorView = null;
        }
      };
    }
  });
  function showResizeHandles(view, wrapper) {
    hideResizeHandles();
    const pos = Number.parseInt(wrapper.getAttribute("data-pos"), 10);
    const node2 = view.state.doc.nodeAt(pos);
    if (!nodeNames.includes(node2?.type.name)) return;
    currentWrapper = wrapper;
    resizeContainer = document.createElement("div");
    resizeContainer.className = "sd-editor-resize-container";
    resizeContainer.style.position = "absolute";
    resizeContainer.style.pointerEvents = "none";
    resizeContainer.style.zIndex = "1000";
    const handles = ["nw", "ne", "sw", "se"];
    for (const handle of handles) {
      const handleEl = document.createElement("div");
      handleEl.className = `sd-editor-resize-handle sd-editor-resize-handle-${handle}`;
      handleEl.setAttribute("data-handle", handle);
      handleEl.setAttribute("data-pos", pos);
      handleEl.style.pointerEvents = "auto";
      resizeContainer.appendChild(handleEl);
    }
    document.body.appendChild(resizeContainer);
    updateHandlePositions(wrapper.firstElementChild);
  }
  function hideResizeHandles() {
    if (resizeContainer?.parentNode) {
      resizeContainer.parentNode.removeChild(resizeContainer);
      resizeContainer = null;
    }
    currentWrapper = null;
  }
  function updateHandlePositions(resizableElement) {
    if (!resizeContainer || !resizableElement) return;
    const rect = resizableElement.getBoundingClientRect();
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
    resizeContainer.style.left = `${rect.left + scrollLeft}px`;
    resizeContainer.style.top = `${rect.top + scrollTop}px`;
    resizeContainer.style.width = `${rect.width}px`;
    resizeContainer.style.height = `${rect.height}px`;
  }
  function startResize(view, event, handleElement) {
    if (!view.hasFocus()) return;
    const handle = handleElement.getAttribute("data-handle");
    const pos = Number.parseInt(handleElement.getAttribute("data-pos"), 10);
    if (view.state.selection.from !== pos || !nodeNames.includes(view.state.selection.node?.type.name)) return;
    const resizableElement = view.nodeDOM(pos);
    if (!resizableElement) return;
    const rect = resizableElement.getBoundingClientRect();
    resizeState = {
      dragging: true,
      startX: event.clientX,
      startY: event.clientY,
      startWidth: rect.width,
      startHeight: rect.height,
      handle,
      pos,
      resizableElement,
      aspectRatio: rect.width / rect.height
    };
    document.addEventListener("mousemove", handleMouseMove2);
    document.addEventListener("mouseup", handleMouseUp);
    document.body.style.cursor = getResizeCursor(handle);
    document.body.style.userSelect = "none";
  }
  function handleMouseMove2(event) {
    if (!resizeState.dragging) return;
    event.preventDefault();
    event.stopPropagation();
    let deltaX = event.clientX - resizeState.startX;
    if (resizeState.handle.includes("w")) deltaX = -deltaX;
    const newWidth = Math.max(20, resizeState.startWidth + deltaX);
    if (resizeState.resizableElement) {
      resizeState.resizableElement.style.width = `${newWidth}px`;
      resizeState.resizableElement.style.height = "auto";
      updateHandlePositions(resizeState.resizableElement);
    }
  }
  function handleMouseUp(event) {
    if (!resizeState.dragging) return;
    cleanupEventListeners();
    let deltaX = event.clientX - resizeState.startX;
    if (resizeState.handle.includes("w")) deltaX = -deltaX;
    const newWidth = Math.max(20, resizeState.startWidth + deltaX);
    const newHeight = newWidth / resizeState.aspectRatio;
    if (editorView && resizeState.pos < editorView.state.doc.content.size) {
      const tr = editorView.state.tr;
      const node2 = tr.doc.nodeAt(resizeState.pos);
      if (nodeNames.includes(node2?.type.name)) {
        const attrs = {
          ...node2.attrs,
          size: {
            ...node2.attrs.size,
            width: Math.round(newWidth),
            height: Math.round(newHeight)
          }
        };
        tr.setNodeMarkup(resizeState.pos, null, attrs);
        tr.setMeta(NodeResizerKey, { action: "resize" });
        editorView.dispatch(tr);
      }
    }
    resizeState = {
      dragging: false,
      startX: 0,
      startY: 0,
      startWidth: 0,
      startHeight: 0,
      handle: null,
      pos: null,
      resizableElement: null,
      aspectRatio: 1
    };
  }
  function cleanupEventListeners() {
    document.removeEventListener("mousemove", handleMouseMove2);
    document.removeEventListener("mouseup", handleMouseUp);
    document.body.style.cursor = "";
    document.body.style.userSelect = "";
  }
  function getResizeCursor(handle) {
    switch (handle) {
      case "nw":
      case "se":
        return "nwse-resize";
      case "ne":
      case "sw":
        return "nesw-resize";
      default:
        return "default";
    }
  }
};
const NodeResizer = Extension.create({
  name: "nodeResizer",
  addPmPlugins() {
    const isHeadless = this.editor.options.isHeadless;
    const hasDocument = typeof document !== "undefined";
    if (isHeadless || !hasDocument) return [];
    return [nodeResizer(["image"], this.editor)];
  }
});
const getRichTextExtensions = () => {
  return [
    Bold,
    BulletList,
    Color,
    Document,
    FontFamily,
    FontSize,
    History,
    Heading,
    Italic,
    ListItem,
    LineHeight,
    Link,
    OrderedList,
    Paragraph,
    Strike,
    Text,
    TextAlign,
    TextIndent,
    TextStyle,
    Underline,
    Placeholder,
    PopoverPlugin,
    Mention,
    Highlight,
    FormatCommands,
    Table,
    TableRow,
    TableCell,
    TableHeader,
    FieldAnnotation,
    DropCursor,
    TrackInsert,
    TrackDelete,
    TrackFormat,
    AiPlugin,
    Image,
    NodeResizer,
    CustomSelection
  ];
};
const getStarterExtensions = () => {
  return [
    Bold,
    BlockNode,
    BulletList,
    Color,
    CommentRangeStart,
    CommentRangeEnd,
    CommentReference,
    Document,
    FontFamily,
    FontSize,
    History,
    Heading,
    Italic,
    ListItem,
    LineHeight,
    Link,
    OrderedList,
    Paragraph,
    LineBreak,
    HardBreak,
    RunItem,
    SlashMenu,
    Strike,
    TabNode,
    Text,
    TextAlign,
    TextIndent,
    TextStyle,
    Underline,
    FormatCommands,
    CommentsPlugin,
    Gapcursor,
    Table,
    TableRow,
    TableCell,
    TableHeader,
    FieldAnnotation,
    DropCursor,
    Image,
    BookmarkStart,
    Mention,
    Collaboration,
    CollaborationCursor,
    TrackChanges,
    TrackInsert,
    TrackDelete,
    TrackFormat,
    CommentsMark,
    Pagination,
    Highlight,
    LinkedStyles,
    AiPlugin,
    AiMark,
    AiAnimationMark,
    AiLoaderNode,
    PageNumber,
    TotalPageCount,
    ShapeContainer,
    ShapeTextbox,
    ContentBlock,
    Search,
    StructuredContent,
    StructuredContentBlock,
    DocumentSection,
    NodeResizer,
    CustomSelection,
    TextTransform
  ];
};
const sanitizeNumber = (value, defaultNumber) => {
  let sanitized = value.replace(/[^0-9.]/g, "");
  sanitized = parseFloat(sanitized);
  if (isNaN(sanitized)) sanitized = defaultNumber;
  sanitized = parseFloat(sanitized);
  return sanitized;
};
const throttle = (func, wait, options) => {
  let timeout2, context, args, result;
  let previous = 0;
  if (!options) options = {};
  const later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout2 = null;
    result = func.apply(context, args);
    if (!timeout2) context = args = null;
  };
  const throttled = function() {
    const _now = Date.now();
    if (!previous && options.leading === false) previous = _now;
    const remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      previous = _now;
      result = func.apply(context, args);
      if (!timeout2) context = args = null;
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function() {
    clearTimeout(timeout2);
    previous = 0;
    timeout2 = context = args = null;
  };
  return throttled;
};
const boldIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 46.3 14.3 32 32 32l48 0 16 0 128 0c70.7 0 128 57.3 128 128c0 31.3-11.3 60.1-30 82.3c37.1 22.4 62 63.1 62 109.7c0 70.7-57.3 128-128 128L96 480l-16 0-48 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l16 0 0-160L48 96 32 96C14.3 96 0 81.7 0 64zM224 224c35.3 0 64-28.7 64-64s-28.7-64-64-64L112 96l0 128 112 0zM112 288l0 128 144 0c35.3 0 64-28.7 64-64s-28.7-64-64-64l-32 0-112 0z"/></svg>';
const italicIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128 64c0-17.7 14.3-32 32-32l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-58.7 0L160 416l64 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l58.7 0L224 96l-64 0c-17.7 0-32-14.3-32-32z"/></svg>';
const underlineIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M16 64c0-17.7 14.3-32 32-32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-16 0 0 128c0 53 43 96 96 96s96-43 96-96l0-128-16 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-16 0 0 128c0 88.4-71.6 160-160 160s-160-71.6-160-160L64 96 48 96C30.3 96 16 81.7 16 64zM0 448c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32z"/></svg>';
const listIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M40 48C26.7 48 16 58.7 16 72l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24L40 48zM192 64c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L192 64zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zm0 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l288 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-288 0zM16 232l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0c-13.3 0-24 10.7-24 24zM40 368c-13.3 0-24 10.7-24 24l0 48c0 13.3 10.7 24 24 24l48 0c13.3 0 24-10.7 24-24l0-48c0-13.3-10.7-24-24-24l-48 0z"/></svg>';
const listOlIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M24 56c0-13.3 10.7-24 24-24l32 0c13.3 0 24 10.7 24 24l0 120 16 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-80 0c-13.3 0-24-10.7-24-24s10.7-24 24-24l16 0 0-96-8 0C34.7 80 24 69.3 24 56zM86.7 341.2c-6.5-7.4-18.3-6.9-24 1.2L51.5 357.9c-7.7 10.8-22.7 13.3-33.5 5.6s-13.3-22.7-5.6-33.5l11.1-15.6c23.7-33.2 72.3-35.6 99.2-4.9c21.3 24.4 20.8 60.9-1.1 84.7L86.8 432l33.2 0c13.3 0 24 10.7 24 24s-10.7 24-24 24l-88 0c-9.5 0-18.2-5.6-22-14.4s-2.1-18.9 4.3-25.9l72-78c5.3-5.8 5.4-14.6 .3-20.5zM224 64l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 160l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm0 160l256 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-256 0c-17.7 0-32-14.3-32-32s14.3-32 32-32z"/></svg>';
const imageIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 96C0 60.7 28.7 32 64 32l384 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zM323.8 202.5c-4.5-6.6-11.9-10.5-19.8-10.5s-15.4 3.9-19.8 10.5l-87 127.6L170.7 297c-4.6-5.7-11.5-9-18.7-9s-14.2 3.3-18.7 9l-64 80c-5.8 7.2-6.9 17.1-2.9 25.4s12.4 13.6 21.6 13.6l96 0 32 0 208 0c8.9 0 17.1-4.9 21.2-12.8s3.6-17.4-1.4-24.7l-120-176zM112 192a48 48 0 1 0 0-96 48 48 0 1 0 0 96z"/></svg>';
const linkIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M579.8 267.7c56.5-56.5 56.5-148 0-204.5c-50-50-128.8-56.5-186.3-15.4l-1.6 1.1c-14.4 10.3-17.7 30.3-7.4 44.6s30.3 17.7 44.6 7.4l1.6-1.1c32.1-22.9 76-19.3 103.8 8.6c31.5 31.5 31.5 82.5 0 114L422.3 334.8c-31.5 31.5-82.5 31.5-114 0c-27.9-27.9-31.5-71.8-8.6-103.8l1.1-1.6c10.3-14.4 6.9-34.4-7.4-44.6s-34.4-6.9-44.6 7.4l-1.1 1.6C206.5 251.2 213 330 263 380c56.5 56.5 148 56.5 204.5 0L579.8 267.7zM60.2 244.3c-56.5 56.5-56.5 148 0 204.5c50 50 128.8 56.5 186.3 15.4l1.6-1.1c14.4-10.3 17.7-30.3 7.4-44.6s-30.3-17.7-44.6-7.4l-1.6 1.1c-32.1 22.9-76 19.3-103.8-8.6C74 372 74 321 105.5 289.5L217.7 177.2c31.5-31.5 82.5-31.5 114 0c27.9 27.9 31.5 71.8 8.6 103.9l-1.1 1.6c-10.3 14.4-6.9 34.4 7.4 44.6s34.4 6.9 44.6-7.4l1.1-1.6C433.5 260.8 427 182 377 132c-56.5-56.5-148-56.5-204.5 0L60.2 244.3z"/></svg>';
const alignLeftIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M288 64c0 17.7-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l224 0c17.7 0 32 14.3 32 32zm0 256c0 17.7-14.3 32-32 32L32 352c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zM0 192c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 224c-17.7 0-32-14.3-32-32zM448 448c0 17.7-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"/></svg>';
const alignCenterIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M352 64c0-17.7-14.3-32-32-32L128 32c-17.7 0-32 14.3-32 32s14.3 32 32 32l192 0c17.7 0 32-14.3 32-32zm96 128c0-17.7-14.3-32-32-32L32 160c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32zM0 448c0 17.7 14.3 32 32 32l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 416c-17.7 0-32 14.3-32 32zM352 320c0-17.7-14.3-32-32-32l-192 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l192 0c17.7 0 32-14.3 32-32z"/></svg>';
const alignRightIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M448 64c0 17.7-14.3 32-32 32L192 96c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zm0 256c0 17.7-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32s14.3-32 32-32l224 0c17.7 0 32 14.3 32 32zM0 192c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 224c-17.7 0-32-14.3-32-32zM448 448c0 17.7-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32s14.3-32 32-32l384 0c17.7 0 32 14.3 32 32z"/></svg>';
const alignJustifyIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M448 64c0-17.7-14.3-32-32-32L32 32C14.3 32 0 46.3 0 64S14.3 96 32 96l384 0c17.7 0 32-14.3 32-32zm0 256c0-17.7-14.3-32-32-32L32 288c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32zM0 192c0 17.7 14.3 32 32 32l384 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L32 160c-17.7 0-32 14.3-32 32zM448 448c0-17.7-14.3-32-32-32L32 416c-17.7 0-32 14.3-32 32s14.3 32 32 32l384 0c17.7 0 32-14.3 32-32z"/></svg>';
const indentIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 46.3 14.3 32 32 32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64zM192 192c0-17.7 14.3-32 32-32l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32zm32 96l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zM0 448c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32zM127.8 268.6L25.8 347.9C15.3 356.1 0 348.6 0 335.3L0 176.7c0-13.3 15.3-20.8 25.8-12.6l101.9 79.3c8.2 6.4 8.2 18.9 0 25.3z"/></svg>';
const outdentIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 46.3 14.3 32 32 32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64zM192 192c0-17.7 14.3-32 32-32l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32zm32 96l192 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-192 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zM0 448c0-17.7 14.3-32 32-32l384 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 480c-17.7 0-32-14.3-32-32zM.2 268.6c-8.2-6.4-8.2-18.9 0-25.3l101.9-79.3c10.5-8.2 25.8-.7 25.8 12.6l0 158.6c0 13.3-15.3 20.8-25.8 12.6L.2 268.6z"/></svg>';
const paintRollerIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 28.7 28.7 0 64 0L352 0c35.3 0 64 28.7 64 64l0 64c0 35.3-28.7 64-64 64L64 192c-35.3 0-64-28.7-64-64L0 64zM160 352c0-17.7 14.3-32 32-32l0-16c0-44.2 35.8-80 80-80l144 0c17.7 0 32-14.3 32-32l0-32 0-90.5c37.3 13.2 64 48.7 64 90.5l0 32c0 53-43 96-96 96l-144 0c-8.8 0-16 7.2-16 16l0 16c17.7 0 32 14.3 32 32l0 128c0 17.7-14.3 32-32 32l-64 0c-17.7 0-32-14.3-32-32l0-128z"/></svg>';
const textSlashIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L355.7 253.5 400.2 96 503 96 497 120.2c-4.3 17.1 6.1 34.5 23.3 38.8s34.5-6.1 38.8-23.3l11-44.1C577.6 61.3 554.7 32 523.5 32L376.1 32l-.3 0L204.5 32c-22 0-41.2 15-46.6 36.4l-6.3 25.2L38.8 5.1zm168 131.7c.1-.3 .2-.7 .3-1L217 96l116.7 0L301.3 210.8l-94.5-74.1zM243.3 416L192 416c-17.7 0-32 14.3-32 32s14.3 32 32 32l160 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-42.2 0 17.6-62.1L272.9 311 243.3 416z"/></svg>';
const rotateLeftIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M48.5 224L40 224c-13.3 0-24-10.7-24-24L16 72c0-9.7 5.8-18.5 14.8-22.2s19.3-1.7 26.2 5.2L98.6 96.6c87.6-86.5 228.7-86.2 315.8 1c87.5 87.5 87.5 229.3 0 316.8s-229.3 87.5-316.8 0c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0c62.5 62.5 163.8 62.5 226.3 0s62.5-163.8 0-226.3c-62.2-62.2-162.7-62.5-225.3-1L185 183c6.9 6.9 8.9 17.2 5.2 26.2s-12.5 14.8-22.2 14.8L48.5 224z"/></svg>';
const rotateRightIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M463.5 224l8.5 0c13.3 0 24-10.7 24-24l0-128c0-9.7-5.8-18.5-14.8-22.2s-19.3-1.7-26.2 5.2L413.4 96.6c-87.6-86.5-228.7-86.2-315.8 1c-87.5 87.5-87.5 229.3 0 316.8s229.3 87.5 316.8 0c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0c-62.5 62.5-163.8 62.5-226.3 0s-62.5-163.8 0-226.3c62.2-62.2 162.7-62.5 225.3-1L327 183c-6.9 6.9-8.9 17.2-5.2 26.2s12.5 14.8 22.2 14.8l119.5 0z"/></svg>';
const calendarCheckIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128 0c17.7 0 32 14.3 32 32l0 32 128 0 0-32c0-17.7 14.3-32 32-32s32 14.3 32 32l0 32 48 0c26.5 0 48 21.5 48 48l0 48L0 160l0-48C0 85.5 21.5 64 48 64l48 0 0-32c0-17.7 14.3-32 32-32zM0 192l448 0 0 272c0 26.5-21.5 48-48 48L48 512c-26.5 0-48-21.5-48-48L0 192zM329 305c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-95 95-47-47c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l64 64c9.4 9.4 24.6 9.4 33.9 0L329 305z"/></svg>';
const calendarXmarkIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128 0c17.7 0 32 14.3 32 32l0 32 128 0 0-32c0-17.7 14.3-32 32-32s32 14.3 32 32l0 32 48 0c26.5 0 48 21.5 48 48l0 48L0 160l0-48C0 85.5 21.5 64 48 64l48 0 0-32c0-17.7 14.3-32 32-32zM0 192l448 0 0 272c0 26.5-21.5 48-48 48L48 512c-26.5 0-48-21.5-48-48L0 192zM305 305c9.4-9.4 9.4-24.6 0-33.9s-24.6-9.4-33.9 0l-47 47-47-47c-9.4-9.4-24.6-9.4-33.9 0s-9.4 24.6 0 33.9l47 47-47 47c-9.4 9.4-9.4 24.6 0 33.9s24.6 9.4 33.9 0l47-47 47 47c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-47-47 47-47z"/></svg>';
const listCheckIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M152.1 38.2c9.9 8.9 10.7 24 1.8 33.9l-72 80c-4.4 4.9-10.6 7.8-17.2 7.9s-12.9-2.4-17.6-7L7 113C-2.3 103.6-2.3 88.4 7 79s24.6-9.4 33.9 0l22.1 22.1 55.1-61.2c8.9-9.9 24-10.7 33.9-1.8zm0 160c9.9 8.9 10.7 24 1.8 33.9l-72 80c-4.4 4.9-10.6 7.8-17.2 7.9s-12.9-2.4-17.6-7L7 273c-9.4-9.4-9.4-24.6 0-33.9s24.6-9.4 33.9 0l22.1 22.1 55.1-61.2c8.9-9.9 24-10.7 33.9-1.8zM224 96c0-17.7 14.3-32 32-32l224 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32zm0 160c0-17.7 14.3-32 32-32l224 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-224 0c-17.7 0-32-14.3-32-32zM160 416c0-17.7 14.3-32 32-32l288 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-288 0c-17.7 0-32-14.3-32-32zM48 368a48 48 0 1 1 0 96 48 48 0 1 1 0-96z"/></svg>';
const userEditIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M224 256A128 128 0 1 0 224 0a128 128 0 1 0 0 256zm-45.7 48C79.8 304 0 383.8 0 482.3C0 498.7 13.3 512 29.7 512l293.1 0c-3.1-8.8-3.7-18.4-1.4-27.8l15-60.1c2.8-11.3 8.6-21.5 16.8-29.7l40.3-40.3c-32.1-31-75.7-50.1-123.9-50.1l-91.4 0zm435.5-68.3c-15.6-15.6-40.9-15.6-56.6 0l-29.4 29.4 71 71 29.4-29.4c15.6-15.6 15.6-40.9 0-56.6l-14.4-14.4zM375.9 417c-4.1 4.1-7 9.2-8.4 14.9l-15 60.1c-1.4 5.5 .2 11.2 4.2 15.2s9.7 5.6 15.2 4.2l60.1-15c5.6-1.4 10.8-4.3 14.9-8.4L576.1 358.7l-71-71L375.9 417z"/></svg>';
const eyeIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM144 256a144 144 0 1 1 288 0 144 144 0 1 1 -288 0zm144-64c0 35.3-28.7 64-64 64c-7.1 0-13.9-1.2-20.3-3.3c-5.5-1.8-11.9 1.6-11.7 7.4c.3 6.9 1.3 13.8 3.2 20.7c13.7 51.2 66.4 81.6 117.6 67.9s81.6-66.4 67.9-117.6c-11.1-41.5-47.8-69.4-88.6-71.1c-5.8-.2-9.2 6.1-7.4 11.7c2.1 6.4 3.3 13.2 3.3 20.3z"/></svg>';
const fileIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 64C0 28.7 28.7 0 64 0L224 0l0 128c0 17.7 14.3 32 32 32l128 0 0 288c0 35.3-28.7 64-64 64L64 512c-35.3 0-64-28.7-64-64L0 64zm384 64l-128 0L256 0 384 128z"/></svg>';
const fontIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M254 52.8C249.3 40.3 237.3 32 224 32s-25.3 8.3-30 20.8L57.8 416 32 416c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-1.8 0 18-48 159.6 0 18 48-1.8 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l96 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-25.8 0L254 52.8zM279.8 304l-111.6 0L224 155.1 279.8 304z"/></svg>';
const fileHalfDashedIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M64 0C28.7 0 0 28.7 0 64L0 320l384 0 0-160-128 0c-17.7 0-32-14.3-32-32L224 0 64 0zM256 0l0 128 128 0L256 0zM0 416l64 0 0-64L0 352l0 64zm288 32l-80 0 0 64 80 0 0-64zm-112 0l-80 0 0 64 80 0 0-64zM64 448L0 448c0 35.3 28.7 64 64 64l0-64zm256 0l0 64c35.3 0 64-28.7 64-64l-64 0zm64-32l0-64-64 0 0 64 64 0z"/></svg>';
const commentIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M512 240c0 114.9-114.6 208-256 208c-37.1 0-72.3-6.4-104.1-17.9c-11.9 8.7-31.3 20.6-54.3 30.6C73.6 471.1 44.7 480 16 480c-6.5 0-12.3-3.9-14.8-9.9c-2.5-6-1.1-12.8 3.4-17.4c0 0 0 0 0 0s0 0 0 0s0 0 0 0c0 0 0 0 0 0l.3-.3c.3-.3 .7-.7 1.3-1.4c1.1-1.2 2.8-3.1 4.9-5.7c4.1-5 9.6-12.4 15.2-21.6c10-16.6 19.5-38.4 21.4-62.9C17.7 326.8 0 285.1 0 240C0 125.1 114.6 32 256 32s256 93.1 256 208z"/></svg>';
const circleIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M256 512A256 256 0 1 0 256 0a256 256 0 1 0 0 512z"/></svg>';
const checkIconSvg$1 = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"/></svg>';
const xmarkIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M342.6 150.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L192 210.7 86.6 105.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L146.7 256 41.4 361.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L192 301.3 297.4 406.6c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L237.3 256 342.6 150.6z"/></svg>';
const upRightFromSquareIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M352 0c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9L370.7 96 201.4 265.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L416 141.3l41.4 41.4c9.2 9.2 22.9 11.9 34.9 6.9s19.8-16.6 19.8-29.6l0-128c0-17.7-14.3-32-32-32L352 0zM80 32C35.8 32 0 67.8 0 112L0 432c0 44.2 35.8 80 80 80l320 0c44.2 0 80-35.8 80-80l0-112c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 112c0 8.8-7.2 16-16 16L80 448c-8.8 0-16-7.2-16-16l0-320c0-8.8 7.2-16 16-16l112 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L80 32z"/></svg>';
const ellipsisVerticalIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M64 360a56 56 0 1 0 0 112 56 56 0 1 0 0-112zm0-160a56 56 0 1 0 0 112 56 56 0 1 0 0-112zM120 96A56 56 0 1 0 8 96a56 56 0 1 0 112 0z"/></svg>';
const caretUpIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M182.6 137.4c-12.5-12.5-32.8-12.5-45.3 0l-128 128c-9.2 9.2-11.9 22.9-6.9 34.9s16.6 19.8 29.6 19.8l256 0c12.9 0 24.6-7.8 29.6-19.8s2.2-25.7-6.9-34.9l-128-128z"/></svg>';
const caretDownIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M137.4 374.6c12.5 12.5 32.8 12.5 45.3 0l128-128c9.2-9.2 11.9-22.9 6.9-34.9s-16.6-19.8-29.6-19.8L32 192c-12.9 0-24.6 7.8-29.6 19.8s-2.2 25.7 6.9 34.9l128 128z"/></svg>';
const rulerSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M177.9 494.1c-18.7 18.7-49.1 18.7-67.9 0L17.9 401.9c-18.7-18.7-18.7-49.1 0-67.9l50.7-50.7 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 41.4-41.4 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 41.4-41.4 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 41.4-41.4 48 48c6.2 6.2 16.4 6.2 22.6 0s6.2-16.4 0-22.6l-48-48 50.7-50.7c18.7-18.7 49.1-18.7 67.9 0l92.1 92.1c18.7 18.7 18.7 49.1 0 67.9L177.9 494.1z"/></svg>';
const paintbrushSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M339.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L568.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S517.7-4.4 499.1 9.6L262.4 187.2c-24 18-38.2 46.1-38.4 76.1L339.3 367.1zm-19.6 25.4l-116-104.4C143.9 290.3 96 339.6 96 400c0 3.9 .2 7.8 .6 11.6C98.4 429.1 86.4 448 68.8 448L64 448c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg>';
const highlighterIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M315 315l158.4-215L444.1 70.6 229 229 315 315zm-187 5s0 0 0 0l0-71.7c0-15.3 7.2-29.6 19.5-38.6L420.6 8.4C428 2.9 437 0 446.2 0c11.4 0 22.4 4.5 30.5 12.6l54.8 54.8c8.1 8.1 12.6 19 12.6 30.5c0 9.2-2.9 18.2-8.4 25.6L334.4 396.5c-9 12.3-23.4 19.5-38.6 19.5L224 416l-25.4 25.4c-12.5 12.5-32.8 12.5-45.3 0l-50.7-50.7c-12.5-12.5-12.5-32.8 0-45.3L128 320zM7 466.3l63-63 70.6 70.6-31 31c-4.5 4.5-10.6 7-17 7L24 512c-13.3 0-24-10.7-24-24l0-4.7c0-6.4 2.5-12.5 7-17z"/></svg>\n';
const magicWandIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M224 96l16-32 32-16-32-16-16-32-16 32-32 16 32 16 16 32zM80 160l26.7-53.3L160 80l-53.3-26.7L80 0 53.3 53.3 0 80l53.3 26.7L80 160zm352 128l-26.7 53.3L352 368l53.3 26.7L432 448l26.7-53.3L512 368l-53.3-26.7L432 288zm70.6-193.8L417.8 9.4C411.5 3.1 403.3 0 395.2 0c-8.2 0-16.4 3.1-22.6 9.4L9.4 372.5c-12.5 12.5-12.5 32.8 0 45.3l84.9 84.9c6.3 6.3 14.4 9.4 22.6 9.4 8.2 0 16.4-3.1 22.6-9.4l363.1-363.2c12.5-12.5 12.5-32.8 0-45.2zM359.5 203.5l-50.9-50.9 86.6-86.6 50.9 50.9-86.6 86.6z"/></svg>';
const tableIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M64 256l0-96 160 0 0 96L64 256zm0 64l160 0 0 96L64 416l0-96zm224 96l0-96 160 0 0 96-160 0zM448 256l-160 0 0-96 160 0 0 96zM64 32C28.7 32 0 60.7 0 96L0 416c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-320c0-35.3-28.7-64-64-64L64 32z"/></svg>';
const tableColumnsIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M0 96C0 60.7 28.7 32 64 32l384 0c35.3 0 64 28.7 64 64l0 320c0 35.3-28.7 64-64 64L64 480c-35.3 0-64-28.7-64-64L0 96zm64 64l0 256 160 0 0-256L64 160zm384 0l-160 0 0 256 160 0 0-256z"/></svg>';
const arrowsLeftRightIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M406.6 374.6l96-96c12.5-12.5 12.5-32.8 0-45.3l-96-96c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L402.7 224l-293.5 0 41.4-41.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-96 96c-12.5 12.5-12.5 32.8 0 45.3l96 96c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 288l293.5 0-41.4 41.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0z"/></svg>';
const arrowsToDotIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M256 0c17.7 0 32 14.3 32 32l0 32 32 0c12.9 0 24.6 7.8 29.6 19.8s2.2 25.7-6.9 34.9l-64 64c-12.5 12.5-32.8 12.5-45.3 0l-64-64c-9.2-9.2-11.9-22.9-6.9-34.9s16.6-19.8 29.6-19.8l32 0 0-32c0-17.7 14.3-32 32-32zM169.4 393.4l64-64c12.5-12.5 32.8-12.5 45.3 0l64 64c9.2 9.2 11.9 22.9 6.9 34.9s-16.6 19.8-29.6 19.8l-32 0 0 32c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-32-32 0c-12.9 0-24.6-7.8-29.6-19.8s-2.2-25.7 6.9-34.9zM32 224l32 0 0-32c0-12.9 7.8-24.6 19.8-29.6s25.7-2.2 34.9 6.9l64 64c12.5 12.5 12.5 32.8 0 45.3l-64 64c-9.2 9.2-22.9 11.9-34.9 6.9s-19.8-16.6-19.8-29.6l0-32-32 0c-17.7 0-32-14.3-32-32s14.3-32 32-32zm297.4 54.6c-12.5-12.5-12.5-32.8 0-45.3l64-64c9.2-9.2 22.9-11.9 34.9-6.9s19.8 16.6 19.8 29.6l0 32 32 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-32 0 0 32c0 12.9-7.8 24.6-19.8 29.6s-25.7 2.2-34.9-6.9l-64-64zM256 224a32 32 0 1 1 0 64 32 32 0 1 1 0-64z"/></svg>';
const plusIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M256 80c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 144L48 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l144 0 0 144c0 17.7 14.3 32 32 32s32-14.3 32-32l0-144 144 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-144 0 0-144z"/></svg>';
const trashIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M135.2 17.7C140.6 6.8 151.7 0 163.8 0L284.2 0c12.1 0 23.2 6.8 28.6 17.7L320 32l96 0c17.7 0 32 14.3 32 32s-14.3 32-32 32L32 96C14.3 96 0 81.7 0 64S14.3 32 32 32l96 0 7.2-14.3zM32 128l384 0 0 320c0 35.3-28.7 64-64 64L96 512c-35.3 0-64-28.7-64-64l0-320zm96 64c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16zm96 0c-8.8 0-16 7.2-16 16l0 224c0 8.8 7.2 16 16 16s16-7.2 16-16l0-224c0-8.8-7.2-16-16-16z"/></svg>';
const wrenchIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M352 320c88.4 0 160-71.6 160-160c0-15.3-2.2-30.1-6.2-44.2c-3.1-10.8-16.4-13.2-24.3-5.3l-76.8 76.8c-3 3-7.1 4.7-11.3 4.7L336 192c-8.8 0-16-7.2-16-16l0-57.4c0-4.2 1.7-8.3 4.7-11.3l76.8-76.8c7.9-7.9 5.4-21.2-5.3-24.3C382.1 2.2 367.3 0 352 0C263.6 0 192 71.6 192 160c0 19.1 3.4 37.5 9.5 54.5L19.9 396.1C7.2 408.8 0 426.1 0 444.1C0 481.6 30.4 512 67.9 512c18 0 35.3-7.2 48-19.9L297.5 310.5c17 6.2 35.4 9.5 54.5 9.5zM80 408a24 24 0 1 1 0 48 24 24 0 1 1 0-48z"/></svg>';
const borderNoneIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M32 480a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm96-64a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0-384a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0 256a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM320 416a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0-320a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm0 128a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM224 480a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm0-448a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0 256a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM416 416a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm0-384a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM32 96a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM416 224a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM32 288a32 32 0 1 1 0-64 32 32 0 1 1 0 64zm192 32a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm192 64a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM32 320a32 32 0 1 1 0 64 32 32 0 1 1 0-64zM416 192a32 32 0 1 1 0-64 32 32 0 1 1 0 64zM32 128a32 32 0 1 1 0 64 32 32 0 1 1 0-64zm192 64a32 32 0 1 1 0-64 32 32 0 1 1 0 64z"/></svg>';
const upDownIconSvg = '<svg xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://www.w3.org/2000/svg" viewBox="3 4 18 16"><path stroke="#000000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 10V5m0 0L4 7m2-2 2 2m-2 7v5m0 0 2-2m-2 2-2-2m8-10h8m0 5h-8m0 5h8"></path></svg>\n';
const magnifyingGlassSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352a144 144 0 1 0 0-288 144 144 0 1 0 0 288z"/></svg>\n';
const scissorsIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M278.1 256L444.5 89.6c4.7-4.7 4.7-12.3 0-17-32.8-32.8-86-32.8-118.8 0L210.2 188.1l-24.9-24.9c4.3-10.9 6.7-22.8 6.7-35.3 0-53-43-96-96-96S0 75 0 128s43 96 96 96c4.5 0 9-.3 13.4-.9L142.3 256l-32.9 32.9c-4.4-.6-8.8-.9-13.4-.9-53 0-96 43-96 96s43 96 96 96 96-43 96-96c0-12.5-2.4-24.3-6.7-35.3l24.9-24.9L325.7 439.4c32.8 32.8 86 32.8 118.8 0 4.7-4.7 4.7-12.3 0-17L278.1 256zM96 160c-17.6 0-32-14.4-32-32s14.4-32 32-32 32 14.4 32 32-14.4 32-32 32zm0 256c-17.6 0-32-14.4-32-32s14.4-32 32-32 32 14.4 32 32-14.4 32-32 32z"/></svg>';
const copyIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M320 448v40c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V120c0-13.3 10.7-24 24-24h72v296c0 30.9 25.1 56 56 56h168zm0-344V0H152c-13.3 0-24 10.7-24 24v368c0 13.3 10.7 24 24 24h272c13.3 0 24-10.7 24-24V128H344c-13.2 0-24-10.8-24-24zm121-31L375 7A24 24 0 0 0 358.1 0H352v96h96v-6.1a24 24 0 0 0 -7-17z"/></svg>';
const pasteIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M128 184c0-30.9 25.1-56 56-56h136V56c0-13.3-10.7-24-24-24h-80.6C204.3 12.9 183.6 0 160 0s-44.3 12.9-55.4 32H24C10.7 32 0 42.7 0 56v336c0 13.3 10.7 24 24 24h104V184zm32-144c13.3 0 24 10.7 24 24s-10.7 24-24 24-24-10.7-24-24 10.7-24 24-24zm184 248h104v200c0 13.3-10.7 24-24 24H184c-13.3 0-24-10.7-24-24V184c0-13.3 10.7-24 24-24h136v104c0 13.2 10.8 24 24 24zm104-38.1V256h-96v-96h6.1a24 24 0 0 1 17 7l65.9 65.9a24 24 0 0 1 7 17z"/></svg>';
const strikethroughSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M161.3 144c3.2-17.2 14-30.1 33.7-38.6c21.1-9 51.8-12.3 88.6-6.5c11.9 1.9 48.8 9.1 60.1 12c17.1 4.5 34.6-5.6 39.2-22.7s-5.6-34.6-22.7-39.2c-14.3-3.8-53.6-11.4-66.6-13.4c-44.7-7-88.3-4.2-123.7 10.9c-36.5 15.6-64.4 44.8-71.8 87.3c-.1 .6-.2 1.1-.2 1.7c-2.8 23.9 .5 45.6 10.1 64.6c4.5 9 10.2 16.9 16.7 23.9L32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l448 0c17.7 0 32-14.3 32-32s-14.3-32-32-32l-209.9 0-.4-.1-1.1-.3c-36-10.8-65.2-19.6-85.2-33.1c-9.3-6.3-15-12.6-18.2-19.1c-3.1-6.1-5.2-14.6-3.8-27.4zM348.9 337.2c2.7 6.5 4.4 15.8 1.9 30.1c-3 17.6-13.8 30.8-33.9 39.4c-21.1 9-51.7 12.3-88.5 6.5c-18-2.9-49.1-13.5-74.4-22.1c-5.6-1.9-11-3.7-15.9-5.4c-16.8-5.6-34.9 3.5-40.5 20.3s3.5 34.9 20.3 40.5c3.6 1.2 7.9 2.7 12.7 4.3c0 0 0 0 0 0s0 0 0 0c24.9 8.5 63.6 21.7 87.6 25.6c0 0 0 0 0 0l.2 0c44.7 7 88.3 4.2 123.7-10.9c36.5-15.6 64.4-44.8 71.8-87.3c3.6-21 2.7-40.4-3.1-58.1l-75.7 0c7 5.6 11.4 11.2 13.9 17.2z"/></svg>\n';
const toolbarIcons = {
  undo: rotateLeftIconSvg,
  redo: rotateRightIconSvg,
  bold: boldIconSvg,
  italic: italicIconSvg,
  underline: underlineIconSvg,
  color: fontIconSvg,
  link: linkIconSvg,
  image: imageIconSvg,
  alignLeft: alignLeftIconSvg,
  alignRight: alignRightIconSvg,
  alignCenter: alignCenterIconSvg,
  alignJustify: alignJustifyIconSvg,
  bulletList: listIconSvg,
  numberedList: listOlIconSvg,
  indentLeft: outdentIconSvg,
  indentRight: indentIconSvg,
  pageBreak: fileHalfDashedIconSvg,
  copyFormat: paintRollerIconSvg,
  clearFormatting: textSlashIconSvg,
  trackChanges: listCheckIconSvg,
  trackChangesFinal: fileIconSvg,
  trackChangesOriginal: eyeIconSvg,
  trackChangesAccept: calendarCheckIconSvg,
  trackChangesReject: calendarXmarkIconSvg,
  documentMode: userEditIconSvg,
  documentEditingMode: userEditIconSvg,
  documentSuggestingMode: commentIconSvg,
  documentViewingMode: eyeIconSvg,
  colorOption: circleIconSvg,
  colorOptionCheck: checkIconSvg$1,
  linkInput: linkIconSvg,
  removeLink: xmarkIconSvg,
  openLink: upRightFromSquareIconSvg,
  overflow: ellipsisVerticalIconSvg,
  dropdownCaretUp: caretUpIconSvg,
  dropdownCaretDown: caretDownIconSvg,
  ruler: rulerSvg,
  paintbrush: paintbrushSvg,
  highlight: highlighterIcon,
  ai: magicWandIcon,
  table: tableIconSvg,
  tableActions: tableColumnsIconSvg,
  splitCell: arrowsLeftRightIconSvg,
  mergeCells: arrowsToDotIconSvg,
  addRowBefore: plusIconSvg,
  addRowAfter: plusIconSvg,
  addColumnBefore: plusIconSvg,
  addColumnAfter: plusIconSvg,
  deleteRow: trashIconSvg,
  deleteColumn: trashIconSvg,
  deleteTable: trashIconSvg,
  deleteBorders: borderNoneIconSvg,
  fixTables: wrenchIconSvg,
  lineHeight: upDownIconSvg,
  search: magnifyingGlassSvg,
  cut: scissorsIconSvg,
  copy: copyIconSvg,
  paste: pasteIconSvg,
  strikethrough: strikethroughSvg
};
const _hoisted_1$4$1 = { class: "toolbar-icon" };
const _hoisted_2$3$1 = ["innerHTML"];
const _sfc_main$5$1 = {
  __name: "ToolbarButtonIcon",
  props: {
    name: {
      type: String,
      required: true
    },
    color: {
      type: String,
      default: null
    },
    icon: {
      type: String,
      default: null
    }
  },
  setup(__props) {
    const props = __props;
    const getBarColor = vue.computed(() => {
      if (props.name === "color") return { backgroundColor: props.color || "#111111" };
      if (props.name === "highlight") return { backgroundColor: props.color || "#D6D6D6" };
    });
    const hasColorBar = vue.computed(() => {
      return ["color", "highlight"].includes(props.name);
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$4$1, [
        vue.createBaseVNode("div", {
          class: vue.normalizeClass(["toolbar-icon__icon", [`toolbar-icon__icon--${props.name}`]]),
          innerHTML: __props.icon
        }, null, 10, _hoisted_2$3$1),
        hasColorBar.value ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: "color-bar",
          style: vue.normalizeStyle(getBarColor.value)
        }, null, 4)) : vue.createCommentVNode("", true)
      ]);
    };
  }
};
const ToolbarButtonIcon = /* @__PURE__ */ _export_sfc(_sfc_main$5$1, [["__scopeId", "data-v-6d7523ab"]]);
const _hoisted_1$3$1 = ["role", "aria-label", "onKeydown"];
const _hoisted_2$2$1 = ["data-item"];
const _hoisted_3$2$1 = {
  key: 1,
  class: "button-label"
};
const _hoisted_4$1$1 = { key: 2 };
const _hoisted_5$4 = ["onKeydown", "id"];
const _hoisted_6$2 = ["placeholder", "onKeydown", "id"];
const _hoisted_7$1 = ["innerHTML"];
const _hoisted_8$1 = {
  "aria-live": "polite",
  class: "visually-hidden"
};
const _sfc_main$4$1 = {
  __name: "ToolbarButton",
  props: {
    iconColor: {
      type: String,
      default: null
    },
    active: {
      type: Boolean,
      default: false
    },
    isNarrow: {
      type: Boolean,
      default: false
    },
    isWide: {
      type: Boolean,
      default: false
    },
    toolbarItem: {
      type: Object,
      required: true
    },
    defaultLabel: {
      type: String,
      default: null
    },
    isOverflowItem: {
      type: Boolean,
      default: false
    }
  },
  emits: ["buttonClick", "textSubmit"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const {
      name,
      active,
      icon,
      label,
      hideLabel,
      iconColor,
      hasCaret,
      disabled,
      inlineTextInputVisible,
      hasInlineTextInput,
      minWidth,
      style: style2,
      attributes
    } = props.toolbarItem;
    const inlineTextInput = vue.ref(label);
    const inlineInput = vue.ref(null);
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const handleClick2 = () => {
      if (hasInlineTextInput) {
        vue.nextTick(() => {
          inlineInput.value?.focus();
          inlineInput.value?.select();
        });
      }
      emit("buttonClick");
    };
    const handleInputSubmit = () => {
      const value = inlineTextInput.value;
      const cleanValue = value.replace(/[^0-9]/g, "");
      emit("textSubmit", cleanValue);
      inlineTextInput.value = cleanValue;
    };
    const getStyle = vue.computed(() => {
      if (style2.value) return style2.value;
      return {
        minWidth: props.minWidth
      };
    });
    const caretIcon = vue.computed(() => {
      return active.value ? toolbarIcons.dropdownCaretUp : toolbarIcons.dropdownCaretDown;
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["toolbar-item", vue.unref(attributes).className]),
        style: vue.normalizeStyle(getStyle.value),
        role: __props.isOverflowItem ? "menuitem" : "button",
        "aria-label": vue.unref(attributes).ariaLabel,
        onClick: handleClick2,
        onKeydown: vue.withKeys(vue.withModifiers(handleClick2, ["stop"]), ["enter"]),
        tabindex: "0"
      }, [
        vue.createBaseVNode("div", {
          class: vue.normalizeClass(["toolbar-button", {
            active: vue.unref(active),
            disabled: vue.unref(disabled),
            narrow: __props.isNarrow,
            wide: __props.isWide,
            "has-inline-text-input": vue.unref(hasInlineTextInput),
            "high-contrast": vue.unref(isHighContrastMode2)
          }]),
          "data-item": `btn-${vue.unref(name) || ""}`
        }, [
          vue.unref(icon) ? (vue.openBlock(), vue.createBlock(ToolbarButtonIcon, {
            key: 0,
            color: vue.unref(iconColor),
            class: "toolbar-icon",
            icon: vue.unref(icon),
            name: vue.unref(name)
          }, null, 8, ["color", "icon", "name"])) : vue.createCommentVNode("", true),
          vue.unref(label) && !vue.unref(hideLabel) && !vue.unref(inlineTextInputVisible) ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$2$1, vue.toDisplayString(vue.unref(label)), 1)) : vue.createCommentVNode("", true),
          vue.unref(inlineTextInputVisible) ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_4$1$1, [
            vue.unref(name) === "fontSize" ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
              key: 0,
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => inlineTextInput.value = $event),
              onKeydown: vue.withKeys(vue.withModifiers(handleInputSubmit, ["prevent"]), ["enter"]),
              type: "text",
              class: vue.normalizeClass(["button-text-input", { "high-contrast": vue.unref(isHighContrastMode2) }]),
              id: "inlineTextInput-" + vue.unref(name),
              autocomplete: "off",
              ref_key: "inlineInput",
              ref: inlineInput
            }, null, 42, _hoisted_5$4)), [
              [vue.vModelText, inlineTextInput.value]
            ]) : vue.withDirectives((vue.openBlock(), vue.createElementBlock("input", {
              key: 1,
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => inlineTextInput.value = $event),
              placeholder: vue.unref(label),
              onKeydown: vue.withKeys(vue.withModifiers(handleInputSubmit, ["prevent"]), ["enter"]),
              type: "text",
              class: "button-text-input",
              id: "inlineTextInput-" + vue.unref(name),
              autocomplete: "off",
              ref_key: "inlineInput",
              ref: inlineInput
            }, null, 40, _hoisted_6$2)), [
              [vue.vModelText, inlineTextInput.value]
            ])
          ])) : vue.createCommentVNode("", true),
          vue.unref(hasCaret) ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 3,
            class: "dropdown-caret",
            innerHTML: caretIcon.value,
            style: vue.normalizeStyle({ opacity: vue.unref(disabled) ? 0.6 : 1 })
          }, null, 12, _hoisted_7$1)) : vue.createCommentVNode("", true),
          vue.createBaseVNode("div", _hoisted_8$1, vue.toDisplayString(`${vue.unref(attributes).ariaLabel} ${vue.unref(active) ? "selected" : "unset"}`), 1)
        ], 10, _hoisted_2$2$1)
      ], 46, _hoisted_1$3$1);
    };
  }
};
const ToolbarButton = /* @__PURE__ */ _export_sfc(_sfc_main$4$1, [["__scopeId", "data-v-303b3245"]]);
const _hoisted_1$2$1 = {
  class: "toolbar-separator",
  role: "separator",
  "aria-label": "Toolbar separator"
};
const _sfc_main$3$1 = {
  __name: "ToolbarSeparator",
  props: {
    active: {
      type: Boolean,
      default: false
    }
  },
  emits: ["command"],
  setup(__props, { emit: __emit }) {
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const getSeparatorColor = () => {
      if (isHighContrastMode2.value) {
        return "#000";
      }
      return "#dbdbdb";
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$2$1, [
        vue.createBaseVNode("div", {
          class: "separator-inner",
          style: vue.normalizeStyle({ backgroundColor: getSeparatorColor() })
        }, null, 4)
      ]);
    };
  }
};
const ToolbarSeparator = /* @__PURE__ */ _export_sfc(_sfc_main$3$1, [["__scopeId", "data-v-4ef9aa18"]]);
const _hoisted_1$1$1 = { class: "overflow-menu" };
const _hoisted_2$1$1 = { class: "overflow-menu-trigger" };
const _hoisted_3$1$1 = {
  key: 0,
  class: "overflow-menu_items",
  role: "group"
};
const _sfc_main$2$1 = {
  __name: "OverflowMenu",
  props: {
    toolbarItem: {
      type: Object,
      required: true
    },
    overflowItems: {
      type: Array,
      required: true
    }
  },
  emits: ["buttonClick"],
  setup(__props, { emit: __emit }) {
    const { proxy } = vue.getCurrentInstance();
    const emit = __emit;
    const props = __props;
    const isDropdownOpened = vue.computed(() => props.toolbarItem.expand.value);
    const overflowToolbarItem = vue.computed(() => ({
      ...props.toolbarItem,
      active: isDropdownOpened.value
    }));
    const toggleOverflowMenu = () => {
      emit("buttonClick", props.toolbarItem);
    };
    const handleCommand = ({ item, argument }) => {
      proxy.$toolbar.emitCommand({ item, argument });
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1$1, [
        vue.createBaseVNode("div", _hoisted_2$1$1, [
          vue.createVNode(ToolbarButton, {
            "toolbar-item": overflowToolbarItem.value,
            onButtonClick: toggleOverflowMenu
          }, null, 8, ["toolbar-item"])
        ]),
        isDropdownOpened.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$1$1, [
          vue.createVNode(ButtonGroup, {
            class: "superdoc-toolbar-overflow",
            "toolbar-items": __props.overflowItems,
            "from-overflow": "",
            onCommand: handleCommand
          }, null, 8, ["toolbar-items"])
        ])) : vue.createCommentVNode("", true)
      ]);
    };
  }
};
const OverflowMenu = /* @__PURE__ */ _export_sfc(_sfc_main$2$1, [["__scopeId", "data-v-8bf2f427"]]);
function plugin$1(options) {
  let _bPrefix = ".";
  let _ePrefix = "__";
  let _mPrefix = "--";
  let c2;
  if (options) {
    let t = options.blockPrefix;
    if (t) {
      _bPrefix = t;
    }
    t = options.elementPrefix;
    if (t) {
      _ePrefix = t;
    }
    t = options.modifierPrefix;
    if (t) {
      _mPrefix = t;
    }
  }
  const _plugin = {
    install(instance) {
      c2 = instance.c;
      const ctx2 = instance.context;
      ctx2.bem = {};
      ctx2.bem.b = null;
      ctx2.bem.els = null;
    }
  };
  function b2(arg) {
    let memorizedB;
    let memorizedE;
    return {
      before(ctx2) {
        memorizedB = ctx2.bem.b;
        memorizedE = ctx2.bem.els;
        ctx2.bem.els = null;
      },
      after(ctx2) {
        ctx2.bem.b = memorizedB;
        ctx2.bem.els = memorizedE;
      },
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        context.bem.b = arg;
        return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
      }
    };
  }
  function e(arg) {
    let memorizedE;
    return {
      before(ctx2) {
        memorizedE = ctx2.bem.els;
      },
      after(ctx2) {
        ctx2.bem.els = memorizedE;
      },
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        context.bem.els = arg.split(",").map((v2) => v2.trim());
        return context.bem.els.map((el) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el}`).join(", ");
      }
    };
  }
  function m2(arg) {
    return {
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        const modifiers2 = arg.split(",").map((v2) => v2.trim());
        function elementToSelector(el) {
          return modifiers2.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== void 0 ? `${_ePrefix}${el}` : ""}${_mPrefix}${modifier}`).join(", ");
        }
        const els = context.bem.els;
        if (els !== null) {
          if (process$1$1.env.NODE_ENV !== "production" && els.length >= 2) {
            throw Error(`[css-render/plugin-bem]: m(${arg}) is invalid, using modifier inside multiple elements is not allowed`);
          }
          return elementToSelector(els[0]);
        } else {
          return elementToSelector();
        }
      }
    };
  }
  function notM(arg) {
    return {
      $({ context, props }) {
        arg = typeof arg === "string" ? arg : arg({ context, props });
        const els = context.bem.els;
        if (process$1$1.env.NODE_ENV !== "production" && els !== null && els.length >= 2) {
          throw Error(`[css-render/plugin-bem]: notM(${arg}) is invalid, using modifier inside multiple elements is not allowed`);
        }
        return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
      }
    };
  }
  const cB2 = ((...args) => c2(b2(args[0]), args[1], args[2]));
  const cE2 = ((...args) => c2(e(args[0]), args[1], args[2]));
  const cM2 = ((...args) => c2(m2(args[0]), args[1], args[2]));
  const cNotM2 = ((...args) => c2(notM(args[0]), args[1], args[2]));
  Object.assign(_plugin, {
    cB: cB2,
    cE: cE2,
    cM: cM2,
    cNotM: cNotM2
  });
  return _plugin;
}
function ampCount(selector) {
  let cnt = 0;
  for (let i = 0; i < selector.length; ++i) {
    if (selector[i] === "&")
      ++cnt;
  }
  return cnt;
}
const separatorRegex = /\s*,(?![^(]*\))\s*/g;
const extraSpaceRegex = /\s+/g;
function resolveSelectorWithAmp(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    let round2 = ampCount(partialSelector);
    if (!round2) {
      amp.forEach((partialAmp) => {
        nextAmp.push(
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          (partialAmp && partialAmp + " ") + partialSelector
        );
      });
      return;
    } else if (round2 === 1) {
      amp.forEach((partialAmp) => {
        nextAmp.push(partialSelector.replace("&", partialAmp));
      });
      return;
    }
    let partialNextAmp = [
      partialSelector
    ];
    while (round2--) {
      const nextPartialNextAmp = [];
      partialNextAmp.forEach((selectorItr) => {
        amp.forEach((partialAmp) => {
          nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
        });
      });
      partialNextAmp = nextPartialNextAmp;
    }
    partialNextAmp.forEach((part) => nextAmp.push(part));
  });
  return nextAmp;
}
function resolveSelector(amp, selector) {
  const nextAmp = [];
  selector.split(separatorRegex).forEach((partialSelector) => {
    amp.forEach((partialAmp) => {
      nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
    });
  });
  return nextAmp;
}
function parseSelectorPath(selectorPaths) {
  let amp = [""];
  selectorPaths.forEach((selector) => {
    selector = selector && selector.trim();
    if (
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      !selector
    ) {
      return;
    }
    if (selector.includes("&")) {
      amp = resolveSelectorWithAmp(amp, selector);
    } else {
      amp = resolveSelector(amp, selector);
    }
  });
  return amp.join(", ").replace(extraSpaceRegex, " ");
}
function removeElement(el) {
  if (!el)
    return;
  const parentElement = el.parentElement;
  if (parentElement)
    parentElement.removeChild(el);
}
function queryElement(id, parent) {
  return (parent !== null && parent !== void 0 ? parent : document.head).querySelector(`style[cssr-id="${id}"]`);
}
function createElement(id) {
  const el = document.createElement("style");
  el.setAttribute("cssr-id", id);
  return el;
}
function isMediaOrSupports(selector) {
  if (!selector)
    return false;
  return /^\s*@(s|m)/.test(selector);
}
const kebabRegex = /[A-Z]/g;
function kebabCase(pattern) {
  return pattern.replace(kebabRegex, (match) => "-" + match.toLowerCase());
}
function unwrapProperty(prop, indent = "  ") {
  if (typeof prop === "object" && prop !== null) {
    return " {\n" + Object.entries(prop).map((v2) => {
      return indent + `  ${kebabCase(v2[0])}: ${v2[1]};`;
    }).join("\n") + "\n" + indent + "}";
  }
  return `: ${prop};`;
}
function unwrapProperties(props, instance, params2) {
  if (typeof props === "function") {
    return props({
      context: instance.context,
      props: params2
    });
  }
  return props;
}
function createStyle(selector, props, instance, params2) {
  if (!props)
    return "";
  const unwrappedProps = unwrapProperties(props, instance, params2);
  if (!unwrappedProps)
    return "";
  if (typeof unwrappedProps === "string") {
    return `${selector} {
${unwrappedProps}
}`;
  }
  const propertyNames = Object.keys(unwrappedProps);
  if (propertyNames.length === 0) {
    if (instance.config.keepEmptyBlock)
      return selector + " {\n}";
    return "";
  }
  const statements = selector ? [
    selector + " {"
  ] : [];
  propertyNames.forEach((propertyName) => {
    const property2 = unwrappedProps[propertyName];
    if (propertyName === "raw") {
      statements.push("\n" + property2 + "\n");
      return;
    }
    propertyName = kebabCase(propertyName);
    if (property2 !== null && property2 !== void 0) {
      statements.push(`  ${propertyName}${unwrapProperty(property2)}`);
    }
  });
  if (selector) {
    statements.push("}");
  }
  return statements.join("\n");
}
function loopCNodeListWithCallback(children, options, callback) {
  if (!children)
    return;
  children.forEach((child) => {
    if (Array.isArray(child)) {
      loopCNodeListWithCallback(child, options, callback);
    } else if (typeof child === "function") {
      const grandChildren = child(options);
      if (Array.isArray(grandChildren)) {
        loopCNodeListWithCallback(grandChildren, options, callback);
      } else if (grandChildren) {
        callback(grandChildren);
      }
    } else if (child) {
      callback(child);
    }
  });
}
function traverseCNode(node2, selectorPaths, styles, instance, params2) {
  const $2 = node2.$;
  let blockSelector = "";
  if (!$2 || typeof $2 === "string") {
    if (isMediaOrSupports($2)) {
      blockSelector = $2;
    } else {
      selectorPaths.push($2);
    }
  } else if (typeof $2 === "function") {
    const selector2 = $2({
      context: instance.context,
      props: params2
    });
    if (isMediaOrSupports(selector2)) {
      blockSelector = selector2;
    } else {
      selectorPaths.push(selector2);
    }
  } else {
    if ($2.before)
      $2.before(instance.context);
    if (!$2.$ || typeof $2.$ === "string") {
      if (isMediaOrSupports($2.$)) {
        blockSelector = $2.$;
      } else {
        selectorPaths.push($2.$);
      }
    } else if ($2.$) {
      const selector2 = $2.$({
        context: instance.context,
        props: params2
      });
      if (isMediaOrSupports(selector2)) {
        blockSelector = selector2;
      } else {
        selectorPaths.push(selector2);
      }
    }
  }
  const selector = parseSelectorPath(selectorPaths);
  const style2 = createStyle(selector, node2.props, instance, params2);
  if (blockSelector) {
    styles.push(`${blockSelector} {`);
  } else if (style2.length) {
    styles.push(style2);
  }
  if (node2.children) {
    loopCNodeListWithCallback(node2.children, {
      context: instance.context,
      props: params2
    }, (childNode) => {
      if (typeof childNode === "string") {
        const style3 = createStyle(selector, { raw: childNode }, instance, params2);
        styles.push(style3);
      } else {
        traverseCNode(childNode, selectorPaths, styles, instance, params2);
      }
    });
  }
  selectorPaths.pop();
  if (blockSelector) {
    styles.push("}");
  }
  if ($2 && $2.after)
    $2.after(instance.context);
}
function render$1(node2, instance, props) {
  const styles = [];
  traverseCNode(node2, [], styles, instance, props);
  return styles.join("\n\n");
}
function murmur2(str) {
  var h2 = 0;
  var k, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
    k ^= /* k >>> r: */
    k >>> 24;
    h2 = /* Math.imul(k, m): */
    (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
if (typeof window !== "undefined") {
  window.__cssrContext = {};
}
function unmount(instance, node2, id, parent) {
  const { els } = node2;
  if (id === void 0) {
    els.forEach(removeElement);
    node2.els = [];
  } else {
    const target = queryElement(id, parent);
    if (target && els.includes(target)) {
      removeElement(target);
      node2.els = els.filter((el) => el !== target);
    }
  }
}
function addElementToList(els, target) {
  els.push(target);
}
function mount(instance, node2, id, props, head, force, anchorMetaName, parent, ssrAdapter2) {
  let style2;
  if (id === void 0) {
    style2 = node2.render(props);
    id = murmur2(style2);
  }
  if (ssrAdapter2) {
    ssrAdapter2.adapter(id, style2 !== null && style2 !== void 0 ? style2 : node2.render(props));
    return;
  }
  if (parent === void 0) {
    parent = document.head;
  }
  const queriedTarget = queryElement(id, parent);
  if (queriedTarget !== null && !force) {
    return queriedTarget;
  }
  const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
  if (style2 === void 0)
    style2 = node2.render(props);
  target.textContent = style2;
  if (queriedTarget !== null)
    return queriedTarget;
  if (anchorMetaName) {
    const anchorMetaEl = parent.querySelector(`meta[name="${anchorMetaName}"]`);
    if (anchorMetaEl) {
      parent.insertBefore(target, anchorMetaEl);
      addElementToList(node2.els, target);
      return target;
    }
  }
  if (head) {
    parent.insertBefore(target, parent.querySelector("style, link"));
  } else {
    parent.appendChild(target);
  }
  addElementToList(node2.els, target);
  return target;
}
function wrappedRender(props) {
  return render$1(this, this.instance, props);
}
function wrappedMount(options = {}) {
  const { id, ssr, props, head = false, force = false, anchorMetaName, parent } = options;
  const targetElement = mount(this.instance, this, id, props, head, force, anchorMetaName, parent, ssr);
  return targetElement;
}
function wrappedUnmount(options = {}) {
  const { id, parent } = options;
  unmount(this.instance, this, id, parent);
}
const createCNode = function(instance, $2, props, children) {
  return {
    instance,
    $: $2,
    props,
    children,
    els: [],
    render: wrappedRender,
    mount: wrappedMount,
    unmount: wrappedUnmount
  };
};
const c$2 = function(instance, $2, props, children) {
  if (Array.isArray($2)) {
    return createCNode(instance, { $: null }, null, $2);
  } else if (Array.isArray(props)) {
    return createCNode(instance, $2, null, props);
  } else if (Array.isArray(children)) {
    return createCNode(instance, $2, props, children);
  } else {
    return createCNode(instance, $2, props, null);
  }
};
function CssRender(config = {}) {
  const cssr2 = {
    c: ((...args) => c$2(cssr2, ...args)),
    use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
    find: queryElement,
    context: {},
    config
  };
  return cssr2;
}
function exists(id, ssr) {
  if (id === void 0)
    return false;
  if (ssr) {
    const { context: { ids } } = ssr;
    return ids.has(id);
  }
  return queryElement(id) !== null;
}
const namespace = "n";
const prefix$1 = `.${namespace}-`;
const elementPrefix = "__";
const modifierPrefix = "--";
const cssr = CssRender();
const plugin = plugin$1({
  blockPrefix: prefix$1,
  elementPrefix,
  modifierPrefix
});
cssr.use(plugin);
const {
  c: c$1,
  find
} = cssr;
const {
  cB,
  cE,
  cM,
  cNotM
} = plugin;
const cCB = (...args) => {
  return c$1(">", [cB(...args)]);
};
function createKey(prefix2, suffix2) {
  return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
}
let onceCbs = [];
const paramsMap = /* @__PURE__ */ new WeakMap();
function flushOnceCallbacks() {
  onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));
  onceCbs = [];
}
function beforeNextFrameOnce(cb, ...params2) {
  paramsMap.set(cb, params2);
  if (onceCbs.includes(cb))
    return;
  onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
}
function happensIn(e, dataSetPropName) {
  let { target } = e;
  while (target) {
    if (target.dataset) {
      if (target.dataset[dataSetPropName] !== void 0)
        return true;
    }
    target = target.parentElement;
  }
  return false;
}
function getPreciseEventTarget(event) {
  return event.composedPath()[0] || null;
}
function depx(value) {
  if (typeof value === "string") {
    if (value.endsWith("px")) {
      return Number(value.slice(0, value.length - 2));
    }
    return Number(value);
  }
  return value;
}
function pxfy(value) {
  if (value === void 0 || value === null)
    return void 0;
  if (typeof value === "number")
    return `${value}px`;
  if (value.endsWith("px"))
    return value;
  return `${value}px`;
}
function getMargin(value, position) {
  const parts = value.trim().split(/\s+/g);
  const margin = {
    top: parts[0]
  };
  switch (parts.length) {
    case 1:
      margin.right = parts[0];
      margin.bottom = parts[0];
      margin.left = parts[0];
      break;
    case 2:
      margin.right = parts[1];
      margin.left = parts[1];
      margin.bottom = parts[0];
      break;
    case 3:
      margin.right = parts[1];
      margin.bottom = parts[2];
      margin.left = parts[1];
      break;
    case 4:
      margin.right = parts[1];
      margin.bottom = parts[2];
      margin.left = parts[3];
      break;
    default:
      throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
  }
  return margin;
}
const colors = {
  aliceblue: "#F0F8FF",
  antiquewhite: "#FAEBD7",
  aqua: "#0FF",
  aquamarine: "#7FFFD4",
  azure: "#F0FFFF",
  beige: "#F5F5DC",
  bisque: "#FFE4C4",
  black: "#000",
  blanchedalmond: "#FFEBCD",
  blue: "#00F",
  blueviolet: "#8A2BE2",
  brown: "#A52A2A",
  burlywood: "#DEB887",
  cadetblue: "#5F9EA0",
  chartreuse: "#7FFF00",
  chocolate: "#D2691E",
  coral: "#FF7F50",
  cornflowerblue: "#6495ED",
  cornsilk: "#FFF8DC",
  crimson: "#DC143C",
  cyan: "#0FF",
  darkblue: "#00008B",
  darkcyan: "#008B8B",
  darkgoldenrod: "#B8860B",
  darkgray: "#A9A9A9",
  darkgrey: "#A9A9A9",
  darkgreen: "#006400",
  darkkhaki: "#BDB76B",
  darkmagenta: "#8B008B",
  darkolivegreen: "#556B2F",
  darkorange: "#FF8C00",
  darkorchid: "#9932CC",
  darkred: "#8B0000",
  darksalmon: "#E9967A",
  darkseagreen: "#8FBC8F",
  darkslateblue: "#483D8B",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  darkturquoise: "#00CED1",
  darkviolet: "#9400D3",
  deeppink: "#FF1493",
  deepskyblue: "#00BFFF",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1E90FF",
  firebrick: "#B22222",
  floralwhite: "#FFFAF0",
  forestgreen: "#228B22",
  fuchsia: "#F0F",
  gainsboro: "#DCDCDC",
  ghostwhite: "#F8F8FF",
  gold: "#FFD700",
  goldenrod: "#DAA520",
  gray: "#808080",
  grey: "#808080",
  green: "#008000",
  greenyellow: "#ADFF2F",
  honeydew: "#F0FFF0",
  hotpink: "#FF69B4",
  indianred: "#CD5C5C",
  indigo: "#4B0082",
  ivory: "#FFFFF0",
  khaki: "#F0E68C",
  lavender: "#E6E6FA",
  lavenderblush: "#FFF0F5",
  lawngreen: "#7CFC00",
  lemonchiffon: "#FFFACD",
  lightblue: "#ADD8E6",
  lightcoral: "#F08080",
  lightcyan: "#E0FFFF",
  lightgoldenrodyellow: "#FAFAD2",
  lightgray: "#D3D3D3",
  lightgrey: "#D3D3D3",
  lightgreen: "#90EE90",
  lightpink: "#FFB6C1",
  lightsalmon: "#FFA07A",
  lightseagreen: "#20B2AA",
  lightskyblue: "#87CEFA",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#B0C4DE",
  lightyellow: "#FFFFE0",
  lime: "#0F0",
  limegreen: "#32CD32",
  linen: "#FAF0E6",
  magenta: "#F0F",
  maroon: "#800000",
  mediumaquamarine: "#66CDAA",
  mediumblue: "#0000CD",
  mediumorchid: "#BA55D3",
  mediumpurple: "#9370DB",
  mediumseagreen: "#3CB371",
  mediumslateblue: "#7B68EE",
  mediumspringgreen: "#00FA9A",
  mediumturquoise: "#48D1CC",
  mediumvioletred: "#C71585",
  midnightblue: "#191970",
  mintcream: "#F5FFFA",
  mistyrose: "#FFE4E1",
  moccasin: "#FFE4B5",
  navajowhite: "#FFDEAD",
  navy: "#000080",
  oldlace: "#FDF5E6",
  olive: "#808000",
  olivedrab: "#6B8E23",
  orange: "#FFA500",
  orangered: "#FF4500",
  orchid: "#DA70D6",
  palegoldenrod: "#EEE8AA",
  palegreen: "#98FB98",
  paleturquoise: "#AFEEEE",
  palevioletred: "#DB7093",
  papayawhip: "#FFEFD5",
  peachpuff: "#FFDAB9",
  peru: "#CD853F",
  pink: "#FFC0CB",
  plum: "#DDA0DD",
  powderblue: "#B0E0E6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#F00",
  rosybrown: "#BC8F8F",
  royalblue: "#4169E1",
  saddlebrown: "#8B4513",
  salmon: "#FA8072",
  sandybrown: "#F4A460",
  seagreen: "#2E8B57",
  seashell: "#FFF5EE",
  sienna: "#A0522D",
  silver: "#C0C0C0",
  skyblue: "#87CEEB",
  slateblue: "#6A5ACD",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#FFFAFA",
  springgreen: "#00FF7F",
  steelblue: "#4682B4",
  tan: "#D2B48C",
  teal: "#008080",
  thistle: "#D8BFD8",
  tomato: "#FF6347",
  turquoise: "#40E0D0",
  violet: "#EE82EE",
  wheat: "#F5DEB3",
  white: "#FFF",
  whitesmoke: "#F5F5F5",
  yellow: "#FF0",
  yellowgreen: "#9ACD32",
  transparent: "#0000"
};
function hsv2rgb(h2, s, v2) {
  s /= 100;
  v2 /= 100;
  let f = (n, k = (n + h2 / 60) % 6) => v2 - v2 * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5) * 255, f(3) * 255, f(1) * 255];
}
function hsl2rgb(h2, s, l3) {
  s /= 100;
  l3 /= 100;
  let a = s * Math.min(l3, 1 - l3);
  let f = (n, k = (n + h2 / 30) % 12) => l3 - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
  return [f(0) * 255, f(8) * 255, f(4) * 255];
}
const prefix = "^\\s*";
const suffix = "\\s*$";
const percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
const hex = "([0-9A-Fa-f])";
const dhex = "([0-9A-Fa-f]{2})";
const hslRegex = new RegExp(`${prefix}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
const hsvRegex = new RegExp(`${prefix}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
const hslaRegex = new RegExp(`${prefix}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
const hsvaRegex = new RegExp(`${prefix}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
const rgbRegex = new RegExp(`${prefix}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
const rgbaRegex = new RegExp(`${prefix}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
const sHexRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${suffix}`);
const hexRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${suffix}`);
const sHexaRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${hex}${suffix}`);
const hexaRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
function parseHex(value) {
  return parseInt(value, 16);
}
function hsla(color) {
  try {
    let i;
    if (i = hslaRegex.exec(color)) {
      return [
        roundDeg(i[1]),
        roundPercent(i[5]),
        roundPercent(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = hslRegex.exec(color)) {
      return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
    }
    throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function hsva(color) {
  try {
    let i;
    if (i = hsvaRegex.exec(color)) {
      return [
        roundDeg(i[1]),
        roundPercent(i[5]),
        roundPercent(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = hsvRegex.exec(color)) {
      return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
    }
    throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function rgba(color) {
  try {
    let i;
    if (i = hexRegex.exec(color)) {
      return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
    } else if (i = rgbRegex.exec(color)) {
      return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
    } else if (i = rgbaRegex.exec(color)) {
      return [
        roundChannel(i[1]),
        roundChannel(i[5]),
        roundChannel(i[9]),
        roundAlpha(i[13])
      ];
    } else if (i = sHexRegex.exec(color)) {
      return [
        parseHex(i[1] + i[1]),
        parseHex(i[2] + i[2]),
        parseHex(i[3] + i[3]),
        1
      ];
    } else if (i = hexaRegex.exec(color)) {
      return [
        parseHex(i[1]),
        parseHex(i[2]),
        parseHex(i[3]),
        roundAlpha(parseHex(i[4]) / 255)
      ];
    } else if (i = sHexaRegex.exec(color)) {
      return [
        parseHex(i[1] + i[1]),
        parseHex(i[2] + i[2]),
        parseHex(i[3] + i[3]),
        roundAlpha(parseHex(i[4] + i[4]) / 255)
      ];
    } else if (color in colors) {
      return rgba(colors[color]);
    } else if (hslRegex.test(color) || hslaRegex.test(color)) {
      const [h2, s, l3, a] = hsla(color);
      return [...hsl2rgb(h2, s, l3), a];
    } else if (hsvRegex.test(color) || hsvaRegex.test(color)) {
      const [h2, s, v2, a] = hsva(color);
      return [...hsv2rgb(h2, s, v2), a];
    }
    throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
  } catch (e) {
    throw e;
  }
}
function normalizeAlpha(alphaValue) {
  return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
}
function stringifyRgba(r2, g, b2, a) {
  return `rgba(${roundChannel(r2)}, ${roundChannel(g)}, ${roundChannel(b2)}, ${normalizeAlpha(a)})`;
}
function compositeChannel(v1, a1, v2, a2, a) {
  return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a);
}
function composite(background, overlay2) {
  if (!Array.isArray(background))
    background = rgba(background);
  if (!Array.isArray(overlay2))
    overlay2 = rgba(overlay2);
  const a1 = background[3];
  const a2 = overlay2[3];
  const alpha = roundAlpha(a1 + a2 - a1 * a2);
  return stringifyRgba(compositeChannel(background[0], a1, overlay2[0], a2, alpha), compositeChannel(background[1], a1, overlay2[1], a2, alpha), compositeChannel(background[2], a1, overlay2[2], a2, alpha), alpha);
}
function changeColor(base2, options) {
  const [r2, g, b2, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
  if (typeof options.alpha === "number") {
    return stringifyRgba(r2, g, b2, options.alpha);
  }
  return stringifyRgba(r2, g, b2, a);
}
function scaleColor(base2, options) {
  const [r2, g, b2, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
  const { lightness = 1, alpha = 1 } = options;
  return toRgbaString([r2 * lightness, g * lightness, b2 * lightness, a * alpha]);
}
function roundAlpha(value) {
  const v2 = Math.round(Number(value) * 100) / 100;
  if (v2 > 1)
    return 1;
  if (v2 < 0)
    return 0;
  return v2;
}
function roundDeg(value) {
  const v2 = Math.round(Number(value));
  if (v2 >= 360)
    return 0;
  if (v2 < 0)
    return 0;
  return v2;
}
function roundChannel(value) {
  const v2 = Math.round(Number(value));
  if (v2 > 255)
    return 255;
  if (v2 < 0)
    return 0;
  return v2;
}
function roundPercent(value) {
  const v2 = Math.round(Number(value));
  if (v2 > 100)
    return 100;
  if (v2 < 0)
    return 0;
  return v2;
}
function toRgbaString(base2) {
  const [r2, g, b2] = base2;
  if (3 in base2) {
    return `rgba(${roundChannel(r2)}, ${roundChannel(g)}, ${roundChannel(b2)}, ${roundAlpha(base2[3])})`;
  }
  return `rgba(${roundChannel(r2)}, ${roundChannel(g)}, ${roundChannel(b2)}, 1)`;
}
function createId(length2 = 8) {
  return Math.random().toString(16).slice(2, 2 + length2);
}
function repeat(count, v2) {
  const ret = [];
  for (let i = 0; i < count; ++i) {
    ret.push(v2);
  }
  return ret;
}
function getEventTarget(e) {
  const path = e.composedPath();
  return path[0];
}
const traps = {
  mousemoveoutside: /* @__PURE__ */ new WeakMap(),
  clickoutside: /* @__PURE__ */ new WeakMap()
};
function createTrapHandler(name, el, originalHandler) {
  if (name === "mousemoveoutside") {
    const moveHandler = (e) => {
      if (el.contains(getEventTarget(e)))
        return;
      originalHandler(e);
    };
    return {
      mousemove: moveHandler,
      touchstart: moveHandler
    };
  } else if (name === "clickoutside") {
    let mouseDownOutside = false;
    const downHandler = (e) => {
      mouseDownOutside = !el.contains(getEventTarget(e));
    };
    const upHanlder = (e) => {
      if (!mouseDownOutside)
        return;
      if (el.contains(getEventTarget(e)))
        return;
      originalHandler(e);
    };
    return {
      mousedown: downHandler,
      mouseup: upHanlder,
      touchstart: downHandler,
      touchend: upHanlder
    };
  }
  console.error(
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
  );
  return {};
}
function ensureTrapHandlers(name, el, handler) {
  const handlers2 = traps[name];
  let elHandlers = handlers2.get(el);
  if (elHandlers === void 0) {
    handlers2.set(el, elHandlers = /* @__PURE__ */ new WeakMap());
  }
  let trapHandler = elHandlers.get(handler);
  if (trapHandler === void 0) {
    elHandlers.set(handler, trapHandler = createTrapHandler(name, el, handler));
  }
  return trapHandler;
}
function trapOn(name, el, handler, options) {
  if (name === "mousemoveoutside" || name === "clickoutside") {
    const trapHandlers = ensureTrapHandlers(name, el, handler);
    Object.keys(trapHandlers).forEach((key) => {
      on(key, document, trapHandlers[key], options);
    });
    return true;
  }
  return false;
}
function trapOff(name, el, handler, options) {
  if (name === "mousemoveoutside" || name === "clickoutside") {
    const trapHandlers = ensureTrapHandlers(name, el, handler);
    Object.keys(trapHandlers).forEach((key) => {
      off(key, document, trapHandlers[key], options);
    });
    return true;
  }
  return false;
}
function createDelegate() {
  if (typeof window === "undefined") {
    return {
      on: () => {
      },
      off: () => {
      }
    };
  }
  const propagationStopped = /* @__PURE__ */ new WeakMap();
  const immediatePropagationStopped = /* @__PURE__ */ new WeakMap();
  function trackPropagation() {
    propagationStopped.set(this, true);
  }
  function trackImmediate() {
    propagationStopped.set(this, true);
    immediatePropagationStopped.set(this, true);
  }
  function spy(event, propName, fn2) {
    const source = event[propName];
    event[propName] = function() {
      fn2.apply(event, arguments);
      return source.apply(event, arguments);
    };
    return event;
  }
  function unspy(event, propName) {
    event[propName] = Event.prototype[propName];
  }
  const currentTargets = /* @__PURE__ */ new WeakMap();
  const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
  function getCurrentTarget() {
    var _a2;
    return (_a2 = currentTargets.get(this)) !== null && _a2 !== void 0 ? _a2 : null;
  }
  function defineCurrentTarget(event, getter) {
    if (currentTargetDescriptor === void 0)
      return;
    Object.defineProperty(event, "currentTarget", {
      configurable: true,
      enumerable: true,
      get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
    });
  }
  const phaseToTypeToElToHandlers = {
    bubble: {},
    capture: {}
  };
  const typeToWindowEventHandlers = {};
  function createUnifiedHandler() {
    const delegeteHandler = function(e) {
      const { type: type2, eventPhase, bubbles } = e;
      const target = getEventTarget(e);
      if (eventPhase === 2)
        return;
      const phase = eventPhase === 1 ? "capture" : "bubble";
      let cursor = target;
      const path = [];
      while (true) {
        if (cursor === null)
          cursor = window;
        path.push(cursor);
        if (cursor === window) {
          break;
        }
        cursor = cursor.parentNode || null;
      }
      const captureElToHandlers = phaseToTypeToElToHandlers.capture[type2];
      const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type2];
      spy(e, "stopPropagation", trackPropagation);
      spy(e, "stopImmediatePropagation", trackImmediate);
      defineCurrentTarget(e, getCurrentTarget);
      if (phase === "capture") {
        if (captureElToHandlers === void 0)
          return;
        for (let i = path.length - 1; i >= 0; --i) {
          if (propagationStopped.has(e))
            break;
          const target2 = path[i];
          const handlers2 = captureElToHandlers.get(target2);
          if (handlers2 !== void 0) {
            currentTargets.set(e, target2);
            for (const handler of handlers2) {
              if (immediatePropagationStopped.has(e))
                break;
              handler(e);
            }
          }
          if (i === 0 && !bubbles && bubbleElToHandlers !== void 0) {
            const bubbleHandlers = bubbleElToHandlers.get(target2);
            if (bubbleHandlers !== void 0) {
              for (const handler of bubbleHandlers) {
                if (immediatePropagationStopped.has(e))
                  break;
                handler(e);
              }
            }
          }
        }
      } else if (phase === "bubble") {
        if (bubbleElToHandlers === void 0)
          return;
        for (let i = 0; i < path.length; ++i) {
          if (propagationStopped.has(e))
            break;
          const target2 = path[i];
          const handlers2 = bubbleElToHandlers.get(target2);
          if (handlers2 !== void 0) {
            currentTargets.set(e, target2);
            for (const handler of handlers2) {
              if (immediatePropagationStopped.has(e))
                break;
              handler(e);
            }
          }
        }
      }
      unspy(e, "stopPropagation");
      unspy(e, "stopImmediatePropagation");
      defineCurrentTarget(e);
    };
    delegeteHandler.displayName = "evtdUnifiedHandler";
    return delegeteHandler;
  }
  function createUnifiedWindowEventHandler() {
    const delegateHandler = function(e) {
      const { type: type2, eventPhase } = e;
      if (eventPhase !== 2)
        return;
      const handlers2 = typeToWindowEventHandlers[type2];
      if (handlers2 === void 0)
        return;
      handlers2.forEach((handler) => handler(e));
    };
    delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
    return delegateHandler;
  }
  const unifiedHandler = createUnifiedHandler();
  const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
  function ensureElToHandlers(phase, type2) {
    const phaseHandlers = phaseToTypeToElToHandlers[phase];
    if (phaseHandlers[type2] === void 0) {
      phaseHandlers[type2] = /* @__PURE__ */ new Map();
      window.addEventListener(type2, unifiedHandler, phase === "capture");
    }
    return phaseHandlers[type2];
  }
  function ensureWindowEventHandlers(type2) {
    const windowEventHandlers = typeToWindowEventHandlers[type2];
    if (windowEventHandlers === void 0) {
      typeToWindowEventHandlers[type2] = /* @__PURE__ */ new Set();
      window.addEventListener(type2, unfiendWindowEventHandler);
    }
    return typeToWindowEventHandlers[type2];
  }
  function ensureHandlers(elToHandlers, el) {
    let elHandlers = elToHandlers.get(el);
    if (elHandlers === void 0) {
      elToHandlers.set(el, elHandlers = /* @__PURE__ */ new Set());
    }
    return elHandlers;
  }
  function handlerExist(el, phase, type2, handler) {
    const elToHandlers = phaseToTypeToElToHandlers[phase][type2];
    if (elToHandlers !== void 0) {
      const handlers2 = elToHandlers.get(el);
      if (handlers2 !== void 0) {
        if (handlers2.has(handler))
          return true;
      }
    }
    return false;
  }
  function windowEventHandlerExist(type2, handler) {
    const handlers2 = typeToWindowEventHandlers[type2];
    if (handlers2 !== void 0) {
      if (handlers2.has(handler)) {
        return true;
      }
    }
    return false;
  }
  function on2(type2, el, handler, options) {
    let mergedHandler;
    if (typeof options === "object" && options.once === true) {
      mergedHandler = (e) => {
        off2(type2, el, mergedHandler, options);
        handler(e);
      };
    } else {
      mergedHandler = handler;
    }
    const trapped = trapOn(type2, el, mergedHandler, options);
    if (trapped)
      return;
    const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
    const elToHandlers = ensureElToHandlers(phase, type2);
    const handlers2 = ensureHandlers(elToHandlers, el);
    if (!handlers2.has(mergedHandler))
      handlers2.add(mergedHandler);
    if (el === window) {
      const windowEventHandlers = ensureWindowEventHandlers(type2);
      if (!windowEventHandlers.has(mergedHandler)) {
        windowEventHandlers.add(mergedHandler);
      }
    }
  }
  function off2(type2, el, handler, options) {
    const trapped = trapOff(type2, el, handler, options);
    if (trapped)
      return;
    const capture = options === true || typeof options === "object" && options.capture === true;
    const phase = capture ? "capture" : "bubble";
    const elToHandlers = ensureElToHandlers(phase, type2);
    const handlers2 = ensureHandlers(elToHandlers, el);
    if (el === window) {
      const mirrorPhase = capture ? "bubble" : "capture";
      if (!handlerExist(el, mirrorPhase, type2, handler) && windowEventHandlerExist(type2, handler)) {
        const windowEventHandlers = typeToWindowEventHandlers[type2];
        windowEventHandlers.delete(handler);
        if (windowEventHandlers.size === 0) {
          window.removeEventListener(type2, unfiendWindowEventHandler);
          typeToWindowEventHandlers[type2] = void 0;
        }
      }
    }
    if (handlers2.has(handler))
      handlers2.delete(handler);
    if (handlers2.size === 0) {
      elToHandlers.delete(el);
    }
    if (elToHandlers.size === 0) {
      window.removeEventListener(type2, unifiedHandler, phase === "capture");
      phaseToTypeToElToHandlers[phase][type2] = void 0;
    }
  }
  return {
    on: on2,
    off: off2
  };
}
const { on, off } = createDelegate();
function useFalseUntilTruthy(originalRef) {
  const currentRef = vue.ref(!!originalRef.value);
  if (currentRef.value)
    return vue.readonly(currentRef);
  const stop = vue.watch(originalRef, (value) => {
    if (value) {
      currentRef.value = true;
      stop();
    }
  });
  return vue.readonly(currentRef);
}
function useMemo(getterOrOptions) {
  const computedValueRef = vue.computed(getterOrOptions);
  const valueRef = vue.ref(computedValueRef.value);
  vue.watch(computedValueRef, (value) => {
    valueRef.value = value;
  });
  if (typeof getterOrOptions === "function") {
    return valueRef;
  } else {
    return {
      __v_isRef: true,
      get value() {
        return valueRef.value;
      },
      set value(v2) {
        getterOrOptions.set(v2);
      }
    };
  }
}
function hasInstance() {
  return vue.getCurrentInstance() !== null;
}
const isBrowser$2 = typeof window !== "undefined";
let fontsReady;
let isFontReady;
const init = () => {
  var _a2, _b;
  fontsReady = isBrowser$2 ? (_b = (_a2 = document) === null || _a2 === void 0 ? void 0 : _a2.fonts) === null || _b === void 0 ? void 0 : _b.ready : void 0;
  isFontReady = false;
  if (fontsReady !== void 0) {
    void fontsReady.then(() => {
      isFontReady = true;
    });
  } else {
    isFontReady = true;
  }
};
init();
function onFontsReady(cb) {
  if (isFontReady)
    return;
  let deactivated = false;
  vue.onMounted(() => {
    if (!isFontReady) {
      fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
        if (deactivated)
          return;
        cb();
      });
    }
  });
  vue.onBeforeUnmount(() => {
    deactivated = true;
  });
}
function useMergedState(controlledStateRef, uncontrolledStateRef) {
  vue.watch(controlledStateRef, (value) => {
    if (value !== void 0) {
      uncontrolledStateRef.value = value;
    }
  });
  return vue.computed(() => {
    if (controlledStateRef.value === void 0) {
      return uncontrolledStateRef.value;
    }
    return controlledStateRef.value;
  });
}
function isMounted() {
  const isMounted2 = vue.ref(false);
  vue.onMounted(() => {
    isMounted2.value = true;
  });
  return vue.readonly(isMounted2);
}
function useCompitable(reactive2, keys2) {
  return vue.computed(() => {
    for (const key of keys2) {
      if (reactive2[key] !== void 0)
        return reactive2[key];
    }
    return reactive2[keys2[keys2.length - 1]];
  });
}
const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) && // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
!window.MSStream;
function useIsIos() {
  return isIos;
}
function useKeyboard(options = {}, enabledRef) {
  const state2 = vue.reactive({
    ctrl: false,
    command: false,
    win: false,
    shift: false,
    tab: false
  });
  const { keydown, keyup } = options;
  const keydownHandler2 = (e) => {
    switch (e.key) {
      case "Control":
        state2.ctrl = true;
        break;
      case "Meta":
        state2.command = true;
        state2.win = true;
        break;
      case "Shift":
        state2.shift = true;
        break;
      case "Tab":
        state2.tab = true;
        break;
    }
    if (keydown !== void 0) {
      Object.keys(keydown).forEach((key) => {
        if (key !== e.key)
          return;
        const handler = keydown[key];
        if (typeof handler === "function") {
          handler(e);
        } else {
          const { stop = false, prevent = false } = handler;
          if (stop)
            e.stopPropagation();
          if (prevent)
            e.preventDefault();
          handler.handler(e);
        }
      });
    }
  };
  const keyupHandler = (e) => {
    switch (e.key) {
      case "Control":
        state2.ctrl = false;
        break;
      case "Meta":
        state2.command = false;
        state2.win = false;
        break;
      case "Shift":
        state2.shift = false;
        break;
      case "Tab":
        state2.tab = false;
        break;
    }
    if (keyup !== void 0) {
      Object.keys(keyup).forEach((key) => {
        if (key !== e.key)
          return;
        const handler = keyup[key];
        if (typeof handler === "function") {
          handler(e);
        } else {
          const { stop = false, prevent = false } = handler;
          if (stop)
            e.stopPropagation();
          if (prevent)
            e.preventDefault();
          handler.handler(e);
        }
      });
    }
  };
  const setup = () => {
    if (enabledRef === void 0 || enabledRef.value) {
      on("keydown", document, keydownHandler2);
      on("keyup", document, keyupHandler);
    }
    if (enabledRef !== void 0) {
      vue.watch(enabledRef, (value) => {
        if (value) {
          on("keydown", document, keydownHandler2);
          on("keyup", document, keyupHandler);
        } else {
          off("keydown", document, keydownHandler2);
          off("keyup", document, keyupHandler);
        }
      });
    }
  };
  if (hasInstance()) {
    vue.onBeforeMount(setup);
    vue.onBeforeUnmount(() => {
      if (enabledRef === void 0 || enabledRef.value) {
        off("keydown", document, keydownHandler2);
        off("keyup", document, keyupHandler);
      }
    });
  } else {
    setup();
  }
  return vue.readonly(state2);
}
function createInjectionKey(key) {
  return key;
}
const internalSelectionMenuBodyInjectionKey = createInjectionKey("n-internal-select-menu-body");
const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
const modalBodyInjectionKey = createInjectionKey("n-modal-body");
const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
const teleportDisabled = "__disabled__";
function useAdjustedTo(props) {
  const modal = vue.inject(modalBodyInjectionKey, null);
  const drawer = vue.inject(drawerBodyInjectionKey, null);
  const popover = vue.inject(popoverBodyInjectionKey, null);
  const selectMenu = vue.inject(internalSelectionMenuBodyInjectionKey, null);
  const fullscreenElementRef = vue.ref();
  if (typeof document !== "undefined") {
    fullscreenElementRef.value = document.fullscreenElement;
    const handleFullscreenChange = () => {
      fullscreenElementRef.value = document.fullscreenElement;
    };
    vue.onMounted(() => {
      on("fullscreenchange", document, handleFullscreenChange);
    });
    vue.onBeforeUnmount(() => {
      off("fullscreenchange", document, handleFullscreenChange);
    });
  }
  return useMemo(() => {
    var _a2;
    const {
      to
    } = props;
    if (to !== void 0) {
      if (to === false) return teleportDisabled;
      if (to === true) return fullscreenElementRef.value || "body";
      return to;
    }
    if (modal === null || modal === void 0 ? void 0 : modal.value) {
      return (_a2 = modal.value.$el) !== null && _a2 !== void 0 ? _a2 : modal.value;
    }
    if (drawer === null || drawer === void 0 ? void 0 : drawer.value) return drawer.value;
    if (popover === null || popover === void 0 ? void 0 : popover.value) return popover.value;
    if (selectMenu === null || selectMenu === void 0 ? void 0 : selectMenu.value) return selectMenu.value;
    return to !== null && to !== void 0 ? to : fullscreenElementRef.value || "body";
  });
}
useAdjustedTo.tdkey = teleportDisabled;
useAdjustedTo.propTo = {
  type: [String, Object, Boolean],
  default: void 0
};
function useDeferredTrue(valueRef, delay, shouldDelayRef) {
  const delayedRef = vue.ref(valueRef.value);
  let timerId = null;
  vue.watch(valueRef, (value) => {
    if (timerId !== null) window.clearTimeout(timerId);
    if (value === true) {
      if (shouldDelayRef && !shouldDelayRef.value) {
        delayedRef.value = true;
      } else {
        timerId = window.setTimeout(() => {
          delayedRef.value = true;
        }, delay);
      }
    } else {
      delayedRef.value = false;
    }
  });
  return delayedRef;
}
const isBrowser$1 = typeof document !== "undefined" && typeof window !== "undefined";
let houdiniRegistered = false;
function useHoudini() {
  if (!isBrowser$1) return;
  if (!window.CSS) return;
  if (!houdiniRegistered) {
    houdiniRegistered = true;
    if ("registerProperty" in (window === null || window === void 0 ? void 0 : window.CSS)) {
      try {
        ;
        CSS.registerProperty({
          name: "--n-color-start",
          syntax: "<color>",
          inherits: false,
          initialValue: "#0000"
        });
        CSS.registerProperty({
          name: "--n-color-end",
          syntax: "<color>",
          inherits: false,
          initialValue: "#0000"
        });
      } catch (_a2) {
      }
    }
  }
}
function useReactivated(callback) {
  const isDeactivatedRef = {
    isDeactivated: false
  };
  let activateStateInitialized = false;
  vue.onActivated(() => {
    isDeactivatedRef.isDeactivated = false;
    if (!activateStateInitialized) {
      activateStateInitialized = true;
      return;
    }
    callback();
  });
  vue.onDeactivated(() => {
    isDeactivatedRef.isDeactivated = true;
    if (!activateStateInitialized) {
      activateStateInitialized = true;
    }
  });
  return isDeactivatedRef;
}
function getSlot(scope, slots, slotName = "default") {
  const slot = slots[slotName];
  if (slot === void 0) {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
  }
  return slot();
}
function flatten$2(vNodes, filterCommentNode = true, result = []) {
  vNodes.forEach((vNode) => {
    if (vNode === null)
      return;
    if (typeof vNode !== "object") {
      if (typeof vNode === "string" || typeof vNode === "number") {
        result.push(vue.createTextVNode(String(vNode)));
      }
      return;
    }
    if (Array.isArray(vNode)) {
      flatten$2(vNode, filterCommentNode, result);
      return;
    }
    if (vNode.type === vue.Fragment) {
      if (vNode.children === null)
        return;
      if (Array.isArray(vNode.children)) {
        flatten$2(vNode.children, filterCommentNode, result);
      }
    } else if (vNode.type !== vue.Comment) {
      result.push(vNode);
    }
  });
  return result;
}
function getFirstVNode(scope, slots, slotName = "default") {
  const slot = slots[slotName];
  if (slot === void 0) {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
  }
  const content = flatten$2(slot());
  if (content.length === 1) {
    return content[0];
  } else {
    throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);
  }
}
let viewMeasurer = null;
function ensureViewBoundingRect() {
  if (viewMeasurer === null) {
    viewMeasurer = document.getElementById("v-binder-view-measurer");
    if (viewMeasurer === null) {
      viewMeasurer = document.createElement("div");
      viewMeasurer.id = "v-binder-view-measurer";
      const { style: style2 } = viewMeasurer;
      style2.position = "fixed";
      style2.left = "0";
      style2.right = "0";
      style2.top = "0";
      style2.bottom = "0";
      style2.pointerEvents = "none";
      style2.visibility = "hidden";
      document.body.appendChild(viewMeasurer);
    }
  }
  return viewMeasurer.getBoundingClientRect();
}
function getPointRect(x, y2) {
  const viewRect = ensureViewBoundingRect();
  return {
    top: y2,
    left: x,
    height: 0,
    width: 0,
    right: viewRect.width - x,
    bottom: viewRect.height - y2
  };
}
function getRect(el) {
  const elRect = el.getBoundingClientRect();
  const viewRect = ensureViewBoundingRect();
  return {
    left: elRect.left - viewRect.left,
    top: elRect.top - viewRect.top,
    bottom: viewRect.height + viewRect.top - elRect.bottom,
    right: viewRect.width + viewRect.left - elRect.right,
    width: elRect.width,
    height: elRect.height
  };
}
function getParentNode(node2) {
  if (node2.nodeType === 9) {
    return null;
  }
  return node2.parentNode;
}
function getScrollParent(node2) {
  if (node2 === null)
    return null;
  const parentNode2 = getParentNode(node2);
  if (parentNode2 === null) {
    return null;
  }
  if (parentNode2.nodeType === 9) {
    return document;
  }
  if (parentNode2.nodeType === 1) {
    const { overflow, overflowX, overflowY } = getComputedStyle(parentNode2);
    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
      return parentNode2;
    }
  }
  return getScrollParent(parentNode2);
}
const Binder = vue.defineComponent({
  name: "Binder",
  props: {
    syncTargetWithParent: Boolean,
    syncTarget: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    var _a2;
    vue.provide("VBinder", (_a2 = vue.getCurrentInstance()) === null || _a2 === void 0 ? void 0 : _a2.proxy);
    const VBinder = vue.inject("VBinder", null);
    const targetRef = vue.ref(null);
    const setTargetRef = (el) => {
      targetRef.value = el;
      if (VBinder && props.syncTargetWithParent) {
        VBinder.setTargetRef(el);
      }
    };
    let scrollableNodes = [];
    const ensureScrollListener = () => {
      let cursor = targetRef.value;
      while (true) {
        cursor = getScrollParent(cursor);
        if (cursor === null)
          break;
        scrollableNodes.push(cursor);
      }
      for (const el of scrollableNodes) {
        on("scroll", el, onScroll, true);
      }
    };
    const removeScrollListeners = () => {
      for (const el of scrollableNodes) {
        off("scroll", el, onScroll, true);
      }
      scrollableNodes = [];
    };
    const followerScrollListeners = /* @__PURE__ */ new Set();
    const addScrollListener = (listener) => {
      if (followerScrollListeners.size === 0) {
        ensureScrollListener();
      }
      if (!followerScrollListeners.has(listener)) {
        followerScrollListeners.add(listener);
      }
    };
    const removeScrollListener = (listener) => {
      if (followerScrollListeners.has(listener)) {
        followerScrollListeners.delete(listener);
      }
      if (followerScrollListeners.size === 0) {
        removeScrollListeners();
      }
    };
    const onScroll = () => {
      beforeNextFrameOnce(onScrollRaf);
    };
    const onScrollRaf = () => {
      followerScrollListeners.forEach((listener) => listener());
    };
    const followerResizeListeners = /* @__PURE__ */ new Set();
    const addResizeListener = (listener) => {
      if (followerResizeListeners.size === 0) {
        on("resize", window, onResize);
      }
      if (!followerResizeListeners.has(listener)) {
        followerResizeListeners.add(listener);
      }
    };
    const removeResizeListener = (listener) => {
      if (followerResizeListeners.has(listener)) {
        followerResizeListeners.delete(listener);
      }
      if (followerResizeListeners.size === 0) {
        off("resize", window, onResize);
      }
    };
    const onResize = () => {
      followerResizeListeners.forEach((listener) => listener());
    };
    vue.onBeforeUnmount(() => {
      off("resize", window, onResize);
      removeScrollListeners();
    });
    return {
      targetRef,
      setTargetRef,
      addScrollListener,
      removeScrollListener,
      addResizeListener,
      removeResizeListener
    };
  },
  render() {
    return getSlot("binder", this.$slots);
  }
});
const VTarget = vue.defineComponent({
  name: "Target",
  setup() {
    const { setTargetRef, syncTarget } = vue.inject("VBinder");
    const setTargetDirective = {
      mounted: setTargetRef,
      updated: setTargetRef
    };
    return {
      syncTarget,
      setTargetDirective
    };
  },
  render() {
    const { syncTarget, setTargetDirective } = this;
    if (syncTarget) {
      return vue.withDirectives(getFirstVNode("follower", this.$slots), [
        [setTargetDirective]
      ]);
    }
    return getFirstVNode("follower", this.$slots);
  }
});
const ctxKey$1 = "@@mmoContext";
const mousemoveoutside = {
  mounted(el, { value }) {
    el[ctxKey$1] = {
      handler: void 0
    };
    if (typeof value === "function") {
      el[ctxKey$1].handler = value;
      on("mousemoveoutside", el, value);
    }
  },
  updated(el, { value }) {
    const ctx2 = el[ctxKey$1];
    if (typeof value === "function") {
      if (ctx2.handler) {
        if (ctx2.handler !== value) {
          off("mousemoveoutside", el, ctx2.handler);
          ctx2.handler = value;
          on("mousemoveoutside", el, value);
        }
      } else {
        el[ctxKey$1].handler = value;
        on("mousemoveoutside", el, value);
      }
    } else {
      if (ctx2.handler) {
        off("mousemoveoutside", el, ctx2.handler);
        ctx2.handler = void 0;
      }
    }
  },
  unmounted(el) {
    const { handler } = el[ctxKey$1];
    if (handler) {
      off("mousemoveoutside", el, handler);
    }
    el[ctxKey$1].handler = void 0;
  }
};
const ctxKey = "@@coContext";
const clickoutside = {
  mounted(el, { value, modifiers: modifiers2 }) {
    el[ctxKey] = {
      handler: void 0
    };
    if (typeof value === "function") {
      el[ctxKey].handler = value;
      on("clickoutside", el, value, {
        capture: modifiers2.capture
      });
    }
  },
  updated(el, { value, modifiers: modifiers2 }) {
    const ctx2 = el[ctxKey];
    if (typeof value === "function") {
      if (ctx2.handler) {
        if (ctx2.handler !== value) {
          off("clickoutside", el, ctx2.handler, {
            capture: modifiers2.capture
          });
          ctx2.handler = value;
          on("clickoutside", el, value, {
            capture: modifiers2.capture
          });
        }
      } else {
        el[ctxKey].handler = value;
        on("clickoutside", el, value, {
          capture: modifiers2.capture
        });
      }
    } else {
      if (ctx2.handler) {
        off("clickoutside", el, ctx2.handler, {
          capture: modifiers2.capture
        });
        ctx2.handler = void 0;
      }
    }
  },
  unmounted(el, { modifiers: modifiers2 }) {
    const { handler } = el[ctxKey];
    if (handler) {
      off("clickoutside", el, handler, {
        capture: modifiers2.capture
      });
    }
    el[ctxKey].handler = void 0;
  }
};
function warn$2(location2, message) {
  console.error(`[vdirs/${location2}]: ${message}`);
}
class ZIndexManager {
  constructor() {
    this.elementZIndex = /* @__PURE__ */ new Map();
    this.nextZIndex = 2e3;
  }
  get elementCount() {
    return this.elementZIndex.size;
  }
  ensureZIndex(el, zIndex) {
    const { elementZIndex } = this;
    if (zIndex !== void 0) {
      el.style.zIndex = `${zIndex}`;
      elementZIndex.delete(el);
      return;
    }
    const { nextZIndex } = this;
    if (elementZIndex.has(el)) {
      const currentZIndex = elementZIndex.get(el);
      if (currentZIndex + 1 === this.nextZIndex)
        return;
    }
    el.style.zIndex = `${nextZIndex}`;
    elementZIndex.set(el, nextZIndex);
    this.nextZIndex = nextZIndex + 1;
    this.squashState();
  }
  unregister(el, zIndex) {
    const { elementZIndex } = this;
    if (elementZIndex.has(el)) {
      elementZIndex.delete(el);
    } else if (zIndex === void 0) {
      warn$2("z-index-manager/unregister-element", "Element not found when unregistering.");
    }
    this.squashState();
  }
  squashState() {
    const { elementCount } = this;
    if (!elementCount) {
      this.nextZIndex = 2e3;
    }
    if (this.nextZIndex - elementCount > 2500)
      this.rearrange();
  }
  rearrange() {
    const elementZIndexPair = Array.from(this.elementZIndex.entries());
    elementZIndexPair.sort((pair1, pair2) => {
      return pair1[1] - pair2[1];
    });
    this.nextZIndex = 2e3;
    elementZIndexPair.forEach((pair) => {
      const el = pair[0];
      const zIndex = this.nextZIndex++;
      if (`${zIndex}` !== el.style.zIndex)
        el.style.zIndex = `${zIndex}`;
    });
  }
}
const zIndexManager = new ZIndexManager();
const ctx = "@@ziContext";
const zindexable = {
  mounted(el, bindings) {
    const { value = {} } = bindings;
    const { zIndex, enabled } = value;
    el[ctx] = {
      enabled: !!enabled,
      initialized: false
    };
    if (enabled) {
      zIndexManager.ensureZIndex(el, zIndex);
      el[ctx].initialized = true;
    }
  },
  updated(el, bindings) {
    const { value = {} } = bindings;
    const { zIndex, enabled } = value;
    const cachedEnabled = el[ctx].enabled;
    if (enabled && !cachedEnabled) {
      zIndexManager.ensureZIndex(el, zIndex);
      el[ctx].initialized = true;
    }
    el[ctx].enabled = !!enabled;
  },
  unmounted(el, bindings) {
    if (!el[ctx].initialized)
      return;
    const { value = {} } = bindings;
    const { zIndex } = value;
    zIndexManager.unregister(el, zIndex);
  }
};
const ssrContextKey = "@css-render/vue3-ssr";
function createStyleString(id, style2) {
  return `<style cssr-id="${id}">
${style2}
</style>`;
}
function ssrAdapter(id, style2, ssrContext) {
  const { styles, ids } = ssrContext;
  if (ids.has(id))
    return;
  if (styles !== null) {
    ids.add(id);
    styles.push(createStyleString(id, style2));
  }
}
const isBrowser = typeof document !== "undefined";
function useSsrAdapter() {
  if (isBrowser)
    return void 0;
  const context = vue.inject(ssrContextKey, null);
  if (context === null)
    return void 0;
  return {
    adapter: (id, style2) => ssrAdapter(id, style2, context),
    context
  };
}
function warn$1(location2, message) {
  console.error(`[vueuc/${location2}]: ${message}`);
}
const { c } = CssRender();
const cssrAnchorMetaName$1 = "vueuc-style";
function resolveTo(selector) {
  if (typeof selector === "string") {
    return document.querySelector(selector);
  }
  return selector();
}
const LazyTeleport = vue.defineComponent({
  name: "LazyTeleport",
  props: {
    to: {
      type: [String, Object],
      default: void 0
    },
    disabled: Boolean,
    show: {
      type: Boolean,
      required: true
    }
  },
  setup(props) {
    return {
      showTeleport: useFalseUntilTruthy(vue.toRef(props, "show")),
      mergedTo: vue.computed(() => {
        const { to } = props;
        return to !== null && to !== void 0 ? to : "body";
      })
    };
  },
  render() {
    return this.showTeleport ? this.disabled ? getSlot("lazy-teleport", this.$slots) : vue.h(vue.Teleport, {
      disabled: this.disabled,
      to: this.mergedTo
    }, getSlot("lazy-teleport", this.$slots)) : null;
  }
});
const oppositionPositions = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
const oppositeAligns = {
  start: "end",
  center: "center",
  end: "start"
};
const propToCompare = {
  top: "height",
  bottom: "height",
  left: "width",
  right: "width"
};
const transformOrigins = {
  "bottom-start": "top left",
  bottom: "top center",
  "bottom-end": "top right",
  "top-start": "bottom left",
  top: "bottom center",
  "top-end": "bottom right",
  "right-start": "top left",
  right: "center left",
  "right-end": "bottom left",
  "left-start": "top right",
  left: "center right",
  "left-end": "bottom right"
};
const overlapTransformOrigin = {
  "bottom-start": "bottom left",
  bottom: "bottom center",
  "bottom-end": "bottom right",
  "top-start": "top left",
  top: "top center",
  "top-end": "top right",
  "right-start": "top right",
  right: "center right",
  "right-end": "bottom right",
  "left-start": "top left",
  left: "center left",
  "left-end": "bottom left"
};
const oppositeAlignCssPositionProps = {
  "bottom-start": "right",
  "bottom-end": "left",
  "top-start": "right",
  "top-end": "left",
  "right-start": "bottom",
  "right-end": "top",
  "left-start": "bottom",
  "left-end": "top"
};
const keepOffsetDirection = {
  top: true,
  bottom: false,
  left: true,
  right: false
  // left--
};
const cssPositionToOppositeAlign = {
  top: "end",
  bottom: "start",
  left: "end",
  right: "start"
};
function getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, shift2, flip2, overlap) {
  if (!flip2 || overlap) {
    return { placement, top: 0, left: 0 };
  }
  const [position, align] = placement.split("-");
  let properAlign = align !== null && align !== void 0 ? align : "center";
  let properOffset = {
    top: 0,
    left: 0
  };
  const deriveOffset = (oppositeAlignCssSizeProp, alignCssPositionProp, offsetVertically2) => {
    let left2 = 0;
    let top2 = 0;
    const diff = followerRect[oppositeAlignCssSizeProp] - targetRect[alignCssPositionProp] - targetRect[oppositeAlignCssSizeProp];
    if (diff > 0 && shift2) {
      if (offsetVertically2) {
        top2 = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
      } else {
        left2 = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
      }
    }
    return {
      left: left2,
      top: top2
    };
  };
  const offsetVertically = position === "left" || position === "right";
  if (properAlign !== "center") {
    const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
    const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
    const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp];
    if (followerRect[oppositeAlignCssSizeProp] > targetRect[oppositeAlignCssSizeProp]) {
      if (
        // current space is not enough
        // ----------[ target ]---------|
        // -------[     follower        ]
        targetRect[oppositeAlignCssPositionProp] + targetRect[oppositeAlignCssSizeProp] < followerRect[oppositeAlignCssSizeProp]
      ) {
        const followerOverTargetSize = (followerRect[oppositeAlignCssSizeProp] - targetRect[oppositeAlignCssSizeProp]) / 2;
        if (targetRect[oppositeAlignCssPositionProp] < followerOverTargetSize || targetRect[currentAlignCssPositionProp] < followerOverTargetSize) {
          if (targetRect[oppositeAlignCssPositionProp] < targetRect[currentAlignCssPositionProp]) {
            properAlign = oppositeAligns[align];
            properOffset = deriveOffset(oppositeAlignCssSizeProp, currentAlignCssPositionProp, offsetVertically);
          } else {
            properOffset = deriveOffset(oppositeAlignCssSizeProp, oppositeAlignCssPositionProp, offsetVertically);
          }
        } else {
          properAlign = "center";
        }
      }
    } else if (followerRect[oppositeAlignCssSizeProp] < targetRect[oppositeAlignCssSizeProp]) {
      if (targetRect[currentAlignCssPositionProp] < 0 && // opposite align has larger space
      // ------------[   target   ]
      // ----------------[follower]
      targetRect[oppositeAlignCssPositionProp] > targetRect[currentAlignCssPositionProp]) {
        properAlign = oppositeAligns[align];
      }
    }
  } else {
    const possibleAlternativeAlignCssPositionProp1 = position === "bottom" || position === "top" ? "left" : "top";
    const possibleAlternativeAlignCssPositionProp2 = oppositionPositions[possibleAlternativeAlignCssPositionProp1];
    const alternativeAlignCssSizeProp = propToCompare[possibleAlternativeAlignCssPositionProp1];
    const followerOverTargetSize = (followerRect[alternativeAlignCssSizeProp] - targetRect[alternativeAlignCssSizeProp]) / 2;
    if (
      // center is not enough
      // ----------- [ target ]--|
      // -------[     follower     ]
      targetRect[possibleAlternativeAlignCssPositionProp1] < followerOverTargetSize || targetRect[possibleAlternativeAlignCssPositionProp2] < followerOverTargetSize
    ) {
      if (targetRect[possibleAlternativeAlignCssPositionProp1] > targetRect[possibleAlternativeAlignCssPositionProp2]) {
        properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp1];
        properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp1, offsetVertically);
      } else {
        properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp2];
        properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp2, offsetVertically);
      }
    }
  }
  let properPosition = position;
  if (
    // space is not enough
    targetRect[position] < followerRect[propToCompare[position]] && // opposite position's space is larger
    targetRect[position] < targetRect[oppositionPositions[position]]
  ) {
    properPosition = oppositionPositions[position];
  }
  return {
    placement: properAlign !== "center" ? `${properPosition}-${properAlign}` : properPosition,
    left: properOffset.left,
    top: properOffset.top
  };
}
function getProperTransformOrigin(placement, overlap) {
  if (overlap)
    return overlapTransformOrigin[placement];
  return transformOrigins[placement];
}
function getOffset(placement, offsetRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap) {
  if (overlap) {
    switch (placement) {
      case "bottom-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-100%)"
        };
      case "bottom-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "top-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: ""
        };
      case "top-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%)"
        };
      case "right-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%)"
        };
      case "right-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-100%)"
        };
      case "left-start":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: ""
        };
      case "left-end":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-100%)"
        };
      case "top":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
          transform: "translateX(-50%)"
        };
      case "right":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
          transform: "translateX(-100%) translateY(-50%)"
        };
      case "left":
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left)}px`,
          transform: "translateY(-50%)"
        };
      case "bottom":
      default:
        return {
          top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
          left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
          transform: "translateX(-50%) translateY(-100%)"
        };
    }
  }
  switch (placement) {
    case "bottom-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: ""
      };
    case "bottom-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%)"
      };
    case "top-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%)"
      };
    case "top-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%) translateY(-100%)"
      };
    case "right-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: ""
      };
    case "right-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%)"
      };
    case "left-start":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%)"
      };
    case "left-end":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-100%) translateY(-100%)"
      };
    case "top":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-100%) translateX(-50%)"
      };
    case "right":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-50%)"
      };
    case "left":
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
        transform: "translateY(-50%) translateX(-100%)"
      };
    case "bottom":
    default:
      return {
        top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
        left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
        transform: "translateX(-50%)"
      };
  }
}
const style$5 = c([
  c(".v-binder-follower-container", {
    position: "absolute",
    left: "0",
    right: "0",
    top: "0",
    height: "0",
    pointerEvents: "none",
    zIndex: "auto"
  }),
  c(".v-binder-follower-content", {
    position: "absolute",
    zIndex: "auto"
  }, [
    c("> *", {
      pointerEvents: "all"
    })
  ])
]);
const VFollower = vue.defineComponent({
  name: "Follower",
  inheritAttrs: false,
  props: {
    show: Boolean,
    enabled: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String,
      default: "bottom"
    },
    syncTrigger: {
      type: Array,
      default: ["resize", "scroll"]
    },
    to: [String, Object],
    flip: {
      type: Boolean,
      default: true
    },
    internalShift: Boolean,
    x: Number,
    y: Number,
    width: String,
    minWidth: String,
    containerClass: String,
    teleportDisabled: Boolean,
    zindexable: {
      type: Boolean,
      default: true
    },
    zIndex: Number,
    overlap: Boolean
  },
  setup(props) {
    const VBinder = vue.inject("VBinder");
    const mergedEnabledRef = useMemo(() => {
      return props.enabled !== void 0 ? props.enabled : props.show;
    });
    const followerRef = vue.ref(null);
    const offsetContainerRef = vue.ref(null);
    const ensureListeners2 = () => {
      const { syncTrigger } = props;
      if (syncTrigger.includes("scroll")) {
        VBinder.addScrollListener(syncPosition);
      }
      if (syncTrigger.includes("resize")) {
        VBinder.addResizeListener(syncPosition);
      }
    };
    const removeListeners = () => {
      VBinder.removeScrollListener(syncPosition);
      VBinder.removeResizeListener(syncPosition);
    };
    vue.onMounted(() => {
      if (mergedEnabledRef.value) {
        syncPosition();
        ensureListeners2();
      }
    });
    const ssrAdapter2 = useSsrAdapter();
    style$5.mount({
      id: "vueuc/binder",
      head: true,
      anchorMetaName: cssrAnchorMetaName$1,
      ssr: ssrAdapter2
    });
    vue.onBeforeUnmount(() => {
      removeListeners();
    });
    onFontsReady(() => {
      if (mergedEnabledRef.value) {
        syncPosition();
      }
    });
    const syncPosition = () => {
      if (!mergedEnabledRef.value) {
        return;
      }
      const follower = followerRef.value;
      if (follower === null)
        return;
      const target = VBinder.targetRef;
      const { x, y: y2, overlap } = props;
      const targetRect = x !== void 0 && y2 !== void 0 ? getPointRect(x, y2) : getRect(target);
      follower.style.setProperty("--v-target-width", `${Math.round(targetRect.width)}px`);
      follower.style.setProperty("--v-target-height", `${Math.round(targetRect.height)}px`);
      const { width, minWidth, placement, internalShift, flip: flip2 } = props;
      follower.setAttribute("v-placement", placement);
      if (overlap) {
        follower.setAttribute("v-overlap", "");
      } else {
        follower.removeAttribute("v-overlap");
      }
      const { style: style2 } = follower;
      if (width === "target") {
        style2.width = `${targetRect.width}px`;
      } else if (width !== void 0) {
        style2.width = width;
      } else {
        style2.width = "";
      }
      if (minWidth === "target") {
        style2.minWidth = `${targetRect.width}px`;
      } else if (minWidth !== void 0) {
        style2.minWidth = minWidth;
      } else {
        style2.minWidth = "";
      }
      const followerRect = getRect(follower);
      const offsetContainerRect = getRect(offsetContainerRef.value);
      const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip2, overlap);
      const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
      const { left: left2, top: top2, transform } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);
      follower.setAttribute("v-placement", properPlacement);
      follower.style.setProperty("--v-offset-left", `${Math.round(offsetLeftToStandardPlacement)}px`);
      follower.style.setProperty("--v-offset-top", `${Math.round(offsetTopToStandardPlacement)}px`);
      follower.style.transform = `translateX(${left2}) translateY(${top2}) ${transform}`;
      follower.style.setProperty("--v-transform-origin", properTransformOrigin);
      follower.style.transformOrigin = properTransformOrigin;
    };
    vue.watch(mergedEnabledRef, (value) => {
      if (value) {
        ensureListeners2();
        syncOnNextTick();
      } else {
        removeListeners();
      }
    });
    const syncOnNextTick = () => {
      vue.nextTick().then(syncPosition).catch((e) => console.error(e));
    };
    [
      "placement",
      "x",
      "y",
      "internalShift",
      "flip",
      "width",
      "overlap",
      "minWidth"
    ].forEach((prop) => {
      vue.watch(vue.toRef(props, prop), syncPosition);
    });
    ["teleportDisabled"].forEach((prop) => {
      vue.watch(vue.toRef(props, prop), syncOnNextTick);
    });
    vue.watch(vue.toRef(props, "syncTrigger"), (value) => {
      if (!value.includes("resize")) {
        VBinder.removeResizeListener(syncPosition);
      } else {
        VBinder.addResizeListener(syncPosition);
      }
      if (!value.includes("scroll")) {
        VBinder.removeScrollListener(syncPosition);
      } else {
        VBinder.addScrollListener(syncPosition);
      }
    });
    const isMountedRef = isMounted();
    const mergedToRef = useMemo(() => {
      const { to } = props;
      if (to !== void 0)
        return to;
      if (isMountedRef.value) {
        return void 0;
      }
      return void 0;
    });
    return {
      VBinder,
      mergedEnabled: mergedEnabledRef,
      offsetContainerRef,
      followerRef,
      mergedTo: mergedToRef,
      syncPosition
    };
  },
  render() {
    return vue.h(LazyTeleport, {
      show: this.show,
      to: this.mergedTo,
      disabled: this.teleportDisabled
    }, {
      default: () => {
        var _a2, _b;
        const vNode = vue.h("div", {
          class: ["v-binder-follower-container", this.containerClass],
          ref: "offsetContainerRef"
        }, [
          vue.h("div", {
            class: "v-binder-follower-content",
            ref: "followerRef"
          }, (_b = (_a2 = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a2))
        ]);
        if (this.zindexable) {
          return vue.withDirectives(vNode, [
            [
              zindexable,
              {
                enabled: this.mergedEnabled,
                zIndex: this.zIndex
              }
            ]
          ]);
        }
        return vNode;
      }
    });
  }
});
var resizeObservers = [];
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function(obj) {
  return Object.freeze(obj);
};
var ResizeObserverSize = /* @__PURE__ */ (function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
})();
var DOMRectReadOnly = (function() {
  function DOMRectReadOnly2(x, y2, width, height) {
    this.x = x;
    this.y = y2;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a2 = this, x = _a2.x, y2 = _a2.y, top2 = _a2.top, right2 = _a2.right, bottom2 = _a2.bottom, left2 = _a2.left, width = _a2.width, height = _a2.height;
    return { x, y: y2, top: top2, right: right2, bottom: bottom2, left: left2, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
})();
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a2 = target.getBBox(), width = _a2.width, height = _a2.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
  var _a2;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a2 = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};
var global = typeof window !== "undefined" ? window : {};
var cache = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global.navigator && global.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size(),
  borderBoxSize: size(),
  contentBoxSize: size(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache.has(target) && !forceRecalculation) {
    return cache.get(target);
  }
  if (isHidden(target)) {
    cache.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft + borderRight;
  var verticalBorderArea = borderTop + borderBottom;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a2 = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a2.borderBoxSize, contentBoxSize = _a2.contentBoxSize, devicePixelContentBoxSize = _a2.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};
var ResizeObserverEntry = /* @__PURE__ */ (function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
})();
var calculateDepthForNode = function(node2) {
  if (isHidden(node2)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node2.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot) {
      var entry = new ResizeObserverEntry(ot.target);
      var targetDepth = calculateDepthForNode(ot.target);
      entries.push(entry);
      ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot) {
      if (ot.isActive()) {
        if (calculateDepthForNode(ot.target) > depth) {
          ro.activeTargets.push(ot);
        } else {
          ro.skippedTargets.push(ot);
        }
      }
    });
  });
};
var process = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver2() {
    requestAnimationFrame(cb);
  });
};
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time = function(timeout2) {
  if (timeout2 === void 0) {
    timeout2 = 0;
  }
  return Date.now() + timeout2;
};
var scheduled = false;
var Scheduler = (function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout2) {
    var _this = this;
    if (timeout2 === void 0) {
      timeout2 = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time(timeout2);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process();
      } finally {
        scheduled = false;
        timeout2 = until - time();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout2 > 0) {
          _this.run(timeout2);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name) {
        return global.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name) {
        return global.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
})();
var scheduler = new Scheduler();
var updateCount = function(n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = (function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size2 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size2;
    }
    if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
})();
var ResizeObserverDetail = /* @__PURE__ */ (function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
})();
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i = 0; i < observationTargets.length; i += 1) {
    if (observationTargets[i].target === target) {
      return i;
    }
  }
  return -1;
};
var ResizeObserverController = (function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index2 = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index2 >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index2, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot) {
      return _this.unobserve(resizeObserver, ot.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
})();
var ResizeObserver$1 = (function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver2.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver2.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver2;
})();
class ResizeObserverDelegate {
  constructor() {
    this.handleResize = this.handleResize.bind(this);
    this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver$1)(this.handleResize);
    this.elHandlersMap = /* @__PURE__ */ new Map();
  }
  handleResize(entries) {
    for (const entry of entries) {
      const handler = this.elHandlersMap.get(entry.target);
      if (handler !== void 0) {
        handler(entry);
      }
    }
  }
  registerHandler(el, handler) {
    this.elHandlersMap.set(el, handler);
    this.observer.observe(el);
  }
  unregisterHandler(el) {
    if (!this.elHandlersMap.has(el)) {
      return;
    }
    this.elHandlersMap.delete(el);
    this.observer.unobserve(el);
  }
}
const resizeObserverManager = new ResizeObserverDelegate();
const VResizeObserver = vue.defineComponent({
  name: "ResizeObserver",
  props: {
    onResize: Function
  },
  setup(props) {
    let registered = false;
    const proxy = vue.getCurrentInstance().proxy;
    function handleResize(entry) {
      const { onResize } = props;
      if (onResize !== void 0)
        onResize(entry);
    }
    vue.onMounted(() => {
      const el = proxy.$el;
      if (el === void 0) {
        warn$1("resize-observer", "$el does not exist.");
        return;
      }
      if (el.nextElementSibling !== el.nextSibling) {
        if (el.nodeType === 3 && el.nodeValue !== "") {
          warn$1("resize-observer", "$el can not be observed (it may be a text node).");
          return;
        }
      }
      if (el.nextElementSibling !== null) {
        resizeObserverManager.registerHandler(el.nextElementSibling, handleResize);
        registered = true;
      }
    });
    vue.onBeforeUnmount(() => {
      if (registered) {
        resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
      }
    });
  },
  render() {
    return vue.renderSlot(this.$slots, "default");
  }
});
function isHTMLElement(node2) {
  return node2 instanceof HTMLElement;
}
function focusFirstDescendant(node2) {
  for (let i = 0; i < node2.childNodes.length; i++) {
    const child = node2.childNodes[i];
    if (isHTMLElement(child)) {
      if (attemptFocus(child) || focusFirstDescendant(child)) {
        return true;
      }
    }
  }
  return false;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child)) {
      if (attemptFocus(child) || focusLastDescendant(child)) {
        return true;
      }
    }
  }
  return false;
}
function attemptFocus(element) {
  if (!isFocusable(element)) {
    return false;
  }
  try {
    element.focus({ preventScroll: true });
  } catch (e) {
  }
  return document.activeElement === element;
}
function isFocusable(element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
    return true;
  }
  if (element.getAttribute("disabled")) {
    return false;
  }
  switch (element.nodeName) {
    case "A":
      return !!element.href && element.rel !== "ignore";
    case "INPUT":
      return element.type !== "hidden" && element.type !== "file";
    case "BUTTON":
    case "SELECT":
    case "TEXTAREA":
      return true;
    default:
      return false;
  }
}
let stack = [];
const FocusTrap = vue.defineComponent({
  name: "FocusTrap",
  props: {
    disabled: Boolean,
    active: Boolean,
    autoFocus: {
      type: Boolean,
      default: true
    },
    onEsc: Function,
    initialFocusTo: String,
    finalFocusTo: String,
    returnFocusOnDeactivated: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const id = createId();
    const focusableStartRef = vue.ref(null);
    const focusableEndRef = vue.ref(null);
    let activated = false;
    let ignoreInternalFocusChange = false;
    const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
    function isCurrentActive() {
      const currentActiveId = stack[stack.length - 1];
      return currentActiveId === id;
    }
    function handleDocumentKeydown(e) {
      var _a2;
      if (e.code === "Escape") {
        if (isCurrentActive()) {
          (_a2 = props.onEsc) === null || _a2 === void 0 ? void 0 : _a2.call(props, e);
        }
      }
    }
    vue.onMounted(() => {
      vue.watch(() => props.active, (value) => {
        if (value) {
          activate();
          on("keydown", document, handleDocumentKeydown);
        } else {
          off("keydown", document, handleDocumentKeydown);
          if (activated) {
            deactivate();
          }
        }
      }, {
        immediate: true
      });
    });
    vue.onBeforeUnmount(() => {
      off("keydown", document, handleDocumentKeydown);
      if (activated)
        deactivate();
    });
    function handleDocumentFocus(e) {
      if (ignoreInternalFocusChange)
        return;
      if (isCurrentActive()) {
        const mainEl = getMainEl();
        if (mainEl === null)
          return;
        if (mainEl.contains(getPreciseEventTarget(e)))
          return;
        resetFocusTo("first");
      }
    }
    function getMainEl() {
      const focusableStartEl = focusableStartRef.value;
      if (focusableStartEl === null)
        return null;
      let mainEl = focusableStartEl;
      while (true) {
        mainEl = mainEl.nextSibling;
        if (mainEl === null)
          break;
        if (mainEl instanceof Element && mainEl.tagName === "DIV") {
          break;
        }
      }
      return mainEl;
    }
    function activate() {
      var _a2;
      if (props.disabled)
        return;
      stack.push(id);
      if (props.autoFocus) {
        const { initialFocusTo } = props;
        if (initialFocusTo === void 0) {
          resetFocusTo("first");
        } else {
          (_a2 = resolveTo(initialFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
        }
      }
      activated = true;
      document.addEventListener("focus", handleDocumentFocus, true);
    }
    function deactivate() {
      var _a2;
      if (props.disabled)
        return;
      document.removeEventListener("focus", handleDocumentFocus, true);
      stack = stack.filter((idInStack) => idInStack !== id);
      if (isCurrentActive())
        return;
      const { finalFocusTo } = props;
      if (finalFocusTo !== void 0) {
        (_a2 = resolveTo(finalFocusTo)) === null || _a2 === void 0 ? void 0 : _a2.focus({ preventScroll: true });
      } else if (props.returnFocusOnDeactivated) {
        if (lastFocusedElement instanceof HTMLElement) {
          ignoreInternalFocusChange = true;
          lastFocusedElement.focus({ preventScroll: true });
          ignoreInternalFocusChange = false;
        }
      }
    }
    function resetFocusTo(target) {
      if (!isCurrentActive())
        return;
      if (props.active) {
        const focusableStartEl = focusableStartRef.value;
        const focusableEndEl = focusableEndRef.value;
        if (focusableStartEl !== null && focusableEndEl !== null) {
          const mainEl = getMainEl();
          if (mainEl == null || mainEl === focusableEndEl) {
            ignoreInternalFocusChange = true;
            focusableStartEl.focus({ preventScroll: true });
            ignoreInternalFocusChange = false;
            return;
          }
          ignoreInternalFocusChange = true;
          const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
          ignoreInternalFocusChange = false;
          if (!focused) {
            ignoreInternalFocusChange = true;
            focusableStartEl.focus({ preventScroll: true });
            ignoreInternalFocusChange = false;
          }
        }
      }
    }
    function handleStartFocus(e) {
      if (ignoreInternalFocusChange)
        return;
      const mainEl = getMainEl();
      if (mainEl === null)
        return;
      if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
        resetFocusTo("last");
      } else {
        resetFocusTo("first");
      }
    }
    function handleEndFocus(e) {
      if (ignoreInternalFocusChange)
        return;
      if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
        resetFocusTo("last");
      } else {
        resetFocusTo("first");
      }
    }
    return {
      focusableStartRef,
      focusableEndRef,
      focusableStyle: "position: absolute; height: 0; width: 0;",
      handleStartFocus,
      handleEndFocus
    };
  },
  render() {
    const { default: defaultSlot } = this.$slots;
    if (defaultSlot === void 0)
      return null;
    if (this.disabled)
      return defaultSlot();
    const { active, focusableStyle } = this;
    return vue.h(vue.Fragment, null, [
      vue.h("div", {
        "aria-hidden": "true",
        tabindex: active ? "0" : "-1",
        ref: "focusableStartRef",
        style: focusableStyle,
        onFocus: this.handleStartFocus
      }),
      defaultSlot(),
      vue.h("div", {
        "aria-hidden": "true",
        style: focusableStyle,
        ref: "focusableEndRef",
        tabindex: active ? "0" : "-1",
        onFocus: this.handleEndFocus
      })
    ]);
  }
});
const pureNumberRegex = /^(\d|\.)+$/;
const numberRegex = /(\d|\.)+/;
function formatLength(length2, {
  c: c2 = 1,
  offset: offset2 = 0,
  attachPx = true
} = {}) {
  if (typeof length2 === "number") {
    const result = (length2 + offset2) * c2;
    if (result === 0) return "0";
    return `${result}px`;
  } else if (typeof length2 === "string") {
    if (pureNumberRegex.test(length2)) {
      const result = (Number(length2) + offset2) * c2;
      if (attachPx) {
        if (result === 0) return "0";
        return `${result}px`;
      } else {
        return `${result}`;
      }
    } else {
      const result = numberRegex.exec(length2);
      if (!result) return length2;
      return length2.replace(numberRegex, String((Number(result[0]) + offset2) * c2));
    }
  }
  return length2;
}
function rtlInset(inset) {
  const {
    left: left2,
    right: right2,
    top: top2,
    bottom: bottom2
  } = getMargin(inset);
  return `${top2} ${left2} ${bottom2} ${right2}`;
}
let _isJsdom;
function isJsdom() {
  if (_isJsdom === void 0) {
    _isJsdom = navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
  }
  return _isJsdom;
}
const warnedMessages = /* @__PURE__ */ new Set();
function warnOnce(location2, message) {
  const mergedMessage = `[naive/${location2}]: ${message}`;
  if (warnedMessages.has(mergedMessage)) return;
  warnedMessages.add(mergedMessage);
  console.error(mergedMessage);
}
function warn(location2, message) {
  console.error(`[naive/${location2}]: ${message}`);
}
function throwError(location2, message) {
  throw new Error(`[naive/${location2}]: ${message}`);
}
function call(funcs, ...args) {
  if (Array.isArray(funcs)) {
    funcs.forEach((func) => call(func, ...args));
  } else {
    return funcs(...args);
  }
}
function createRefSetter(ref2) {
  return (inst) => {
    if (inst) {
      ref2.value = inst.$el;
    } else {
      ref2.value = null;
    }
  };
}
function flatten$1(vNodes, filterCommentNode = true, result = []) {
  vNodes.forEach((vNode) => {
    if (vNode === null) return;
    if (typeof vNode !== "object") {
      if (typeof vNode === "string" || typeof vNode === "number") {
        result.push(vue.createTextVNode(String(vNode)));
      }
      return;
    }
    if (Array.isArray(vNode)) {
      flatten$1(vNode, filterCommentNode, result);
      return;
    }
    if (vNode.type === vue.Fragment) {
      if (vNode.children === null) return;
      if (Array.isArray(vNode.children)) {
        flatten$1(vNode.children, filterCommentNode, result);
      }
    } else {
      if (vNode.type === vue.Comment && filterCommentNode) return;
      result.push(vNode);
    }
  });
  return result;
}
function getFirstSlotVNode(slots, slotName = "default", props = void 0) {
  const slot = slots[slotName];
  if (!slot) {
    warn("getFirstSlotVNode", `slot[${slotName}] is empty`);
    return null;
  }
  const slotContent = flatten$1(slot(props));
  if (slotContent.length === 1) {
    return slotContent[0];
  } else {
    warn("getFirstSlotVNode", `slot[${slotName}] should have exactly one child`);
    return null;
  }
}
function keep(object, keys2 = [], rest) {
  const keepedObject = {};
  keys2.forEach((key) => {
    keepedObject[key] = object[key];
  });
  return Object.assign(keepedObject, rest);
}
function render(r2, ...args) {
  if (typeof r2 === "function") {
    return r2(...args);
  } else if (typeof r2 === "string") {
    return vue.createTextVNode(r2);
  } else if (typeof r2 === "number") {
    return vue.createTextVNode(String(r2));
  } else {
    return null;
  }
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!vue.isVNode(child)) {
      return true;
    }
    if (child.type === vue.Comment) {
      return false;
    }
    if (child.type === vue.Fragment && !ensureValidVNode(child.children)) {
      return false;
    }
    return true;
  }) ? vnodes : null;
}
function resolveWrappedSlot(slot, wrapper) {
  const children = slot && ensureValidVNode(slot());
  return wrapper(children || null);
}
function isSlotEmpty(slot) {
  return !(slot && ensureValidVNode(slot()));
}
const Wrapper = vue.defineComponent({
  render() {
    var _a2, _b;
    return (_b = (_a2 = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a2);
  }
});
const configProviderInjectionKey = createInjectionKey("n-config-provider");
const defaultClsPrefix = "n";
function useConfig(props = {}, options = {
  defaultBordered: true
}) {
  const NConfigProvider = vue.inject(configProviderInjectionKey, null);
  return {
    // NConfigProvider,
    inlineThemeDisabled: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.inlineThemeDisabled,
    mergedRtlRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef,
    mergedComponentPropsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef,
    mergedBreakpointsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBreakpointsRef,
    mergedBorderedRef: vue.computed(() => {
      var _a2, _b;
      const {
        bordered
      } = props;
      if (bordered !== void 0) return bordered;
      return (_b = (_a2 = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value) !== null && _a2 !== void 0 ? _a2 : options.defaultBordered) !== null && _b !== void 0 ? _b : true;
    }),
    mergedClsPrefixRef: NConfigProvider ? NConfigProvider.mergedClsPrefixRef : vue.shallowRef(defaultClsPrefix),
    namespaceRef: vue.computed(() => NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value)
  };
}
function useThemeClass(componentName, hashRef, cssVarsRef, props) {
  if (!cssVarsRef) throwError("useThemeClass", "cssVarsRef is not passed");
  const NConfigProvider = vue.inject(configProviderInjectionKey, null);
  const mergedThemeHashRef = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeHashRef;
  const styleMountTarget = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.styleMountTarget;
  const themeClassRef = vue.ref("");
  const ssrAdapter2 = useSsrAdapter();
  let renderCallback;
  const hashClassPrefix = `__${componentName}`;
  const mountStyle = () => {
    let finalThemeHash = hashClassPrefix;
    const hashValue = hashRef ? hashRef.value : void 0;
    const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
    if (themeHash) finalThemeHash += `-${themeHash}`;
    if (hashValue) finalThemeHash += `-${hashValue}`;
    const {
      themeOverrides,
      builtinThemeOverrides
    } = props;
    if (themeOverrides) {
      finalThemeHash += `-${murmur2(JSON.stringify(themeOverrides))}`;
    }
    if (builtinThemeOverrides) {
      finalThemeHash += `-${murmur2(JSON.stringify(builtinThemeOverrides))}`;
    }
    themeClassRef.value = finalThemeHash;
    renderCallback = () => {
      const cssVars = cssVarsRef.value;
      let style2 = "";
      for (const key in cssVars) {
        style2 += `${key}: ${cssVars[key]};`;
      }
      c$1(`.${finalThemeHash}`, style2).mount({
        id: finalThemeHash,
        ssr: ssrAdapter2,
        parent: styleMountTarget
      });
      renderCallback = void 0;
    };
  };
  vue.watchEffect(() => {
    mountStyle();
  });
  return {
    themeClass: themeClassRef,
    onRender: () => {
      renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
    }
  };
}
var freeGlobal = typeof global$1 == "object" && global$1 && global$1.Object === Object && global$1;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal || freeSelf || Function("return this")();
var Symbol$1 = root.Symbol;
var objectProto$e = Object.prototype;
var hasOwnProperty$b = objectProto$e.hasOwnProperty;
var nativeObjectToString$1 = objectProto$e.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var objectProto$d = Object.prototype;
var nativeObjectToString = objectProto$d.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var symbolTag$1 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
}
function arrayMap(array, iteratee) {
  var index2 = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
  while (++index2 < length2) {
    result[index2] = iteratee(array[index2], index2, array);
  }
  return result;
}
var isArray = Array.isArray;
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray(value)) {
    return arrayMap(value, baseToString) + "";
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
function isObject(value) {
  var type2 = typeof value;
  return value != null && (type2 == "object" || type2 == "function");
}
function identity(value) {
  return value;
}
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var coreJsData = root["__core-js_shared__"];
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
})();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
var funcToString$1 = funcProto$1.toString;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : void 0;
}
var WeakMap$1 = getNative(root, "WeakMap");
var objectCreate = Object.create;
var baseCreate = /* @__PURE__ */ (function() {
  function object() {
  }
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
})();
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
function copyArray(source, array) {
  var index2 = -1, length2 = source.length;
  array || (array = Array(length2));
  while (++index2 < length2) {
    array[index2] = source[index2];
  }
  return array;
}
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
function constant(value) {
  return function() {
    return value;
  };
}
var defineProperty = (function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
})();
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant(string),
    "writable": true
  });
};
var setToString = shortOut(baseSetToString);
var MAX_SAFE_INTEGER$1 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length2) {
  var type2 = typeof value;
  length2 = length2 == null ? MAX_SAFE_INTEGER$1 : length2;
  return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
}
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var objectProto$b = Object.prototype;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$9.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index2 = -1, length2 = props.length;
  while (++index2 < length2) {
    var key = props[index2];
    var newValue = void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}
var nativeMax = Math.max;
function overRest(func, start2, transform) {
  start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
  return function() {
    var args = arguments, index2 = -1, length2 = nativeMax(args.length - start2, 0), array = Array(length2);
    while (++index2 < length2) {
      array[index2] = args[start2 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start2 + 1);
    while (++index2 < start2) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start2] = transform(array);
    return apply(func, this, otherArgs);
  };
}
function baseRest(func, start2) {
  return setToString(overRest(func, start2, identity), func + "");
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}
function isIterateeCall(value, index2, object) {
  if (!isObject(object)) {
    return false;
  }
  var type2 = typeof index2;
  if (type2 == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type2 == "string" && index2 in object) {
    return eq(object[index2], value);
  }
  return false;
}
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard2 = length2 > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
    if (guard2 && isIterateeCall(sources[0], sources[1], guard2)) {
      customizer = length2 < 3 ? void 0 : customizer;
      length2 = 1;
    }
    object = Object(object);
    while (++index2 < length2) {
      var source = sources[index2];
      if (source) {
        assigner(object, source, index2, customizer);
      }
    }
    return object;
  });
}
var objectProto$a = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
  return value === proto;
}
function baseTimes(n, iteratee) {
  var index2 = -1, result = Array(n);
  while (++index2 < n) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$2;
}
var objectProto$9 = Object.prototype;
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
var isArguments = baseIsArguments(/* @__PURE__ */ (function() {
  return arguments;
})()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
function stubFalse() {
  return false;
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
var freeProcess = moduleExports$1 && freeGlobal.process;
var nodeUtil = (function() {
  try {
    var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
    if (types2) {
      return types2;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
})();
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
var objectProto$8 = Object.prototype;
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex(key, length2)))) {
      result.push(key);
    }
  }
  return result;
}
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var nativeKeys = overArg(Object.keys, Object);
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$6.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type2 = typeof value;
  if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
var nativeCreate = getNative(Object, "create");
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
}
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
function Hash(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear;
Hash.prototype["delete"] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
function assocIndexOf(array, key) {
  var length2 = array.length;
  while (length2--) {
    if (eq(array[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
function listCacheGet(key) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}
function listCacheSet(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
function ListCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype["delete"] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
var Map$1 = getNative(root, "Map");
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
function isKeyable(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
function getMapData(map22, key) {
  var data = map22.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
function mapCacheDelete(key) {
  var result = getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}
function mapCacheSet(key, value) {
  var data = getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
function MapCache(entries) {
  var index2 = -1, length2 = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype["delete"] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache2.set(key, result) || cache2;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache2.size === MAX_MEMOIZE_SIZE) {
      cache2.clear();
    }
    return key;
  });
  var cache2 = result.cache;
  return result;
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46) {
    result.push("");
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
  });
  return result;
});
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}
function toKey(value) {
  if (typeof value == "string" || isSymbol(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -Infinity ? "-0" : result;
}
function baseGet(object, path) {
  path = castPath(path, object);
  var index2 = 0, length2 = path.length;
  while (object != null && index2 < length2) {
    object = object[toKey(path[index2++])];
  }
  return index2 && index2 == length2 ? object : void 0;
}
function get2(object, path, defaultValue) {
  var result = object == null ? void 0 : baseGet(object, path);
  return result === void 0 ? defaultValue : result;
}
function arrayPush(array, values) {
  var index2 = -1, length2 = values.length, offset2 = array.length;
  while (++index2 < length2) {
    array[offset2 + index2] = values[index2];
  }
  return array;
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
var objectTag$2 = "[object Object]";
var funcProto = Function.prototype, objectProto$3 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
var objectCtorString = funcToString.call(Object);
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
function stackClear() {
  this.__data__ = new ListCache();
  this.size = 0;
}
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
function stackGet(key) {
  return this.__data__.get(key);
}
function stackHas(key) {
  return this.__data__.has(key);
}
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear;
Stack.prototype["delete"] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root.Buffer : void 0;
Buffer ? Buffer.allocUnsafe : void 0;
function cloneBuffer(buffer2, isDeep) {
  {
    return buffer2.slice();
  }
}
function arrayFilter(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index2 < length2) {
    var value = array[index2];
    if (predicate(value, index2, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
function stubArray() {
  return [];
}
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}
var DataView$1 = getNative(root, "DataView");
var Promise$1 = getNative(root, "Promise");
var Set$1 = getNative(root, "Set");
var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag$1 = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
var getTag = baseGetTag;
if (DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
  getTag = function(value) {
    var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag$1;
        case mapCtorString:
          return mapTag$1;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag$1;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}
function cloneTypedArray(typedArray, isDeep) {
  var buffer2 = cloneArrayBuffer(typedArray.buffer);
  return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
}
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
function setCacheHas(value) {
  return this.__data__.has(value);
}
function SetCache(values) {
  var index2 = -1, length2 = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index2 < length2) {
    this.add(values[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
function arraySome(array, predicate) {
  var index2 = -1, length2 = array == null ? 0 : array.length;
  while (++index2 < length2) {
    if (predicate(array[index2], index2, array)) {
      return true;
    }
  }
  return false;
}
function cacheHas(cache2, key) {
  return cache2.has(key);
}
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack2.get(array);
  var othStacked = stack2.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
  stack2.set(array, other);
  stack2.set(other, array);
  while (++index2 < arrLength) {
    var arrValue = array[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack2) : customizer(arrValue, othValue, index2, array, other, stack2);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome(other, function(othValue2, othIndex) {
        if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
      result = false;
      break;
    }
  }
  stack2["delete"](array);
  stack2["delete"](other);
  return result;
}
function mapToArray(map22) {
  var index2 = -1, result = Array(map22.size);
  map22.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
function setToArray(set) {
  var index2 = -1, result = Array(set.size);
  set.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;
    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
        return false;
      }
      return true;
    case boolTag:
    case dateTag:
    case numberTag:
      return eq(+object, +other);
    case errorTag:
      return object.name == other.name && object.message == other.message;
    case regexpTag:
    case stringTag:
      return object == other + "";
    case mapTag:
      var convert = mapToArray;
    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = setToArray);
      if (object.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack2.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack2.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
      stack2["delete"](object);
      return result;
    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack2.get(object);
  var othStacked = stack2.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack2.set(object, other);
  stack2.set(other, object);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack2["delete"](object);
  stack2["delete"](other);
  return result;
}
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
  var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack2 || (stack2 = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
      stack2 || (stack2 = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack2 || (stack2 = new Stack());
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
}
function baseIsEqual(value, other, bitmask, customizer, stack2) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
}
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object, source, matchData, customizer) {
  var index2 = matchData.length, length2 = index2;
  if (object == null) {
    return !length2;
  }
  object = Object(object);
  while (index2--) {
    var data = matchData[index2];
    if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index2 < length2) {
    data = matchData[index2];
    var key = data[0], objValue = object[key], srcValue = data[1];
    if (data[2]) {
      if (objValue === void 0 && !(key in object)) {
        return false;
      }
    } else {
      var stack2 = new Stack();
      var result;
      if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
        return false;
      }
    }
  }
  return true;
}
function isStrictComparable(value) {
  return value === value && !isObject(value);
}
function getMatchData(object) {
  var result = keys(object), length2 = result.length;
  while (length2--) {
    var key = result[length2], value = object[key];
    result[length2] = [key, value, isStrictComparable(value)];
  }
  return result;
}
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
  };
}
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);
  var index2 = -1, length2 = path.length, result = false;
  while (++index2 < length2) {
    var key = toKey(path[index2]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index2 != length2) {
    return result;
  }
  length2 = object == null ? 0 : object.length;
  return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object) || isArguments(object));
}
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get2(object, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
function baseProperty(key) {
  return function(object) {
    return object == null ? void 0 : object[key];
  };
}
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == "object") {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object), props = keysFunc(object), length2 = props.length;
    while (length2--) {
      var key = props[++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}
var baseFor = createBaseFor();
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length2 = collection.length, index2 = -1, iterable = Object(collection);
    while (++index2 < length2) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var baseEach = createBaseEach(baseForOwn);
function assignMergeValue(object, key, value) {
  if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}
function safeGet(object, key) {
  if (key === "constructor" && typeof object[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object[key];
}
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
  var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue);
      } else {
        newValue = [];
      }
    } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      } else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack2.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
    stack2["delete"](srcValue);
  }
  assignMergeValue(object, key, newValue);
}
function baseMerge(object, source, srcIndex, customizer, stack2) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack2 || (stack2 = new Stack());
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
    } else {
      var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
  baseEach(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
function map2(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee));
}
var merge$1 = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});
const cssrAnchorMetaName = "naive-ui-style";
function useRtl(mountId, rtlStateRef, clsPrefixRef) {
  if (!rtlStateRef) return void 0;
  const ssrAdapter2 = useSsrAdapter();
  const componentRtlStateRef = vue.computed(() => {
    const {
      value: rtlState
    } = rtlStateRef;
    if (!rtlState) {
      return void 0;
    }
    const componentRtlState = rtlState[mountId];
    if (!componentRtlState) {
      return void 0;
    }
    return componentRtlState;
  });
  const NConfigProvider = vue.inject(configProviderInjectionKey, null);
  const mountStyle = () => {
    vue.watchEffect(() => {
      const {
        value: clsPrefix
      } = clsPrefixRef;
      const id = `${clsPrefix}${mountId}Rtl`;
      if (exists(id, ssrAdapter2)) return;
      const {
        value: componentRtlState
      } = componentRtlStateRef;
      if (!componentRtlState) return;
      componentRtlState.style.mount({
        id,
        head: true,
        anchorMetaName: cssrAnchorMetaName,
        props: {
          bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
        },
        ssr: ssrAdapter2,
        parent: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.styleMountTarget
      });
    });
  };
  if (ssrAdapter2) {
    mountStyle();
  } else {
    vue.onBeforeMount(mountStyle);
  }
  return componentRtlStateRef;
}
const commonVariables$2 = {
  fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
  fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
  fontWeight: "400",
  fontWeightStrong: "500",
  cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
  cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
  cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
  borderRadius: "3px",
  borderRadiusSmall: "2px",
  fontSize: "14px",
  fontSizeMini: "12px",
  fontSizeTiny: "12px",
  fontSizeSmall: "14px",
  fontSizeMedium: "14px",
  fontSizeLarge: "15px",
  fontSizeHuge: "16px",
  lineHeight: "1.6",
  heightMini: "16px",
  // private now, it's too small
  heightTiny: "22px",
  heightSmall: "28px",
  heightMedium: "34px",
  heightLarge: "40px",
  heightHuge: "46px"
};
const {
  fontSize,
  fontFamily,
  lineHeight
} = commonVariables$2;
const globalStyle = c$1("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c$1("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
function createTheme(theme) {
  return theme;
}
function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
  const ssrAdapter2 = useSsrAdapter();
  const NConfigProvider = vue.inject(configProviderInjectionKey, null);
  if (style2) {
    const mountStyle = () => {
      const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
      style2.mount({
        id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
        head: true,
        props: {
          bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
        },
        anchorMetaName: cssrAnchorMetaName,
        ssr: ssrAdapter2,
        parent: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.styleMountTarget
      });
      if (!(NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled)) {
        globalStyle.mount({
          id: "n-global",
          head: true,
          anchorMetaName: cssrAnchorMetaName,
          ssr: ssrAdapter2,
          parent: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.styleMountTarget
        });
      }
    };
    if (ssrAdapter2) {
      mountStyle();
    } else {
      vue.onBeforeMount(mountStyle);
    }
  }
  const mergedThemeRef = vue.computed(() => {
    var _a2;
    const {
      theme: {
        common: selfCommon,
        self: self2,
        peers = {}
      } = {},
      themeOverrides: selfOverrides = {},
      builtinThemeOverrides: builtinOverrides = {}
    } = props;
    const {
      common: selfCommonOverrides,
      peers: peersOverrides
    } = selfOverrides;
    const {
      common: globalCommon = void 0,
      [resolveId]: {
        common: globalSelfCommon = void 0,
        self: globalSelf = void 0,
        peers: globalPeers = {}
      } = {}
    } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value) || {};
    const {
      common: globalCommonOverrides = void 0,
      [resolveId]: globalSelfOverrides = {}
    } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value) || {};
    const {
      common: globalSelfCommonOverrides,
      peers: globalPeersOverrides = {}
    } = globalSelfOverrides;
    const mergedCommon = merge$1({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
    const mergedSelf = merge$1(
      // {}, executed every time, no need for empty obj
      (_a2 = self2 || globalSelf || defaultTheme.self) === null || _a2 === void 0 ? void 0 : _a2(mergedCommon),
      builtinOverrides,
      globalSelfOverrides,
      selfOverrides
    );
    return {
      common: mergedCommon,
      self: mergedSelf,
      peers: merge$1({}, defaultTheme.peers, globalPeers, peers),
      peerOverrides: merge$1({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
    };
  });
  return mergedThemeRef;
}
useTheme.props = {
  theme: Object,
  themeOverrides: Object,
  builtinThemeOverrides: Object
};
const ChevronRightIcon = vue.defineComponent({
  name: "ChevronRight",
  render() {
    return vue.h("svg", {
      viewBox: "0 0 16 16",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg"
    }, vue.h("path", {
      d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z",
      fill: "currentColor"
    }));
  }
});
const {
  cubicBezierEaseInOut
} = commonVariables$2;
function fadeInTransition({
  name = "fade-in",
  enterDuration = "0.2s",
  leaveDuration = "0.2s",
  enterCubicBezier = cubicBezierEaseInOut,
  leaveCubicBezier = cubicBezierEaseInOut
} = {}) {
  return [c$1(`&.${name}-transition-enter-active`, {
    transition: `all ${enterDuration} ${enterCubicBezier}!important`
  }), c$1(`&.${name}-transition-leave-active`, {
    transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
  }), c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
    opacity: 0
  }), c$1(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
    opacity: 1
  })];
}
const base = {
  neutralBase: "#FFF",
  neutralInvertBase: "#000",
  neutralTextBase: "#000",
  neutralPopover: "#fff",
  neutralCard: "#fff",
  neutralModal: "#fff",
  neutralBody: "#fff",
  alpha1: "0.82",
  alpha2: "0.72",
  alpha3: "0.38",
  alpha4: "0.24",
  // disabled text, placeholder, icon
  alpha5: "0.18",
  // disabled placeholder
  alphaClose: "0.6",
  alphaDisabled: "0.5",
  alphaAvatar: "0.2",
  alphaProgressRail: ".08",
  alphaInput: "0",
  alphaScrollbar: "0.25",
  alphaScrollbarHover: "0.4",
  // primary
  primaryHover: "#36ad6a",
  primaryDefault: "#18a058",
  primaryActive: "#0c7a43",
  primarySuppl: "#36ad6a",
  // info
  infoHover: "#4098fc",
  infoDefault: "#2080f0",
  infoActive: "#1060c9",
  infoSuppl: "#4098fc",
  // error
  errorHover: "#de576d",
  errorDefault: "#d03050",
  errorActive: "#ab1f3f",
  errorSuppl: "#de576d",
  // warning
  warningHover: "#fcb040",
  warningDefault: "#f0a020",
  warningActive: "#c97c10",
  warningSuppl: "#fcb040",
  // success
  successHover: "#36ad6a",
  successDefault: "#18a058",
  successActive: "#0c7a43",
  successSuppl: "#36ad6a"
};
const baseBackgroundRgb = rgba(base.neutralBase);
const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
const overlayPrefix = `rgba(${baseInvertBackgroundRgb.slice(0, 3).join(", ")}, `;
function overlay(alpha) {
  return `${overlayPrefix + String(alpha)})`;
}
function neutral(alpha) {
  const overlayRgba = Array.from(baseInvertBackgroundRgb);
  overlayRgba[3] = Number(alpha);
  return composite(baseBackgroundRgb, overlayRgba);
}
const derived = Object.assign(Object.assign({
  name: "common"
}, commonVariables$2), {
  baseColor: base.neutralBase,
  // primary color
  primaryColor: base.primaryDefault,
  primaryColorHover: base.primaryHover,
  primaryColorPressed: base.primaryActive,
  primaryColorSuppl: base.primarySuppl,
  // info color
  infoColor: base.infoDefault,
  infoColorHover: base.infoHover,
  infoColorPressed: base.infoActive,
  infoColorSuppl: base.infoSuppl,
  // success color
  successColor: base.successDefault,
  successColorHover: base.successHover,
  successColorPressed: base.successActive,
  successColorSuppl: base.successSuppl,
  // warning color
  warningColor: base.warningDefault,
  warningColorHover: base.warningHover,
  warningColorPressed: base.warningActive,
  warningColorSuppl: base.warningSuppl,
  // error color
  errorColor: base.errorDefault,
  errorColorHover: base.errorHover,
  errorColorPressed: base.errorActive,
  errorColorSuppl: base.errorSuppl,
  // text color
  textColorBase: base.neutralTextBase,
  textColor1: "rgb(31, 34, 37)",
  textColor2: "rgb(51, 54, 57)",
  textColor3: "rgb(118, 124, 130)",
  // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
  // textColor5: neutral(base.alpha5),
  textColorDisabled: neutral(base.alpha4),
  placeholderColor: neutral(base.alpha4),
  placeholderColorDisabled: neutral(base.alpha5),
  iconColor: neutral(base.alpha4),
  iconColorHover: scaleColor(neutral(base.alpha4), {
    lightness: 0.75
  }),
  iconColorPressed: scaleColor(neutral(base.alpha4), {
    lightness: 0.9
  }),
  iconColorDisabled: neutral(base.alpha5),
  opacity1: base.alpha1,
  opacity2: base.alpha2,
  opacity3: base.alpha3,
  opacity4: base.alpha4,
  opacity5: base.alpha5,
  dividerColor: "rgb(239, 239, 245)",
  borderColor: "rgb(224, 224, 230)",
  // close
  closeIconColor: neutral(Number(base.alphaClose)),
  closeIconColorHover: neutral(Number(base.alphaClose)),
  closeIconColorPressed: neutral(Number(base.alphaClose)),
  closeColorHover: "rgba(0, 0, 0, .09)",
  closeColorPressed: "rgba(0, 0, 0, .13)",
  // clear
  clearColor: neutral(base.alpha4),
  clearColorHover: scaleColor(neutral(base.alpha4), {
    lightness: 0.75
  }),
  clearColorPressed: scaleColor(neutral(base.alpha4), {
    lightness: 0.9
  }),
  scrollbarColor: overlay(base.alphaScrollbar),
  scrollbarColorHover: overlay(base.alphaScrollbarHover),
  scrollbarWidth: "5px",
  scrollbarHeight: "5px",
  scrollbarBorderRadius: "5px",
  progressRailColor: neutral(base.alphaProgressRail),
  railColor: "rgb(219, 219, 223)",
  popoverColor: base.neutralPopover,
  tableColor: base.neutralCard,
  cardColor: base.neutralCard,
  modalColor: base.neutralModal,
  bodyColor: base.neutralBody,
  tagColor: "#eee",
  avatarColor: neutral(base.alphaAvatar),
  invertedColor: "rgb(0, 20, 40)",
  inputColor: neutral(base.alphaInput),
  codeColor: "rgb(244, 244, 248)",
  tabColor: "rgb(247, 247, 250)",
  actionColor: "rgb(250, 250, 252)",
  tableHeaderColor: "rgb(250, 250, 252)",
  hoverColor: "rgb(243, 243, 245)",
  // use color with alpha since it can be nested with header filter & sorter effect
  tableColorHover: "rgba(0, 0, 100, 0.03)",
  tableColorStriped: "rgba(0, 0, 100, 0.02)",
  pressedColor: "rgb(237, 237, 239)",
  opacityDisabled: base.alphaDisabled,
  inputColorDisabled: "rgb(250, 250, 252)",
  // secondary button color
  // can also be used in tertiary button & quaternary button
  buttonColor2: "rgba(46, 51, 56, .05)",
  buttonColor2Hover: "rgba(46, 51, 56, .09)",
  buttonColor2Pressed: "rgba(46, 51, 56, .13)",
  boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
  boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
  boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
});
const commonVars$1 = {
  railInsetHorizontalBottom: "auto 2px 4px 2px",
  railInsetHorizontalTop: "4px 2px auto 2px",
  railInsetVerticalRight: "2px 4px 2px auto",
  railInsetVerticalLeft: "2px auto 2px 4px",
  railColor: "transparent"
};
function self$6(vars) {
  const {
    scrollbarColor,
    scrollbarColorHover,
    scrollbarHeight,
    scrollbarWidth,
    scrollbarBorderRadius
  } = vars;
  return Object.assign(Object.assign({}, commonVars$1), {
    height: scrollbarHeight,
    width: scrollbarWidth,
    borderRadius: scrollbarBorderRadius,
    color: scrollbarColor,
    colorHover: scrollbarColorHover
  });
}
const scrollbarLight = {
  common: derived,
  self: self$6
};
const style$4 = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c$1(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1(">", [
  // We can't set overflow hidden since it affects positioning.
  cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)
])])]), c$1(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 background: var(--n-scrollbar-rail-color);
 -webkit-user-select: none;
 `, [cM("horizontal", `
 height: var(--n-scrollbar-height);
 `, [c$1(">", [cE("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM("horizontal--top", `
 top: var(--n-scrollbar-rail-top-horizontal-top); 
 right: var(--n-scrollbar-rail-right-horizontal-top); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-top); 
 left: var(--n-scrollbar-rail-left-horizontal-top); 
 `), cM("horizontal--bottom", `
 top: var(--n-scrollbar-rail-top-horizontal-bottom); 
 right: var(--n-scrollbar-rail-right-horizontal-bottom); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-bottom); 
 left: var(--n-scrollbar-rail-left-horizontal-bottom); 
 `), cM("vertical", `
 width: var(--n-scrollbar-width);
 `, [c$1(">", [cE("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM("vertical--left", `
 top: var(--n-scrollbar-rail-top-vertical-left); 
 right: var(--n-scrollbar-rail-right-vertical-left); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-left); 
 left: var(--n-scrollbar-rail-left-vertical-left); 
 `), cM("vertical--right", `
 top: var(--n-scrollbar-rail-top-vertical-right); 
 right: var(--n-scrollbar-rail-right-vertical-right); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-right); 
 left: var(--n-scrollbar-rail-left-vertical-right); 
 `), cM("disabled", [c$1(">", [cE("scrollbar", "pointer-events: none;")])]), c$1(">", [cE("scrollbar", `
 z-index: 1;
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c$1("&:hover", "background-color: var(--n-scrollbar-color-hover);")])])])])]);
const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), {
  duration: {
    type: Number,
    default: 0
  },
  scrollable: {
    type: Boolean,
    default: true
  },
  xScrollable: Boolean,
  trigger: {
    type: String,
    default: "hover"
  },
  useUnifiedContainer: Boolean,
  triggerDisplayManually: Boolean,
  // If container is set, resize observer won't not attached
  container: Function,
  content: Function,
  containerClass: String,
  containerStyle: [String, Object],
  contentClass: [String, Array],
  contentStyle: [String, Object],
  horizontalRailStyle: [String, Object],
  verticalRailStyle: [String, Object],
  onScroll: Function,
  onWheel: Function,
  onResize: Function,
  internalOnUpdateScrollLeft: Function,
  internalHoistYRail: Boolean,
  yPlacement: {
    type: String,
    default: "right"
  },
  xPlacement: {
    type: String,
    default: "bottom"
  }
});
const Scrollbar = vue.defineComponent({
  name: "Scrollbar",
  props: scrollbarProps,
  inheritAttrs: false,
  setup(props) {
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled,
      mergedRtlRef
    } = useConfig(props);
    const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
    const wrapperRef = vue.ref(null);
    const containerRef = vue.ref(null);
    const contentRef = vue.ref(null);
    const yRailRef = vue.ref(null);
    const xRailRef = vue.ref(null);
    const contentHeightRef = vue.ref(null);
    const contentWidthRef = vue.ref(null);
    const containerHeightRef = vue.ref(null);
    const containerWidthRef = vue.ref(null);
    const yRailSizeRef = vue.ref(null);
    const xRailSizeRef = vue.ref(null);
    const containerScrollTopRef = vue.ref(0);
    const containerScrollLeftRef = vue.ref(0);
    const isShowXBarRef = vue.ref(false);
    const isShowYBarRef = vue.ref(false);
    let yBarPressed = false;
    let xBarPressed = false;
    let xBarVanishTimerId;
    let yBarVanishTimerId;
    let memoYTop = 0;
    let memoXLeft = 0;
    let memoMouseX = 0;
    let memoMouseY = 0;
    const isIos2 = useIsIos();
    const themeRef = useTheme("Scrollbar", "-scrollbar", style$4, scrollbarLight, props, mergedClsPrefixRef);
    const yBarSizeRef = vue.computed(() => {
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      const {
        value: yRailSize
      } = yRailSizeRef;
      if (containerHeight === null || contentHeight === null || yRailSize === null) {
        return 0;
      } else {
        return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + depx(themeRef.value.self.width) * 1.5);
      }
    });
    const yBarSizePxRef = vue.computed(() => {
      return `${yBarSizeRef.value}px`;
    });
    const xBarSizeRef = vue.computed(() => {
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      const {
        value: xRailSize
      } = xRailSizeRef;
      if (containerWidth === null || contentWidth === null || xRailSize === null) {
        return 0;
      } else {
        return xRailSize * containerWidth / contentWidth + depx(themeRef.value.self.height) * 1.5;
      }
    });
    const xBarSizePxRef = vue.computed(() => {
      return `${xBarSizeRef.value}px`;
    });
    const yBarTopRef = vue.computed(() => {
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: containerScrollTop
      } = containerScrollTopRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      const {
        value: yRailSize
      } = yRailSizeRef;
      if (containerHeight === null || contentHeight === null || yRailSize === null) {
        return 0;
      } else {
        const heightDiff = contentHeight - containerHeight;
        if (!heightDiff) return 0;
        return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
      }
    });
    const yBarTopPxRef = vue.computed(() => {
      return `${yBarTopRef.value}px`;
    });
    const xBarLeftRef = vue.computed(() => {
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: containerScrollLeft
      } = containerScrollLeftRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      const {
        value: xRailSize
      } = xRailSizeRef;
      if (containerWidth === null || contentWidth === null || xRailSize === null) {
        return 0;
      } else {
        const widthDiff = contentWidth - containerWidth;
        if (!widthDiff) return 0;
        return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
      }
    });
    const xBarLeftPxRef = vue.computed(() => {
      return `${xBarLeftRef.value}px`;
    });
    const needYBarRef = vue.computed(() => {
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
    });
    const needXBarRef = vue.computed(() => {
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
    });
    const mergedShowXBarRef = vue.computed(() => {
      const {
        trigger: trigger2
      } = props;
      return trigger2 === "none" || isShowXBarRef.value;
    });
    const mergedShowYBarRef = vue.computed(() => {
      const {
        trigger: trigger2
      } = props;
      return trigger2 === "none" || isShowYBarRef.value;
    });
    const mergedContainerRef = vue.computed(() => {
      const {
        container
      } = props;
      if (container) return container();
      return containerRef.value;
    });
    const mergedContentRef = vue.computed(() => {
      const {
        content
      } = props;
      if (content) return content();
      return contentRef.value;
    });
    const scrollTo = (options, y2) => {
      if (!props.scrollable) return;
      if (typeof options === "number") {
        scrollToPosition(options, y2 !== null && y2 !== void 0 ? y2 : 0, 0, false, "auto");
        return;
      }
      const {
        left: left2,
        top: top2,
        index: index2,
        elSize,
        position,
        behavior,
        el,
        debounce: debounce2 = true
      } = options;
      if (left2 !== void 0 || top2 !== void 0) {
        scrollToPosition(left2 !== null && left2 !== void 0 ? left2 : 0, top2 !== null && top2 !== void 0 ? top2 : 0, 0, false, behavior);
      }
      if (el !== void 0) {
        scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce2, behavior);
      } else if (index2 !== void 0 && elSize !== void 0) {
        scrollToPosition(0, index2 * elSize, elSize, debounce2, behavior);
      } else if (position === "bottom") {
        scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
      } else if (position === "top") {
        scrollToPosition(0, 0, 0, false, behavior);
      }
    };
    const activateState = useReactivated(() => {
      if (!props.container) {
        scrollTo({
          top: containerScrollTopRef.value,
          left: containerScrollLeftRef.value
        });
      }
    });
    const handleContentResize = () => {
      if (activateState.isDeactivated) return;
      sync();
    };
    const handleContainerResize = (e) => {
      if (activateState.isDeactivated) return;
      const {
        onResize
      } = props;
      if (onResize) onResize(e);
      sync();
    };
    const scrollBy = (options, y2) => {
      if (!props.scrollable) return;
      const {
        value: container
      } = mergedContainerRef;
      if (!container) return;
      if (typeof options === "object") {
        container.scrollBy(options);
      } else {
        container.scrollBy(options, y2 || 0);
      }
    };
    function scrollToPosition(left2, top2, elSize, debounce2, behavior) {
      const {
        value: container
      } = mergedContainerRef;
      if (!container) return;
      if (debounce2) {
        const {
          scrollTop,
          offsetHeight
        } = container;
        if (top2 > scrollTop) {
          if (top2 + elSize <= scrollTop + offsetHeight) ;
          else {
            container.scrollTo({
              left: left2,
              top: top2 + elSize - offsetHeight,
              behavior
            });
          }
          return;
        }
      }
      container.scrollTo({
        left: left2,
        top: top2,
        behavior
      });
    }
    function handleMouseEnterWrapper() {
      showXBar();
      showYBar();
      sync();
    }
    function handleMouseLeaveWrapper() {
      hideBar();
    }
    function hideBar() {
      hideYBar();
      hideXBar();
    }
    function hideYBar() {
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      yBarVanishTimerId = window.setTimeout(() => {
        isShowYBarRef.value = false;
      }, props.duration);
    }
    function hideXBar() {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      xBarVanishTimerId = window.setTimeout(() => {
        isShowXBarRef.value = false;
      }, props.duration);
    }
    function showXBar() {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      isShowXBarRef.value = true;
    }
    function showYBar() {
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      isShowYBarRef.value = true;
    }
    function handleScroll(e) {
      const {
        onScroll
      } = props;
      if (onScroll) onScroll(e);
      syncScrollState();
    }
    function syncScrollState() {
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        containerScrollTopRef.value = container.scrollTop;
        containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
      }
    }
    function syncPositionState() {
      const {
        value: content
      } = mergedContentRef;
      if (content) {
        contentHeightRef.value = content.offsetHeight;
        contentWidthRef.value = content.offsetWidth;
      }
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        containerHeightRef.value = container.offsetHeight;
        containerWidthRef.value = container.offsetWidth;
      }
      const {
        value: xRailEl
      } = xRailRef;
      const {
        value: yRailEl
      } = yRailRef;
      if (xRailEl) {
        xRailSizeRef.value = xRailEl.offsetWidth;
      }
      if (yRailEl) {
        yRailSizeRef.value = yRailEl.offsetHeight;
      }
    }
    function syncUnifiedContainer() {
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        containerScrollTopRef.value = container.scrollTop;
        containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
        containerHeightRef.value = container.offsetHeight;
        containerWidthRef.value = container.offsetWidth;
        contentHeightRef.value = container.scrollHeight;
        contentWidthRef.value = container.scrollWidth;
      }
      const {
        value: xRailEl
      } = xRailRef;
      const {
        value: yRailEl
      } = yRailRef;
      if (xRailEl) {
        xRailSizeRef.value = xRailEl.offsetWidth;
      }
      if (yRailEl) {
        yRailSizeRef.value = yRailEl.offsetHeight;
      }
    }
    function sync() {
      if (!props.scrollable) return;
      if (props.useUnifiedContainer) {
        syncUnifiedContainer();
      } else {
        syncPositionState();
        syncScrollState();
      }
    }
    function isMouseUpAway(e) {
      var _a2;
      return !((_a2 = wrapperRef.value) === null || _a2 === void 0 ? void 0 : _a2.contains(getPreciseEventTarget(e)));
    }
    function handleXScrollMouseDown(e) {
      e.preventDefault();
      e.stopPropagation();
      xBarPressed = true;
      on("mousemove", window, handleXScrollMouseMove, true);
      on("mouseup", window, handleXScrollMouseUp, true);
      memoXLeft = containerScrollLeftRef.value;
      memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
    }
    function handleXScrollMouseMove(e) {
      if (!xBarPressed) return;
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      const {
        value: containerWidth
      } = containerWidthRef;
      const {
        value: contentWidth
      } = contentWidthRef;
      const {
        value: xBarSize
      } = xBarSizeRef;
      if (containerWidth === null || contentWidth === null) return;
      const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
      const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
      const toScrollLeftUpperBound = contentWidth - containerWidth;
      let toScrollLeft = memoXLeft + dScrollLeft;
      toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
      toScrollLeft = Math.max(toScrollLeft, 0);
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
        const {
          internalOnUpdateScrollLeft
        } = props;
        if (internalOnUpdateScrollLeft) internalOnUpdateScrollLeft(toScrollLeft);
      }
    }
    function handleXScrollMouseUp(e) {
      e.preventDefault();
      e.stopPropagation();
      off("mousemove", window, handleXScrollMouseMove, true);
      off("mouseup", window, handleXScrollMouseUp, true);
      xBarPressed = false;
      sync();
      if (isMouseUpAway(e)) {
        hideBar();
      }
    }
    function handleYScrollMouseDown(e) {
      e.preventDefault();
      e.stopPropagation();
      yBarPressed = true;
      on("mousemove", window, handleYScrollMouseMove, true);
      on("mouseup", window, handleYScrollMouseUp, true);
      memoYTop = containerScrollTopRef.value;
      memoMouseY = e.clientY;
    }
    function handleYScrollMouseMove(e) {
      if (!yBarPressed) return;
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      const {
        value: containerHeight
      } = containerHeightRef;
      const {
        value: contentHeight
      } = contentHeightRef;
      const {
        value: yBarSize
      } = yBarSizeRef;
      if (containerHeight === null || contentHeight === null) return;
      const dY = e.clientY - memoMouseY;
      const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
      const toScrollTopUpperBound = contentHeight - containerHeight;
      let toScrollTop = memoYTop + dScrollTop;
      toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
      toScrollTop = Math.max(toScrollTop, 0);
      const {
        value: container
      } = mergedContainerRef;
      if (container) {
        container.scrollTop = toScrollTop;
      }
    }
    function handleYScrollMouseUp(e) {
      e.preventDefault();
      e.stopPropagation();
      off("mousemove", window, handleYScrollMouseMove, true);
      off("mouseup", window, handleYScrollMouseUp, true);
      yBarPressed = false;
      sync();
      if (isMouseUpAway(e)) {
        hideBar();
      }
    }
    vue.watchEffect(() => {
      const {
        value: needXBar
      } = needXBarRef;
      const {
        value: needYBar
      } = needYBarRef;
      const {
        value: mergedClsPrefix
      } = mergedClsPrefixRef;
      const {
        value: xRailEl
      } = xRailRef;
      const {
        value: yRailEl
      } = yRailRef;
      if (xRailEl) {
        if (!needXBar) {
          xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        } else {
          xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        }
      }
      if (yRailEl) {
        if (!needYBar) {
          yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        } else {
          yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
        }
      }
    });
    vue.onMounted(() => {
      if (props.container) return;
      sync();
    });
    vue.onBeforeUnmount(() => {
      if (xBarVanishTimerId !== void 0) {
        window.clearTimeout(xBarVanishTimerId);
      }
      if (yBarVanishTimerId !== void 0) {
        window.clearTimeout(yBarVanishTimerId);
      }
      off("mousemove", window, handleYScrollMouseMove, true);
      off("mouseup", window, handleYScrollMouseUp, true);
    });
    const cssVarsRef = vue.computed(() => {
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: {
          color,
          colorHover,
          height,
          width,
          borderRadius,
          railInsetHorizontalTop,
          railInsetHorizontalBottom,
          railInsetVerticalRight,
          railInsetVerticalLeft,
          railColor
        }
      } = themeRef.value;
      const {
        top: railTopHorizontalTop,
        right: railRightHorizontalTop,
        bottom: railBottomHorizontalTop,
        left: railLeftHorizontalTop
      } = getMargin(railInsetHorizontalTop);
      const {
        top: railTopHorizontalBottom,
        right: railRightHorizontalBottom,
        bottom: railBottomHorizontalBottom,
        left: railLeftHorizontalBottom
      } = getMargin(railInsetHorizontalBottom);
      const {
        top: railTopVerticalRight,
        right: railRightVerticalRight,
        bottom: railBottomVerticalRight,
        left: railLeftVerticalRight
      } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalRight) : railInsetVerticalRight);
      const {
        top: railTopVerticalLeft,
        right: railRightVerticalLeft,
        bottom: railBottomVerticalLeft,
        left: railLeftVerticalLeft
      } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalLeft) : railInsetVerticalLeft);
      return {
        "--n-scrollbar-bezier": cubicBezierEaseInOut2,
        "--n-scrollbar-color": color,
        "--n-scrollbar-color-hover": colorHover,
        "--n-scrollbar-border-radius": borderRadius,
        "--n-scrollbar-width": width,
        "--n-scrollbar-height": height,
        "--n-scrollbar-rail-top-horizontal-top": railTopHorizontalTop,
        "--n-scrollbar-rail-right-horizontal-top": railRightHorizontalTop,
        "--n-scrollbar-rail-bottom-horizontal-top": railBottomHorizontalTop,
        "--n-scrollbar-rail-left-horizontal-top": railLeftHorizontalTop,
        "--n-scrollbar-rail-top-horizontal-bottom": railTopHorizontalBottom,
        "--n-scrollbar-rail-right-horizontal-bottom": railRightHorizontalBottom,
        "--n-scrollbar-rail-bottom-horizontal-bottom": railBottomHorizontalBottom,
        "--n-scrollbar-rail-left-horizontal-bottom": railLeftHorizontalBottom,
        "--n-scrollbar-rail-top-vertical-right": railTopVerticalRight,
        "--n-scrollbar-rail-right-vertical-right": railRightVerticalRight,
        "--n-scrollbar-rail-bottom-vertical-right": railBottomVerticalRight,
        "--n-scrollbar-rail-left-vertical-right": railLeftVerticalRight,
        "--n-scrollbar-rail-top-vertical-left": railTopVerticalLeft,
        "--n-scrollbar-rail-right-vertical-left": railRightVerticalLeft,
        "--n-scrollbar-rail-bottom-vertical-left": railBottomVerticalLeft,
        "--n-scrollbar-rail-left-vertical-left": railLeftVerticalLeft,
        "--n-scrollbar-rail-color": railColor
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
    const exposedMethods = {
      scrollTo,
      scrollBy,
      sync,
      syncUnifiedContainer,
      handleMouseEnterWrapper,
      handleMouseLeaveWrapper
    };
    return Object.assign(Object.assign({}, exposedMethods), {
      mergedClsPrefix: mergedClsPrefixRef,
      rtlEnabled: rtlEnabledRef,
      containerScrollTop: containerScrollTopRef,
      wrapperRef,
      containerRef,
      contentRef,
      yRailRef,
      xRailRef,
      needYBar: needYBarRef,
      needXBar: needXBarRef,
      yBarSizePx: yBarSizePxRef,
      xBarSizePx: xBarSizePxRef,
      yBarTopPx: yBarTopPxRef,
      xBarLeftPx: xBarLeftPxRef,
      isShowXBar: mergedShowXBarRef,
      isShowYBar: mergedShowYBarRef,
      isIos: isIos2,
      handleScroll,
      handleContentResize,
      handleContainerResize,
      handleYScrollMouseDown,
      handleXScrollMouseDown,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    });
  },
  render() {
    var _a2;
    const {
      $slots,
      mergedClsPrefix,
      triggerDisplayManually,
      rtlEnabled,
      internalHoistYRail,
      yPlacement,
      xPlacement,
      xScrollable
    } = this;
    if (!this.scrollable) return (_a2 = $slots.default) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
    const triggerIsNone = this.trigger === "none";
    const createYRail = (className, style2) => {
      return vue.h("div", {
        ref: "yRailRef",
        class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--vertical`, `${mergedClsPrefix}-scrollbar-rail--vertical--${yPlacement}`, className],
        "data-scrollbar-rail": true,
        style: [style2 || "", this.verticalRailStyle],
        "aria-hidden": true
      }, vue.h(triggerIsNone ? Wrapper : vue.Transition, triggerIsNone ? null : {
        name: "fade-in-transition"
      }, {
        default: () => this.needYBar && this.isShowYBar && !this.isIos ? vue.h("div", {
          class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
          style: {
            height: this.yBarSizePx,
            top: this.yBarTopPx
          },
          onMousedown: this.handleYScrollMouseDown
        }) : null
      }));
    };
    const createChildren = () => {
      var _a22, _b;
      (_a22 = this.onRender) === null || _a22 === void 0 ? void 0 : _a22.call(this);
      return vue.h("div", vue.mergeProps(this.$attrs, {
        role: "none",
        ref: "wrapperRef",
        class: [`${mergedClsPrefix}-scrollbar`, this.themeClass, rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`],
        style: this.cssVars,
        onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
        onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
      }), [this.container ? (_b = $slots.default) === null || _b === void 0 ? void 0 : _b.call($slots) : vue.h("div", {
        role: "none",
        ref: "containerRef",
        class: [`${mergedClsPrefix}-scrollbar-container`, this.containerClass],
        style: this.containerStyle,
        onScroll: this.handleScroll,
        onWheel: this.onWheel
      }, vue.h(VResizeObserver, {
        onResize: this.handleContentResize
      }, {
        default: () => vue.h("div", {
          ref: "contentRef",
          role: "none",
          style: [{
            width: this.xScrollable ? "fit-content" : null
          }, this.contentStyle],
          class: [`${mergedClsPrefix}-scrollbar-content`, this.contentClass]
        }, $slots)
      })), internalHoistYRail ? null : createYRail(void 0, void 0), xScrollable && vue.h("div", {
        ref: "xRailRef",
        class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--horizontal`, `${mergedClsPrefix}-scrollbar-rail--horizontal--${xPlacement}`],
        style: this.horizontalRailStyle,
        "data-scrollbar-rail": true,
        "aria-hidden": true
      }, vue.h(triggerIsNone ? Wrapper : vue.Transition, triggerIsNone ? null : {
        name: "fade-in-transition"
      }, {
        default: () => this.needXBar && this.isShowXBar && !this.isIos ? vue.h("div", {
          class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
          style: {
            width: this.xBarSizePx,
            right: rtlEnabled ? this.xBarLeftPx : void 0,
            left: rtlEnabled ? void 0 : this.xBarLeftPx
          },
          onMousedown: this.handleXScrollMouseDown
        }) : null
      }))]);
    };
    const scrollbarNode = this.container ? createChildren() : vue.h(VResizeObserver, {
      onResize: this.handleContainerResize
    }, {
      default: createChildren
    });
    if (internalHoistYRail) {
      return vue.h(vue.Fragment, null, scrollbarNode, createYRail(this.themeClass, this.cssVars));
    } else {
      return scrollbarNode;
    }
  }
});
const XScrollbar = Scrollbar;
function toArray(arg) {
  if (Array.isArray(arg))
    return arg;
  return [arg];
}
const TRAVERSE_COMMAND = {
  STOP: "STOP"
};
function traverseWithCb(treeNode, callback) {
  const command2 = callback(treeNode);
  if (treeNode.children !== void 0 && command2 !== TRAVERSE_COMMAND.STOP) {
    treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));
  }
}
function getNonLeafKeys(treeNodes, options = {}) {
  const { preserveGroup = false } = options;
  const keys2 = [];
  const cb = preserveGroup ? (node2) => {
    if (!node2.isLeaf) {
      keys2.push(node2.key);
      traverse(node2.children);
    }
  } : (node2) => {
    if (!node2.isLeaf) {
      if (!node2.isGroup)
        keys2.push(node2.key);
      traverse(node2.children);
    }
  };
  function traverse(nodes) {
    nodes.forEach(cb);
  }
  traverse(treeNodes);
  return keys2;
}
function isLeaf(rawNode, getChildren2) {
  const { isLeaf: isLeaf2 } = rawNode;
  if (isLeaf2 !== void 0)
    return isLeaf2;
  else if (!getChildren2(rawNode))
    return true;
  return false;
}
function defaultGetChildren(node2) {
  return node2.children;
}
function defaultGetKey(node2) {
  return node2.key;
}
function isIgnored() {
  return false;
}
function isShallowLoaded(rawNode, getChildren2) {
  const { isLeaf: isLeaf2 } = rawNode;
  if (isLeaf2 === false && !Array.isArray(getChildren2(rawNode)))
    return false;
  return true;
}
function isDisabled(rawNode) {
  return rawNode.disabled === true;
}
function isExpilicitlyNotLoaded(rawNode, getChildren2) {
  return rawNode.isLeaf === false && !Array.isArray(getChildren2(rawNode));
}
function isNodeInvalid(rawNode, getChildren2) {
  if (rawNode.isLeaf === true) {
    const children = getChildren2(rawNode);
    if (Array.isArray(children) && children.length > 0)
      return true;
  }
  return false;
}
function unwrapCheckedKeys(result) {
  var _a2;
  if (result === void 0 || result === null)
    return [];
  if (Array.isArray(result))
    return result;
  return (_a2 = result.checkedKeys) !== null && _a2 !== void 0 ? _a2 : [];
}
function unwrapIndeterminateKeys(result) {
  var _a2;
  if (result === void 0 || result === null || Array.isArray(result)) {
    return [];
  }
  return (_a2 = result.indeterminateKeys) !== null && _a2 !== void 0 ? _a2 : [];
}
function merge(originalKeys, keysToAdd) {
  const set = new Set(originalKeys);
  keysToAdd.forEach((key) => {
    if (!set.has(key)) {
      set.add(key);
    }
  });
  return Array.from(set);
}
function minus(originalKeys, keysToRemove) {
  const set = new Set(originalKeys);
  keysToRemove.forEach((key) => {
    if (set.has(key)) {
      set.delete(key);
    }
  });
  return Array.from(set);
}
function isGroup(rawNode) {
  return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === "group";
}
class SubtreeNotLoadedError extends Error {
  constructor() {
    super();
    this.message = "SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.";
  }
}
function getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
  return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);
}
function getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {
  const visitedKeys = /* @__PURE__ */ new Set();
  uncheckedKeys.forEach((uncheckedKey) => {
    const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);
    if (uncheckedTreeNode !== void 0) {
      let nodeCursor = uncheckedTreeNode.parent;
      while (nodeCursor !== null) {
        if (nodeCursor.disabled)
          break;
        if (visitedKeys.has(nodeCursor.key))
          break;
        else {
          visitedKeys.add(nodeCursor.key);
        }
        nodeCursor = nodeCursor.parent;
      }
    }
  });
  return visitedKeys;
}
function getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
  const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);
  const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);
  const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);
  const keysToRemove = [];
  extendedCheckedKeySet.forEach((key) => {
    if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {
      keysToRemove.push(key);
    }
  });
  keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));
  return extendedCheckedKeySet;
}
function getCheckedKeys(options, treeMate) {
  const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;
  if (!cascade) {
    if (keysToCheck !== void 0) {
      return {
        checkedKeys: merge(checkedKeys, keysToCheck),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    } else if (keysToUncheck !== void 0) {
      return {
        checkedKeys: minus(checkedKeys, keysToUncheck),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    } else {
      return {
        checkedKeys: Array.from(checkedKeys),
        indeterminateKeys: Array.from(indeterminateKeys)
      };
    }
  }
  const { levelTreeNodeMap } = treeMate;
  let extendedCheckedKeySet;
  if (keysToUncheck !== void 0) {
    extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);
  } else if (keysToCheck !== void 0) {
    extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);
  } else {
    extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);
  }
  const checkStrategyIsParent = checkStrategy === "parent";
  const checkStrategyIsChild = checkStrategy === "child" || leafOnly;
  const syntheticCheckedKeySet = extendedCheckedKeySet;
  const syntheticIndeterminateKeySet = /* @__PURE__ */ new Set();
  const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));
  for (let level = maxLevel; level >= 0; level -= 1) {
    const levelIsZero = level === 0;
    const levelTreeNodes = levelTreeNodeMap.get(level);
    for (const levelTreeNode of levelTreeNodes) {
      if (levelTreeNode.isLeaf)
        continue;
      const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;
      if (checkStrategyIsChild && shallowLoaded) {
        levelTreeNode.children.forEach((v2) => {
          if (!v2.disabled && !v2.isLeaf && v2.shallowLoaded && syntheticCheckedKeySet.has(v2.key)) {
            syntheticCheckedKeySet.delete(v2.key);
          }
        });
      }
      if (levelTreeNode.disabled || !shallowLoaded) {
        continue;
      }
      let fullyChecked = true;
      let partialChecked = false;
      let allDisabled = true;
      for (const childNode of levelTreeNode.children) {
        const childKey = childNode.key;
        if (childNode.disabled)
          continue;
        if (allDisabled)
          allDisabled = false;
        if (syntheticCheckedKeySet.has(childKey)) {
          partialChecked = true;
        } else if (syntheticIndeterminateKeySet.has(childKey)) {
          partialChecked = true;
          fullyChecked = false;
          break;
        } else {
          fullyChecked = false;
          if (partialChecked) {
            break;
          }
        }
      }
      if (fullyChecked && !allDisabled) {
        if (checkStrategyIsParent) {
          levelTreeNode.children.forEach((v2) => {
            if (!v2.disabled && syntheticCheckedKeySet.has(v2.key)) {
              syntheticCheckedKeySet.delete(v2.key);
            }
          });
        }
        syntheticCheckedKeySet.add(levelTreeNodeKey);
      } else if (partialChecked) {
        syntheticIndeterminateKeySet.add(levelTreeNodeKey);
      }
      if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {
        syntheticCheckedKeySet.delete(levelTreeNodeKey);
      }
    }
  }
  return {
    checkedKeys: Array.from(syntheticCheckedKeySet),
    indeterminateKeys: Array.from(syntheticIndeterminateKeySet)
  };
}
function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {
  const { treeNodeMap, getChildren: getChildren2 } = treeMate;
  const visitedKeySet = /* @__PURE__ */ new Set();
  const extendedKeySet = new Set(checkedKeys);
  checkedKeys.forEach((checkedKey) => {
    const checkedTreeNode = treeNodeMap.get(checkedKey);
    if (checkedTreeNode !== void 0) {
      traverseWithCb(checkedTreeNode, (treeNode) => {
        if (treeNode.disabled) {
          return TRAVERSE_COMMAND.STOP;
        }
        const { key } = treeNode;
        if (visitedKeySet.has(key))
          return;
        visitedKeySet.add(key);
        extendedKeySet.add(key);
        if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren2)) {
          if (isUnchecking) {
            return TRAVERSE_COMMAND.STOP;
          } else if (!allowNotLoaded) {
            throw new SubtreeNotLoadedError();
          }
        }
      });
    }
  });
  return extendedKeySet;
}
function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {
  var _a2;
  const treeNodeMap = treeMate.treeNodeMap;
  let treeNode = key === null || key === void 0 ? null : (_a2 = treeNodeMap.get(key)) !== null && _a2 !== void 0 ? _a2 : null;
  const mergedPath = {
    keyPath: [],
    treeNodePath: [],
    treeNode
  };
  if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {
    mergedPath.treeNode = null;
    return mergedPath;
  }
  while (treeNode) {
    if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {
      mergedPath.treeNodePath.push(treeNode);
    }
    treeNode = treeNode.parent;
  }
  mergedPath.treeNodePath.reverse();
  if (!includeSelf)
    mergedPath.treeNodePath.pop();
  mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode2) => treeNode2.key);
  return mergedPath;
}
function getFirstAvailableNode(nodes) {
  if (nodes.length === 0)
    return null;
  const node2 = nodes[0];
  if (node2.isGroup || node2.ignored || node2.disabled) {
    return node2.getNext();
  }
  return node2;
}
function rawGetNext(node2, loop) {
  const sibs = node2.siblings;
  const l3 = sibs.length;
  const { index: index2 } = node2;
  if (loop) {
    return sibs[(index2 + 1) % l3];
  } else {
    if (index2 === sibs.length - 1)
      return null;
    return sibs[index2 + 1];
  }
}
function move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {
  const iterate = dir === "prev" ? rawGetPrev : rawGetNext;
  const getChildOptions = {
    reverse: dir === "prev"
  };
  let meet = false;
  let endNode = null;
  function traverse(node2) {
    if (node2 === null)
      return;
    if (node2 === fromNode) {
      if (!meet) {
        meet = true;
      } else if (!fromNode.disabled && !fromNode.isGroup) {
        endNode = fromNode;
        return;
      }
    } else {
      if ((!node2.disabled || includeDisabled) && !node2.ignored && !node2.isGroup) {
        endNode = node2;
        return;
      }
    }
    if (node2.isGroup) {
      const child = getChild(node2, getChildOptions);
      if (child !== null) {
        endNode = child;
      } else {
        traverse(iterate(node2, loop));
      }
    } else {
      const nextNode = iterate(node2, false);
      if (nextNode !== null) {
        traverse(nextNode);
      } else {
        const parent = rawGetParent(node2);
        if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
          traverse(iterate(parent, loop));
        } else if (loop) {
          traverse(iterate(node2, true));
        }
      }
    }
  }
  traverse(fromNode);
  return endNode;
}
function rawGetPrev(node2, loop) {
  const sibs = node2.siblings;
  const l3 = sibs.length;
  const { index: index2 } = node2;
  if (loop) {
    return sibs[(index2 - 1 + l3) % l3];
  } else {
    if (index2 === 0)
      return null;
    return sibs[index2 - 1];
  }
}
function rawGetParent(node2) {
  return node2.parent;
}
function getChild(node2, options = {}) {
  const { reverse = false } = options;
  const { children } = node2;
  if (children) {
    const { length: length2 } = children;
    const start2 = reverse ? length2 - 1 : 0;
    const end2 = reverse ? -1 : length2;
    const delta = reverse ? -1 : 1;
    for (let i = start2; i !== end2; i += delta) {
      const child = children[i];
      if (!child.disabled && !child.ignored) {
        if (child.isGroup) {
          const childInGroup = getChild(child, options);
          if (childInGroup !== null)
            return childInGroup;
        } else {
          return child;
        }
      }
    }
  }
  return null;
}
const moveMethods = {
  getChild() {
    if (this.ignored)
      return null;
    return getChild(this);
  },
  getParent() {
    const { parent } = this;
    if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
      return parent.getParent();
    }
    return parent;
  },
  getNext(options = {}) {
    return move(this, "next", options);
  },
  getPrev(options = {}) {
    return move(this, "prev", options);
  }
};
function flatten(treeNodes, expandedKeys) {
  const expandedKeySet = expandedKeys ? new Set(expandedKeys) : void 0;
  const flattenedNodes = [];
  function traverse(treeNodes2) {
    treeNodes2.forEach((treeNode) => {
      flattenedNodes.push(treeNode);
      if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)
        return;
      if (treeNode.isGroup) {
        traverse(treeNode.children);
      } else if (
        // normal non-leaf node
        expandedKeySet === void 0 || expandedKeySet.has(treeNode.key)
      ) {
        traverse(treeNode.children);
      }
    });
  }
  traverse(treeNodes);
  return flattenedNodes;
}
function contains(parent, child) {
  const parentKey = parent.key;
  while (child) {
    if (child.key === parentKey)
      return true;
    child = child.parent;
  }
  return false;
}
function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren2, parent = null, level = 0) {
  const treeNodes = [];
  rawNodes.forEach((rawNode, index2) => {
    var _a2;
    if (process$1$1.env.NODE_ENV !== "production" && isNodeInvalid(rawNode, getChildren2)) {
      console.error("[treemate]: node", rawNode, "is invalid");
    }
    const treeNode = Object.create(nodeProto);
    treeNode.rawNode = rawNode;
    treeNode.siblings = treeNodes;
    treeNode.level = level;
    treeNode.index = index2;
    treeNode.isFirstChild = index2 === 0;
    treeNode.isLastChild = index2 + 1 === rawNodes.length;
    treeNode.parent = parent;
    if (!treeNode.ignored) {
      const rawChildren = getChildren2(rawNode);
      if (Array.isArray(rawChildren)) {
        treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren2, treeNode, level + 1);
      }
    }
    treeNodes.push(treeNode);
    treeNodeMap.set(treeNode.key, treeNode);
    if (!levelTreeNodeMap.has(level))
      levelTreeNodeMap.set(level, []);
    (_a2 = levelTreeNodeMap.get(level)) === null || _a2 === void 0 ? void 0 : _a2.push(treeNode);
  });
  return treeNodes;
}
function createTreeMate(rawNodes, options = {}) {
  var _a2;
  const treeNodeMap = /* @__PURE__ */ new Map();
  const levelTreeNodeMap = /* @__PURE__ */ new Map();
  const { getDisabled = isDisabled, getIgnored = isIgnored, getIsGroup = isGroup, getKey = defaultGetKey } = options;
  const _getChildren = (_a2 = options.getChildren) !== null && _a2 !== void 0 ? _a2 : defaultGetChildren;
  const getChildren2 = options.ignoreEmptyChildren ? (node2) => {
    const children = _getChildren(node2);
    if (Array.isArray(children)) {
      if (!children.length)
        return null;
      return children;
    }
    return children;
  } : _getChildren;
  const nodeProto = Object.assign({
    get key() {
      return getKey(this.rawNode);
    },
    get disabled() {
      return getDisabled(this.rawNode);
    },
    get isGroup() {
      return getIsGroup(this.rawNode);
    },
    get isLeaf() {
      return isLeaf(this.rawNode, getChildren2);
    },
    get shallowLoaded() {
      return isShallowLoaded(this.rawNode, getChildren2);
    },
    get ignored() {
      return getIgnored(this.rawNode);
    },
    contains(node2) {
      return contains(this, node2);
    }
  }, moveMethods);
  const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren2);
  function getNode(key) {
    if (key === null || key === void 0)
      return null;
    const tmNode = treeNodeMap.get(key);
    if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
      return tmNode;
    }
    return null;
  }
  function _getNode(key) {
    if (key === null || key === void 0)
      return null;
    const tmNode = treeNodeMap.get(key);
    if (tmNode && !tmNode.ignored) {
      return tmNode;
    }
    return null;
  }
  function getPrev(key, options2) {
    const node2 = _getNode(key);
    if (!node2)
      return null;
    return node2.getPrev(options2);
  }
  function getNext(key, options2) {
    const node2 = _getNode(key);
    if (!node2)
      return null;
    return node2.getNext(options2);
  }
  function getParent(key) {
    const node2 = _getNode(key);
    if (!node2)
      return null;
    return node2.getParent();
  }
  function getChild2(key) {
    const node2 = _getNode(key);
    if (!node2)
      return null;
    return node2.getChild();
  }
  const treemate = {
    treeNodes,
    treeNodeMap,
    levelTreeNodeMap,
    maxLevel: Math.max(...levelTreeNodeMap.keys()),
    getChildren: getChildren2,
    getFlattenedNodes(expandedKeys) {
      return flatten(treeNodes, expandedKeys);
    },
    getNode,
    getPrev,
    getNext,
    getParent,
    getChild: getChild2,
    getFirstAvailableNode() {
      return getFirstAvailableNode(treeNodes);
    },
    getPath(key, options2 = {}) {
      return getPath(key, options2, treemate);
    },
    getCheckedKeys(checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    check(keysToCheck, checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        keysToCheck: keysToCheck === void 0 || keysToCheck === null ? [] : toArray(keysToCheck),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    uncheck(keysToUncheck, checkedKeys, options2 = {}) {
      const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
      return getCheckedKeys({
        checkedKeys: unwrapCheckedKeys(checkedKeys),
        indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
        keysToUncheck: keysToUncheck === null || keysToUncheck === void 0 ? [] : toArray(keysToUncheck),
        cascade,
        leafOnly,
        checkStrategy,
        allowNotLoaded
      }, treemate);
    },
    getNonLeafKeys(options2 = {}) {
      return getNonLeafKeys(treeNodes, options2);
    }
  };
  return treemate;
}
const {
  cubicBezierEaseIn,
  cubicBezierEaseOut
} = commonVariables$2;
function fadeInScaleUpTransition({
  transformOrigin = "inherit",
  duration = ".2s",
  enterScale = ".9",
  originalTransform = "",
  originalTransition = ""
} = {}) {
  return [c$1("&.fade-in-scale-up-transition-leave-active", {
    transformOrigin,
    transition: `opacity ${duration} ${cubicBezierEaseIn}, transform ${duration} ${cubicBezierEaseIn} ${originalTransition && `,${originalTransition}`}`
  }), c$1("&.fade-in-scale-up-transition-enter-active", {
    transformOrigin,
    transition: `opacity ${duration} ${cubicBezierEaseOut}, transform ${duration} ${cubicBezierEaseOut} ${originalTransition && `,${originalTransition}`}`
  }), c$1("&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to", {
    opacity: 0,
    transform: `${originalTransform} scale(${enterScale})`
  }), c$1("&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to", {
    opacity: 1,
    transform: `${originalTransform} scale(1)`
  })];
}
const commonVariables$1 = {
  space: "6px",
  spaceArrow: "10px",
  arrowOffset: "10px",
  arrowOffsetVertical: "10px",
  arrowHeight: "6px",
  padding: "8px 14px"
};
function self$5(vars) {
  const {
    boxShadow2,
    popoverColor,
    textColor2,
    borderRadius,
    fontSize: fontSize2,
    dividerColor
  } = vars;
  return Object.assign(Object.assign({}, commonVariables$1), {
    fontSize: fontSize2,
    borderRadius,
    color: popoverColor,
    dividerColor,
    textColor: textColor2,
    boxShadow: boxShadow2
  });
}
const popoverLight = {
  name: "Popover",
  common: derived,
  self: self$5
};
const oppositePlacement = {
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
const arrowSize = "var(--n-arrow-height) * 1.414";
const style$3 = c$1([cB("popover", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 box-shadow: var(--n-box-shadow);
 word-break: break-word;
 `, [c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("raw", `
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 `, [cNotM("scrollable", [cNotM("show-header-or-footer", "padding: var(--n-padding);")])]), cE("header", `
 padding: var(--n-padding);
 border-bottom: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cE("footer", `
 padding: var(--n-padding);
 border-top: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cM("scrollable, show-header-or-footer", [cE("content", `
 padding: var(--n-padding);
 `)])]), cB("popover-shared", `
 transform-origin: inherit;
 `, [
  cB("popover-arrow-wrapper", `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [cB("popover-arrow", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 display: block;
 width: calc(${arrowSize});
 height: calc(${arrowSize});
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--n-color);
 pointer-events: all;
 `)]),
  // body transition
  c$1("&.popover-transition-enter-from, &.popover-transition-leave-to", `
 opacity: 0;
 transform: scale(.85);
 `),
  c$1("&.popover-transition-enter-to, &.popover-transition-leave-from", `
 transform: scale(1);
 opacity: 1;
 `),
  c$1("&.popover-transition-enter-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-out),
 transform .15s var(--n-bezier-ease-out);
 `),
  c$1("&.popover-transition-leave-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-in),
 transform .15s var(--n-bezier-ease-in);
 `)
]), placementStyle("top-start", `
 top: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("top-start")} - var(--v-offset-left));
 `), placementStyle("top", `
 top: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("top-end", `
 top: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("top-end")} + var(--v-offset-left));
 `), placementStyle("bottom-start", `
 bottom: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("bottom-start")} - var(--v-offset-left));
 `), placementStyle("bottom", `
 bottom: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("bottom-end", `
 bottom: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("bottom-end")} + var(--v-offset-left));
 `), placementStyle("left-start", `
 left: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("left-start")} - var(--v-offset-top));
 `), placementStyle("left", `
 left: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("left-end", `
 left: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("left-end")} + var(--v-offset-top));
 `), placementStyle("right-start", `
 right: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("right-start")} - var(--v-offset-top));
 `), placementStyle("right", `
 right: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("right-end", `
 right: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("right-end")} + var(--v-offset-top));
 `), ...map2({
  top: ["right-start", "left-start"],
  right: ["top-end", "bottom-end"],
  bottom: ["right-end", "left-end"],
  left: ["top-start", "bottom-start"]
}, (placements2, direction) => {
  const isVertical = ["right", "left"].includes(direction);
  const sizeType = isVertical ? "width" : "height";
  return placements2.map((placement) => {
    const isReverse = placement.split("-")[1] === "end";
    const targetSize = `var(--v-target-${sizeType}, 0px)`;
    const centerOffset = `calc((${targetSize} - ${arrowSize}) / 2)`;
    const offset2 = getArrowOffset(placement);
    return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", [cM("center-arrow", [cB("popover-arrow", `${direction}: calc(max(${centerOffset}, ${offset2}) ${isReverse ? "+" : "-"} var(--v-offset-${isVertical ? "left" : "top"}));`)])])]);
  });
})]);
function getArrowOffset(placement) {
  return ["top", "bottom"].includes(placement.split("-")[0]) ? "var(--n-arrow-offset)" : "var(--n-arrow-offset-vertical)";
}
function placementStyle(placement, arrowStyleLiteral) {
  const position = placement.split("-")[0];
  const sizeStyle = ["top", "bottom"].includes(position) ? "height: var(--n-space-arrow);" : "width: var(--n-space-arrow);";
  return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", `
 margin-${oppositePlacement[position]}: var(--n-space);
 `, [cM("show-arrow", `
 margin-${oppositePlacement[position]}: var(--n-space-arrow);
 `), cM("overlap", `
 margin: 0;
 `), cCB("popover-arrow-wrapper", `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${position}: 100%;
 ${oppositePlacement[position]}: auto;
 ${sizeStyle}
 `, [cB("popover-arrow", arrowStyleLiteral)])])]);
}
const popoverBodyProps = Object.assign(Object.assign({}, useTheme.props), {
  to: useAdjustedTo.propTo,
  show: Boolean,
  trigger: String,
  showArrow: Boolean,
  delay: Number,
  duration: Number,
  raw: Boolean,
  arrowPointToCenter: Boolean,
  arrowClass: String,
  arrowStyle: [String, Object],
  arrowWrapperClass: String,
  arrowWrapperStyle: [String, Object],
  displayDirective: String,
  x: Number,
  y: Number,
  flip: Boolean,
  overlap: Boolean,
  placement: String,
  width: [Number, String],
  keepAliveOnHover: Boolean,
  scrollable: Boolean,
  contentClass: String,
  contentStyle: [Object, String],
  headerClass: String,
  headerStyle: [Object, String],
  footerClass: String,
  footerStyle: [Object, String],
  // private
  internalDeactivateImmediately: Boolean,
  animated: Boolean,
  onClickoutside: Function,
  internalTrapFocus: Boolean,
  internalOnAfterLeave: Function,
  // deprecated
  minWidth: Number,
  maxWidth: Number
});
function renderArrow({
  arrowClass,
  arrowStyle,
  arrowWrapperClass,
  arrowWrapperStyle,
  clsPrefix
}) {
  return vue.h("div", {
    key: "__popover-arrow__",
    style: arrowWrapperStyle,
    class: [`${clsPrefix}-popover-arrow-wrapper`, arrowWrapperClass]
  }, vue.h("div", {
    class: [`${clsPrefix}-popover-arrow`, arrowClass],
    style: arrowStyle
  }));
}
const NPopoverBody = vue.defineComponent({
  name: "PopoverBody",
  inheritAttrs: false,
  props: popoverBodyProps,
  setup(props, {
    slots,
    attrs
  }) {
    const {
      namespaceRef,
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Popover", "-popover", style$3, popoverLight, props, mergedClsPrefixRef);
    const followerRef = vue.ref(null);
    const NPopover2 = vue.inject("NPopover");
    const bodyRef = vue.ref(null);
    const followerEnabledRef = vue.ref(props.show);
    const displayedRef = vue.ref(false);
    vue.watchEffect(() => {
      const {
        show
      } = props;
      if (show && !isJsdom() && !props.internalDeactivateImmediately) {
        displayedRef.value = true;
      }
    });
    const directivesRef = vue.computed(() => {
      const {
        trigger: trigger2,
        onClickoutside
      } = props;
      const directives = [];
      const {
        positionManuallyRef: {
          value: positionManually
        }
      } = NPopover2;
      if (!positionManually) {
        if (trigger2 === "click" && !onClickoutside) {
          directives.push([clickoutside, handleClickOutside2, void 0, {
            capture: true
          }]);
        }
        if (trigger2 === "hover") {
          directives.push([mousemoveoutside, handleMouseMoveOutside]);
        }
      }
      if (onClickoutside) {
        directives.push([clickoutside, handleClickOutside2, void 0, {
          capture: true
        }]);
      }
      if (props.displayDirective === "show" || props.animated && displayedRef.value) {
        directives.push([vue.vShow, props.show]);
      }
      return directives;
    });
    const cssVarsRef = vue.computed(() => {
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2,
          cubicBezierEaseIn: cubicBezierEaseIn2,
          cubicBezierEaseOut: cubicBezierEaseOut2
        },
        self: {
          space,
          spaceArrow,
          padding,
          fontSize: fontSize2,
          textColor,
          dividerColor,
          color,
          boxShadow,
          borderRadius,
          arrowHeight,
          arrowOffset,
          arrowOffsetVertical
        }
      } = themeRef.value;
      return {
        "--n-box-shadow": boxShadow,
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-bezier-ease-in": cubicBezierEaseIn2,
        "--n-bezier-ease-out": cubicBezierEaseOut2,
        "--n-font-size": fontSize2,
        "--n-text-color": textColor,
        "--n-color": color,
        "--n-divider-color": dividerColor,
        "--n-border-radius": borderRadius,
        "--n-arrow-height": arrowHeight,
        "--n-arrow-offset": arrowOffset,
        "--n-arrow-offset-vertical": arrowOffsetVertical,
        "--n-padding": padding,
        "--n-space": space,
        "--n-space-arrow": spaceArrow
      };
    });
    const styleRef = vue.computed(() => {
      const width = props.width === "trigger" ? void 0 : formatLength(props.width);
      const style2 = [];
      if (width) {
        style2.push({
          width
        });
      }
      const {
        maxWidth,
        minWidth
      } = props;
      if (maxWidth) {
        style2.push({
          maxWidth: formatLength(maxWidth)
        });
      }
      if (minWidth) {
        style2.push({
          maxWidth: formatLength(minWidth)
        });
      }
      if (!inlineThemeDisabled) {
        style2.push(cssVarsRef.value);
      }
      return style2;
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("popover", void 0, cssVarsRef, props) : void 0;
    NPopover2.setBodyInstance({
      syncPosition
    });
    vue.onBeforeUnmount(() => {
      NPopover2.setBodyInstance(null);
    });
    vue.watch(vue.toRef(props, "show"), (value) => {
      if (props.animated) return;
      if (value) {
        followerEnabledRef.value = true;
      } else {
        followerEnabledRef.value = false;
      }
    });
    function syncPosition() {
      var _a2;
      (_a2 = followerRef.value) === null || _a2 === void 0 ? void 0 : _a2.syncPosition();
    }
    function handleMouseEnter(e) {
      if (props.trigger === "hover" && props.keepAliveOnHover && props.show) {
        NPopover2.handleMouseEnter(e);
      }
    }
    function handleMouseLeave2(e) {
      if (props.trigger === "hover" && props.keepAliveOnHover) {
        NPopover2.handleMouseLeave(e);
      }
    }
    function handleMouseMoveOutside(e) {
      if (props.trigger === "hover" && !getTriggerElement().contains(getPreciseEventTarget(e))) {
        NPopover2.handleMouseMoveOutside(e);
      }
    }
    function handleClickOutside2(e) {
      if (props.trigger === "click" && !getTriggerElement().contains(getPreciseEventTarget(e)) || props.onClickoutside) {
        NPopover2.handleClickOutside(e);
      }
    }
    function getTriggerElement() {
      return NPopover2.getTriggerElement();
    }
    vue.provide(popoverBodyInjectionKey, bodyRef);
    vue.provide(drawerBodyInjectionKey, null);
    vue.provide(modalBodyInjectionKey, null);
    function renderContentNode() {
      themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
      const shouldRenderDom = props.displayDirective === "show" || props.show || props.animated && displayedRef.value;
      if (!shouldRenderDom) {
        return null;
      }
      let contentNode;
      const renderBody = NPopover2.internalRenderBodyRef.value;
      const {
        value: mergedClsPrefix
      } = mergedClsPrefixRef;
      if (!renderBody) {
        const {
          value: extraClass
        } = NPopover2.extraClassRef;
        const {
          internalTrapFocus
        } = props;
        const hasHeaderOrFooter = !isSlotEmpty(slots.header) || !isSlotEmpty(slots.footer);
        const renderContentInnerNode = () => {
          var _a2, _b;
          const body = hasHeaderOrFooter ? vue.h(vue.Fragment, null, resolveWrappedSlot(slots.header, (children) => {
            return children ? vue.h("div", {
              class: [`${mergedClsPrefix}-popover__header`, props.headerClass],
              style: props.headerStyle
            }, children) : null;
          }), resolveWrappedSlot(slots.default, (children) => {
            return children ? vue.h("div", {
              class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
              style: props.contentStyle
            }, slots) : null;
          }), resolveWrappedSlot(slots.footer, (children) => {
            return children ? vue.h("div", {
              class: [`${mergedClsPrefix}-popover__footer`, props.footerClass],
              style: props.footerStyle
            }, children) : null;
          })) : props.scrollable ? (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots) : vue.h("div", {
            class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
            style: props.contentStyle
          }, slots);
          const maybeScrollableBody = props.scrollable ? vue.h(XScrollbar, {
            contentClass: hasHeaderOrFooter ? void 0 : `${mergedClsPrefix}-popover__content ${(_b = props.contentClass) !== null && _b !== void 0 ? _b : ""}`,
            contentStyle: hasHeaderOrFooter ? void 0 : props.contentStyle
          }, {
            default: () => body
          }) : body;
          const arrow2 = props.showArrow ? renderArrow({
            arrowClass: props.arrowClass,
            arrowStyle: props.arrowStyle,
            arrowWrapperClass: props.arrowWrapperClass,
            arrowWrapperStyle: props.arrowWrapperStyle,
            clsPrefix: mergedClsPrefix
          }) : null;
          return [maybeScrollableBody, arrow2];
        };
        contentNode = vue.h("div", vue.mergeProps({
          class: [`${mergedClsPrefix}-popover`, `${mergedClsPrefix}-popover-shared`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, extraClass.map((v2) => `${mergedClsPrefix}-${v2}`), {
            [`${mergedClsPrefix}-popover--scrollable`]: props.scrollable,
            [`${mergedClsPrefix}-popover--show-header-or-footer`]: hasHeaderOrFooter,
            [`${mergedClsPrefix}-popover--raw`]: props.raw,
            [`${mergedClsPrefix}-popover-shared--overlap`]: props.overlap,
            [`${mergedClsPrefix}-popover-shared--show-arrow`]: props.showArrow,
            [`${mergedClsPrefix}-popover-shared--center-arrow`]: props.arrowPointToCenter
          }],
          ref: bodyRef,
          style: styleRef.value,
          onKeydown: NPopover2.handleKeydown,
          onMouseenter: handleMouseEnter,
          onMouseleave: handleMouseLeave2
        }, attrs), internalTrapFocus ? vue.h(FocusTrap, {
          active: props.show,
          autoFocus: true
        }, {
          default: renderContentInnerNode
        }) : renderContentInnerNode());
      } else {
        contentNode = renderBody(
          // The popover class and overlap class must exists, they will be used
          // to place the body & transition animation.
          // Shadow class exists for reuse box-shadow.
          [`${mergedClsPrefix}-popover-shared`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, props.overlap && `${mergedClsPrefix}-popover-shared--overlap`, props.showArrow && `${mergedClsPrefix}-popover-shared--show-arrow`, props.arrowPointToCenter && `${mergedClsPrefix}-popover-shared--center-arrow`],
          bodyRef,
          styleRef.value,
          handleMouseEnter,
          handleMouseLeave2
        );
      }
      return vue.withDirectives(contentNode, directivesRef.value);
    }
    return {
      displayed: displayedRef,
      namespace: namespaceRef,
      isMounted: NPopover2.isMountedRef,
      zIndex: NPopover2.zIndexRef,
      followerRef,
      adjustedTo: useAdjustedTo(props),
      followerEnabled: followerEnabledRef,
      renderContentNode
    };
  },
  render() {
    return vue.h(VFollower, {
      ref: "followerRef",
      zIndex: this.zIndex,
      show: this.show,
      enabled: this.followerEnabled,
      to: this.adjustedTo,
      x: this.x,
      y: this.y,
      flip: this.flip,
      placement: this.placement,
      containerClass: this.namespace,
      overlap: this.overlap,
      width: this.width === "trigger" ? "target" : void 0,
      teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
    }, {
      default: () => {
        return this.animated ? vue.h(vue.Transition, {
          name: "popover-transition",
          appear: this.isMounted,
          // Don't use watch to enable follower, since the transition may
          // make position sync timing very subtle and buggy.
          onEnter: () => {
            this.followerEnabled = true;
          },
          onAfterLeave: () => {
            var _a2;
            (_a2 = this.internalOnAfterLeave) === null || _a2 === void 0 ? void 0 : _a2.call(this);
            this.followerEnabled = false;
            this.displayed = false;
          }
        }, {
          default: this.renderContentNode
        }) : this.renderContentNode();
      }
    });
  }
});
const bodyPropKeys = Object.keys(popoverBodyProps);
const triggerEventMap = {
  focus: ["onFocus", "onBlur"],
  click: ["onClick"],
  hover: ["onMouseenter", "onMouseleave"],
  manual: [],
  nested: ["onFocus", "onBlur", "onMouseenter", "onMouseleave", "onClick"]
};
function appendEvents(vNode, trigger2, events2) {
  triggerEventMap[trigger2].forEach((eventName) => {
    if (!vNode.props) {
      vNode.props = {};
    } else {
      vNode.props = Object.assign({}, vNode.props);
    }
    const originalHandler = vNode.props[eventName];
    const handler = events2[eventName];
    if (!originalHandler) {
      vNode.props[eventName] = handler;
    } else {
      vNode.props[eventName] = (...args) => {
        originalHandler(...args);
        handler(...args);
      };
    }
  });
}
const popoverBaseProps = {
  show: {
    type: Boolean,
    default: void 0
  },
  defaultShow: Boolean,
  showArrow: {
    type: Boolean,
    default: true
  },
  trigger: {
    type: String,
    default: "hover"
  },
  delay: {
    type: Number,
    default: 100
  },
  duration: {
    type: Number,
    default: 100
  },
  raw: Boolean,
  placement: {
    type: String,
    default: "top"
  },
  x: Number,
  y: Number,
  arrowPointToCenter: Boolean,
  disabled: Boolean,
  getDisabled: Function,
  displayDirective: {
    type: String,
    default: "if"
  },
  arrowClass: String,
  arrowStyle: [String, Object],
  arrowWrapperClass: String,
  arrowWrapperStyle: [String, Object],
  flip: {
    type: Boolean,
    default: true
  },
  animated: {
    type: Boolean,
    default: true
  },
  width: {
    type: [Number, String],
    default: void 0
  },
  overlap: Boolean,
  keepAliveOnHover: {
    type: Boolean,
    default: true
  },
  zIndex: Number,
  to: useAdjustedTo.propTo,
  scrollable: Boolean,
  contentClass: String,
  contentStyle: [Object, String],
  headerClass: String,
  headerStyle: [Object, String],
  footerClass: String,
  footerStyle: [Object, String],
  // events
  onClickoutside: Function,
  "onUpdate:show": [Function, Array],
  onUpdateShow: [Function, Array],
  // internal
  internalDeactivateImmediately: Boolean,
  internalSyncTargetWithParent: Boolean,
  internalInheritedEventHandlers: {
    type: Array,
    default: () => []
  },
  internalTrapFocus: Boolean,
  internalExtraClass: {
    type: Array,
    default: () => []
  },
  // deprecated
  onShow: [Function, Array],
  onHide: [Function, Array],
  arrow: {
    type: Boolean,
    default: void 0
  },
  minWidth: Number,
  maxWidth: Number
};
const popoverProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), {
  internalOnAfterLeave: Function,
  internalRenderBody: Function
});
const NPopover = vue.defineComponent({
  name: "Popover",
  inheritAttrs: false,
  props: popoverProps,
  slots: Object,
  __popover__: true,
  setup(props) {
    if (process$1$1.env.NODE_ENV !== "production") {
      vue.watchEffect(() => {
        if (props.maxWidth !== void 0) {
          warnOnce("popover", "`max-width` is deprecated, please use `style` instead.");
        }
        if (props.minWidth !== void 0) {
          warnOnce("popover", "`min-width` is deprecated, please use `style` instead.");
        }
        if (props.arrow !== void 0) {
          warnOnce("popover", "`arrow` is deprecated, please use `showArrow` instead.");
        }
        if (props.onHide !== void 0) {
          warnOnce("popover", "`on-hide` is deprecated, please use `on-update:show` instead.");
        }
        if (props.onShow !== void 0) {
          warnOnce("popover", "`on-show` is deprecated, please use `on-update:show` instead.");
        }
      });
    }
    const isMountedRef = isMounted();
    const binderInstRef = vue.ref(null);
    const controlledShowRef = vue.computed(() => props.show);
    const uncontrolledShowRef = vue.ref(props.defaultShow);
    const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
    const mergedShowConsideringDisabledPropRef = useMemo(() => {
      if (props.disabled) return false;
      return mergedShowWithoutDisabledRef.value;
    });
    const getMergedDisabled = () => {
      if (props.disabled) return true;
      const {
        getDisabled
      } = props;
      if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled()) return true;
      return false;
    };
    const getMergedShow = () => {
      if (getMergedDisabled()) return false;
      return mergedShowWithoutDisabledRef.value;
    };
    const compatibleShowArrowRef = useCompitable(props, ["arrow", "showArrow"]);
    const mergedShowArrowRef = vue.computed(() => {
      if (props.overlap) return false;
      return compatibleShowArrowRef.value;
    });
    let bodyInstance = null;
    const showTimerIdRef = vue.ref(null);
    const hideTimerIdRef = vue.ref(null);
    const positionManuallyRef = useMemo(() => {
      return props.x !== void 0 && props.y !== void 0;
    });
    function doUpdateShow(value) {
      const {
        "onUpdate:show": _onUpdateShow,
        onUpdateShow,
        onShow: onShow2,
        onHide: onHide2
      } = props;
      uncontrolledShowRef.value = value;
      if (_onUpdateShow) {
        call(_onUpdateShow, value);
      }
      if (onUpdateShow) {
        call(onUpdateShow, value);
      }
      if (value && onShow2) {
        call(onShow2, true);
      }
      if (value && onHide2) {
        call(onHide2, false);
      }
    }
    function syncPosition() {
      if (bodyInstance) {
        bodyInstance.syncPosition();
      }
    }
    function clearShowTimer() {
      const {
        value: showTimerId
      } = showTimerIdRef;
      if (showTimerId) {
        window.clearTimeout(showTimerId);
        showTimerIdRef.value = null;
      }
    }
    function clearHideTimer() {
      const {
        value: hideTimerId
      } = hideTimerIdRef;
      if (hideTimerId) {
        window.clearTimeout(hideTimerId);
        hideTimerIdRef.value = null;
      }
    }
    function handleFocus() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "focus" && !mergedDisabled) {
        if (getMergedShow()) return;
        doUpdateShow(true);
      }
    }
    function handleBlur() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "focus" && !mergedDisabled) {
        if (!getMergedShow()) return;
        doUpdateShow(false);
      }
    }
    function handleMouseEnter() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "hover" && !mergedDisabled) {
        clearHideTimer();
        if (showTimerIdRef.value !== null) return;
        if (getMergedShow()) return;
        const delayCallback = () => {
          doUpdateShow(true);
          showTimerIdRef.value = null;
        };
        const {
          delay
        } = props;
        if (delay === 0) {
          delayCallback();
        } else {
          showTimerIdRef.value = window.setTimeout(delayCallback, delay);
        }
      }
    }
    function handleMouseLeave2() {
      const mergedDisabled = getMergedDisabled();
      if (props.trigger === "hover" && !mergedDisabled) {
        clearShowTimer();
        if (hideTimerIdRef.value !== null) return;
        if (!getMergedShow()) return;
        const delayedCallback = () => {
          doUpdateShow(false);
          hideTimerIdRef.value = null;
        };
        const {
          duration
        } = props;
        if (duration === 0) {
          delayedCallback();
        } else {
          hideTimerIdRef.value = window.setTimeout(delayedCallback, duration);
        }
      }
    }
    function handleMouseMoveOutside() {
      handleMouseLeave2();
    }
    function handleClickOutside2(e) {
      var _a2;
      if (!getMergedShow()) return;
      if (props.trigger === "click") {
        clearShowTimer();
        clearHideTimer();
        doUpdateShow(false);
      }
      (_a2 = props.onClickoutside) === null || _a2 === void 0 ? void 0 : _a2.call(props, e);
    }
    function handleClick2() {
      if (props.trigger === "click" && !getMergedDisabled()) {
        clearShowTimer();
        clearHideTimer();
        const nextShow = !getMergedShow();
        doUpdateShow(nextShow);
      }
    }
    function handleKeydown(e) {
      if (!props.internalTrapFocus) return;
      if (e.key === "Escape") {
        clearShowTimer();
        clearHideTimer();
        doUpdateShow(false);
      }
    }
    function setShow(value) {
      uncontrolledShowRef.value = value;
    }
    function getTriggerElement() {
      var _a2;
      return (_a2 = binderInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.targetRef;
    }
    function setBodyInstance(value) {
      bodyInstance = value;
    }
    vue.provide("NPopover", {
      getTriggerElement,
      handleKeydown,
      handleMouseEnter,
      handleMouseLeave: handleMouseLeave2,
      handleClickOutside: handleClickOutside2,
      handleMouseMoveOutside,
      setBodyInstance,
      positionManuallyRef,
      isMountedRef,
      zIndexRef: vue.toRef(props, "zIndex"),
      extraClassRef: vue.toRef(props, "internalExtraClass"),
      internalRenderBodyRef: vue.toRef(props, "internalRenderBody")
    });
    vue.watchEffect(() => {
      if (mergedShowWithoutDisabledRef.value && getMergedDisabled()) {
        doUpdateShow(false);
      }
    });
    const returned = {
      binderInstRef,
      positionManually: positionManuallyRef,
      mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
      // if to show popover body
      uncontrolledShow: uncontrolledShowRef,
      mergedShowArrow: mergedShowArrowRef,
      getMergedShow,
      setShow,
      handleClick: handleClick2,
      handleMouseEnter,
      handleMouseLeave: handleMouseLeave2,
      handleFocus,
      handleBlur,
      syncPosition
    };
    return returned;
  },
  render() {
    var _a2;
    const {
      positionManually,
      $slots: slots
    } = this;
    let triggerVNode;
    let popoverInside = false;
    if (!positionManually) {
      triggerVNode = getFirstSlotVNode(slots, "trigger");
      if (triggerVNode) {
        triggerVNode = vue.cloneVNode(triggerVNode);
        triggerVNode = triggerVNode.type === vue.Text ? vue.h("span", [triggerVNode]) : triggerVNode;
        const handlers2 = {
          onClick: this.handleClick,
          onMouseenter: this.handleMouseEnter,
          onMouseleave: this.handleMouseLeave,
          onFocus: this.handleFocus,
          onBlur: this.handleBlur
        };
        if ((_a2 = triggerVNode.type) === null || _a2 === void 0 ? void 0 : _a2.__popover__) {
          popoverInside = true;
          if (!triggerVNode.props) {
            triggerVNode.props = {
              internalSyncTargetWithParent: true,
              internalInheritedEventHandlers: []
            };
          }
          triggerVNode.props.internalSyncTargetWithParent = true;
          if (!triggerVNode.props.internalInheritedEventHandlers) {
            triggerVNode.props.internalInheritedEventHandlers = [handlers2];
          } else {
            triggerVNode.props.internalInheritedEventHandlers = [handlers2, ...triggerVNode.props.internalInheritedEventHandlers];
          }
        } else {
          const {
            internalInheritedEventHandlers
          } = this;
          const ascendantAndCurrentHandlers = [handlers2, ...internalInheritedEventHandlers];
          const mergedHandlers = {
            onBlur: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onBlur(e);
              });
            },
            onFocus: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onFocus(e);
              });
            },
            onClick: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onClick(e);
              });
            },
            onMouseenter: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onMouseenter(e);
              });
            },
            onMouseleave: (e) => {
              ascendantAndCurrentHandlers.forEach((_handlers) => {
                _handlers.onMouseleave(e);
              });
            }
          };
          appendEvents(triggerVNode, internalInheritedEventHandlers ? "nested" : positionManually ? "manual" : this.trigger, mergedHandlers);
        }
      }
    }
    return vue.h(Binder, {
      ref: "binderInstRef",
      syncTarget: !popoverInside,
      syncTargetWithParent: this.internalSyncTargetWithParent
    }, {
      default: () => {
        void this.mergedShowConsideringDisabledProp;
        const mergedShow = this.getMergedShow();
        return [this.internalTrapFocus && mergedShow ? vue.withDirectives(vue.h("div", {
          style: {
            position: "fixed",
            top: 0,
            right: 0,
            bottom: 0,
            left: 0
          }
        }), [[zindexable, {
          enabled: mergedShow,
          zIndex: this.zIndex
        }]]) : null, positionManually ? null : vue.h(VTarget, null, {
          default: () => triggerVNode
        }), vue.h(NPopoverBody, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), {
          showArrow: this.mergedShowArrow,
          show: mergedShow
        })), {
          default: () => {
            var _a22, _b;
            return (_b = (_a22 = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a22);
          },
          header: () => {
            var _a22, _b;
            return (_b = (_a22 = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a22);
          },
          footer: () => {
            var _a22, _b;
            return (_b = (_a22 = this.$slots).footer) === null || _b === void 0 ? void 0 : _b.call(_a22);
          }
        })];
      }
    });
  }
});
const commonVariables = {
  padding: "4px 0",
  optionIconSizeSmall: "14px",
  optionIconSizeMedium: "16px",
  optionIconSizeLarge: "16px",
  optionIconSizeHuge: "18px",
  optionSuffixWidthSmall: "14px",
  optionSuffixWidthMedium: "14px",
  optionSuffixWidthLarge: "16px",
  optionSuffixWidthHuge: "16px",
  optionIconSuffixWidthSmall: "32px",
  optionIconSuffixWidthMedium: "32px",
  optionIconSuffixWidthLarge: "36px",
  optionIconSuffixWidthHuge: "36px",
  optionPrefixWidthSmall: "14px",
  optionPrefixWidthMedium: "14px",
  optionPrefixWidthLarge: "16px",
  optionPrefixWidthHuge: "16px",
  optionIconPrefixWidthSmall: "36px",
  optionIconPrefixWidthMedium: "36px",
  optionIconPrefixWidthLarge: "40px",
  optionIconPrefixWidthHuge: "40px"
};
function self$4(vars) {
  const {
    primaryColor,
    textColor2,
    dividerColor,
    hoverColor,
    popoverColor,
    invertedColor,
    borderRadius,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    fontSizeHuge,
    heightSmall,
    heightMedium,
    heightLarge,
    heightHuge,
    textColor3,
    opacityDisabled
  } = vars;
  return Object.assign(Object.assign({}, commonVariables), {
    optionHeightSmall: heightSmall,
    optionHeightMedium: heightMedium,
    optionHeightLarge: heightLarge,
    optionHeightHuge: heightHuge,
    borderRadius,
    fontSizeSmall,
    fontSizeMedium,
    fontSizeLarge,
    fontSizeHuge,
    // non-inverted
    optionTextColor: textColor2,
    optionTextColorHover: textColor2,
    optionTextColorActive: primaryColor,
    optionTextColorChildActive: primaryColor,
    color: popoverColor,
    dividerColor,
    suffixColor: textColor2,
    prefixColor: textColor2,
    optionColorHover: hoverColor,
    optionColorActive: changeColor(primaryColor, {
      alpha: 0.1
    }),
    groupHeaderTextColor: textColor3,
    // inverted
    optionTextColorInverted: "#BBB",
    optionTextColorHoverInverted: "#FFF",
    optionTextColorActiveInverted: "#FFF",
    optionTextColorChildActiveInverted: "#FFF",
    colorInverted: invertedColor,
    dividerColorInverted: "#BBB",
    suffixColorInverted: "#BBB",
    prefixColorInverted: "#BBB",
    optionColorHoverInverted: primaryColor,
    optionColorActiveInverted: primaryColor,
    groupHeaderTextColorInverted: "#AAA",
    optionOpacityDisabled: opacityDisabled
  });
}
const dropdownLight = createTheme({
  name: "Dropdown",
  common: derived,
  peers: {
    Popover: popoverLight
  },
  self: self$4
});
const commonVars = {
  padding: "8px 14px"
};
function self$3(vars) {
  const {
    borderRadius,
    boxShadow2,
    baseColor
  } = vars;
  return Object.assign(Object.assign({}, commonVars), {
    borderRadius,
    boxShadow: boxShadow2,
    color: composite(baseColor, "rgba(0, 0, 0, .85)"),
    textColor: baseColor
  });
}
const tooltipLight = createTheme({
  name: "Tooltip",
  common: derived,
  peers: {
    Popover: popoverLight
  },
  self: self$3
});
const tooltipProps = Object.assign(Object.assign({}, popoverBaseProps), useTheme.props);
const NTooltip = vue.defineComponent({
  name: "Tooltip",
  props: tooltipProps,
  slots: Object,
  __popover__: true,
  setup(props) {
    const {
      mergedClsPrefixRef
    } = useConfig(props);
    const themeRef = useTheme("Tooltip", "-tooltip", void 0, tooltipLight, props, mergedClsPrefixRef);
    const popoverRef = vue.ref(null);
    const tooltipExposedMethod = {
      syncPosition() {
        popoverRef.value.syncPosition();
      },
      setShow(show) {
        popoverRef.value.setShow(show);
      }
    };
    return Object.assign(Object.assign({}, tooltipExposedMethod), {
      popoverRef,
      mergedTheme: themeRef,
      popoverThemeOverrides: vue.computed(() => {
        return themeRef.value.self;
      })
    });
  },
  render() {
    const {
      mergedTheme,
      internalExtraClass
    } = this;
    return vue.h(NPopover, Object.assign(Object.assign({}, this.$props), {
      theme: mergedTheme.peers.Popover,
      themeOverrides: mergedTheme.peerOverrides.Popover,
      builtinThemeOverrides: this.popoverThemeOverrides,
      internalExtraClass: internalExtraClass.concat("tooltip"),
      ref: "popoverRef"
    }), this.$slots);
  }
});
const dropdownMenuInjectionKey = createInjectionKey("n-dropdown-menu");
const dropdownInjectionKey = createInjectionKey("n-dropdown");
const dropdownOptionInjectionKey = createInjectionKey("n-dropdown-option");
const NDropdownDivider = vue.defineComponent({
  name: "DropdownDivider",
  props: {
    clsPrefix: {
      type: String,
      required: true
    }
  },
  render() {
    return vue.h("div", {
      class: `${this.clsPrefix}-dropdown-divider`
    });
  }
});
const NDropdownGroupHeader = vue.defineComponent({
  name: "DropdownGroupHeader",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    }
  },
  setup() {
    const {
      showIconRef,
      hasSubmenuRef
    } = vue.inject(dropdownMenuInjectionKey);
    const {
      renderLabelRef,
      labelFieldRef,
      nodePropsRef,
      renderOptionRef
    } = vue.inject(dropdownInjectionKey);
    return {
      labelField: labelFieldRef,
      showIcon: showIconRef,
      hasSubmenu: hasSubmenuRef,
      renderLabel: renderLabelRef,
      nodeProps: nodePropsRef,
      renderOption: renderOptionRef
    };
  },
  render() {
    var _a2;
    const {
      clsPrefix,
      hasSubmenu,
      showIcon,
      nodeProps,
      renderLabel,
      renderOption
    } = this;
    const {
      rawNode
    } = this.tmNode;
    const node2 = vue.h("div", Object.assign({
      class: `${clsPrefix}-dropdown-option`
    }, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode)), vue.h("div", {
      class: `${clsPrefix}-dropdown-option-body ${clsPrefix}-dropdown-option-body--group`
    }, vue.h("div", {
      "data-dropdown-option": true,
      class: [`${clsPrefix}-dropdown-option-body__prefix`, showIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
    }, render(rawNode.icon)), vue.h("div", {
      class: `${clsPrefix}-dropdown-option-body__label`,
      "data-dropdown-option": true
    }, renderLabel ? renderLabel(rawNode) : render((_a2 = rawNode.title) !== null && _a2 !== void 0 ? _a2 : rawNode[this.labelField])), vue.h("div", {
      class: [`${clsPrefix}-dropdown-option-body__suffix`, hasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`],
      "data-dropdown-option": true
    })));
    if (renderOption) {
      return renderOption({
        node: node2,
        option: rawNode
      });
    }
    return node2;
  }
});
function self$2(vars) {
  const {
    textColorBase,
    opacity1,
    opacity2,
    opacity3,
    opacity4,
    opacity5
  } = vars;
  return {
    color: textColorBase,
    opacity1Depth: opacity1,
    opacity2Depth: opacity2,
    opacity3Depth: opacity3,
    opacity4Depth: opacity4,
    opacity5Depth: opacity5
  };
}
const iconLight = {
  common: derived,
  self: self$2
};
const style$2 = cB("icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
`, [cM("color-transition", {
  transition: "color .3s var(--n-bezier)"
}), cM("depth", {
  color: "var(--n-color)"
}, [c$1("svg", {
  opacity: "var(--n-opacity)",
  transition: "opacity .3s var(--n-bezier)"
})]), c$1("svg", {
  height: "1em",
  width: "1em"
})]);
const iconProps = Object.assign(Object.assign({}, useTheme.props), {
  depth: [String, Number],
  size: [Number, String],
  color: String,
  component: [Object, Function]
});
const NIcon = vue.defineComponent({
  _n_icon__: true,
  name: "Icon",
  inheritAttrs: false,
  props: iconProps,
  setup(props) {
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Icon", "-icon", style$2, iconLight, props, mergedClsPrefixRef);
    const cssVarsRef = vue.computed(() => {
      const {
        depth
      } = props;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: self2
      } = themeRef.value;
      if (depth !== void 0) {
        const {
          color,
          [`opacity${depth}Depth`]: opacity
        } = self2;
        return {
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color": color,
          "--n-opacity": opacity
        };
      }
      return {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-color": "",
        "--n-opacity": ""
      };
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon", vue.computed(() => `${props.depth || "d"}`), cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      mergedStyle: vue.computed(() => {
        const {
          size: size2,
          color
        } = props;
        return {
          fontSize: formatLength(size2),
          color
        };
      }),
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    var _a2;
    const {
      $parent,
      depth,
      mergedClsPrefix,
      component,
      onRender,
      themeClass
    } = this;
    if ((_a2 = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a2 === void 0 ? void 0 : _a2._n_icon__) {
      warn("icon", "don't wrap `n-icon` inside `n-icon`");
    }
    onRender === null || onRender === void 0 ? void 0 : onRender();
    return vue.h("i", vue.mergeProps(this.$attrs, {
      role: "img",
      class: [`${mergedClsPrefix}-icon`, themeClass, {
        [`${mergedClsPrefix}-icon--depth`]: depth,
        [`${mergedClsPrefix}-icon--color-transition`]: depth !== void 0
      }],
      style: [this.cssVars, this.mergedStyle]
    }), component ? vue.h(component) : this.$slots);
  }
});
function isSubmenuNode(rawNode, childrenField) {
  return rawNode.type === "submenu" || rawNode.type === void 0 && rawNode[childrenField] !== void 0;
}
function isGroupNode(rawNode) {
  return rawNode.type === "group";
}
function isDividerNode(rawNode) {
  return rawNode.type === "divider";
}
function isRenderNode(rawNode) {
  return rawNode.type === "render";
}
const NDropdownOption = vue.defineComponent({
  name: "DropdownOption",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    },
    parentKey: {
      type: [String, Number],
      default: null
    },
    placement: {
      type: String,
      default: "right-start"
    },
    props: Object,
    scrollable: Boolean
  },
  setup(props) {
    const NDropdown2 = vue.inject(dropdownInjectionKey);
    const {
      hoverKeyRef,
      keyboardKeyRef,
      lastToggledSubmenuKeyRef,
      pendingKeyPathRef,
      activeKeyPathRef,
      animatedRef,
      mergedShowRef,
      renderLabelRef,
      renderIconRef,
      labelFieldRef,
      childrenFieldRef,
      renderOptionRef,
      nodePropsRef,
      menuPropsRef
    } = NDropdown2;
    const NDropdownOption2 = vue.inject(dropdownOptionInjectionKey, null);
    const NDropdownMenu2 = vue.inject(dropdownMenuInjectionKey);
    const NPopoverBody2 = vue.inject(popoverBodyInjectionKey);
    const rawNodeRef = vue.computed(() => props.tmNode.rawNode);
    const hasSubmenuRef = vue.computed(() => {
      const {
        value: childrenField
      } = childrenFieldRef;
      return isSubmenuNode(props.tmNode.rawNode, childrenField);
    });
    const mergedDisabledRef = vue.computed(() => {
      const {
        disabled
      } = props.tmNode;
      return disabled;
    });
    const showSubmenuRef = vue.computed(() => {
      if (!hasSubmenuRef.value) return false;
      const {
        key,
        disabled
      } = props.tmNode;
      if (disabled) return false;
      const {
        value: hoverKey
      } = hoverKeyRef;
      const {
        value: keyboardKey
      } = keyboardKeyRef;
      const {
        value: lastToggledSubmenuKey
      } = lastToggledSubmenuKeyRef;
      const {
        value: pendingKeyPath
      } = pendingKeyPathRef;
      if (hoverKey !== null) return pendingKeyPath.includes(key);
      if (keyboardKey !== null) {
        return pendingKeyPath.includes(key) && pendingKeyPath[pendingKeyPath.length - 1] !== key;
      }
      if (lastToggledSubmenuKey !== null) return pendingKeyPath.includes(key);
      return false;
    });
    const shouldDelayRef = vue.computed(() => {
      return keyboardKeyRef.value === null && !animatedRef.value;
    });
    const deferredShowSubmenuRef = useDeferredTrue(showSubmenuRef, 300, shouldDelayRef);
    const parentEnteringSubmenuRef = vue.computed(() => {
      return !!(NDropdownOption2 === null || NDropdownOption2 === void 0 ? void 0 : NDropdownOption2.enteringSubmenuRef.value);
    });
    const enteringSubmenuRef = vue.ref(false);
    vue.provide(dropdownOptionInjectionKey, {
      enteringSubmenuRef
    });
    function handleSubmenuBeforeEnter() {
      enteringSubmenuRef.value = true;
    }
    function handleSubmenuAfterEnter() {
      enteringSubmenuRef.value = false;
    }
    function handleMouseEnter() {
      const {
        parentKey,
        tmNode
      } = props;
      if (tmNode.disabled) return;
      if (!mergedShowRef.value) return;
      lastToggledSubmenuKeyRef.value = parentKey;
      keyboardKeyRef.value = null;
      hoverKeyRef.value = tmNode.key;
    }
    function handleMouseMove2() {
      const {
        tmNode
      } = props;
      if (tmNode.disabled) return;
      if (!mergedShowRef.value) return;
      if (hoverKeyRef.value === tmNode.key) return;
      handleMouseEnter();
    }
    function handleMouseLeave2(e) {
      if (props.tmNode.disabled) return;
      if (!mergedShowRef.value) return;
      const {
        relatedTarget
      } = e;
      if (relatedTarget && !happensIn({
        target: relatedTarget
      }, "dropdownOption") && !happensIn({
        target: relatedTarget
      }, "scrollbarRail")) {
        hoverKeyRef.value = null;
      }
    }
    function handleClick2() {
      const {
        value: hasSubmenu
      } = hasSubmenuRef;
      const {
        tmNode
      } = props;
      if (!mergedShowRef.value) return;
      if (!hasSubmenu && !tmNode.disabled) {
        NDropdown2.doSelect(tmNode.key, tmNode.rawNode);
        NDropdown2.doUpdateShow(false);
      }
    }
    return {
      labelField: labelFieldRef,
      renderLabel: renderLabelRef,
      renderIcon: renderIconRef,
      siblingHasIcon: NDropdownMenu2.showIconRef,
      siblingHasSubmenu: NDropdownMenu2.hasSubmenuRef,
      menuProps: menuPropsRef,
      popoverBody: NPopoverBody2,
      animated: animatedRef,
      mergedShowSubmenu: vue.computed(() => {
        return deferredShowSubmenuRef.value && !parentEnteringSubmenuRef.value;
      }),
      rawNode: rawNodeRef,
      hasSubmenu: hasSubmenuRef,
      pending: useMemo(() => {
        const {
          value: pendingKeyPath
        } = pendingKeyPathRef;
        const {
          key
        } = props.tmNode;
        return pendingKeyPath.includes(key);
      }),
      childActive: useMemo(() => {
        const {
          value: activeKeyPath
        } = activeKeyPathRef;
        const {
          key
        } = props.tmNode;
        const index2 = activeKeyPath.findIndex((k) => key === k);
        if (index2 === -1) return false;
        return index2 < activeKeyPath.length - 1;
      }),
      active: useMemo(() => {
        const {
          value: activeKeyPath
        } = activeKeyPathRef;
        const {
          key
        } = props.tmNode;
        const index2 = activeKeyPath.findIndex((k) => key === k);
        if (index2 === -1) return false;
        return index2 === activeKeyPath.length - 1;
      }),
      mergedDisabled: mergedDisabledRef,
      renderOption: renderOptionRef,
      nodeProps: nodePropsRef,
      handleClick: handleClick2,
      handleMouseMove: handleMouseMove2,
      handleMouseEnter,
      handleMouseLeave: handleMouseLeave2,
      handleSubmenuBeforeEnter,
      handleSubmenuAfterEnter
    };
  },
  render() {
    var _a2, _b;
    const {
      animated,
      rawNode,
      mergedShowSubmenu,
      clsPrefix,
      siblingHasIcon,
      siblingHasSubmenu,
      renderLabel,
      renderIcon,
      renderOption,
      nodeProps,
      props,
      scrollable
    } = this;
    let submenuVNode = null;
    if (mergedShowSubmenu) {
      const submenuNodeProps = (_a2 = this.menuProps) === null || _a2 === void 0 ? void 0 : _a2.call(this, rawNode, rawNode.children);
      submenuVNode = vue.h(NDropdownMenu, Object.assign({}, submenuNodeProps, {
        clsPrefix,
        scrollable: this.scrollable,
        tmNodes: this.tmNode.children,
        parentKey: this.tmNode.key
      }));
    }
    const builtinProps = {
      class: [`${clsPrefix}-dropdown-option-body`, this.pending && `${clsPrefix}-dropdown-option-body--pending`, this.active && `${clsPrefix}-dropdown-option-body--active`, this.childActive && `${clsPrefix}-dropdown-option-body--child-active`, this.mergedDisabled && `${clsPrefix}-dropdown-option-body--disabled`],
      onMousemove: this.handleMouseMove,
      onMouseenter: this.handleMouseEnter,
      onMouseleave: this.handleMouseLeave,
      onClick: this.handleClick
    };
    const optionNodeProps = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
    const node2 = vue.h("div", Object.assign({
      class: [`${clsPrefix}-dropdown-option`, optionNodeProps === null || optionNodeProps === void 0 ? void 0 : optionNodeProps.class],
      "data-dropdown-option": true
    }, optionNodeProps), vue.h("div", vue.mergeProps(builtinProps, props), [vue.h("div", {
      class: [`${clsPrefix}-dropdown-option-body__prefix`, siblingHasIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
    }, [renderIcon ? renderIcon(rawNode) : render(rawNode.icon)]), vue.h("div", {
      "data-dropdown-option": true,
      class: `${clsPrefix}-dropdown-option-body__label`
    }, renderLabel ? renderLabel(rawNode) : render((_b = rawNode[this.labelField]) !== null && _b !== void 0 ? _b : rawNode.title)), vue.h("div", {
      "data-dropdown-option": true,
      class: [`${clsPrefix}-dropdown-option-body__suffix`, siblingHasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`]
    }, this.hasSubmenu ? vue.h(NIcon, null, {
      default: () => vue.h(ChevronRightIcon, null)
    }) : null)]), this.hasSubmenu ? vue.h(Binder, null, {
      default: () => [vue.h(VTarget, null, {
        default: () => vue.h("div", {
          class: `${clsPrefix}-dropdown-offset-container`
        }, vue.h(VFollower, {
          show: this.mergedShowSubmenu,
          placement: this.placement,
          to: scrollable ? this.popoverBody || void 0 : void 0,
          teleportDisabled: !scrollable
        }, {
          default: () => {
            return vue.h("div", {
              class: `${clsPrefix}-dropdown-menu-wrapper`
            }, animated ? vue.h(vue.Transition, {
              onBeforeEnter: this.handleSubmenuBeforeEnter,
              onAfterEnter: this.handleSubmenuAfterEnter,
              name: "fade-in-scale-up-transition",
              appear: true
            }, {
              default: () => submenuVNode
            }) : submenuVNode);
          }
        }))
      })]
    }) : null);
    if (renderOption) {
      return renderOption({
        node: node2,
        option: rawNode
      });
    }
    return node2;
  }
});
const NDropdownGroup = vue.defineComponent({
  name: "NDropdownGroup",
  props: {
    clsPrefix: {
      type: String,
      required: true
    },
    tmNode: {
      type: Object,
      required: true
    },
    parentKey: {
      type: [String, Number],
      default: null
    }
  },
  render() {
    const {
      tmNode,
      parentKey,
      clsPrefix
    } = this;
    const {
      children
    } = tmNode;
    return vue.h(vue.Fragment, null, vue.h(NDropdownGroupHeader, {
      clsPrefix,
      tmNode,
      key: tmNode.key
    }), children === null || children === void 0 ? void 0 : children.map((child) => {
      const {
        rawNode
      } = child;
      if (rawNode.show === false) return null;
      if (isDividerNode(rawNode)) {
        return vue.h(NDropdownDivider, {
          clsPrefix,
          key: child.key
        });
      }
      if (child.isGroup) {
        warn("dropdown", "`group` node is not allowed to be put in `group` node.");
        return null;
      }
      return vue.h(NDropdownOption, {
        clsPrefix,
        tmNode: child,
        parentKey,
        key: child.key
      });
    }));
  }
});
const NDropdownRenderOption = vue.defineComponent({
  name: "DropdownRenderOption",
  props: {
    tmNode: {
      type: Object,
      required: true
    }
  },
  render() {
    const {
      rawNode: {
        render: render2,
        props
      }
    } = this.tmNode;
    return vue.h("div", props, [render2 === null || render2 === void 0 ? void 0 : render2()]);
  }
});
const NDropdownMenu = vue.defineComponent({
  name: "DropdownMenu",
  props: {
    scrollable: Boolean,
    showArrow: Boolean,
    arrowStyle: [String, Object],
    clsPrefix: {
      type: String,
      required: true
    },
    tmNodes: {
      type: Array,
      default: () => []
    },
    parentKey: {
      type: [String, Number],
      default: null
    }
  },
  setup(props) {
    const {
      renderIconRef,
      childrenFieldRef
    } = vue.inject(dropdownInjectionKey);
    vue.provide(dropdownMenuInjectionKey, {
      showIconRef: vue.computed(() => {
        const renderIcon = renderIconRef.value;
        return props.tmNodes.some((tmNode) => {
          var _a2;
          if (tmNode.isGroup) {
            return (_a2 = tmNode.children) === null || _a2 === void 0 ? void 0 : _a2.some(({
              rawNode: rawChild
            }) => renderIcon ? renderIcon(rawChild) : rawChild.icon);
          }
          const {
            rawNode
          } = tmNode;
          return renderIcon ? renderIcon(rawNode) : rawNode.icon;
        });
      }),
      hasSubmenuRef: vue.computed(() => {
        const {
          value: childrenField
        } = childrenFieldRef;
        return props.tmNodes.some((tmNode) => {
          var _a2;
          if (tmNode.isGroup) {
            return (_a2 = tmNode.children) === null || _a2 === void 0 ? void 0 : _a2.some(({
              rawNode: rawChild
            }) => isSubmenuNode(rawChild, childrenField));
          }
          const {
            rawNode
          } = tmNode;
          return isSubmenuNode(rawNode, childrenField);
        });
      })
    });
    const bodyRef = vue.ref(null);
    vue.provide(modalBodyInjectionKey, null);
    vue.provide(drawerBodyInjectionKey, null);
    vue.provide(popoverBodyInjectionKey, bodyRef);
    return {
      bodyRef
    };
  },
  render() {
    const {
      parentKey,
      clsPrefix,
      scrollable
    } = this;
    const menuOptionsNode = this.tmNodes.map((tmNode) => {
      const {
        rawNode
      } = tmNode;
      if (rawNode.show === false) return null;
      if (isRenderNode(rawNode)) {
        return vue.h(NDropdownRenderOption, {
          tmNode,
          key: tmNode.key
        });
      }
      if (isDividerNode(rawNode)) {
        return vue.h(NDropdownDivider, {
          clsPrefix,
          key: tmNode.key
        });
      }
      if (isGroupNode(rawNode)) {
        return vue.h(NDropdownGroup, {
          clsPrefix,
          tmNode,
          parentKey,
          key: tmNode.key
        });
      }
      return vue.h(NDropdownOption, {
        clsPrefix,
        tmNode,
        parentKey,
        key: tmNode.key,
        props: rawNode.props,
        scrollable
      });
    });
    return vue.h("div", {
      class: [`${clsPrefix}-dropdown-menu`, scrollable && `${clsPrefix}-dropdown-menu--scrollable`],
      ref: "bodyRef"
    }, scrollable ? vue.h(XScrollbar, {
      contentClass: `${clsPrefix}-dropdown-menu__content`
    }, {
      default: () => menuOptionsNode
    }) : menuOptionsNode, this.showArrow ? renderArrow({
      clsPrefix,
      arrowStyle: this.arrowStyle,
      arrowClass: void 0,
      arrowWrapperClass: void 0,
      arrowWrapperStyle: void 0
    }) : null);
  }
});
const style$1 = cB("dropdown-menu", `
 transform-origin: var(--v-transform-origin);
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 position: relative;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [fadeInScaleUpTransition(), cB("dropdown-option", `
 position: relative;
 `, [c$1("a", `
 text-decoration: none;
 color: inherit;
 outline: none;
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("dropdown-option-body", `
 display: flex;
 cursor: pointer;
 position: relative;
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-font-size);
 color: var(--n-option-text-color);
 transition: color .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 left: 4px;
 right: 4px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `), cNotM("disabled", [cM("pending", `
 color: var(--n-option-text-color-hover);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-hover);
 `), c$1("&::before", "background-color: var(--n-option-color-hover);")]), cM("active", `
 color: var(--n-option-text-color-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-active);
 `), c$1("&::before", "background-color: var(--n-option-color-active);")]), cM("child-active", `
 color: var(--n-option-text-color-child-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-child-active);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-option-opacity-disabled);
 `), cM("group", `
 font-size: calc(var(--n-font-size) - 1px);
 color: var(--n-group-header-text-color);
 `, [cE("prefix", `
 width: calc(var(--n-option-prefix-width) / 2);
 `, [cM("show-icon", `
 width: calc(var(--n-option-icon-prefix-width) / 2);
 `)])]), cE("prefix", `
 width: var(--n-option-prefix-width);
 display: flex;
 justify-content: center;
 align-items: center;
 color: var(--n-prefix-color);
 transition: color .3s var(--n-bezier);
 z-index: 1;
 `, [cM("show-icon", `
 width: var(--n-option-icon-prefix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cE("label", `
 white-space: nowrap;
 flex: 1;
 z-index: 1;
 `), cE("suffix", `
 box-sizing: border-box;
 flex-grow: 0;
 flex-shrink: 0;
 display: flex;
 justify-content: flex-end;
 align-items: center;
 min-width: var(--n-option-suffix-width);
 padding: 0 8px;
 transition: color .3s var(--n-bezier);
 color: var(--n-suffix-color);
 z-index: 1;
 `, [cM("has-submenu", `
 width: var(--n-option-icon-suffix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cB("dropdown-menu", "pointer-events: all;")]), cB("dropdown-offset-container", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: -4px;
 bottom: -4px;
 `)]), cB("dropdown-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 4px 0;
 `), cB("dropdown-menu-wrapper", `
 transform-origin: var(--v-transform-origin);
 width: fit-content;
 `), c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("scrollable", `
 padding: var(--n-padding);
 `), cM("scrollable", [cE("content", `
 padding: var(--n-padding);
 `)])]);
const dropdownBaseProps = {
  animated: {
    type: Boolean,
    default: true
  },
  keyboard: {
    type: Boolean,
    default: true
  },
  size: {
    type: String,
    default: "medium"
  },
  inverted: Boolean,
  placement: {
    type: String,
    default: "bottom"
  },
  onSelect: [Function, Array],
  options: {
    type: Array,
    default: () => []
  },
  menuProps: Function,
  showArrow: Boolean,
  renderLabel: Function,
  renderIcon: Function,
  renderOption: Function,
  nodeProps: Function,
  labelField: {
    type: String,
    default: "label"
  },
  keyField: {
    type: String,
    default: "key"
  },
  childrenField: {
    type: String,
    default: "children"
  },
  // for menu, not documented
  value: [String, Number]
};
const popoverPropKeys = Object.keys(popoverBaseProps);
const dropdownProps = Object.assign(Object.assign(Object.assign({}, popoverBaseProps), dropdownBaseProps), useTheme.props);
const NDropdown = vue.defineComponent({
  name: "Dropdown",
  inheritAttrs: false,
  props: dropdownProps,
  setup(props) {
    const uncontrolledShowRef = vue.ref(false);
    const mergedShowRef = useMergedState(vue.toRef(props, "show"), uncontrolledShowRef);
    const treemateRef = vue.computed(() => {
      const {
        keyField,
        childrenField
      } = props;
      return createTreeMate(props.options, {
        getKey(node2) {
          return node2[keyField];
        },
        getDisabled(node2) {
          return node2.disabled === true;
        },
        getIgnored(node2) {
          return node2.type === "divider" || node2.type === "render";
        },
        getChildren(node2) {
          return node2[childrenField];
        }
      });
    });
    const tmNodesRef = vue.computed(() => {
      return treemateRef.value.treeNodes;
    });
    const hoverKeyRef = vue.ref(null);
    const keyboardKeyRef = vue.ref(null);
    const lastToggledSubmenuKeyRef = vue.ref(null);
    const pendingKeyRef = vue.computed(() => {
      var _a2, _b, _c;
      return (_c = (_b = (_a2 = hoverKeyRef.value) !== null && _a2 !== void 0 ? _a2 : keyboardKeyRef.value) !== null && _b !== void 0 ? _b : lastToggledSubmenuKeyRef.value) !== null && _c !== void 0 ? _c : null;
    });
    const pendingKeyPathRef = vue.computed(() => treemateRef.value.getPath(pendingKeyRef.value).keyPath);
    const activeKeyPathRef = vue.computed(() => treemateRef.value.getPath(props.value).keyPath);
    const keyboardEnabledRef = useMemo(() => {
      return props.keyboard && mergedShowRef.value;
    });
    useKeyboard({
      keydown: {
        ArrowUp: {
          prevent: true,
          handler: handleKeydownUp
        },
        ArrowRight: {
          prevent: true,
          handler: handleKeydownRight
        },
        ArrowDown: {
          prevent: true,
          handler: handleKeydownDown
        },
        ArrowLeft: {
          prevent: true,
          handler: handleKeydownLeft
        },
        Enter: {
          prevent: true,
          handler: handleKeydownEnter
        },
        Escape: handleKeydownEsc
      }
    }, keyboardEnabledRef);
    const {
      mergedClsPrefixRef,
      inlineThemeDisabled
    } = useConfig(props);
    const themeRef = useTheme("Dropdown", "-dropdown", style$1, dropdownLight, props, mergedClsPrefixRef);
    vue.provide(dropdownInjectionKey, {
      labelFieldRef: vue.toRef(props, "labelField"),
      childrenFieldRef: vue.toRef(props, "childrenField"),
      renderLabelRef: vue.toRef(props, "renderLabel"),
      renderIconRef: vue.toRef(props, "renderIcon"),
      hoverKeyRef,
      keyboardKeyRef,
      lastToggledSubmenuKeyRef,
      pendingKeyPathRef,
      activeKeyPathRef,
      animatedRef: vue.toRef(props, "animated"),
      mergedShowRef,
      nodePropsRef: vue.toRef(props, "nodeProps"),
      renderOptionRef: vue.toRef(props, "renderOption"),
      menuPropsRef: vue.toRef(props, "menuProps"),
      doSelect,
      doUpdateShow
    });
    vue.watch(mergedShowRef, (value) => {
      if (!props.animated && !value) {
        clearPendingState();
      }
    });
    function doSelect(key, node2) {
      const {
        onSelect
      } = props;
      if (onSelect) call(onSelect, key, node2);
    }
    function doUpdateShow(value) {
      const {
        "onUpdate:show": _onUpdateShow,
        onUpdateShow
      } = props;
      if (_onUpdateShow) call(_onUpdateShow, value);
      if (onUpdateShow) call(onUpdateShow, value);
      uncontrolledShowRef.value = value;
    }
    function clearPendingState() {
      hoverKeyRef.value = null;
      keyboardKeyRef.value = null;
      lastToggledSubmenuKeyRef.value = null;
    }
    function handleKeydownEsc() {
      doUpdateShow(false);
    }
    function handleKeydownLeft() {
      handleKeydown("left");
    }
    function handleKeydownRight() {
      handleKeydown("right");
    }
    function handleKeydownUp() {
      handleKeydown("up");
    }
    function handleKeydownDown() {
      handleKeydown("down");
    }
    function handleKeydownEnter() {
      const pendingNode = getPendingNode();
      if ((pendingNode === null || pendingNode === void 0 ? void 0 : pendingNode.isLeaf) && mergedShowRef.value) {
        doSelect(pendingNode.key, pendingNode.rawNode);
        doUpdateShow(false);
      }
    }
    function getPendingNode() {
      var _a2;
      const {
        value: treeMate
      } = treemateRef;
      const {
        value: pendingKey
      } = pendingKeyRef;
      if (!treeMate || pendingKey === null) return null;
      return (_a2 = treeMate.getNode(pendingKey)) !== null && _a2 !== void 0 ? _a2 : null;
    }
    function handleKeydown(direction) {
      const {
        value: pendingKey
      } = pendingKeyRef;
      const {
        value: {
          getFirstAvailableNode: getFirstAvailableNode2
        }
      } = treemateRef;
      let nextKeyboardKey = null;
      if (pendingKey === null) {
        const firstNode = getFirstAvailableNode2();
        if (firstNode !== null) {
          nextKeyboardKey = firstNode.key;
        }
      } else {
        const currentNode = getPendingNode();
        if (currentNode) {
          let nextNode;
          switch (direction) {
            case "down":
              nextNode = currentNode.getNext();
              break;
            case "up":
              nextNode = currentNode.getPrev();
              break;
            case "right":
              nextNode = currentNode.getChild();
              break;
            case "left":
              nextNode = currentNode.getParent();
              break;
          }
          if (nextNode) nextKeyboardKey = nextNode.key;
        }
      }
      if (nextKeyboardKey !== null) {
        hoverKeyRef.value = null;
        keyboardKeyRef.value = nextKeyboardKey;
      }
    }
    const cssVarsRef = vue.computed(() => {
      const {
        size: size2,
        inverted
      } = props;
      const {
        common: {
          cubicBezierEaseInOut: cubicBezierEaseInOut2
        },
        self: self2
      } = themeRef.value;
      const {
        padding,
        dividerColor,
        borderRadius,
        optionOpacityDisabled,
        [createKey("optionIconSuffixWidth", size2)]: optionIconSuffixWidth,
        [createKey("optionSuffixWidth", size2)]: optionSuffixWidth,
        [createKey("optionIconPrefixWidth", size2)]: optionIconPrefixWidth,
        [createKey("optionPrefixWidth", size2)]: optionPrefixWidth,
        [createKey("fontSize", size2)]: fontSize2,
        [createKey("optionHeight", size2)]: optionHeight,
        [createKey("optionIconSize", size2)]: optionIconSize
      } = self2;
      const vars = {
        "--n-bezier": cubicBezierEaseInOut2,
        "--n-font-size": fontSize2,
        "--n-padding": padding,
        "--n-border-radius": borderRadius,
        "--n-option-height": optionHeight,
        "--n-option-prefix-width": optionPrefixWidth,
        "--n-option-icon-prefix-width": optionIconPrefixWidth,
        "--n-option-suffix-width": optionSuffixWidth,
        "--n-option-icon-suffix-width": optionIconSuffixWidth,
        "--n-option-icon-size": optionIconSize,
        "--n-divider-color": dividerColor,
        "--n-option-opacity-disabled": optionOpacityDisabled
      };
      if (inverted) {
        vars["--n-color"] = self2.colorInverted;
        vars["--n-option-color-hover"] = self2.optionColorHoverInverted;
        vars["--n-option-color-active"] = self2.optionColorActiveInverted;
        vars["--n-option-text-color"] = self2.optionTextColorInverted;
        vars["--n-option-text-color-hover"] = self2.optionTextColorHoverInverted;
        vars["--n-option-text-color-active"] = self2.optionTextColorActiveInverted;
        vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActiveInverted;
        vars["--n-prefix-color"] = self2.prefixColorInverted;
        vars["--n-suffix-color"] = self2.suffixColorInverted;
        vars["--n-group-header-text-color"] = self2.groupHeaderTextColorInverted;
      } else {
        vars["--n-color"] = self2.color;
        vars["--n-option-color-hover"] = self2.optionColorHover;
        vars["--n-option-color-active"] = self2.optionColorActive;
        vars["--n-option-text-color"] = self2.optionTextColor;
        vars["--n-option-text-color-hover"] = self2.optionTextColorHover;
        vars["--n-option-text-color-active"] = self2.optionTextColorActive;
        vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActive;
        vars["--n-prefix-color"] = self2.prefixColor;
        vars["--n-suffix-color"] = self2.suffixColor;
        vars["--n-group-header-text-color"] = self2.groupHeaderTextColor;
      }
      return vars;
    });
    const themeClassHandle = inlineThemeDisabled ? useThemeClass("dropdown", vue.computed(() => `${props.size[0]}${props.inverted ? "i" : ""}`), cssVarsRef, props) : void 0;
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      mergedTheme: themeRef,
      // data
      tmNodes: tmNodesRef,
      // show
      mergedShow: mergedShowRef,
      // methods
      handleAfterLeave: () => {
        if (!props.animated) return;
        clearPendingState();
      },
      doUpdateShow,
      cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
      themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
      onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
    };
  },
  render() {
    const renderPopoverBody = (className, ref2, style2, onMouseenter, onMouseleave) => {
      var _a2;
      const {
        mergedClsPrefix,
        menuProps
      } = this;
      (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
      const menuNodeProps = (menuProps === null || menuProps === void 0 ? void 0 : menuProps(void 0, this.tmNodes.map((v2) => v2.rawNode))) || {};
      const dropdownProps2 = {
        ref: createRefSetter(ref2),
        class: [className, `${mergedClsPrefix}-dropdown`, this.themeClass],
        clsPrefix: mergedClsPrefix,
        tmNodes: this.tmNodes,
        style: [...style2, this.cssVars],
        showArrow: this.showArrow,
        arrowStyle: this.arrowStyle,
        scrollable: this.scrollable,
        onMouseenter,
        onMouseleave
      };
      return vue.h(NDropdownMenu, vue.mergeProps(this.$attrs, dropdownProps2, menuNodeProps));
    };
    const {
      mergedTheme
    } = this;
    const popoverProps2 = {
      show: this.mergedShow,
      theme: mergedTheme.peers.Popover,
      themeOverrides: mergedTheme.peerOverrides.Popover,
      internalOnAfterLeave: this.handleAfterLeave,
      internalRenderBody: renderPopoverBody,
      onUpdateShow: this.doUpdateShow,
      "onUpdate:show": void 0
    };
    return vue.h(NPopover, Object.assign({}, keep(this.$props, popoverPropKeys), popoverProps2), {
      trigger: () => {
        var _a2, _b;
        return (_b = (_a2 = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a2);
      }
    });
  }
});
function self$1(vars) {
  const {
    heightSmall,
    heightMedium,
    heightLarge,
    borderRadius
  } = vars;
  return {
    color: "#eee",
    colorEnd: "#ddd",
    borderRadius,
    heightSmall,
    heightMedium,
    heightLarge
  };
}
const skeletonLight = {
  common: derived,
  self: self$1
};
const style = c$1([cB("skeleton", `
 height: 1em;
 width: 100%;
 transition:
 --n-color-start .3s var(--n-bezier),
 --n-color-end .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 animation: 2s skeleton-loading infinite cubic-bezier(0.36, 0, 0.64, 1);
 background-color: var(--n-color-start);
 `), c$1("@keyframes skeleton-loading", `
 0% {
 background: var(--n-color-start);
 }
 40% {
 background: var(--n-color-end);
 }
 80% {
 background: var(--n-color-start);
 }
 100% {
 background: var(--n-color-start);
 }
 `)]);
const skeletonProps = Object.assign(Object.assign({}, useTheme.props), {
  text: Boolean,
  round: Boolean,
  circle: Boolean,
  height: [String, Number],
  width: [String, Number],
  size: String,
  repeat: {
    type: Number,
    default: 1
  },
  animated: {
    type: Boolean,
    default: true
  },
  sharp: {
    type: Boolean,
    default: true
  }
});
const NSkeleton = vue.defineComponent({
  name: "Skeleton",
  inheritAttrs: false,
  props: skeletonProps,
  setup(props) {
    useHoudini();
    const {
      mergedClsPrefixRef
    } = useConfig(props);
    const themeRef = useTheme("Skeleton", "-skeleton", style, skeletonLight, props, mergedClsPrefixRef);
    return {
      mergedClsPrefix: mergedClsPrefixRef,
      style: vue.computed(() => {
        var _a2, _b;
        const theme = themeRef.value;
        const {
          common: {
            cubicBezierEaseInOut: cubicBezierEaseInOut2
          }
        } = theme;
        const selfThemeVars = theme.self;
        const {
          color,
          colorEnd,
          borderRadius
        } = selfThemeVars;
        let sizeHeight;
        const {
          circle,
          sharp,
          round: round2,
          width,
          height,
          size: size2,
          text,
          animated
        } = props;
        if (size2 !== void 0) {
          sizeHeight = selfThemeVars[createKey("height", size2)];
        }
        const mergedWidth = circle ? (_a2 = width !== null && width !== void 0 ? width : height) !== null && _a2 !== void 0 ? _a2 : sizeHeight : width;
        const mergedHeight = (_b = circle ? width !== null && width !== void 0 ? width : height : height) !== null && _b !== void 0 ? _b : sizeHeight;
        return {
          display: text ? "inline-block" : "",
          verticalAlign: text ? "-0.125em" : "",
          borderRadius: circle ? "50%" : round2 ? "4096px" : sharp ? "" : borderRadius,
          width: typeof mergedWidth === "number" ? pxfy(mergedWidth) : mergedWidth,
          height: typeof mergedHeight === "number" ? pxfy(mergedHeight) : mergedHeight,
          animation: !animated ? "none" : "",
          "--n-bezier": cubicBezierEaseInOut2,
          "--n-color-start": color,
          "--n-color-end": colorEnd
        };
      })
    };
  },
  render() {
    const {
      repeat: repeatProp,
      style: style2,
      mergedClsPrefix,
      $attrs
    } = this;
    const child = vue.h("div", vue.mergeProps({
      class: `${mergedClsPrefix}-skeleton`,
      style: style2
    }, $attrs));
    if (repeatProp > 1) {
      return vue.h(vue.Fragment, null, repeat(repeatProp, null).map((_2) => [child, "\n"]));
    }
    return child;
  }
});
const _hoisted_1$e = ["onKeydown", "tabindex"];
const _hoisted_2$b = { key: 0 };
const _hoisted_3$9 = { key: 0 };
const _hoisted_4$5 = { key: 0 };
const _sfc_main$1$1 = {
  __name: "ButtonGroup",
  props: {
    toolbarItems: {
      type: Array,
      required: true
    },
    overflowItems: {
      type: Array,
      default: () => []
    },
    position: {
      type: String,
      default: "left"
    },
    fromOverflow: {
      type: Boolean,
      default: false
    }
  },
  emits: ["command"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const toolbarItemRefs = vue.ref([]);
    const props = __props;
    const currentItem = vue.ref(null);
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const isMobile = window.matchMedia("(max-width: 768px)").matches;
    const styleMap = {
      left: {
        minWidth: "120px",
        justifyContent: "flex-start"
      },
      right: {
        minWidth: "120px",
        justifyContent: "flex-end"
      },
      default: {
        // Only grow if not on a mobile device
        flexGrow: isMobile ? 0 : 1,
        justifyContent: "center"
      }
    };
    const getPositionStyle = vue.computed(() => {
      return styleMap[props.position] || styleMap.default;
    });
    const isButton = (item) => item.type === "button";
    const isDropdown = (item) => item.type === "dropdown";
    const isSeparator = (item) => item.type === "separator";
    const isOverflow = (item) => item.type === "overflow";
    const handleToolbarButtonClick = (item, argument = null) => {
      emit("item-clicked");
      currentItem.value = item;
      currentItem.value.expand = !currentItem.value.expand;
      if (item.disabled.value) return;
      emit("command", { item, argument });
    };
    const handleToolbarButtonTextSubmit = (item, argument) => {
      if (item.disabled.value) return;
      currentItem.value = null;
      emit("command", { item, argument });
    };
    const closeDropdowns = () => {
      if (!currentItem.value) return;
      currentItem.value.expand = false;
      currentItem.value = null;
    };
    const selectedOption = vue.ref(null);
    const handleSelect = (item, option) => {
      closeDropdowns();
      const value = item.dropdownValueKey.value ? option[item.dropdownValueKey.value] : option.label;
      emit("command", { item, argument: value, option });
      selectedOption.value = option.key;
    };
    const dropdownOptions = (item) => {
      if (!item.nestedOptions?.value?.length) return [];
      return item.nestedOptions.value.map((option) => {
        return {
          ...option,
          props: {
            ...option.props,
            class: selectedOption.value === option.key ? "selected" : ""
          }
        };
      });
    };
    const getDropdownAttributes = (option, item) => {
      return {
        role: "menuitem",
        ariaLabel: `${item.attributes.value.ariaLabel} - ${option.label}`
      };
    };
    const handleClickOutside2 = (e) => {
      closeDropdowns();
    };
    const moveToNextButton = (e) => {
      const currentButton = e.target;
      const nextButton = e.target.closest(".toolbar-item-ctn").nextElementSibling;
      if (nextButton) {
        currentButton.setAttribute("tabindex", "-1");
        nextButton.setAttribute("tabindex", "0");
        nextButton.focus();
      }
    };
    const moveToPreviousButton = (e) => {
      const currentButton = e.target;
      const previousButton = e.target.closest(".toolbar-item-ctn").previousElementSibling;
      if (previousButton) {
        currentButton.setAttribute("tabindex", "-1");
        previousButton.setAttribute("tabindex", "0");
        previousButton.focus();
      }
    };
    const moveToNextButtonGroup = (e) => {
      const nextButtonGroup = e.target.closest(".button-group").nextElementSibling;
      if (nextButtonGroup) {
        nextButtonGroup.setAttribute("tabindex", "0");
        nextButtonGroup.focus();
      } else {
        const editor = document.querySelector(".ProseMirror");
        if (editor) {
          editor.focus();
        }
      }
    };
    const moveToPreviousButtonGroup = (e) => {
      const previousButtonGroup = e.target.closest(".button-group").previousElementSibling;
      if (previousButtonGroup) {
        previousButtonGroup.setAttribute("tabindex", "0");
        previousButtonGroup.focus();
      }
    };
    const handleKeyDown2 = (e, item) => {
      const isTypingField = e.target.nodeName === "INPUT" || e.target.nodeName === "TEXTAREA";
      const isTypingToolbarItem = item.name.value === "fontSize";
      if (isTypingField && isTypingToolbarItem) {
        return;
      }
      e.preventDefault();
      switch (e.key) {
        case "Enter":
          console.log("Enter");
          handleToolbarButtonClick(item, null);
          break;
        case "Escape":
          closeDropdowns();
          break;
        case "ArrowRight":
          closeDropdowns();
          moveToNextButton(e);
          break;
        case "ArrowLeft":
          closeDropdowns();
          moveToPreviousButton(e);
          break;
        case "Tab":
          if (e.shiftKey) {
            moveToPreviousButtonGroup(e);
          } else {
            moveToNextButtonGroup(e);
          }
          break;
      }
    };
    const handleFocus = (e) => {
      const firstButton = toolbarItemRefs.value.find((item) => !item.classList.contains("disabled"));
      if (firstButton) {
        firstButton.setAttribute("tabindex", "0");
        firstButton.focus();
      }
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        style: vue.normalizeStyle(getPositionStyle.value),
        class: "button-group",
        role: "group",
        onFocus: handleFocus
      }, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.toolbarItems, (item, index2) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            key: item.id.value,
            class: vue.normalizeClass([{
              narrow: item.isNarrow.value,
              wide: item.isWide.value,
              disabled: item.disabled.value
            }, "toolbar-item-ctn"]),
            onKeydown: (e) => handleKeyDown2(e, item),
            ref_for: true,
            ref_key: "toolbarItemRefs",
            ref: toolbarItemRefs,
            tabindex: index2 === 0 ? 0 : -1
          }, [
            isSeparator(item) ? (vue.openBlock(), vue.createBlock(ToolbarSeparator, {
              key: 0,
              style: { "width": "20px" }
            })) : vue.createCommentVNode("", true),
            isDropdown(item) && item.nestedOptions?.value?.length ? (vue.openBlock(), vue.createBlock(vue.unref(NDropdown), {
              key: 1,
              options: dropdownOptions(item),
              trigger: item.disabled.value ? null : "click",
              show: item.expand.value,
              size: "medium",
              placement: "bottom-start",
              class: vue.normalizeClass(["toolbar-button toolbar-dropdown sd-editor-toolbar-dropdown", { "high-contrast": vue.unref(isHighContrastMode2) }]),
              onSelect: (key, option) => handleSelect(item, option),
              onClickoutside: handleClickOutside2,
              style: vue.normalizeStyle(item.dropdownStyles.value),
              "menu-props": () => ({
                role: "menu"
              }),
              "node-props": (option) => getDropdownAttributes(option, item)
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.unref(NTooltip), {
                  trigger: "hover",
                  disabled: !item.tooltip?.value
                }, {
                  trigger: vue.withCtx(() => [
                    vue.createVNode(ToolbarButton, {
                      "toolbar-item": item,
                      disabled: item.disabled.value,
                      onTextSubmit: ($event) => handleToolbarButtonTextSubmit(item, $event),
                      onButtonClick: ($event) => handleToolbarButtonClick(item)
                    }, null, 8, ["toolbar-item", "disabled", "onTextSubmit", "onButtonClick"])
                  ]),
                  default: vue.withCtx(() => [
                    vue.createBaseVNode("div", null, [
                      vue.createTextVNode(vue.toDisplayString(item.tooltip) + " ", 1),
                      item.disabled.value ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$b, "(disabled)")) : vue.createCommentVNode("", true)
                    ])
                  ]),
                  _: 2
                }, 1032, ["disabled"])
              ]),
              _: 2
            }, 1032, ["options", "trigger", "show", "class", "onSelect", "style", "node-props"])) : isButton(item) ? (vue.openBlock(), vue.createBlock(vue.unref(NTooltip), {
              key: 2,
              trigger: "hover",
              class: "sd-editor-toolbar-tooltip"
            }, {
              trigger: vue.withCtx(() => [
                vue.createVNode(ToolbarButton, {
                  "toolbar-item": item,
                  "is-overflow-item": __props.fromOverflow,
                  onTextSubmit: ($event) => handleToolbarButtonTextSubmit(item, $event),
                  onButtonClick: ($event) => handleToolbarButtonClick(item)
                }, null, 8, ["toolbar-item", "is-overflow-item", "onTextSubmit", "onButtonClick"])
              ]),
              default: vue.withCtx(() => [
                item.tooltip ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$9, [
                  vue.createTextVNode(vue.toDisplayString(item.tooltip) + " ", 1),
                  item.disabled.value ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_4$5, "(disabled)")) : vue.createCommentVNode("", true)
                ])) : vue.createCommentVNode("", true)
              ]),
              _: 2
            }, 1024)) : vue.createCommentVNode("", true),
            isOverflow(item) && __props.overflowItems.length ? (vue.openBlock(), vue.createBlock(OverflowMenu, {
              key: 3,
              "toolbar-item": item,
              onButtonClick: ($event) => handleToolbarButtonClick(item),
              "overflow-items": __props.overflowItems
            }, null, 8, ["toolbar-item", "onButtonClick", "overflow-items"])) : vue.createCommentVNode("", true)
          ], 42, _hoisted_1$e);
        }), 128))
      ], 36);
    };
  }
};
const ButtonGroup = /* @__PURE__ */ _export_sfc(_sfc_main$1$1, [["__scopeId", "data-v-4ccab1c9"]]);
const _sfc_main$f = {
  __name: "Toolbar",
  emits: ["command", "toggle", "select"],
  setup(__props, { emit: __emit }) {
    const { proxy } = vue.getCurrentInstance();
    let toolbarKey = vue.ref(1);
    const showLeftSide = proxy.$toolbar.config?.toolbarGroups?.includes("left");
    const showRightSide = proxy.$toolbar.config?.toolbarGroups?.includes("right");
    const excludeButtonsList = proxy.$toolbar.config?.toolbarButtonsExclude || [];
    const getFilteredItems = (position) => {
      return proxy.$toolbar.getToolbarItemByGroup(position).filter((item) => !excludeButtonsList.includes(item.name.value));
    };
    vue.onMounted(() => {
      window.addEventListener("resize", onResizeThrottled);
      window.addEventListener("keydown", onKeyDown);
    });
    vue.onDeactivated(() => {
      window.removeEventListener("resize", onResizeThrottled);
      window.removeEventListener("keydown", onKeyDown);
    });
    const onKeyDown = async (e) => {
      if (e.metaKey && e.key === "f") {
        const searchItem = proxy.$toolbar.getToolbarItemByName("search");
        if (searchItem) {
          e.preventDefault();
          searchItem.expand.value = true;
          await vue.nextTick();
          if (searchItem.inputRef.value) {
            searchItem.inputRef.value.focus();
          }
        }
      }
    };
    const onWindowResized = async () => {
      await proxy.$toolbar.onToolbarResize();
      toolbarKey.value += 1;
    };
    const onResizeThrottled = throttle(onWindowResized, 300);
    const handleCommand = ({ item, argument, option }) => {
      proxy.$toolbar.emitCommand({ item, argument, option });
    };
    const restoreSelection2 = () => {
      proxy.$toolbar.activeEditor?.commands?.restoreSelection();
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: "superdoc-toolbar",
        key: vue.unref(toolbarKey),
        role: "toolbar",
        "aria-label": "Toolbar"
      }, [
        vue.unref(showLeftSide) ? (vue.openBlock(), vue.createBlock(ButtonGroup, {
          key: 0,
          tabindex: "0",
          "toolbar-items": getFilteredItems("left"),
          position: "left",
          onCommand: handleCommand,
          onItemClicked: restoreSelection2,
          class: "superdoc-toolbar-group-side"
        }, null, 8, ["toolbar-items"])) : vue.createCommentVNode("", true),
        vue.createVNode(ButtonGroup, {
          tabindex: "0",
          "toolbar-items": getFilteredItems("center"),
          "overflow-items": vue.unref(proxy).$toolbar.overflowItems,
          position: "center",
          onCommand: handleCommand,
          onItemClicked: restoreSelection2
        }, null, 8, ["toolbar-items", "overflow-items"]),
        vue.unref(showRightSide) ? (vue.openBlock(), vue.createBlock(ButtonGroup, {
          key: 1,
          tabindex: "0",
          "toolbar-items": getFilteredItems("right"),
          position: "right",
          onCommand: handleCommand,
          onItemClicked: restoreSelection2,
          class: "superdoc-toolbar-group-side"
        }, null, 8, ["toolbar-items"])) : vue.createCommentVNode("", true)
      ]);
    };
  }
};
const Toolbar = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["__scopeId", "data-v-639f50b4"]]);
const DEFAULT_API_ENDPOINT = "https://sd-dev-express-gateway-i6xtm.ondigitalocean.app/insights";
const SYSTEM_PROMPT = "You are an expert copywriter and you are immersed in a document editor. You are to provide document related text responses based on the user prompts. Only write what is asked for. Do not provide explanations. Try to keep placeholders as short as possible. Do not output your prompt. Your instructions are: ";
async function baseInsightsFetch(payload, options = {}) {
  const apiKey = options.apiKey;
  const apiEndpoint = options.endpoint || DEFAULT_API_ENDPOINT;
  try {
    const headers = {
      "Content-Type": "application/json"
    };
    if (apiKey) {
      headers["x-api-key"] = apiKey;
    }
    const response = await fetch(apiEndpoint, {
      method: "POST",
      headers,
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Harbour API error: ${response.status} - ${errorText}`);
    }
    return response;
  } catch (error) {
    console.error("Error calling Harbour API:", error);
    throw error;
  }
}
async function processStream(stream, onChunk, onDone) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  let result = "";
  let buffer2 = "";
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        if (typeof onDone === "function") {
          onDone();
        }
        break;
      }
      const chunk = decoder.decode(value, { stream: true });
      if (typeof onChunk === "function") {
        onChunk(chunk);
      }
    }
    let extractedValue = getJsonBetweenFencesFromResponse(buffer2);
    if (extractedValue !== null) {
      result = extractedValue;
    }
    return result || "";
  } catch (error) {
    console.error("Error reading stream:", error);
    throw error;
  } finally {
    reader.releaseLock();
  }
}
function getJsonBetweenFencesFromResponse(buffer2) {
  try {
    const jsonRegex = /```json\s*\n([\s\S]*?)\n\s*```/;
    const match = buffer2.match(jsonRegex);
    if (match && match[1]) {
      const jsonObj = JSON.parse(match[1]);
      if (jsonObj.custom_prompt && jsonObj.custom_prompt.value !== void 0) {
        return jsonObj.custom_prompt.value || "";
      }
    }
    return null;
  } catch {
    return null;
  }
}
async function writeStreaming(prompt, options = {}, onChunk, onDone) {
  if (!prompt) {
    throw new Error("Prompt is required for text generation");
  }
  const payload = {
    stream: true,
    context: SYSTEM_PROMPT,
    doc_text: "",
    insights: [
      {
        type: "custom_prompt",
        name: "text_generation",
        message: `Generate text based on the following prompt: ${prompt}`
      }
    ]
  };
  if (options.documentXml) {
    payload.document_content = options.documentXml;
  }
  const response = await baseInsightsFetch(payload, options.config || {});
  if (!response.body) return "";
  return await processStream(response.body, onChunk, onDone);
}
async function rewriteStreaming(text, prompt = "", options = {}, onChunk, onDone) {
  if (!text) {
    throw new Error("Text is required for rewriting");
  }
  const message = prompt ? `Rewrite the following text: "${text}" using these instructions: ${prompt}` : `Rewrite the following text: "${text}"`;
  const payload = {
    stream: true,
    context: SYSTEM_PROMPT,
    insights: [
      {
        type: "custom_prompt",
        name: "text_rewrite",
        message
      }
    ]
  };
  const response = await baseInsightsFetch(payload, options.config || {});
  if (!response.body) return "";
  return await processStream(response.body, onChunk, onDone);
}
const formatRegistry = {
  rules: [
    {
      name: "bold",
      pattern: /\*\*(.*?)\*\*/g,
      transform: (_match, content) => ({
        type: "text",
        marks: [{ type: "bold" }],
        text: content
      })
    },
    {
      name: "italic",
      pattern: /\*(.*?)\*/g,
      transform: (_match, content) => ({
        type: "text",
        marks: [{ type: "italic" }],
        text: content
      })
    },
    {
      name: "underline",
      pattern: /<(?:u|ins)>(.*?)<\/(?:u|ins)>/g,
      transform: (_match, content) => ({
        type: "text",
        marks: [{ type: "underline" }],
        text: content
      })
    }
  ]
};
function formatDocument(editor) {
  try {
    let doc2 = editor.state.doc;
    const docText = doc2.textContent || "";
    if (!docText) return;
    formatRegistry.rules.forEach((rule) => {
      rule.pattern.lastIndex = 0;
      const matches2 = [];
      let match;
      while ((match = rule.pattern.exec(docText)) !== null) {
        matches2.push({
          rule,
          startPos: match.index,
          endPos: match.index + match[0].length,
          originalText: match[0],
          contentText: match[1]
        });
      }
      matches2.sort((a, b2) => b2.startPos - a.startPos);
      for (const match2 of matches2) {
        const { startPos, endPos, originalText, contentText } = match2;
        try {
          let tr = editor.state.tr;
          const replacement = rule.transform(originalText, contentText, editor);
          const nodesInRange = [];
          doc2.nodesBetween(startPos, Math.min(endPos, doc2.content.size), (node2, pos) => {
            if (node2.isText) {
              nodesInRange.push({ node: node2, pos });
            }
            return true;
          });
          if (nodesInRange.length > 0) {
            let foundExactMatch = false;
            let actualStartPos = -1;
            let actualEndPos = -1;
            for (let i = 0; i < nodesInRange.length; i++) {
              const nodeInfo = nodesInRange[i];
              const nodeText = nodeInfo.node.text || "";
              const nodePos = nodeInfo.pos;
              if (nodeText.includes(originalText)) {
                const nodeMatchIndex = nodeText.indexOf(originalText);
                actualStartPos = nodePos + nodeMatchIndex;
                actualEndPos = actualStartPos + originalText.length;
                foundExactMatch = true;
                break;
              }
            }
            if (!foundExactMatch) {
              let combinedText = "";
              let offsets = [];
              let basePos = nodesInRange[0].pos;
              for (const nodeInfo of nodesInRange) {
                const nodeText = nodeInfo.node.text || "";
                const relativePos = nodeInfo.pos - basePos;
                for (let i = 0; i < nodeText.length; i++) {
                  offsets.push(relativePos + i);
                }
                combinedText += nodeText;
              }
              const matchIndex = combinedText.indexOf(originalText);
              if (matchIndex >= 0) {
                actualStartPos = basePos + offsets[matchIndex];
                const endIndex = matchIndex + originalText.length - 1;
                actualEndPos = basePos + (offsets[endIndex] || 0) + 1;
                foundExactMatch = true;
              }
            }
            if (foundExactMatch) {
              const marks = replacement.marks ? replacement.marks.map((mark) => editor.schema.marks[mark.type].create(mark.attrs)) : [];
              tr = tr.delete(actualStartPos, actualEndPos);
              tr = tr.insert(actualStartPos, editor.schema.text(replacement.text, marks));
              if (tr.docChanged) {
                editor.view.dispatch(tr);
                doc2 = editor.state.doc;
              }
            }
          }
        } catch (error) {
          console.error("Error processing match:", error);
        }
      }
    });
  } catch (error) {
    console.error("Error formatting document:", error);
  }
}
const edit = '<!-- @note: includes color gradient for inline svg AI Writer -->\n<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->\n    <linearGradient id="gradient" x1="125%" y1="50%" x2="-25%" y2="50%">\n        <stop offset="-20%" stop-color="rgba(218, 215, 118, 0.5)" />\n        <stop offset="30%" stop-color="rgb(191, 100, 100)" />\n        <stop offset="60%" stop-color="rgb(77, 82, 217)" />\n        <stop offset="150%" stop-color="rgb(255, 219, 102)" />\n    </linearGradient>\n    <path fill="url(#gradient)" d="M402.3 344.9l32-32c5-5 13.7-1.5 13.7 5.7V464c0 26.5-21.5 48-48 48H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h273.5c7.1 0 10.7 8.6 5.7 13.7l-32 32c-1.5 1.5-3.5 2.3-5.7 2.3H48v352h352V350.5c0-2.1 .8-4.1 2.3-5.6zm156.6-201.8L296.3 405.7l-90.4 10c-26.2 2.9-48.5-19.2-45.6-45.6l10-90.4L432.9 17.1c22.9-22.9 59.9-22.9 82.7 0l43.2 43.2c22.9 22.9 22.9 60 .1 82.8zM460.1 174L402 115.9 216.2 301.8l-7.3 65.3 65.3-7.3L460.1 174zm64.8-79.7l-43.2-43.2c-4.1-4.1-10.8-4.1-14.8 0L436 82l58.1 58.1 30.9-30.9c4-4.2 4-10.8-.1-14.9z"/>\n</svg>';
const paperPlane = '<!-- @note: includes color gradient for inline svg AI Writer -->\n<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->\n  <defs>\n    <linearGradient id="gradient" x1="125%" y1="50%" x2="-25%" y2="50%">\n      <stop offset="-20%" stop-color="rgba(218, 215, 118, 0.5)" />\n      <stop offset="30%" stop-color="rgb(191, 100, 100)" />\n      <stop offset="60%" stop-color="rgb(77, 82, 217)" />\n      <stop offset="150%" stop-color="rgb(255, 219, 102)" />\n    </linearGradient>\n  </defs>\n  <path fill="url(#gradient)" d="M440 6.5L24 246.4c-34.4 19.9-31.1 70.8 5.7 85.9L144 379.6V464c0 46.4 59.2 65.5 86.6 28.6l43.8-59.1 111.9 46.2c5.9 2.4 12.1 3.6 18.3 3.6 8.2 0 16.3-2.1 23.6-6.2 12.8-7.2 21.6-20 23.9-34.5l59.4-387.2c6.1-40.1-36.9-68.8-71.5-48.9zM192 464v-64.6l36.6 15.1L192 464zm212.6-28.7l-153.8-63.5L391 169.5c10.7-15.5-9.5-33.5-23.7-21.2L155.8 332.6 48 288 464 48l-59.4 387.3z"/>\n</svg>';
const _hoisted_1$d = { class: "ai-user-input-field" };
const _hoisted_2$a = ["innerHTML"];
const _hoisted_3$8 = ["placeholder"];
const _hoisted_4$4 = { class: "ai-loader" };
const _hoisted_5$3 = ["innerHTML"];
const _sfc_main$e = {
  __name: "AIWriter",
  props: {
    selectedText: {
      type: String,
      required: true
    },
    handleClose: {
      type: Function,
      required: true
    },
    editor: {
      type: Object,
      required: true
    },
    apiKey: {
      type: String
    },
    endpoint: {
      type: String,
      required: false
    }
  },
  setup(__props) {
    const props = __props;
    const selectionState = vue.ref(null);
    const aiWriterRef = vue.ref(null);
    const handleClickOutside2 = (event) => {
      if (aiWriterRef.value && !aiWriterRef.value.contains(event.target)) {
        if (!isLoading.value) {
          props.editor.commands.removeAiMark();
        }
        props.handleClose();
      }
    };
    const editableRef = vue.ref(null);
    const saveSelection = () => {
      if (props.selectedText) {
        selectionState.value = {
          ...props.editor.state.selection,
          from: props.editor.state.selection.from,
          to: props.editor.state.selection.to
        };
        props.editor.commands.setMeta("storedSelection", selectionState.value);
        props.editor.commands.insertAiMark();
      }
    };
    const focusTextarea = () => {
      setTimeout(() => {
        vue.nextTick(() => {
          if (editableRef.value) {
            editableRef.value.focus();
          }
        });
      }, 0);
    };
    const addEventListeners = () => {
      document.addEventListener("mousedown", handleClickOutside2);
      document.addEventListener("keydown", handleCaptureKeyDown, true);
    };
    const removeEventListeners = () => {
      document.removeEventListener("mousedown", handleClickOutside2);
      document.removeEventListener("keydown", handleCaptureKeyDown, true);
    };
    vue.onMounted(() => {
      saveSelection();
      focusTextarea();
      addEventListeners();
    });
    vue.onUnmounted(() => {
      if (!isLoading.value) {
        props.editor.commands.removeAiMark();
      }
      removeEventListeners();
    });
    const handleCaptureKeyDown = (event) => {
      if (editableRef.value && event.target === editableRef.value && ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(event.key)) {
        event.stopPropagation();
      }
    };
    const placeholderText = vue.computed(
      () => props.selectedText ? "Insert prompt to update text" : "Insert prompt to generate text"
    );
    const isLoading = vue.ref(false);
    const isError = vue.ref("");
    const promptText = vue.ref("");
    const textProcessingStarted = vue.ref(false);
    const previousText = vue.ref("");
    const isFormatting = vue.ref(false);
    const pendingFormatting = vue.ref(false);
    const isInSuggestingMode = vue.computed(() => {
      return props.editor.isInSuggestingMode?.() || false;
    });
    const getDocumentXml = () => {
      try {
        return props.editor.state.doc.textContent || "";
      } catch (error) {
        console.error("Error getting document XML:", error);
        return "";
      }
    };
    const handleTextChunk = async (text) => {
      try {
        props.editor.commands.removeAiNode("aiLoaderNode");
        if (props.selectedText && !textProcessingStarted.value) {
          props.editor.commands.removeAiMark();
          props.editor.commands.clearAiHighlightStyle();
          if (selectionState.value) {
            const { state: state2 } = props.editor;
            const { from: from2, to } = selectionState.value;
            const tr = state2.tr.setSelection(TextSelection$1.create(state2.doc, from2, to));
            props.editor.view.dispatch(tr);
          } else {
            console.warn("[AIWriter] No stored selection to restore");
          }
          props.editor.commands.deleteSelection();
          textProcessingStarted.value = true;
        }
        if (text === null || text === void 0 || text === "") {
          return;
        }
        const textStr = String(text);
        const wrappedContent = {
          type: "text",
          marks: [
            {
              type: "aiAnimationMark",
              attrs: {
                class: "sd-ai-text-appear",
                dataMarkId: `ai-animation-${Date.now()}`
              }
            }
          ],
          text: textStr
        };
        props.editor.commands.insertContent(wrappedContent);
        pendingFormatting.value = true;
        if (!isFormatting.value) {
          await runSafeFormat();
        }
        props.handleClose();
      } catch (error) {
        console.error("Error handling text chunk:", error);
      }
    };
    const runSafeFormat = async () => {
      if (isFormatting.value) return;
      try {
        isFormatting.value = true;
        pendingFormatting.value = false;
        await vue.nextTick();
        formatDocument(props.editor);
        if (pendingFormatting.value) {
          pendingFormatting.value = false;
          await runSafeFormat();
        }
      } finally {
        isFormatting.value = false;
      }
    };
    const handleDone = async () => {
      if (pendingFormatting.value || isFormatting.value) {
        pendingFormatting.value = true;
        await new Promise((resolve) => {
          const checkFormatting = () => {
            if (!isFormatting.value && !pendingFormatting.value) {
              resolve();
            } else {
              setTimeout(checkFormatting, 100);
            }
          };
          checkFormatting();
        });
      }
      await runSafeFormat();
      setTimeout(() => {
        props.editor.commands.removeAiMark("aiAnimationMark");
        props.editor.commands.removeAiMark();
      }, 1e3);
    };
    const handleSubmit = async () => {
      isError.value = "";
      textProcessingStarted.value = false;
      previousText.value = "";
      isLoading.value = true;
      try {
        props.handleClose();
        if (props.selectedText) {
          props.editor.commands.updateAiHighlightStyle("sd-ai-highlight-pulse");
          props.editor.commands.removeSelectionAfterAiPulse();
        } else {
          props.editor.commands.insertContent({
            type: "aiLoaderNode"
          });
        }
        if (isInSuggestingMode.value) {
          props.editor.commands.enableTrackChanges();
        }
        const documentXml = getDocumentXml();
        const options = {
          // @todo: implement grabbing document text
          docText: "",
          documentXml,
          config: {
            // Pass the aiApiKey to the AI helper functions
            apiKey: props.apiKey,
            endpoint: props.endpoint
          }
        };
        if (props.selectedText) {
          await rewriteStreaming(props.selectedText, promptText.value, options, handleTextChunk, handleDone);
        } else {
          await writeStreaming(promptText.value, options, handleTextChunk, handleDone);
        }
      } catch (error) {
        console.error("AI generation error:", error);
        isError.value = error.message || "An error occurred";
      } finally {
        promptText.value = "";
        if (isInSuggestingMode.value) {
          props.editor.commands.disableTrackChanges();
        }
        isLoading.value = false;
        textProcessingStarted.value = false;
      }
    };
    const handleKeyDown2 = (event) => {
      if (event.key === "Enter" && !event.shiftKey) {
        event.preventDefault();
        handleSubmit();
      }
    };
    const handleInput = (event) => {
      if (isError.value) {
        isError.value = "";
      }
      promptText.value = event.target.value;
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: "ai-writer prosemirror-isolated",
        ref_key: "aiWriterRef",
        ref: aiWriterRef,
        onMousedown: _cache[1] || (_cache[1] = vue.withModifiers(() => {
        }, ["stop"]))
      }, [
        vue.createBaseVNode("div", _hoisted_1$d, [
          vue.createBaseVNode("span", {
            class: "ai-textarea-icon",
            innerHTML: vue.unref(edit)
          }, null, 8, _hoisted_2$a),
          vue.withDirectives(vue.createBaseVNode("textarea", {
            ref_key: "editableRef",
            ref: editableRef,
            class: "ai-textarea",
            placeholder: placeholderText.value,
            onKeydown: handleKeyDown2,
            onInput: handleInput,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => promptText.value = $event),
            rows: "4"
          }, null, 40, _hoisted_3$8), [
            [vue.vModelText, promptText.value]
          ])
        ]),
        vue.createBaseVNode("div", _hoisted_4$4, [
          promptText.value ? (vue.openBlock(), vue.createElementBlock("span", {
            key: 0,
            class: "ai-textarea-icon ai-submit-button",
            onClick: vue.withModifiers(handleSubmit, ["stop"]),
            innerHTML: vue.unref(paperPlane)
          }, null, 8, _hoisted_5$3)) : vue.createCommentVNode("", true)
        ])
      ], 544);
    };
  }
};
const AIWriter = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["__scopeId", "data-v-e8e0f607"]]);
async function createZip(blobs, fileNames) {
  const zip = new JSZip();
  blobs.forEach((blob, index2) => {
    zip.file(fileNames[index2], blob);
  });
  const zipBlob = await zip.generateAsync({ type: "blob" });
  return zipBlob;
}
var __defProp = Object.defineProperty;
var __typeError = (msg2) => {
  throw TypeError(msg2);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg2) => member.has(obj) || __typeError("Cannot " + msg2);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _SuperToolbar_instances, initToolbarGroups_fn, _interceptedCommands, makeToolbarItems_fn, initDefaultFonts_fn, updateHighlightColors_fn, deactivateAll_fn, updateToolbarHistory_fn, runCommandWithArgumentOnly_fn;
var eventemitter3 = { exports: {} };
var hasRequiredEventemitter3;
function requireEventemitter3() {
  if (hasRequiredEventemitter3) return eventemitter3.exports;
  hasRequiredEventemitter3 = 1;
  (function(module2) {
    var has = Object.prototype.hasOwnProperty, prefix2 = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix2 = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix2 ? prefix2 + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter22() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter22.prototype.eventNames = function eventNames() {
      var names = [], events2, name;
      if (this._eventsCount === 0) return names;
      for (name in events2 = this._events) {
        if (has.call(events2, name)) names.push(prefix2 ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events2));
      }
      return names;
    };
    EventEmitter22.prototype.listeners = function listeners(event) {
      var evt = prefix2 ? prefix2 + event : event, handlers2 = this._events[evt];
      if (!handlers2) return [];
      if (handlers2.fn) return [handlers2.fn];
      for (var i2 = 0, l22 = handlers2.length, ee = new Array(l22); i2 < l22; i2++) {
        ee[i2] = handlers2[i2].fn;
      }
      return ee;
    };
    EventEmitter22.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix2 ? prefix2 + event : event, listeners = this._events[evt];
      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };
    EventEmitter22.prototype.emit = function emit(event, a12, a2, a3, a42, a5) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return false;
      var listeners = this._events[evt], len = arguments.length, args, i2;
      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a12), true;
          case 3:
            return listeners.fn.call(listeners.context, a12, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a12, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a12, a2, a3, a42), true;
          case 6:
            return listeners.fn.call(listeners.context, a12, a2, a3, a42, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length2 = listeners.length, j2;
        for (i2 = 0; i2 < length2; i2++) {
          if (listeners[i2].once) this.removeListener(event, listeners[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i2].fn.call(listeners[i2].context);
              break;
            case 2:
              listeners[i2].fn.call(listeners[i2].context, a12);
              break;
            case 3:
              listeners[i2].fn.call(listeners[i2].context, a12, a2);
              break;
            case 4:
              listeners[i2].fn.call(listeners[i2].context, a12, a2, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners[i2].fn.apply(listeners[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter22.prototype.on = function on2(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter22.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter22.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix2 ? prefix2 + event : event;
      if (!this._events[evt]) return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn2 && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events2 = [], length2 = listeners.length; i2 < length2; i2++) {
          if (listeners[i2].fn !== fn2 || once && !listeners[i2].once || context && listeners[i2].context !== context) {
            events2.push(listeners[i2]);
          }
        }
        if (events2.length) this._events[evt] = events2.length === 1 ? events2[0] : events2;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter22.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix2 ? prefix2 + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter22.prototype.off = EventEmitter22.prototype.removeListener;
    EventEmitter22.prototype.addListener = EventEmitter22.prototype.on;
    EventEmitter22.prefixed = prefix2;
    EventEmitter22.EventEmitter = EventEmitter22;
    {
      module2.exports = EventEmitter22;
    }
  })(eventemitter3);
  return eventemitter3.exports;
}
var eventemitter3Exports = requireEventemitter3();
const EventEmitter2 = /* @__PURE__ */ getDefaultExportFromCjs$1(eventemitter3Exports);
const useToolbarItem = (options) => {
  const types2 = ["button", "options", "separator", "dropdown", "overflow"];
  if (!types2.includes(options.type)) {
    throw new Error("Invalid toolbar item type - " + options.type);
  }
  if (options.type === "button" && !options.defaultLabel && !options.icon) {
    throw new Error("Toolbar button item needs either icon or label - " + options.name);
  }
  if (!options.name) {
    throw new Error("Invalid toolbar item name - " + options.name);
  }
  const id = vue.ref(v4());
  const type2 = options.type;
  const name = vue.ref(options.name);
  const command2 = options.command;
  const noArgumentCommand = options.noArgumentCommand;
  const icon = vue.ref(options.icon);
  const group = vue.ref(options.group || "center");
  const allowWithoutEditor = vue.ref(options.allowWithoutEditor);
  const attributes = vue.ref(options.attributes || {});
  const initiallyDisabled = options.disabled || false;
  const disabled = vue.ref(options.disabled);
  const active = vue.ref(false);
  const expand = vue.ref(false);
  const style2 = vue.ref(options.style);
  const isNarrow = vue.ref(options.isNarrow);
  const isWide = vue.ref(options.isWide);
  const minWidth = vue.ref(options.minWidth);
  const suppressActiveHighlight = vue.ref(options.suppressActiveHighlight || false);
  const argument = vue.ref(options.argument);
  const childItem = vue.ref(null);
  const parentItem = vue.ref(null);
  const iconColor = vue.ref(options.iconColor);
  const hasCaret = vue.ref(options.hasCaret);
  const dropdownStyles = vue.ref(options.dropdownStyles);
  const tooltip = vue.ref(options.tooltip);
  const tooltipVisible = vue.ref(options.tooltipVisible);
  const tooltipTimeout = vue.ref(options.tooltipTimeout);
  const defaultLabel = vue.ref(options.defaultLabel);
  const label = vue.ref(options.label);
  const hideLabel = vue.ref(options.hideLabel);
  const inlineTextInputVisible = vue.ref(options.inlineTextInputVisible);
  const hasInlineTextInput = vue.ref(options.hasInlineTextInput);
  const markName = vue.ref(options.markName);
  const labelAttr = vue.ref(options.labelAttr);
  const selectedValue = vue.ref(options.selectedValue);
  const dropdownValueKey = vue.ref(options.dropdownValueKey);
  const inputRef = vue.ref(options.inputRef || null);
  const nestedOptions = vue.ref([]);
  if (options.options) {
    if (!Array.isArray(options.options)) throw new Error("Invalid toolbar item options - " + options.options);
    nestedOptions.value?.push(...options.options);
  }
  const activate = (attrs) => {
    onActivate(attrs);
    if (suppressActiveHighlight.value) return;
    active.value = true;
  };
  const deactivate = () => {
    onDeactivate();
    active.value = false;
  };
  const setDisabled = (state2) => {
    disabled.value = state2;
  };
  const resetDisabled = () => {
    disabled.value = initiallyDisabled;
  };
  const onActivate = options.onActivate || (() => null);
  const onDeactivate = options.onDeactivate || (() => null);
  const unref2 = () => {
    const flattened = {};
    Object.keys(refs).forEach((key) => {
      if (refs[key].value !== void 0) {
        flattened[key] = refs[key].value;
      }
    });
    return flattened;
  };
  const refs = {
    id,
    name,
    type: type2,
    command: command2,
    noArgumentCommand,
    icon,
    tooltip,
    group,
    attributes,
    disabled,
    active,
    expand,
    nestedOptions,
    style: style2,
    isNarrow,
    isWide,
    minWidth,
    argument,
    parentItem,
    iconColor,
    hasCaret,
    dropdownStyles,
    tooltipVisible,
    tooltipTimeout,
    defaultLabel,
    label,
    hideLabel,
    inlineTextInputVisible,
    hasInlineTextInput,
    markName,
    labelAttr,
    childItem,
    allowWithoutEditor,
    dropdownValueKey,
    selectedValue,
    inputRef
  };
  return {
    ...refs,
    unref: unref2,
    activate,
    deactivate,
    setDisabled,
    resetDisabled,
    onActivate,
    onDeactivate
  };
};
const _hoisted_1$c = ["onClick", "innerHTML", "aria-label", "onKeydown"];
const _sfc_main$d = {
  __name: "AlignmentButtons",
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const emit = __emit;
    const alignmentButtonsRefs = vue.ref([]);
    const alignmentButtons = [
      {
        key: "left",
        ariaLabel: "Align left",
        icon: toolbarIcons.alignLeft
      },
      {
        key: "center",
        ariaLabel: "Align center",
        icon: toolbarIcons.alignCenter
      },
      {
        key: "right",
        ariaLabel: "Align right",
        icon: toolbarIcons.alignRight
      },
      {
        key: "justify",
        ariaLabel: "Justify",
        icon: toolbarIcons.alignJustify
      }
    ];
    const select = (alignment2) => {
      emit("select", alignment2);
    };
    const moveToNextButton = (index2) => {
      if (index2 === alignmentButtonsRefs.value.length - 1) return;
      const nextButton = alignmentButtonsRefs.value[index2 + 1];
      if (nextButton) {
        nextButton.setAttribute("tabindex", "0");
        nextButton.focus();
      }
    };
    const moveToPreviousButton = (index2) => {
      if (index2 === 0) return;
      const previousButton = alignmentButtonsRefs.value[index2 - 1];
      if (previousButton) {
        previousButton.setAttribute("tabindex", "0");
        previousButton.focus();
      }
    };
    const handleKeyDown2 = (e, index2) => {
      switch (e.key) {
        case "ArrowLeft":
          moveToPreviousButton(index2);
          break;
        case "ArrowRight":
          moveToNextButton(index2);
          break;
        case "Enter":
          select(alignmentButtons[index2].key);
          break;
      }
    };
    vue.onMounted(() => {
      const firstButton = alignmentButtonsRefs.value[0];
      if (firstButton) {
        firstButton.setAttribute("tabindex", "0");
        firstButton.focus();
      }
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["alignment-buttons", { "high-contrast": vue.unref(isHighContrastMode2) }])
      }, [
        (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, vue.renderList(alignmentButtons, (button, index2) => {
          return vue.createBaseVNode("div", {
            key: button.key,
            class: "button-icon",
            onClick: ($event) => select(button.key),
            innerHTML: button.icon,
            "data-item": "btn-textAlign-option",
            role: "menuitem",
            "aria-label": button.ariaLabel,
            ref_for: true,
            ref_key: "alignmentButtonsRefs",
            ref: alignmentButtonsRefs,
            onKeydown: vue.withModifiers((event) => handleKeyDown2(event, index2), ["prevent"])
          }, null, 40, _hoisted_1$c);
        }), 64))
      ], 2);
    };
  }
};
const AlignmentButtons = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["__scopeId", "data-v-d84f57b6"]]);
const _hoisted_1$b = ["onClick", "onKeydown"];
const _hoisted_2$9 = { class: "document-mode-column icon-column" };
const _hoisted_3$7 = ["innerHTML"];
const _hoisted_4$3 = { class: "document-mode-column text-column" };
const _hoisted_5$2 = { class: "document-mode-type" };
const _hoisted_6$1 = { class: "document-mode-description" };
const _sfc_main$c = {
  __name: "DocumentMode",
  props: {
    options: {
      type: Array
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const documentModeRefs = vue.ref([]);
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const props = __props;
    const handleClick2 = (item) => {
      emit("select", item);
    };
    const moveToNextOption = (index2) => {
      if (index2 === documentModeRefs.value.length - 1) return;
      const nextOption = documentModeRefs.value[index2 + 1];
      if (nextOption) {
        nextOption.setAttribute("tabindex", "0");
        nextOption.focus();
      }
    };
    const moveToPreviousOption = (index2) => {
      if (index2 === 0) return;
      const previousOption = documentModeRefs.value[index2 - 1];
      if (previousOption) {
        previousOption.setAttribute("tabindex", "0");
        previousOption.focus();
      }
    };
    const handleKeyDown2 = (e, index2) => {
      switch (e.key) {
        case "ArrowDown":
          moveToNextOption(index2);
          break;
        case "ArrowUp":
          moveToPreviousOption(index2);
          break;
        case "Enter":
          handleClick2(props.options[index2]);
          break;
      }
    };
    vue.onMounted(() => {
      documentModeRefs.value[0].setAttribute("tabindex", "0");
      documentModeRefs.value[0].focus();
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["document-mode", { "high-contrast": vue.unref(isHighContrastMode2) }])
      }, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.options, (option, index2) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            class: vue.normalizeClass(["option-item", { disabled: option.disabled }]),
            onClick: ($event) => handleClick2(option),
            "data-item": "btn-documentMode-option",
            role: "menuitem",
            ref_for: true,
            ref_key: "documentModeRefs",
            ref: documentModeRefs,
            onKeydown: vue.withModifiers((event) => handleKeyDown2(event, index2), ["prevent"])
          }, [
            vue.createBaseVNode("div", _hoisted_2$9, [
              vue.createBaseVNode("div", {
                class: "icon-column__icon",
                innerHTML: option.icon
              }, null, 8, _hoisted_3$7)
            ]),
            vue.createBaseVNode("div", _hoisted_4$3, [
              vue.createBaseVNode("div", _hoisted_5$2, vue.toDisplayString(option.label), 1),
              vue.createBaseVNode("div", _hoisted_6$1, vue.toDisplayString(option.description), 1)
            ])
          ], 42, _hoisted_1$b);
        }), 256))
      ], 2);
    };
  }
};
const DocumentMode = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["__scopeId", "data-v-8730b752"]]);
const _hoisted_1$a = {
  key: 0,
  class: "linked-style-buttons"
};
const _hoisted_2$8 = ["onClick", "onKeydown"];
const _sfc_main$b = {
  __name: "LinkedStyle",
  props: {
    editor: {
      type: Object,
      required: true
    },
    selectedOption: {
      type: String
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const styleRefs = vue.ref([]);
    const props = __props;
    const select = (style2) => {
      emit("select", style2);
    };
    const moveToNextStyle = (index2) => {
      if (index2 === styleRefs.value.length - 1) {
        return;
      }
      const nextItem = styleRefs.value[index2 + 1];
      nextItem.setAttribute("tabindex", "0");
      nextItem.focus();
    };
    const moveToPreviousStyle = (index2) => {
      if (index2 === 0) {
        return;
      }
      const previousItem = styleRefs.value[index2 - 1];
      previousItem.setAttribute("tabindex", "0");
      previousItem.focus();
    };
    const handleKeyDown2 = (event, index2, style2) => {
      switch (event.key) {
        case "ArrowDown":
          moveToNextStyle(index2);
          break;
        case "ArrowUp":
          moveToPreviousStyle(index2);
          break;
        case "Enter":
          console.log("style", style2);
          select(style2);
          break;
      }
    };
    vue.onMounted(() => {
      styleRefs.value[0].setAttribute("tabindex", "0");
      styleRefs.value[0].focus();
    });
    return (_ctx, _cache) => {
      return props.editor ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$a, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(getQuickFormatList)(__props.editor), (style2, index2) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            class: vue.normalizeClass(["style-item", { selected: __props.selectedOption === style2.id }]),
            onClick: ($event) => select(style2),
            onKeydown: (event) => handleKeyDown2(event, index2, style2),
            ref_for: true,
            ref_key: "styleRefs",
            ref: styleRefs
          }, [
            vue.createBaseVNode("div", {
              class: "style-name",
              style: vue.normalizeStyle(vue.unref(generateLinkedStyleString)(style2, null, null, false)),
              "data-item": "btn-linkedStyles-option"
            }, vue.toDisplayString(style2.definition.attrs.name), 5)
          ], 42, _hoisted_2$8);
        }), 256))
      ])) : vue.createCommentVNode("", true);
    };
  }
};
const LinkedStyle = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["__scopeId", "data-v-698bdb8e"]]);
const _hoisted_1$9 = {
  key: 0,
  class: "link-title"
};
const _hoisted_2$7 = {
  key: 1,
  class: "link-title"
};
const _hoisted_3$6 = {
  key: 2,
  class: "link-title"
};
const _hoisted_4$2 = {
  key: 3,
  class: "link-input-wrapper"
};
const _hoisted_5$1 = { class: "input-row text-input-row" };
const _hoisted_6 = ["onKeydown"];
const _hoisted_7 = { class: "input-row url-input-row" };
const _hoisted_8 = ["innerHTML"];
const _hoisted_9 = ["onKeydown"];
const _hoisted_10 = ["innerHTML"];
const _hoisted_11 = { class: "input-row link-buttons" };
const _hoisted_12 = ["innerHTML"];
const _hoisted_13 = {
  key: 4,
  class: "input-row go-to-anchor clickable"
};
const _sfc_main$a = {
  __name: "LinkInput",
  props: {
    showInput: {
      type: Boolean,
      default: true
    },
    showLink: {
      type: Boolean,
      default: true
    },
    goToAnchor: {
      type: Function,
      default: () => {
      }
    },
    editor: {
      type: Object,
      required: true
    },
    closePopover: {
      type: Function,
      default: () => {
      }
    }
  },
  setup(__props) {
    const props = __props;
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const urlError = vue.ref(false);
    const getSelectedText = () => {
      if (!props.editor || !props.editor.state) return "";
      const { state: state2 } = props.editor;
      const { selection } = state2;
      const linkMark = state2.schema.marks.link;
      if (selection.empty) {
        const range2 = getMarkRange(selection.$from, linkMark);
        return range2 ? state2.doc.textBetween(range2.from, range2.to, " ") : "";
      }
      const rangeFrom = getMarkRange(selection.$from, linkMark);
      const rangeTo = getMarkRange(selection.$to, linkMark);
      if (rangeFrom || rangeTo) {
        const linkRange = rangeFrom || rangeTo;
        return state2.doc.textBetween(linkRange.from, linkRange.to, " ");
      }
      return state2.doc.textBetween(selection.from, selection.to, " ");
    };
    const getLinkHrefAtSelection = () => {
      if (!props.editor || !props.editor.state) return "";
      const { state: state2 } = props.editor;
      const { schema, selection } = state2;
      const linkMark = schema.marks.link;
      if (!linkMark) return "";
      let href = "";
      const { $from, empty: empty2 } = selection;
      if (empty2) {
        const marks = state2.storedMarks || $from.marks();
        const link = marks.find((mark) => mark.type === linkMark);
        if (link) href = link.attrs.href;
      } else {
        state2.doc.nodesBetween(selection.from, selection.to, (node2) => {
          if (node2.marks) {
            const link = node2.marks.find((mark) => mark.type === linkMark);
            if (link) href = link.attrs.href;
          }
        });
      }
      return href || "";
    };
    const text = vue.ref("");
    const rawUrl = vue.ref("");
    const isAnchor = vue.ref(false);
    const url = vue.computed(() => {
      if (!rawUrl.value) return "";
      if (!rawUrl.value.startsWith("http") && !rawUrl.value.startsWith("#")) return "http://" + rawUrl.value;
      return rawUrl.value;
    });
    const validUrl = vue.computed(() => {
      if (url.value.startsWith("#")) return true;
      const urlSplit = url.value.split(".").filter(Boolean);
      return url.value.includes(".") && urlSplit.length > 1;
    });
    const isEditing = vue.computed(() => !isAnchor.value && !!getLinkHrefAtSelection());
    const isDisabled2 = vue.computed(() => !validUrl.value);
    const openLink = () => {
      window.open(url.value, "_blank");
    };
    const updateFromEditor = () => {
      text.value = getSelectedText();
      rawUrl.value = getLinkHrefAtSelection();
    };
    vue.watch(
      () => props.editor?.state?.selection,
      () => {
        updateFromEditor();
      },
      { immediate: true }
    );
    const focusInput = () => {
      const input = document.querySelector(".link-input-ctn input");
      if (!input) return;
      input.focus();
    };
    vue.onMounted(() => {
      updateFromEditor();
      isAnchor.value = rawUrl.value.startsWith("#");
      if (props.showInput) focusInput();
    });
    const handleSubmit = () => {
      const editor = props.editor;
      if (!editor) return;
      if (!rawUrl.value) {
        if (editor.commands?.unsetLink) editor.commands.unsetLink();
        props.closePopover();
        return;
      }
      if (!validUrl.value) {
        urlError.value = true;
        return;
      }
      const finalText = text.value || url.value;
      if (editor.commands?.toggleLink) {
        editor.commands.toggleLink({ href: url.value, text: finalText });
      }
      const endPos = editor.view.state.selection.$to.pos;
      editor.view.dispatch(editor.view.state.tr.setSelection(new TextSelection$1(editor.view.state.doc.resolve(endPos))));
      setTimeout(() => editor.view.focus(), 100);
      props.closePopover();
    };
    const handleRemove = () => {
      if (props.editor && props.editor.commands && props.editor.commands.unsetLink) {
        props.editor.commands.unsetLink();
        props.closePopover();
      }
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["link-input-ctn", { "high-contrast": vue.unref(isHighContrastMode2) }])
      }, [
        isAnchor.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$9, "Page anchor")) : isEditing.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$7, "Edit link")) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_3$6, "Add link")),
        __props.showInput && !isAnchor.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_4$2, [
          vue.createBaseVNode("div", _hoisted_5$1, [
            _cache[4] || (_cache[4] = vue.createBaseVNode("div", { class: "input-icon text-input-icon" }, "T", -1)),
            vue.withDirectives(vue.createBaseVNode("input", {
              type: "text",
              name: "text",
              placeholder: "Text",
              "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => text.value = $event),
              onKeydown: vue.withKeys(vue.withModifiers(handleSubmit, ["stop", "prevent"]), ["enter"])
            }, null, 40, _hoisted_6), [
              [vue.vModelText, text.value]
            ])
          ]),
          vue.createBaseVNode("div", _hoisted_7, [
            vue.createBaseVNode("div", {
              class: "input-icon",
              innerHTML: vue.unref(toolbarIcons).linkInput
            }, null, 8, _hoisted_8),
            vue.withDirectives(vue.createBaseVNode("input", {
              type: "text",
              name: "link",
              placeholder: "Type or paste a link",
              class: vue.normalizeClass({ error: urlError.value }),
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => rawUrl.value = $event),
              onKeydown: [
                vue.withKeys(vue.withModifiers(handleSubmit, ["stop", "prevent"]), ["enter"]),
                _cache[2] || (_cache[2] = ($event) => urlError.value = false)
              ]
            }, null, 42, _hoisted_9), [
              [vue.vModelText, rawUrl.value]
            ]),
            vue.createBaseVNode("div", {
              class: vue.normalizeClass(["open-link-icon", { disabled: !validUrl.value }]),
              innerHTML: vue.unref(toolbarIcons).openLink,
              onClick: openLink,
              "data-item": "btn-link-open"
            }, null, 10, _hoisted_10)
          ]),
          vue.createBaseVNode("div", _hoisted_11, [
            isEditing.value ? (vue.openBlock(), vue.createElementBlock("button", {
              key: 0,
              class: "remove-btn",
              onClick: handleRemove,
              "data-item": "btn-link-remove"
            }, [
              vue.createBaseVNode("div", {
                class: "remove-btn__icon",
                innerHTML: vue.unref(toolbarIcons).removeLink
              }, null, 8, _hoisted_12),
              _cache[5] || (_cache[5] = vue.createTextVNode(" Remove ", -1))
            ])) : vue.createCommentVNode("", true),
            vue.createBaseVNode("button", {
              class: vue.normalizeClass(["submit-btn", { "disable-btn": isDisabled2.value }]),
              onClick: handleSubmit,
              "data-item": "btn-link-apply"
            }, " Apply ", 2)
          ])
        ])) : isAnchor.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_13, [
          vue.createBaseVNode("a", {
            onClick: _cache[3] || (_cache[3] = vue.withModifiers((...args) => __props.goToAnchor && __props.goToAnchor(...args), ["stop", "prevent"]))
          }, "Go to " + vue.toDisplayString(rawUrl.value.startsWith("#_") ? rawUrl.value.substring(2) : rawUrl.value), 1)
        ])) : vue.createCommentVNode("", true)
      ], 2);
    };
  }
};
const LinkInput = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["__scopeId", "data-v-ba50627b"]]);
const _hoisted_1$8 = ["aria-label", "onClick", "onKeydown"];
const _hoisted_2$6 = ["innerHTML"];
const _hoisted_3$5 = ["innerHTML"];
const ROW_SIZE$1 = 7;
const _sfc_main$9 = {
  __name: "IconGridRow",
  props: {
    icons: {
      type: Array,
      required: true
    },
    activeColor: {
      type: Object,
      required: false
    }
  },
  emits: ["select", "clickoutside"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const isActive2 = vue.computed(() => (option) => {
      if (!props.activeColor.value) return false;
      return props.activeColor.value.toUpperCase() === option.value;
    });
    const getCheckStyle = (color, optionIndex) => {
      const lightColors = ["#FFFFFF", "#FAFF09"];
      if (optionIndex === 5 || lightColors.includes(color)) return { color: "#000" };
      return { color: "#FFF" };
    };
    const handleClick2 = (option) => {
      emit("select", option.value);
    };
    const rowRefs = vue.ref([]);
    const iconRefs = vue.ref([]);
    vue.onMounted(() => {
      const isMatrix = props.icons.every((row) => Array.isArray(row));
      if (!isMatrix) throw new Error("icon props must be 2d array");
      const firstIcon = iconRefs.value[0];
      if (firstIcon) {
        firstIcon.setAttribute("tabindex", "0");
        firstIcon.focus();
      }
    });
    const moveToNextIcon = (rowIndex, optionIndex) => {
      const iconIndex = ROW_SIZE$1 * rowIndex + optionIndex + 1;
      const nextIcon = iconRefs.value[iconIndex];
      if (nextIcon) {
        nextIcon.setAttribute("tabindex", "0");
        nextIcon.focus();
      }
    };
    const moveToPreviousIcon = (rowIndex, optionIndex) => {
      const iconIndex = ROW_SIZE$1 * rowIndex + optionIndex - 1;
      const previousIcon = iconRefs.value[iconIndex];
      if (previousIcon) {
        previousIcon.setAttribute("tabindex", "0");
        previousIcon.focus();
      }
    };
    const moveToNextRow = (rowIndex, optionIndex) => {
      const iconIndex = optionIndex + ROW_SIZE$1 * (rowIndex + 1);
      const nextIcon = iconRefs.value[iconIndex];
      if (nextIcon) {
        nextIcon.setAttribute("tabindex", "0");
        nextIcon.focus();
      }
    };
    const moveToPreviousRow = (rowIndex, optionIndex) => {
      const iconIndex = optionIndex + ROW_SIZE$1 * (rowIndex - 1);
      const previousIcon = iconRefs.value[iconIndex];
      if (previousIcon) {
        previousIcon.setAttribute("tabindex", "0");
        previousIcon.focus();
      }
    };
    const handleKeyDown2 = (event, rowIndex, optionIndex, option) => {
      switch (event.key) {
        case "ArrowRight":
          moveToNextIcon(rowIndex, optionIndex);
          break;
        case "ArrowLeft":
          moveToPreviousIcon(rowIndex, optionIndex);
          break;
        case "ArrowDown":
          moveToNextRow(rowIndex, optionIndex);
          break;
        case "ArrowUp":
          moveToPreviousRow(rowIndex, optionIndex);
          break;
        case "Enter":
          handleClick2(option);
          break;
        case "Escape":
          emit("clickoutside");
          break;
      }
    };
    return (_ctx, _cache) => {
      return vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.icons, (row, rowIndex) => {
        return vue.openBlock(), vue.createElementBlock("div", {
          class: "option-row",
          key: rowIndex,
          role: "group",
          ref_for: true,
          ref_key: "rowRefs",
          ref: rowRefs
        }, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(row, (option, optionIndex) => {
            return vue.openBlock(), vue.createElementBlock("div", {
              class: "option",
              key: optionIndex,
              "aria-label": option.label,
              role: "menuitem",
              ref_for: true,
              ref_key: "iconRefs",
              ref: iconRefs,
              onClick: vue.withModifiers(($event) => handleClick2(option), ["stop", "prevent"]),
              onKeydown: vue.withModifiers((event) => handleKeyDown2(event, rowIndex, optionIndex, option), ["prevent"])
            }, [
              vue.createBaseVNode("div", {
                class: "option__icon",
                innerHTML: option.icon,
                style: vue.normalizeStyle(option.style)
              }, null, 12, _hoisted_2$6),
              isActive2.value(option) ? (vue.openBlock(), vue.createElementBlock("div", {
                key: 0,
                class: "option__check",
                innerHTML: vue.unref(toolbarIcons).colorOptionCheck,
                style: vue.normalizeStyle(getCheckStyle(option.value, optionIndex))
              }, null, 12, _hoisted_3$5)) : vue.createCommentVNode("", true)
            ], 40, _hoisted_1$8);
          }), 128))
        ]);
      }), 128);
    };
  }
};
const IconGridRow = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["__scopeId", "data-v-0f479b6c"]]);
const DropIcon = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M320 512c53.2 0 101.4-21.6 136.1-56.6l-298.3-235C140 257.1 128 292.3 128 320c0 106 86 192 192 192zM505.2 370.7c4.4-16.2 6.8-33.1 6.8-50.7c0-91.2-130.2-262.3-166.6-308.3C339.4 4.2 330.5 0 320.9 0l-1.8 0c-9.6 0-18.5 4.2-24.5 11.7C277.8 33 240.7 81.3 205.8 136L38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L505.2 370.7zM224 336c0 44.2 35.8 80 80 80c8.8 0 16 7.2 16 16s-7.2 16-16 16c-61.9 0-112-50.1-112-112c0-8.8 7.2-16 16-16s16 7.2 16 16z"/></svg>\n';
const _hoisted_1$7 = { class: "options-grid-wrap" };
const _hoisted_2$5 = ["innerHTML"];
const _hoisted_3$4 = { class: "option-grid-ctn" };
const _sfc_main$8 = {
  __name: "IconGrid",
  props: {
    icons: {
      type: Array,
      required: true
    },
    customIcons: {
      type: Array,
      required: false
    },
    activeColor: {
      type: Object,
      required: false
    },
    hasNoneIcon: {
      type: Boolean,
      required: false
    }
  },
  emits: ["select", "clickoutside"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const handleSelect = (option) => {
      emit("select", option);
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$7, [
        __props.hasNoneIcon ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: "none-option",
          role: "menuitem",
          "aria-label": "Clear color selection",
          onClick: _cache[0] || (_cache[0] = ($event) => handleSelect("none"))
        }, [
          vue.createBaseVNode("span", {
            innerHTML: vue.unref(DropIcon),
            class: "none-icon"
          }, null, 8, _hoisted_2$5),
          _cache[1] || (_cache[1] = vue.createTextVNode(" None ", -1))
        ])) : vue.createCommentVNode("", true),
        vue.createBaseVNode("div", _hoisted_3$4, [
          vue.createVNode(IconGridRow, {
            icons: __props.icons,
            "active-color": __props.activeColor,
            onSelect: handleSelect
          }, null, 8, ["icons", "active-color"]),
          __props.customIcons.flat().length ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: 0 }, [
            _cache[2] || (_cache[2] = vue.createBaseVNode("span", { class: "option-grid-ctn__subtitle" }, "Custom colors", -1)),
            vue.createVNode(IconGridRow, {
              icons: __props.customIcons,
              "active-color": __props.activeColor,
              onSelect: handleSelect
            }, null, 8, ["icons", "active-color"])
          ], 64)) : vue.createCommentVNode("", true)
        ])
      ]);
    };
  }
};
const IconGrid = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["__scopeId", "data-v-4c0091c8"]]);
const closeDropdown$1 = (dropdown) => {
  dropdown.expand.value = false;
};
const makeColorOption = (color, label = null) => {
  return {
    label,
    icon: toolbarIcons.colorOption,
    value: color,
    style: {
      color,
      boxShadow: "0 0 5px 1px rgba(0, 0, 0, 0.1)",
      borderRadius: "50%"
    }
  };
};
const renderColorOptions = (superToolbar, button, customIcons = [], hasNoneIcon = false) => {
  const handleSelect = (e) => {
    button.iconColor.value = e;
    superToolbar.emitCommand({ item: button, argument: e });
    closeDropdown$1(button);
  };
  return vue.h("div", {}, [
    vue.h(IconGrid, {
      icons,
      customIcons,
      activeColor: button.iconColor,
      hasNoneIcon,
      onSelect: handleSelect
    })
  ]);
};
const icons = [
  [
    makeColorOption("#111111", "black"),
    makeColorOption("#333333", "dark gray"),
    makeColorOption("#5C5C5C", "medium gray"),
    makeColorOption("#858585", "light gray"),
    makeColorOption("#ADADAD", "very light gray"),
    makeColorOption("#D6D6D6", "transparent gray"),
    makeColorOption("#FFFFFF", "white")
  ],
  [
    makeColorOption("#860028", "dark red"),
    makeColorOption("#D2003F", "red"),
    makeColorOption("#DB3365", "coral red"),
    makeColorOption("#E4668C", "light red"),
    makeColorOption("#ED99B2", "pale pink"),
    makeColorOption("#F6CCD9", "transparent pink"),
    makeColorOption("#FF004D", "bright pink")
  ],
  [
    makeColorOption("#83015E", "dark purple"),
    makeColorOption("#CD0194", "purple"),
    makeColorOption("#D734A9", "orchid"),
    makeColorOption("#E167BF", "light purple"),
    makeColorOption("#EB99D4", "lavender"),
    makeColorOption("#F5CCEA", "transparent pink"),
    makeColorOption("#FF00A8", "neon pink")
  ],
  [
    makeColorOption("#8E220A", "maroon"),
    makeColorOption("#DD340F", "red-orange"),
    makeColorOption("#E45C3F", "burnt orange"),
    makeColorOption("#EB856F", "peach"),
    makeColorOption("#F1AE9F", "pale peach"),
    makeColorOption("#F8D6CF", "transparent peach"),
    makeColorOption("#FF7A00", "orange")
  ],
  [
    makeColorOption("#947D02", "olive"),
    makeColorOption("#E7C302", "mustard yellow"),
    makeColorOption("#ECCF35", "yellow"),
    makeColorOption("#F1DB67", "light yellow"),
    makeColorOption("#F5E79A", "very pale yellow"),
    makeColorOption("#FAF3CC", "transparent yellow"),
    makeColorOption("#FAFF09", "neon yellow")
  ],
  [
    makeColorOption("#055432", "forest green"),
    makeColorOption("#07834F", "green"),
    makeColorOption("#399C72", "medium green"),
    makeColorOption("#6AB595", "light green"),
    makeColorOption("#9CCDB9", "mint"),
    makeColorOption("#CDE6DC", "transparent mint"),
    makeColorOption("#05F38F", "bright teal")
  ],
  [
    makeColorOption("#063E7E", "navy blue"),
    makeColorOption("#0A60C5", "blue"),
    makeColorOption("#3B80D1", "sky blue"),
    makeColorOption("#6CA0DC", "cornflower blue"),
    makeColorOption("#9DBFE8", "light blue"),
    makeColorOption("#CEDFF3", "very light blue"),
    makeColorOption("#21c8ce", "cyan")
  ],
  [
    makeColorOption("#3E027A", "deep purple"),
    makeColorOption("#6103BF", "indigo"),
    makeColorOption("#8136CC", "violet"),
    makeColorOption("#A068D9", "lavender pink"),
    makeColorOption("#C09AE6", "light lilac"),
    makeColorOption("#DFCDF2", "transparent lilac"),
    makeColorOption("#A91DFF", "neon purple")
  ]
];
const getAvailableColorOptions = () => {
  return icons.flat().map((item) => item.value);
};
const _hoisted_1$6 = ["data-cols", "data-rows", "onKeydown", "onClick"];
const _hoisted_2$4 = ["aria-valuetext"];
const ROW_SIZE = 5;
const _sfc_main$7 = {
  __name: "TableGrid",
  emits: ["select", "clickoutside"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const selectedRows = vue.ref(0);
    const selectedCols = vue.ref(0);
    const { isHighContrastMode: isHighContrastMode2 } = useHighContrastMode();
    const tableGridItems = vue.ref([]);
    const onTableGridMouseOver = (event) => {
      let target = event.target;
      let isGrid = !!target.dataset.grid;
      if (isGrid) {
        return;
      }
      let grid = target.parentElement;
      let allItems = [...grid.querySelectorAll("[data-item]")];
      let cols = parseInt(target.dataset.cols, 10);
      let rows = parseInt(target.dataset.rows, 10);
      selectGridItems(allItems, cols, rows);
    };
    const selectGridItems = (allItems, cols, rows) => {
      selectedCols.value = cols;
      selectedRows.value = rows;
      for (let i2 = 0; i2 < allItems.length; i2++) {
        let item = allItems[i2];
        let itemsCols = parseInt(item.dataset.cols, 10);
        let itemsRows = parseInt(item.dataset.rows, 10);
        if (itemsCols <= cols && itemsRows <= rows) {
          item.classList.add("selected");
        } else {
          item.classList.remove("selected");
        }
      }
    };
    const handleClick2 = ({ cols, rows }) => {
      emit("select", { cols, rows });
    };
    const handleKeyDown2 = (event, cols, rows) => {
      let normalizedCols = cols - 1;
      let normalizedRows = rows - 1;
      switch (event.key) {
        case "ArrowRight": {
          if (normalizedCols >= 4) {
            return;
          }
          const currentRow = normalizedRows * ROW_SIZE;
          tableGridItems.value[currentRow + normalizedCols + 1].setAttribute("tabindex", "0");
          tableGridItems.value[currentRow + normalizedCols + 1].focus();
          selectGridItems(tableGridItems.value, cols + 1, rows);
          break;
        }
        case "ArrowLeft": {
          if (normalizedCols <= 0) {
            return;
          }
          const currentRow = normalizedRows * ROW_SIZE;
          tableGridItems.value[currentRow + normalizedCols - 1].setAttribute("tabindex", "0");
          tableGridItems.value[currentRow + normalizedCols - 1].focus();
          selectGridItems(tableGridItems.value, cols - 1, rows);
          break;
        }
        case "ArrowDown": {
          if (normalizedRows >= 4) {
            return;
          }
          const nextRow = (normalizedRows + 1) * ROW_SIZE;
          tableGridItems.value[nextRow + normalizedCols].setAttribute("tabindex", "0");
          tableGridItems.value[nextRow + normalizedCols].focus();
          selectGridItems(tableGridItems.value, cols, rows + 1);
          break;
        }
        case "ArrowUp": {
          if (normalizedRows <= 0) {
            return;
          }
          const previousRow = (normalizedRows - 1) * ROW_SIZE;
          tableGridItems.value[previousRow + normalizedCols].setAttribute("tabindex", "0");
          tableGridItems.value[previousRow + normalizedCols].focus();
          selectGridItems(tableGridItems.value, cols, rows - 1);
          break;
        }
        case "Enter": {
          handleClick2({ cols, rows });
          break;
        }
      }
    };
    vue.onMounted(() => {
      tableGridItems.value[0].setAttribute("tabindex", "0");
      tableGridItems.value[0].focus();
      selectGridItems(tableGridItems.value, 1, 1);
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["toolbar-table-grid-wrapper", { "high-contrast": vue.unref(isHighContrastMode2) }])
      }, [
        vue.createBaseVNode("div", {
          class: "toolbar-table-grid",
          onMouseover: onTableGridMouseOver,
          "data-grid": "true"
        }, [
          (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, vue.renderList(5, (i2) => {
            return vue.openBlock(), vue.createElementBlock(vue.Fragment, { key: i2 }, [
              (vue.openBlock(), vue.createElementBlock(vue.Fragment, null, vue.renderList(5, (n) => {
                return vue.createBaseVNode("div", {
                  class: "toolbar-table-grid__item",
                  key: `${i2}_${n}`,
                  "data-cols": n,
                  "data-rows": i2,
                  "data-item": "true",
                  ref_for: true,
                  ref_key: "tableGridItems",
                  ref: tableGridItems,
                  onKeydown: vue.withModifiers((event) => handleKeyDown2(event, n, i2), ["prevent"]),
                  onClick: vue.withModifiers(($event) => handleClick2({ cols: n, rows: i2 }), ["stop", "prevent"])
                }, null, 40, _hoisted_1$6);
              }), 64))
            ], 64);
          }), 64))
        ], 32),
        vue.createBaseVNode("div", {
          class: "toolbar-table-grid-value",
          "aria-valuetext": `${selectedRows.value} x ${selectedCols.value}`
        }, vue.toDisplayString(selectedRows.value) + " x " + vue.toDisplayString(selectedCols.value), 9, _hoisted_2$4)
      ], 2);
    };
  }
};
const TableGrid = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-92e8d5fb"]]);
const _hoisted_1$5 = { class: "toolbar-table-actions" };
const _hoisted_2$3 = ["onClick", "data-item", "ariaLabel"];
const _hoisted_3$3 = { class: "toolbar-table-actions__icon" };
const _hoisted_4$1 = ["innerHTML"];
const _hoisted_5 = { class: "toolbar-table-actions__label" };
const _sfc_main$6 = {
  __name: "TableActions",
  props: {
    options: {
      type: Array
    }
  },
  emits: ["select"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const handleClick2 = (item) => {
      emit("select", { command: item.command });
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$5, [
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.options, (option) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            class: vue.normalizeClass(["toolbar-table-actions__item", { "toolbar-table-actions__item--border": option.bottomBorder }]),
            onClick: ($event) => handleClick2(option),
            "data-item": option.props?.["data-item"] || "",
            ariaLabel: option.props?.ariaLabel,
            role: "menuitem"
          }, [
            vue.createBaseVNode("div", _hoisted_3$3, [
              vue.createBaseVNode("div", {
                class: "toolbar-table-actions__icon-wrapper",
                innerHTML: option.icon
              }, null, 8, _hoisted_4$1)
            ]),
            vue.createBaseVNode("div", _hoisted_5, vue.toDisplayString(option.label), 1)
          ], 10, _hoisted_2$3);
        }), 256))
      ]);
    };
  }
};
const TableActions = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["__scopeId", "data-v-990b9a25"]]);
function getScrollableParent(element) {
  let currentElement = element;
  while (currentElement) {
    const overflowY = window.getComputedStyle(currentElement).overflowY;
    if (/(auto|scroll)/.test(overflowY) && currentElement.scrollHeight > currentElement.clientHeight) {
      return currentElement;
    }
    currentElement = currentElement.parentElement;
  }
  return document.scrollingElement || document.documentElement;
}
function scrollToElement(targetElement, options = { behavior: "smooth", block: "start" }) {
  if (!targetElement) return;
  const container = getScrollableParent(targetElement);
  const containerRect = container.getBoundingClientRect();
  const targetRect = targetElement.getBoundingClientRect();
  const offsetTop = targetRect.top - containerRect.top + container.scrollTop;
  container.scrollTo({
    top: options.block === "start" ? offsetTop : offsetTop - container.clientHeight + targetElement.offsetHeight,
    behavior: options.behavior
  });
}
const checkIconSvg = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.--><path d="M438.6 105.4c12.5 12.5 12.5 32.8 0 45.3l-256 256c-12.5 12.5-32.8 12.5-45.3 0l-128-128c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0L160 338.7 393.4 105.4c12.5-12.5 32.8-12.5 45.3 0z"/></svg>\n';
const _hoisted_1$4 = { class: "search-input-ctn" };
const _hoisted_2$2 = { class: "row" };
const _hoisted_3$2 = ["onKeydown"];
const _sfc_main$5 = {
  __name: "SearchInput",
  props: {
    searchRef: {
      type: Object
    }
  },
  emits: ["submit"],
  setup(__props, { emit: __emit }) {
    const searchValue = vue.ref("");
    const emit = __emit;
    const handleSubmit = () => {
      emit("submit", { value: searchValue.value });
    };
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$4, [
        vue.createBaseVNode("div", _hoisted_2$2, [
          vue.withDirectives(vue.createBaseVNode("input", {
            ref: __props.searchRef,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchValue.value = $event),
            class: "search-input",
            type: "text",
            name: "search",
            placeholder: "Type search string",
            onKeydown: vue.withKeys(vue.withModifiers(handleSubmit, ["stop", "prevent"]), ["enter"])
          }, null, 40, _hoisted_3$2), [
            [vue.vModelText, searchValue.value]
          ])
        ]),
        vue.createBaseVNode("div", { class: "row submit" }, [
          vue.createBaseVNode("button", {
            class: "submit-btn",
            onClick: handleSubmit
          }, "Apply")
        ])
      ]);
    };
  }
};
const SearchInput = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["__scopeId", "data-v-957cbcf2"]]);
const TOOLBAR_FONTS = [
  {
    label: "Georgia",
    key: "Georgia, serif",
    fontWeight: 400,
    props: {
      style: { fontFamily: "Georgia, serif" },
      "data-item": "btn-fontFamily-option"
    }
  },
  {
    label: "Arial",
    key: "Arial, sans-serif",
    fontWeight: 400,
    props: {
      style: { fontFamily: "Arial, sans-serif" },
      "data-item": "btn-fontFamily-option"
    }
  },
  {
    label: "Courier New",
    key: "Courier New, monospace",
    fontWeight: 400,
    props: {
      style: { fontFamily: "Courier New, monospace" },
      "data-item": "btn-fontFamily-option"
    }
  },
  {
    label: "Times New Roman",
    key: "Times New Roman, serif",
    fontWeight: 400,
    props: {
      style: { fontFamily: "Times New Roman, serif" },
      "data-item": "btn-fontFamily-option"
    }
  }
];
const closeDropdown = (dropdown) => {
  dropdown.expand.value = false;
};
const makeDefaultItems = ({
  superToolbar,
  toolbarIcons: toolbarIcons2,
  toolbarTexts: toolbarTexts2,
  toolbarFonts,
  hideButtons,
  availableWidth,
  role,
  isDev = false
} = {}) => {
  const bold = useToolbarItem({
    type: "button",
    name: "bold",
    command: "toggleBold",
    icon: toolbarIcons2.bold,
    tooltip: toolbarTexts2.bold,
    attributes: {
      ariaLabel: "Bold"
    }
  });
  const fontButton = useToolbarItem({
    type: "dropdown",
    name: "fontFamily",
    tooltip: toolbarTexts2.fontFamily,
    command: "setFontFamily",
    defaultLabel: "Arial",
    label: "Arial",
    markName: "textStyle",
    labelAttr: "fontFamily",
    hasCaret: true,
    isWide: true,
    style: { width: "116px" },
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "Font family"
    },
    options: [...toolbarFonts ? toolbarFonts : TOOLBAR_FONTS],
    onActivate: ({ fontFamily: fontFamily2 }) => {
      if (!fontFamily2) return;
      fontButton.label.value = fontFamily2;
    },
    onDeactivate: () => fontButton.label.value = fontButton.defaultLabel.value
  });
  const aiButton = useToolbarItem({
    type: "dropdown",
    dropdownStyles: {
      padding: 0,
      outline: "none"
    },
    name: "ai",
    tooltip: toolbarTexts2.ai,
    icon: toolbarIcons2.ai,
    hideLabel: true,
    hasCaret: false,
    isWide: true,
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "AI"
    },
    options: [
      {
        type: "render",
        key: "ai",
        render: () => {
          let selectedText = "";
          if (superToolbar.activeEditor) {
            const { state: state2 } = superToolbar.activeEditor;
            const { from: from2, to, empty: empty2 } = state2.selection;
            selectedText = !empty2 ? state2.doc.textBetween(from2, to) : "";
          }
          const handleClose = () => {
            closeDropdown(aiButton);
          };
          return vue.h("div", {}, [
            vue.h(AIWriter, {
              handleClose,
              selectedText,
              editor: superToolbar.activeEditor,
              apiKey: superToolbar.config.aiApiKey,
              endpoint: superToolbar.config.aiEndpoint,
              superToolbar
            })
          ]);
        }
      }
    ]
  });
  const fontSize2 = useToolbarItem({
    type: "dropdown",
    name: "fontSize",
    defaultLabel: "12",
    label: "12",
    minWidth: "50px",
    markName: "textStyle",
    labelAttr: "fontSize",
    tooltip: toolbarTexts2.fontSize,
    hasCaret: true,
    hasInlineTextInput: true,
    inlineTextInputVisible: true,
    suppressActiveHighlight: true,
    isWide: true,
    command: "setFontSize",
    attributes: {
      ariaLabel: "Font size"
    },
    options: [
      { label: "8", key: "8pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "9", key: "9pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "10", key: "10pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "11", key: "11pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "12", key: "12pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "14", key: "14pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "18", key: "18pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "24", key: "24pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "30", key: "30pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "36", key: "36pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "48", key: "48pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "60", key: "60pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "72", key: "72pt", props: { "data-item": "btn-fontSize-option" } },
      { label: "96", key: "96pt", props: { "data-item": "btn-fontSize-option" } }
    ],
    onActivate: ({ fontSize: size2 }) => {
      if (!size2) return fontSize2.label.value = fontSize2.defaultLabel.value;
      let sanitizedValue = sanitizeNumber(size2, 12);
      if (sanitizedValue < 8) sanitizedValue = 8;
      if (sanitizedValue > 96) sanitizedValue = 96;
      fontSize2.label.value = String(sanitizedValue);
    },
    onDeactivate: () => fontSize2.label.value = fontSize2.defaultLabel.value
  });
  const separator = useToolbarItem({
    type: "separator",
    name: "separator",
    isNarrow: true
  });
  const italic = useToolbarItem({
    type: "button",
    name: "italic",
    command: "toggleItalic",
    icon: toolbarIcons2.italic,
    tooltip: toolbarTexts2.italic,
    attributes: {
      ariaLabel: "Italic"
    }
  });
  const underline = useToolbarItem({
    type: "button",
    name: "underline",
    command: "toggleUnderline",
    icon: toolbarIcons2.underline,
    tooltip: toolbarTexts2.underline,
    attributes: {
      ariaLabel: "Underline"
    }
  });
  const strikethrough = useToolbarItem({
    type: "button",
    name: "strike",
    command: "toggleStrike",
    icon: toolbarIcons2.strikethrough,
    tooltip: toolbarTexts2.strikethrough,
    attributes: {
      ariaLabel: "Strikethrough"
    }
  });
  const highlight = useToolbarItem({
    type: "dropdown",
    name: "highlight",
    icon: toolbarIcons2.highlight,
    hideLabel: true,
    markName: "highlight",
    labelAttr: "color",
    tooltip: toolbarTexts2.highlight,
    command: "setHighlight",
    noArgumentCommand: "unsetHighlight",
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "Highlight"
    },
    options: [
      {
        key: "color",
        type: "render",
        render: () => renderColorOptions(superToolbar, highlight, [], true)
      }
    ],
    onActivate: ({ color }) => {
      highlight.iconColor.value = color || "";
    },
    onDeactivate: () => highlight.iconColor.value = ""
  });
  const colorButton = useToolbarItem({
    type: "dropdown",
    name: "color",
    icon: toolbarIcons2.color,
    hideLabel: true,
    markName: "textStyle",
    labelAttr: "color",
    tooltip: toolbarTexts2.color,
    command: "setColor",
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "Color"
    },
    options: [
      {
        key: "color",
        type: "render",
        render: () => renderColorOptions(superToolbar, colorButton)
      }
    ],
    onActivate: ({ color }) => {
      colorButton.iconColor.value = color;
    },
    onDeactivate: () => colorButton.iconColor.value = "#000"
  });
  const searchRef = vue.ref(null);
  const search2 = useToolbarItem({
    type: "dropdown",
    name: "search",
    icon: toolbarIcons2.search,
    tooltip: toolbarTexts2.search,
    group: "right",
    inputRef: searchRef,
    attributes: {
      ariaLabel: "Search"
    },
    options: [
      {
        type: "render",
        key: "searchDropdown",
        render: () => renderSearchDropdown()
      }
    ]
  });
  const renderSearchDropdown = () => {
    const handleSubmit = ({ value }) => {
      superToolbar.activeEditor.commands.search(value);
    };
    return vue.h("div", {}, [
      vue.h(SearchInput, {
        onSubmit: handleSubmit,
        searchRef
      })
    ]);
  };
  const link = useToolbarItem({
    type: "dropdown",
    name: "link",
    markName: "link",
    icon: toolbarIcons2.link,
    tooltip: toolbarTexts2.link,
    attributes: {
      ariaLabel: "Link dropdown"
    },
    options: [
      {
        type: "render",
        key: "linkDropdown",
        render: () => renderLinkDropdown(link)
      }
    ],
    onActivate: ({ href }) => {
      if (href) link.attributes.value = { href };
      else link.attributes.value = {};
    },
    onDeactivate: () => {
      link.attributes.value = {};
      link.expand.value = false;
    }
  });
  function renderLinkDropdown(link2) {
    return vue.h("div", {}, [
      vue.h(LinkInput, {
        editor: superToolbar.activeEditor,
        closePopover: () => closeDropdown(link2),
        goToAnchor: () => {
          closeDropdown(link2);
          if (!superToolbar.activeEditor || !link2.attributes.value?.href) return;
          const anchorName = link2.attributes.value?.href?.slice(1);
          const container = superToolbar.activeEditor.element;
          const anchor = container.querySelector(`a[name='${anchorName}']`);
          if (anchor) scrollToElement(anchor);
        }
      })
    ]);
  }
  const linkInput = useToolbarItem({
    type: "options",
    name: "linkInput",
    command: "toggleLink"
  });
  link.childItem = linkInput;
  linkInput.parentItem = link;
  const image = useToolbarItem({
    type: "button",
    name: "image",
    command: "startImageUpload",
    icon: toolbarIcons2.image,
    tooltip: toolbarTexts2.image,
    disabled: false,
    attributes: {
      ariaLabel: "Image"
    }
  });
  const tableItem = useToolbarItem({
    type: "dropdown",
    name: "table",
    icon: toolbarIcons2.table,
    hideLabel: true,
    labelAttr: "table",
    tooltip: toolbarTexts2.table,
    command: "insertTable",
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "Table"
    },
    options: [
      {
        key: "table",
        type: "render",
        render: () => renderTableGrid(tableItem)
      }
    ]
  });
  function renderTableGrid(tableItem2) {
    const handleSelect = (e) => {
      superToolbar.emitCommand({ item: tableItem2, argument: e });
      closeDropdown(tableItem2);
    };
    return vue.h("div", {}, [
      vue.h(TableGrid, {
        onSelect: handleSelect
      })
    ]);
  }
  const tableActionsItem = useToolbarItem({
    type: "dropdown",
    name: "tableActions",
    command: "executeTableCommand",
    icon: toolbarIcons2.tableActions,
    hideLabel: true,
    disabled: true,
    attributes: {
      ariaLabel: "Table actions"
    },
    options: [
      {
        type: "render",
        render: () => renderTableActions(tableActionsItem)
      }
    ]
  });
  const tableActionsOptions2 = [
    {
      label: toolbarTexts2.addRowBefore,
      command: "addRowBefore",
      icon: toolbarIcons2.addRowBefore,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Add row before"
      }
    },
    {
      label: toolbarTexts2.addRowAfter,
      command: "addRowAfter",
      icon: toolbarIcons2.addRowAfter,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Add row after"
      }
    },
    {
      label: toolbarTexts2.addColumnBefore,
      command: "addColumnBefore",
      icon: toolbarIcons2.addColumnBefore,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Add column before"
      }
    },
    {
      label: toolbarTexts2.addColumnAfter,
      command: "addColumnAfter",
      icon: toolbarIcons2.addColumnAfter,
      bottomBorder: true,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Add column after"
      }
    },
    {
      label: toolbarTexts2.deleteRow,
      command: "deleteRow",
      icon: toolbarIcons2.deleteRow,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Delete row"
      }
    },
    {
      label: toolbarTexts2.deleteColumn,
      command: "deleteColumn",
      icon: toolbarIcons2.deleteColumn,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Delete column"
      }
    },
    {
      label: toolbarTexts2.deleteTable,
      command: "deleteTable",
      icon: toolbarIcons2.deleteTable,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Delete table"
      }
    },
    {
      label: toolbarTexts2.transparentBorders,
      command: "deleteCellAndTableBorders",
      icon: toolbarIcons2.deleteBorders,
      bottomBorder: true,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Delete cell and table borders"
      }
    },
    {
      label: toolbarTexts2.mergeCells,
      command: "mergeCells",
      icon: toolbarIcons2.mergeCells,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Merge cells"
      }
    },
    {
      label: toolbarTexts2.splitCell,
      command: "splitCell",
      icon: toolbarIcons2.splitCell,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Split cells"
      }
    },
    {
      label: toolbarTexts2.fixTables,
      command: "fixTables",
      icon: toolbarIcons2.fixTables,
      props: {
        "data-item": "btn-tableActions-option",
        ariaLabel: "Fix tables"
      }
    }
  ];
  function renderTableActions(tableActionsItem2) {
    return vue.h(TableActions, {
      options: tableActionsOptions2,
      onSelect: (event) => {
        closeDropdown(tableActionsItem2);
        const { command: command2 } = event;
        superToolbar.emitCommand({ item: tableActionsItem2, argument: { command: command2 } });
      }
    });
  }
  const alignment2 = useToolbarItem({
    type: "dropdown",
    name: "textAlign",
    tooltip: toolbarTexts2.textAlign,
    icon: toolbarIcons2.alignLeft,
    command: "setTextAlign",
    hasCaret: true,
    markName: "textAlign",
    labelAttr: "textAlign",
    suppressActiveHighlight: true,
    attributes: {
      ariaLabel: "Text align"
    },
    options: [
      {
        type: "render",
        render: () => {
          const handleSelect = (e) => {
            closeDropdown(alignment2);
            const buttonWithCommand = { ...alignment2, command: "setTextAlign" };
            buttonWithCommand.command = "setTextAlign";
            superToolbar.emitCommand({ item: buttonWithCommand, argument: e });
            setAlignmentIcon(alignment2, e);
          };
          return vue.h("div", {}, [
            vue.h(AlignmentButtons, {
              onSelect: handleSelect
            })
          ]);
        },
        key: "alignment"
      }
    ],
    onActivate: ({ textAlign }) => {
      setAlignmentIcon(alignment2, textAlign);
    },
    onDeactivate: () => {
      setAlignmentIcon(alignment2, "left");
    }
  });
  const setAlignmentIcon = (alignment3, e) => {
    let alignValue = e === "both" ? "justify" : e;
    let icons2 = {
      left: toolbarIcons2.alignLeft,
      right: toolbarIcons2.alignRight,
      center: toolbarIcons2.alignCenter,
      justify: toolbarIcons2.alignJustify
    };
    let icon = icons2[alignValue] ?? icons2.left;
    alignment3.icon.value = icon;
  };
  const bulletedList = useToolbarItem({
    type: "button",
    name: "list",
    command: "toggleBulletList",
    icon: toolbarIcons2.bulletList,
    tooltip: toolbarTexts2.bulletList,
    attributes: {
      ariaLabel: "Bullet list"
    }
  });
  const numberedList = useToolbarItem({
    type: "button",
    name: "numberedlist",
    command: "toggleOrderedList",
    icon: toolbarIcons2.numberedList,
    tooltip: toolbarTexts2.numberedList,
    attributes: {
      ariaLabel: "Numbered list"
    }
  });
  const indentLeft = useToolbarItem({
    type: "button",
    name: "indentleft",
    command: "decreaseTextIndent",
    icon: toolbarIcons2.indentLeft,
    tooltip: toolbarTexts2.indentLeft,
    disabled: false,
    attributes: {
      ariaLabel: "Left indent"
    }
  });
  const indentRight = useToolbarItem({
    type: "button",
    name: "indentright",
    command: "increaseTextIndent",
    icon: toolbarIcons2.indentRight,
    tooltip: toolbarTexts2.indentRight,
    disabled: false,
    attributes: {
      ariaLabel: "Right indent"
    }
  });
  const overflow = useToolbarItem({
    type: "overflow",
    name: "overflow",
    command: null,
    icon: toolbarIcons2.overflow,
    disabled: false,
    attributes: {
      ariaLabel: "Overflow items"
    }
  });
  const zoom = useToolbarItem({
    type: "dropdown",
    name: "zoom",
    allowWithoutEditor: true,
    tooltip: toolbarTexts2.zoom,
    defaultLabel: "100%",
    label: "100%",
    hasCaret: true,
    command: "setZoom",
    isWide: true,
    inlineTextInputVisible: false,
    hasInlineTextInput: true,
    attributes: {
      ariaLabel: "Zoom"
    },
    options: [
      { label: "50%", key: 0.5, props: { "data-item": "btn-zoom-option" } },
      { label: "75%", key: 0.75, props: { "data-item": "btn-zoom-option" } },
      { label: "90%", key: 0.9, props: { "data-item": "btn-zoom-option" } },
      { label: "100%", key: 1, props: { "data-item": "btn-zoom-option" } },
      { label: "125%", key: 1.25, props: { "data-item": "btn-zoom-option" } },
      { label: "150%", key: 1.5, props: { "data-item": "btn-zoom-option" } },
      { label: "200%", key: 2, props: { "data-item": "btn-zoom-option" } }
    ],
    onActivate: ({ zoom: value }) => {
      if (!value) return;
      zoom.label.value = value;
    }
  });
  const undo2 = useToolbarItem({
    type: "button",
    name: "undo",
    disabled: true,
    tooltip: toolbarTexts2.undo,
    command: "undo",
    icon: toolbarIcons2.undo,
    group: "left",
    attributes: {
      ariaLabel: "Undo"
    },
    onDeactivate: () => {
      undo2.disabled.value = !superToolbar.undoDepth;
    }
  });
  const redo2 = useToolbarItem({
    type: "button",
    disabled: true,
    name: "redo",
    tooltip: toolbarTexts2.redo,
    command: "redo",
    icon: toolbarIcons2.redo,
    group: "left",
    attributes: {
      ariaLabel: "Redo"
    },
    onDeactivate: () => {
      redo2.disabled.value = !superToolbar.redoDepth;
    }
  });
  const toggleTrackChanges = useToolbarItem({
    type: "button",
    disabled: false,
    name: "toggleTrackChanges",
    tooltip: toolbarTexts2.trackChanges,
    command: "toggleTrackChanges",
    icon: toolbarIcons2.trackChanges,
    group: "left",
    attributes: {
      ariaLabel: "Track changes"
    }
  });
  const acceptTrackedChangeBySelection = useToolbarItem({
    type: "button",
    disabled: false,
    name: "acceptTrackedChangeBySelection",
    tooltip: toolbarTexts2.trackChangesAccept,
    command: "acceptTrackedChangeBySelection",
    icon: toolbarIcons2.trackChangesAccept,
    group: "left",
    attributes: {
      ariaLabel: "Accept tracked changes"
    }
  });
  const rejectTrackedChangeOnSelection = useToolbarItem({
    type: "button",
    disabled: false,
    name: "rejectTrackedChangeOnSelection",
    tooltip: toolbarTexts2.trackChangesReject,
    command: "rejectTrackedChangeOnSelection",
    icon: toolbarIcons2.trackChangesReject,
    group: "left",
    attributes: {
      ariaLabel: "Reject tracked changes"
    }
  });
  const toggleTrackChangesOriginal = useToolbarItem({
    type: "button",
    disabled: false,
    name: "toggleTrackChangesShowOriginal",
    tooltip: toolbarTexts2.trackChangesOriginal,
    command: "toggleTrackChangesShowOriginal",
    icon: toolbarIcons2.trackChangesOriginal,
    group: "left",
    attributes: {
      ariaLabel: "Toggle tracked changes show original"
    }
  });
  const toggleTrackChangesFinal = useToolbarItem({
    type: "button",
    disabled: false,
    name: "toggleTrackChangesShowFinal",
    tooltip: toolbarTexts2.trackChangesFinal,
    command: "toggleTrackChangesShowFinal",
    icon: toolbarIcons2.trackChangesFinal,
    group: "left",
    attributes: {
      ariaLabel: "Toggle tracked changes show final"
    }
  });
  const clearFormatting = useToolbarItem({
    type: "button",
    name: "clearFormatting",
    command: "clearFormat",
    tooltip: toolbarTexts2.clearFormatting,
    icon: toolbarIcons2.clearFormatting,
    attributes: {
      ariaLabel: "Clear formatting"
    }
  });
  const copyFormat = useToolbarItem({
    type: "button",
    name: "copyFormat",
    tooltip: toolbarTexts2.copyFormat,
    icon: toolbarIcons2.copyFormat,
    command: "copyFormat",
    attributes: {
      ariaLabel: "Copy formatting"
    }
  });
  const getDocumentOptionsAfterRole = (role2, documentOptions2) => {
    if (role2 === "editor") return documentOptions2;
    else if (role2 === "suggester") return documentOptions2.filter((option) => option.value === "suggesting");
    else return documentOptions2.filter((option) => option.value === "viewing");
  };
  const getDefaultLabel = (role2) => {
    if (role2 === "editor") return "Editing";
    else if (role2 === "suggester") return "Suggesting";
    else return "Viewing";
  };
  const documentMode = useToolbarItem({
    type: "dropdown",
    name: "documentMode",
    command: "setDocumentMode",
    allowWithoutEditor: true,
    icon: toolbarIcons2.documentMode,
    defaultLabel: getDefaultLabel(role),
    label: getDefaultLabel(role),
    hasCaret: role === "editor",
    isWide: true,
    style: { display: "flex", justifyContent: "flex-end" },
    inlineTextInputVisible: false,
    hasInlineTextInput: false,
    group: "right",
    disabled: role !== "editor",
    attributes: {
      dropdownPosition: "right",
      className: "toolbar-item--doc-mode",
      ariaLabel: "Document mode"
    },
    options: [
      {
        type: "render",
        render: () => renderDocumentMode(documentMode)
      }
    ]
  });
  const documentOptions = [
    {
      label: toolbarTexts2.documentEditingMode,
      value: "editing",
      icon: toolbarIcons2.documentEditingMode,
      description: toolbarTexts2.documentEditingModeDescription
    },
    {
      label: toolbarTexts2.documentSuggestingMode,
      value: "suggesting",
      icon: toolbarIcons2.documentSuggestingMode,
      description: toolbarTexts2.documentSuggestingModeDescription
    },
    {
      label: toolbarTexts2.documentViewingMode,
      value: "viewing",
      icon: toolbarIcons2.documentViewingMode,
      description: toolbarTexts2.documentViewingModeDescription
    }
  ];
  function renderDocumentMode(renderDocumentButton) {
    const optionsAfterRole = getDocumentOptionsAfterRole(role, documentOptions);
    return vue.h(DocumentMode, {
      options: optionsAfterRole,
      onSelect: (item) => {
        closeDropdown(renderDocumentButton);
        const { label, icon } = item;
        documentMode.label.value = label;
        documentMode.icon.value = icon;
        superToolbar.emitCommand({ item: documentMode, argument: label });
      }
    });
  }
  const pageBreakTool = useToolbarItem({
    type: "button",
    name: "pageBreakTool",
    command: "insertPageBreak",
    icon: toolbarIcons2.pageBreak,
    tooltip: toolbarTexts2.pageBreak,
    attributes: {
      ariaLabel: "Page break"
    }
  });
  const controlSizes = /* @__PURE__ */ new Map([
    ["separator", 20],
    ["zoom", 71],
    ["fontFamily", 118],
    ["fontSize", 57],
    ["textAlign", 40],
    ["linkedStyles", 142],
    ["documentMode", 47],
    ["ai", 32],
    ["default", 32]
  ]);
  const ruler = useToolbarItem({
    type: "button",
    name: "ruler",
    command: "toggleRuler",
    icon: toolbarIcons2.ruler,
    tooltip: toolbarTexts2.ruler,
    attributes: {
      ariaLabel: "Ruler"
    }
  });
  const selectedLinkedStyle = vue.ref(null);
  const linkedStyles = useToolbarItem({
    type: "dropdown",
    name: "linkedStyles",
    command: "setLinkedStyle",
    icon: toolbarIcons2.paintbrush,
    defaultLabel: toolbarTexts2.formatText,
    label: toolbarTexts2.formatText,
    hasCaret: true,
    isWide: true,
    style: { width: "140px" },
    suppressActiveHighlight: true,
    disabled: false,
    attributes: {
      className: "toolbar-item--linked-styles",
      ariaLabel: "Linked styles"
    },
    options: [
      {
        type: "render",
        key: "linkedStyle",
        render: () => {
          const handleSelect = (style2) => {
            closeDropdown(linkedStyles);
            const itemWithCommand = { ...linkedStyles, command: "setLinkedStyle" };
            superToolbar.emitCommand({ item: itemWithCommand, argument: style2 });
            selectedLinkedStyle.value = style2.id;
          };
          return vue.h("div", {}, [
            vue.h(LinkedStyle, {
              editor: superToolbar.activeEditor,
              onSelect: handleSelect,
              selectedOption: selectedLinkedStyle.value
            })
          ]);
        }
      }
    ],
    onActivate: () => {
      linkedStyles.disabled.value = false;
    },
    onDeactivate: () => {
      linkedStyles.disabled.value = true;
    }
  });
  const renderIcon = (value, selectedValue) => {
    if (selectedValue.value.toString() !== value) return;
    return vue.h("div", { innerHTML: checkIconSvg, class: "dropdown-select-icon" });
  };
  const lineHeight2 = useToolbarItem({
    type: "dropdown",
    name: "lineHeight",
    tooltip: toolbarTexts2.lineHeight,
    icon: toolbarIcons2.lineHeight,
    hasCaret: false,
    hasInlineTextInput: false,
    inlineTextInputVisible: false,
    suppressActiveHighlight: true,
    isWide: false,
    command: "setLineHeight",
    dropdownValueKey: "key",
    selectedValue: "1",
    attributes: {
      ariaLabel: "Line height"
    },
    options: [
      {
        label: "1,0",
        key: "1",
        icon: () => renderIcon("1", lineHeight2.selectedValue),
        props: { "data-item": "btn-lineHeight-option" }
      },
      {
        label: "1,15",
        key: "1.15",
        icon: () => renderIcon("1.15", lineHeight2.selectedValue),
        props: { "data-item": "btn-lineHeight-option" }
      },
      {
        label: "1,5",
        key: "1.5",
        icon: () => renderIcon("1.5", lineHeight2.selectedValue),
        props: { "data-item": "btn-lineHeight-option" }
      },
      {
        label: "2,0",
        key: "2",
        icon: () => renderIcon("2", lineHeight2.selectedValue),
        props: { "data-item": "btn-lineHeight-option" }
      },
      {
        label: "2,5",
        key: "2.5",
        icon: () => renderIcon("2.5", lineHeight2.selectedValue),
        props: { "data-item": "btn-lineHeight-option" }
      },
      {
        label: "3,0",
        key: "3",
        icon: () => renderIcon("3", lineHeight2.selectedValue),
        props: { "data-item": "btn-lineHeight-option" }
      }
    ]
  });
  const breakpoints = {
    sm: 768,
    md: 1024,
    xl: 1410
  };
  const stickyItemsWidth = 120;
  const toolbarPadding = 32;
  const itemsToHideXL = ["linkedStyles", "clearFormatting", "copyFormat", "ruler"];
  const itemsToHideSM = ["zoom", "fontFamily", "fontSize", "redo"];
  let toolbarItems = [
    undo2,
    redo2,
    // Dev - tracked changes
    // toggleTrackChanges,
    acceptTrackedChangeBySelection,
    rejectTrackedChangeOnSelection,
    // toggleTrackChangesOriginal,
    // toggleTrackChangesFinal,
    zoom,
    fontButton,
    separator,
    fontSize2,
    separator,
    bold,
    italic,
    underline,
    strikethrough,
    colorButton,
    highlight,
    separator,
    link,
    image,
    tableItem,
    tableActionsItem,
    separator,
    alignment2,
    bulletedList,
    numberedList,
    indentLeft,
    indentRight,
    lineHeight2,
    separator,
    linkedStyles,
    separator,
    ruler,
    pageBreakTool,
    copyFormat,
    clearFormatting,
    aiButton,
    overflow,
    documentMode
  ];
  if (!superToolbar.config?.superdoc?.config?.modules?.ai) {
    toolbarItems = toolbarItems.filter((item) => item.name.value !== "ai");
  }
  if (availableWidth <= breakpoints.md && hideButtons) {
    toolbarItems = toolbarItems.filter((item) => item.type !== "separator");
  }
  if (!superToolbar.config.pagination) {
    toolbarItems = toolbarItems.filter((item) => item.name.value !== "pageBreakTool");
  }
  if (superToolbar.config.mode !== "docx") {
    const getLinkedStylesIndex = toolbarItems.findIndex((item) => item.name.value === "linkedStyles");
    toolbarItems.splice(getLinkedStylesIndex - 1, 2);
    const filterItems = ["ruler", "zoom", "undo", "redo"];
    toolbarItems = toolbarItems.filter((item) => !filterItems.includes(item.name.value));
  }
  const devItems = [toggleTrackChanges, toggleTrackChangesOriginal, toggleTrackChangesFinal];
  if (!isDev) {
    if (role === "viewer") {
      devItems.push(...[acceptTrackedChangeBySelection, rejectTrackedChangeOnSelection]);
    }
    toolbarItems = toolbarItems.filter((item) => !devItems.includes(item));
  }
  const toolbarItemsSticky = [search2, undo2, overflow, documentMode].map((item) => item.name);
  const isStickyItem = (item) => toolbarItemsSticky.includes(item.name);
  const overflowItems = [];
  const visibleItems = [];
  let totalWidth = toolbarPadding + stickyItemsWidth;
  toolbarItems.forEach((item) => {
    const itemWidth = controlSizes.get(item.name.value) || controlSizes.get("default");
    if (availableWidth < breakpoints.xl && itemsToHideXL.includes(item.name.value) && hideButtons) {
      overflowItems.push(item);
      if (item.name.value === "linkedStyles") {
        const linkedStylesIdx = toolbarItems.findIndex((item2) => item2.name.value === "linkedStyles");
        toolbarItems.splice(linkedStylesIdx + 1, 1);
      }
      return;
    }
    if (availableWidth < breakpoints.sm && itemsToHideSM.includes(item.name.value) && hideButtons) {
      overflowItems.push(item);
      return;
    }
    if (isStickyItem(item)) {
      visibleItems.push(item);
      totalWidth += itemWidth;
      return;
    }
    if (totalWidth < availableWidth || !hideButtons) {
      visibleItems.push(item);
      totalWidth += itemWidth;
    } else {
      overflowItems.push(item);
    }
  });
  return {
    defaultItems: visibleItems,
    overflowItems: overflowItems.filter((item) => item.type !== "separator")
  };
};
const toolbarTexts = {
  bold: "Bold",
  fontFamily: "Font",
  ai: "AI text generation",
  fontSize: "Font size",
  italic: "Italic",
  underline: "Underline",
  highlight: "Highlight color",
  strikethrough: "Strikethrough",
  color: "Text color",
  search: "Search",
  link: "Link",
  image: "Image",
  table: "Insert table",
  addRowBefore: "Insert row above",
  addRowAfter: "Insert row below",
  addColumnBefore: "Insert column left",
  addColumnAfter: "Insert column right",
  deleteRow: "Delete row",
  deleteColumn: "Delete column",
  deleteTable: "Delete table",
  transparentBorders: "Transparent borders",
  mergeCells: "Merge cells",
  splitCell: "Split cell",
  fixTables: "Fix tables",
  textAlign: "Alignment",
  bulletList: "Bullet list",
  numberedList: "Numbered list",
  indentLeft: "Left indent",
  indentRight: "Right indent",
  zoom: "Zoom",
  undo: "Undo",
  redo: "Redo",
  trackChanges: "Track Changes",
  trackChangesAccept: "Accept changes under selection",
  trackChangesReject: "Reject changes under selection",
  trackChangesOriginal: "Toggle Show Original",
  trackChangesFinal: "Toggle Show Final",
  clearFormatting: "Clear formatting",
  copyFormat: "Format painter",
  lineHeight: "Line height",
  formatText: "Format text",
  ruler: "Show or hide ruler",
  pageBreak: "Insert page break",
  documentEditingMode: "Editing",
  documentSuggestingMode: "Suggesting",
  documentViewingMode: "Viewing",
  documentEditingModeDescription: "Edit document directly",
  documentSuggestingModeDescription: "Edits become suggestions",
  documentViewingModeDescription: "View clean version of document only"
};
class SuperToolbar extends EventEmitter2 {
  /**
   * Creates a new SuperToolbar instance
   * @param {ToolbarConfig} config - The configuration for the toolbar
   * @returns {void}
   */
  constructor(config) {
    super();
    __privateAdd(this, _SuperToolbar_instances);
    __publicField(this, "config", {
      selector: null,
      toolbarGroups: ["left", "center", "right"],
      role: "editor",
      pagination: false,
      icons: { ...toolbarIcons },
      texts: { ...toolbarTexts },
      fonts: null,
      hideButtons: true,
      responsiveToContainer: false,
      mode: "docx",
      excludeItems: [],
      groups: null,
      editor: null,
      aiApiKey: null,
      aiEndpoint: null,
      customButtons: []
    });
    __privateAdd(this, _interceptedCommands, {
      /**
       * Handles zoom level changes
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {string|number} params.argument - The zoom level (percentage)
       * @returns {void}
       */
      setZoom: ({ item, argument }) => {
        if (!argument) return;
        item.onActivate({ zoom: argument });
        this.emit("superdoc-command", { item, argument });
        const layers = document.querySelector(this.superdoc.config.selector)?.querySelector(".layers");
        if (!layers) return;
        const isMobileDevice = typeof screen.orientation !== "undefined";
        const isSmallScreen = window.matchMedia("(max-width: 834px)").matches;
        if (isMobileDevice && isSmallScreen) {
          layers.style.transformOrigin = "0 0";
          layers.style.transform = `scale(${parseInt(argument) / 100})`;
        } else {
          layers.style.zoom = parseInt(argument) / 100;
        }
        this.superdoc.superdocStore.activeZoom = parseInt(argument);
      },
      /**
       * Sets the document mode
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {string} params.argument - The document mode to set
       * @returns {void}
       */
      setDocumentMode: ({ item, argument }) => {
        if (!argument) return;
        this.emit("superdoc-command", { item, argument });
      },
      /**
       * Sets the font size for text
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {string|number} params.argument - The font size to set
       * @returns {void}
       */
      setFontSize: ({ item, argument }) => {
        __privateMethod(this, _SuperToolbar_instances, runCommandWithArgumentOnly_fn).call(this, { item, argument }, () => {
          this.activeEditor?.commands.setFieldAnnotationsFontSize(argument, true);
        });
      },
      /**
       * Sets the font family for text
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {string} params.argument - The font family to set
       * @returns {void}
       */
      setFontFamily: ({ item, argument }) => {
        __privateMethod(this, _SuperToolbar_instances, runCommandWithArgumentOnly_fn).call(this, { item, argument }, () => {
          this.activeEditor?.commands.setFieldAnnotationsFontFamily(argument, true);
        });
      },
      /**
       * Sets the text color
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {string} params.argument - The color to set
       * @returns {void}
       */
      setColor: ({ item, argument }) => {
        __privateMethod(this, _SuperToolbar_instances, runCommandWithArgumentOnly_fn).call(this, { item, argument }, () => {
          this.activeEditor?.commands.setFieldAnnotationsTextColor(argument, true);
        });
      },
      /**
       * Sets the highlight color for text
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {string} params.argument - The highlight color to set
       * @returns {void}
       */
      setHighlight: ({ item, argument }) => {
        __privateMethod(this, _SuperToolbar_instances, runCommandWithArgumentOnly_fn).call(this, { item, argument, noArgumentCallback: true }, () => {
          let arg = argument !== "none" ? argument : null;
          this.activeEditor?.commands.setFieldAnnotationsTextHighlight(arg, true);
          this.activeEditor?.commands.setCellBackground(arg);
        });
      },
      /**
       * Toggles the ruler visibility
       * @returns {void}
       */
      toggleRuler: () => {
        this.superdoc.toggleRuler();
      },
      /**
       * Initiates the image upload process
       * @async
       * @returns {Promise<void>}
       */
      startImageUpload: async () => {
        let open = getFileOpener();
        let result = await open();
        if (!result?.file) {
          return;
        }
        startImageUpload({
          editor: this.activeEditor,
          view: this.activeEditor.view,
          file: result.file
        });
      },
      /**
       * Increases text indentation or list level
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {*} params.argument - Command arguments
       * @returns {void}
       */
      increaseTextIndent: ({ item, argument }) => {
        let command2 = item.command;
        let { state: state2 } = this.activeEditor;
        let listItem = findParentNode((node2) => node2.type.name === "listItem")(state2.selection);
        if (listItem) {
          return this.activeEditor.commands.increaseListIndent();
        }
        if (command2 in this.activeEditor.commands) {
          this.activeEditor.commands[command2](argument);
        }
      },
      /**
       * Decreases text indentation or list level
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {*} params.argument - Command arguments
       * @returns {boolean}
       */
      decreaseTextIndent: ({ item, argument }) => {
        let command2 = item.command;
        let { state: state2 } = this.activeEditor;
        let listItem = findParentNode((node2) => node2.type.name === "listItem")(state2.selection);
        if (listItem) {
          return this.activeEditor.commands.decreaseListIndent();
        }
        if (command2 in this.activeEditor.commands) {
          this.activeEditor.commands[command2](argument);
        }
      },
      /**
       * Toggles bold formatting for text
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {*} params.argument - Command arguments
       * @returns {void}
       */
      toggleBold: ({ item, argument }) => {
        let command2 = item.command;
        if (command2 in this.activeEditor.commands) {
          this.activeEditor.commands[command2](argument);
          this.activeEditor.commands.toggleFieldAnnotationsFormat("bold", true);
        }
        this.updateToolbarState();
      },
      /**
       * Toggles italic formatting for text
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {*} params.argument - Command arguments
       * @returns {void}
       */
      toggleItalic: ({ item, argument }) => {
        let command2 = item.command;
        if (command2 in this.activeEditor.commands) {
          this.activeEditor.commands[command2](argument);
          this.activeEditor.commands.toggleFieldAnnotationsFormat("italic", true);
        }
        this.updateToolbarState();
      },
      /**
       * Toggles underline formatting for text
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {*} params.argument - Command arguments
       * @returns {void}
       */
      toggleUnderline: ({ item, argument }) => {
        let command2 = item.command;
        if (command2 in this.activeEditor.commands) {
          this.activeEditor.commands[command2](argument);
          this.activeEditor.commands.toggleFieldAnnotationsFormat("underline", true);
        }
        this.updateToolbarState();
      },
      /**
       * Toggles link formatting and updates cursor position
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {*} params.argument - Command arguments
       * @returns {void}
       */
      toggleLink: ({ item, argument }) => {
        let command2 = item.command;
        if (command2 in this.activeEditor.commands) {
          this.activeEditor.commands[command2](argument);
          const { view } = this.activeEditor;
          let { selection } = view.state;
          if (this.activeEditor.options.isHeaderOrFooter) {
            selection = this.activeEditor.options.lastSelection;
          }
          const endPos = selection.$to.pos;
          const newSelection = new TextSelection(view.state.doc.resolve(endPos));
          const tr = view.state.tr.setSelection(newSelection);
          const state2 = view.state.apply(tr);
          view.updateState(state2);
          if (!this.activeEditor.options.isHeaderOrFooter) {
            setTimeout(() => {
              view.focus();
            }, 100);
          }
        }
        this.updateToolbarState();
      },
      /**
       * Inserts a table into the document
       * @param {Object} params - Command parameters
       * @param {CommandItem} params.item - The command item
       * @param {Object} params.argument - Table configuration
       * @returns {void}
       */
      insertTable: ({ item, argument }) => {
        __privateMethod(this, _SuperToolbar_instances, runCommandWithArgumentOnly_fn).call(this, { item, argument });
      },
      /**
       * Executes a table-related command
       * @param {Object} params - Command parameters
       * @param {Object} params.argument - The table command and its parameters
       * @param {string} params.argument.command - The specific table command to execute
       * @returns {void}
       */
      executeTableCommand: ({ argument }) => {
        if (!argument) return;
        let command2 = argument.command;
        if (command2 in this.activeEditor.commands) {
          this.activeEditor.commands[command2](argument);
        }
        this.updateToolbarState();
      }
    });
    __publicField(this, "onToolbarResize", () => {
      __privateMethod(this, _SuperToolbar_instances, makeToolbarItems_fn).call(this, {
        superToolbar: this,
        icons: this.config.icons,
        texts: this.config.texts,
        fonts: this.config.fonts,
        hideButtons: this.config.hideButtons,
        isDev: this.isDev
      });
      if (this.role === "viewer") {
        __privateMethod(this, _SuperToolbar_instances, deactivateAll_fn).call(this);
      }
    });
    this.config = { ...this.config, ...config };
    this.toolbarItems = [];
    this.overflowItems = [];
    this.documentMode = config.documentMode || "editing";
    this.isDev = config.isDev || false;
    this.superdoc = config.superdoc;
    this.role = config.role || "editor";
    this.toolbarContainer = null;
    if (this.config.editor) {
      this.config.mode = this.config.editor.options.mode;
    }
    this.config.icons = {
      ...toolbarIcons,
      ...config.icons
    };
    this.config.texts = {
      ...toolbarTexts,
      ...config.texts
    };
    this.config.hideButtons = config.hideButtons ?? true;
    this.config.responsiveToContainer = config.responsiveToContainer ?? false;
    if (!this.config.selector && this.config.element) {
      this.config.selector = this.config.element;
    }
    this.toolbarContainer = this.findElementBySelector(this.config.selector);
    __privateMethod(this, _SuperToolbar_instances, initToolbarGroups_fn).call(this);
    __privateMethod(this, _SuperToolbar_instances, makeToolbarItems_fn).call(this, {
      superToolbar: this,
      icons: this.config.icons,
      texts: this.config.texts,
      fonts: this.config.fonts,
      hideButtons: this.config.hideButtons,
      isDev: config.isDev
    });
    if (this.config.selector && !this.toolbarContainer) {
      return;
    }
    this.app = vue.createApp(Toolbar);
    this.app.directive("click-outside", vClickOutside);
    this.app.config.globalProperties.$toolbar = this;
    if (this.toolbarContainer) {
      this.toolbar = this.app.mount(this.toolbarContainer);
    }
    this.activeEditor = config.editor || null;
    this.updateToolbarState();
  }
  findElementBySelector(selector) {
    let el = null;
    if (selector) {
      if (selector.startsWith("#") || selector.startsWith(".")) {
        el = document.querySelector(selector);
      } else {
        el = document.getElementById(selector);
      }
      if (!el) {
        return null;
      }
    }
    return el;
  }
  /**
   * Log debug information to the console
   * @param {...*} args - Arguments to log
   * @returns {void}
   */
  log(...args) {
    console.debug("[🎨 super-toolbar]", ...args);
  }
  /**
   * Set the zoom level
   * @param {number} percent_int - The zoom percentage as an integer
   * @returns {void}
   */
  setZoom(percent_int) {
    const allItems = [...this.toolbarItems, ...this.overflowItems];
    const item = allItems.find((item2) => item2.name.value === "zoom");
    __privateGet(this, _interceptedCommands).setZoom({ item, argument: percent_int });
  }
  /**
   * The toolbar expects an active Super Editor instance.
   * @param {Object} editor - The editor instance to attach to the toolbar
   * @returns {void}
   */
  setActiveEditor(editor) {
    this.activeEditor = editor;
    this.activeEditor.on("transaction", this.onEditorTransaction.bind(this));
  }
  /**
   * Get toolbar items by group name
   * @param {string} groupName - The name of the group
   * @returns {ToolbarItem[]} An array of toolbar items in the specified group
   */
  getToolbarItemByGroup(groupName) {
    return this.toolbarItems.filter((item) => (item.group?.value || "center") === groupName);
  }
  /**
   * Get a toolbar item by name
   * @param {string} name - The name of the toolbar item
   * @returns {ToolbarItem|undefined} The toolbar item with the specified name or undefined if not found
   */
  getToolbarItemByName(name) {
    return this.toolbarItems.find((item) => item.name.value === name);
  }
  /**
   * Update the toolbar state based on the current editor state
   * Updates active/inactive state of all toolbar items
   * @returns {void}
   */
  updateToolbarState() {
    __privateMethod(this, _SuperToolbar_instances, updateToolbarHistory_fn).call(this);
    __privateMethod(this, _SuperToolbar_instances, initDefaultFonts_fn).call(this);
    __privateMethod(this, _SuperToolbar_instances, updateHighlightColors_fn).call(this);
    if (!this.activeEditor || this.documentMode === "viewing") {
      __privateMethod(this, _SuperToolbar_instances, deactivateAll_fn).call(this);
      return;
    }
    const marks = getActiveFormatting(this.activeEditor);
    const inTable = isInTable$1(this.activeEditor.state);
    this.toolbarItems.forEach((item) => {
      item.resetDisabled();
      if (item.name.value === "linkedStyles") {
        if (this.activeEditor && !getQuickFormatList(this.activeEditor).length) {
          return item.deactivate();
        } else {
          return item.activate();
        }
      }
      const activeMark = marks.find((mark) => mark.name === item.name.value);
      if (activeMark) {
        item.activate(activeMark.attrs);
      } else {
        item.deactivate();
      }
      const styleIdMark = marks.find((mark) => mark.name === "styleId");
      if (!activeMark && styleIdMark?.attrs.styleId) {
        const markToStyleMap = {
          fontSize: "font-size",
          fontFamily: "font-family",
          bold: "bold",
          textAlign: "textAlign"
        };
        const linkedStyles = this.activeEditor.converter?.linkedStyles.find(
          (style2) => style2.id === styleIdMark.attrs.styleId
        );
        if (linkedStyles && linkedStyles.definition && linkedStyles.definition.styles && markToStyleMap[item.name.value] in linkedStyles.definition.styles) {
          const linkedStylesItem = linkedStyles.definition.styles[markToStyleMap[item.name.value]];
          const value = {
            [item.name.value]: linkedStylesItem
          };
          item.activate(value);
        }
      }
      const spacingAttr = marks.find((mark) => mark.name === "spacing");
      if (item.name.value === "lineHeight" && (activeMark?.attrs?.lineHeight || spacingAttr)) {
        item.selectedValue.value = activeMark?.attrs?.lineHeight || spacingAttr.attrs?.spacing?.line || "";
      }
      if (item.name.value === "tableActions") {
        item.disabled.value = !inTable;
      }
      const listNumberingType = marks.find((mark) => mark.name === "listNumberingType")?.attrs?.listNumberingType;
      if (item.name.value === "list" && listNumberingType === "bullet") {
        item.activate();
      } else if (item.name.value === "numberedlist" && listNumberingType && listNumberingType !== "bullet") {
        item.activate();
      }
    });
  }
  /**
   * React to editor transactions. Might want to debounce this.
   * @param {Object} params - Transaction parameters
   * @param {Object} params.transaction - The transaction object
   * @returns {void}
   */
  onEditorTransaction({ transaction }) {
    if (!transaction.docChanged && !transaction.selectionSet) return;
    this.updateToolbarState();
  }
  /**
   * Main handler for toolbar commands
   * @param {CommandItem} params - Command parameters
   * @param {ToolbarItem} params.item - An instance of the useToolbarItem composable
   * @param {*} [params.argument] - The argument passed to the command
   * @returns {*} The result of the executed command, undefined if no result is returned
   */
  emitCommand({ item, argument, option }) {
    if (this.activeEditor && !this.activeEditor.options.isHeaderOrFooter) {
      this.activeEditor.focus();
    }
    const { command: command2 } = item;
    if (!command2) {
      return;
    }
    this.log("(emmitCommand) Command:", command2, "\n	item:", item, "\n	argument:", argument, "\n	option:", option);
    if (command2 in __privateGet(this, _interceptedCommands)) {
      return __privateGet(this, _interceptedCommands)[command2]({ item, argument });
    }
    if (this.activeEditor && this.activeEditor.commands && command2 in this.activeEditor.commands) {
      this.activeEditor.commands[command2](argument);
    } else if (typeof command2 === "function") {
      command2({ item, argument, option });
    } else {
      throw new Error(`[super-toolbar 🎨] Command not found: ${command2}`);
    }
    this.updateToolbarState();
  }
}
_SuperToolbar_instances = /* @__PURE__ */ new WeakSet();
initToolbarGroups_fn = function() {
  if (this.config.groups && !Array.isArray(this.config.groups) && Object.keys(this.config.groups).length) {
    this.config.toolbarGroups = Object.keys(this.config.groups);
  }
};
_interceptedCommands = /* @__PURE__ */ new WeakMap();
makeToolbarItems_fn = function({ superToolbar, icons: icons2, texts, fonts, hideButtons, isDev = false } = {}) {
  const documentWidth = document.documentElement.clientWidth;
  const containerWidth = this.toolbarContainer?.offsetWidth ?? 0;
  const availableWidth = this.config.responsiveToContainer ? containerWidth : documentWidth;
  const { defaultItems, overflowItems } = makeDefaultItems({
    superToolbar,
    toolbarIcons: icons2,
    toolbarTexts: texts,
    toolbarFonts: fonts,
    hideButtons,
    availableWidth,
    role: this.role,
    isDev
  });
  const customItems = this.config.customButtons || [];
  if (customItems.length) {
    defaultItems.push(...customItems.map((item) => useToolbarItem({ ...item })));
  }
  let allConfigItems = [
    ...defaultItems.map((item) => item.name.value),
    ...overflowItems.map((item) => item.name.value)
  ];
  if (this.config.groups) allConfigItems = Object.values(this.config.groups).flatMap((item) => item);
  const filteredItems = defaultItems.filter((item) => allConfigItems.includes(item.name.value)).filter((item) => !this.config.excludeItems.includes(item.name.value));
  this.toolbarItems = filteredItems;
  this.overflowItems = overflowItems.filter((item) => allConfigItems.includes(item.name.value));
};
initDefaultFonts_fn = function() {
  if (!this.activeEditor || !this.activeEditor.converter) return;
  const { typeface = "Arial", fontSizePt = 12 } = this.activeEditor.converter.getDocumentDefaultStyles() ?? {};
  const fontSizeItem = this.toolbarItems.find((item) => item.name.value === "fontSize");
  if (fontSizeItem) fontSizeItem.defaultLabel.value = fontSizePt;
  const fontFamilyItem = this.toolbarItems.find((item) => item.name.value === "fontFamily");
  if (fontFamilyItem) fontFamilyItem.defaultLabel.value = typeface;
};
updateHighlightColors_fn = function() {
  if (!this.activeEditor || !this.activeEditor.converter) return;
  if (!this.activeEditor.converter.docHiglightColors.size) return;
  const highlightItem = this.toolbarItems.find((item) => item.name.value === "highlight");
  if (!highlightItem) return;
  const pickerColorOptions = getAvailableColorOptions();
  const perChunk = 7;
  const result = Array.from(this.activeEditor.converter.docHiglightColors).reduce((resultArray, item, index2) => {
    const chunkIndex = Math.floor(index2 / perChunk);
    if (!resultArray[chunkIndex]) {
      resultArray[chunkIndex] = [];
    }
    if (!pickerColorOptions.includes(item)) resultArray[chunkIndex].push(makeColorOption(item));
    return resultArray;
  }, []);
  const option = {
    key: "color",
    type: "render",
    render: () => renderColorOptions(this, highlightItem, result, true)
  };
  highlightItem.nestedOptions.value = [option];
};
deactivateAll_fn = function() {
  this.activeEditor = null;
  this.toolbarItems.forEach((item) => {
    const { allowWithoutEditor } = item;
    if (allowWithoutEditor.value) return;
    item.setDisabled(true);
  });
};
updateToolbarHistory_fn = function() {
  if (!this.activeEditor) return;
  if (this.activeEditor.options.ydoc) {
    const undoManager = yUndoPluginKey.getState(this.activeEditor.state)?.undoManager;
    this.undoDepth = undoManager?.undoStack.length || 0;
    this.redoDepth = undoManager?.redoStack.length || 0;
  } else {
    this.undoDepth = undoDepth(this.activeEditor.state);
    this.redoDepth = redoDepth(this.activeEditor.state);
  }
};
runCommandWithArgumentOnly_fn = function({ item, argument, noArgumentCallback = false }, callback) {
  if (!argument || !this.activeEditor) return;
  let command2 = item.command;
  const noArgumentCommand = item.noArgumentCommand;
  if (argument === "none" && this.activeEditor && this.activeEditor.commands && noArgumentCommand in this.activeEditor.commands) {
    this.activeEditor.commands[noArgumentCommand]();
    if (typeof callback === "function" && noArgumentCallback) callback(argument);
    this.updateToolbarState();
    return;
  }
  if (this.activeEditor && this.activeEditor.commands && command2 in this.activeEditor.commands) {
    this.activeEditor.commands[command2](argument);
    if (typeof callback === "function") callback(argument);
    this.updateToolbarState();
  }
};
const ICONS = {
  addRowBefore: plusIconSvg,
  addRowAfter: plusIconSvg,
  addColumnBefore: plusIconSvg,
  addColumnAfter: plusIconSvg,
  deleteRow: trashIconSvg,
  deleteColumn: trashIconSvg,
  deleteTable: trashIconSvg,
  deleteBorders: borderNoneIconSvg,
  mergeCells: arrowsToDotIconSvg,
  splitCell: arrowsLeftRightIconSvg,
  fixTables: wrenchIconSvg,
  ai: magicWandIcon,
  link: linkIconSvg,
  table: tableIconSvg,
  cut: scissorsIconSvg,
  copy: copyIconSvg,
  paste: pasteIconSvg,
  addDocumentSection: plusIconSvg,
  removeDocumentSection: trashIconSvg
};
const TEXTS = {
  addRowBefore: "Insert row above",
  addRowAfter: "Insert row below",
  addColumnBefore: "Insert column left",
  addColumnAfter: "Insert column right",
  deleteRow: "Delete row",
  deleteColumn: "Delete column",
  deleteTable: "Delete table",
  transparentBorders: "Transparent borders",
  mergeCells: "Merge cells",
  splitCell: "Split cell",
  fixTables: "Fix tables",
  insertText: "Insert text",
  replaceText: "Replace text",
  insertLink: "Insert link",
  insertTable: "Insert table",
  editTable: "Edit table",
  cut: "Cut",
  copy: "Copy",
  paste: "Paste",
  removeDocumentSection: "Remove section",
  createDocumentSection: "Create section"
};
const tableActionsOptions = [
  {
    label: TEXTS.addRowBefore,
    command: "addRowBefore",
    icon: ICONS.addRowBefore,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Add row before"
    }
  },
  {
    label: TEXTS.addRowAfter,
    command: "addRowAfter",
    icon: ICONS.addRowAfter,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Add row after"
    }
  },
  {
    label: TEXTS.addColumnBefore,
    command: "addColumnBefore",
    icon: ICONS.addColumnBefore,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Add column before"
    }
  },
  {
    label: TEXTS.addColumnAfter,
    command: "addColumnAfter",
    icon: ICONS.addColumnAfter,
    bottomBorder: true,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Add column after"
    }
  },
  {
    label: TEXTS.deleteRow,
    command: "deleteRow",
    icon: ICONS.deleteRow,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Delete row"
    }
  },
  {
    label: TEXTS.deleteColumn,
    command: "deleteColumn",
    icon: ICONS.deleteColumn,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Delete column"
    }
  },
  {
    label: TEXTS.deleteTable,
    command: "deleteTable",
    icon: ICONS.deleteTable,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Delete table"
    }
  },
  {
    label: TEXTS.transparentBorders,
    command: "deleteCellAndTableBorders",
    icon: ICONS.deleteBorders,
    bottomBorder: true,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Delete cell and table borders"
    }
  },
  {
    label: TEXTS.mergeCells,
    command: "mergeCells",
    icon: ICONS.mergeCells,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Merge cells"
    }
  },
  {
    label: TEXTS.splitCell,
    command: "splitCell",
    icon: ICONS.splitCell,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Split cells"
    }
  },
  {
    label: TEXTS.fixTables,
    command: "fixTables",
    icon: ICONS.fixTables,
    props: {
      "data-item": "btn-tableActions-option",
      ariaLabel: "Fix tables"
    }
  }
];
const TRIGGERS = {
  slash: "slash",
  click: "click"
};
const getPropsByItemId = (itemId, props) => {
  const editor = props.editor;
  const baseProps = {
    editor: vue.markRaw(props.editor)
  };
  switch (itemId) {
    case "insert-text":
      const { state: state2 } = editor.view;
      const { from: from2, to, empty: empty2 } = state2.selection;
      const selectedText = !empty2 ? state2.doc.textBetween(from2, to) : "";
      return {
        ...baseProps,
        selectedText,
        handleClose: props.closePopover || (() => null),
        apiKey: editor.options?.aiApiKey,
        endpoint: editor.options?.aiEndpoint
      };
    case "insert-link":
      return baseProps;
    case "insert-table":
      return {
        ...baseProps,
        onSelect: ({ rows, cols }) => {
          editor.commands.insertTable({ rows, cols });
          props.closePopover();
        }
      };
    case "edit-table":
      return {
        ...baseProps,
        options: tableActionsOptions,
        onSelect: ({ command: command2 }) => {
          if (editor.commands[command2]) {
            editor.commands[command2]();
          }
          props.closePopover();
        }
      };
    case "copy":
    case "paste":
      return {
        ...baseProps
        // These actions don't need additional props
      };
    default:
      return baseProps;
  }
};
async function getEditorContext(editor, event) {
  const { view } = editor;
  const { state: state2 } = view;
  const { from: from2, to, empty: empty2 } = state2.selection;
  const selectedText = !empty2 ? state2.doc.textBetween(from2, to) : "";
  let pos = null;
  let node2 = null;
  if (event) {
    const coords = { left: event.clientX, top: event.clientY };
    pos = view.posAtCoords(coords)?.pos ?? null;
    node2 = pos !== null ? state2.doc.nodeAt(pos) : null;
  } else {
    pos = from2;
    node2 = state2.doc.nodeAt(pos);
  }
  const clipboardContent = await readFromClipboard(state2);
  return {
    editor,
    selectedText,
    pos,
    node: node2,
    event,
    clipboardContent
  };
}
const onMarginClickCursorChange = (event, editor) => {
  const y2 = event.clientY;
  const x = event.clientX;
  const { view } = editor;
  const editorRect = view.dom.getBoundingClientRect();
  let coords = {
    left: 0,
    top: y2
  };
  let isRightMargin = false;
  if (x > editorRect.right) {
    coords.left = editorRect.left + editorRect.width - 1;
    isRightMargin = true;
  } else if (x < editorRect.left) {
    coords.left = editorRect.left;
  }
  const pos = view.posAtCoords(coords)?.pos;
  if (pos) {
    let cursorPos = pos;
    if (isRightMargin) {
      const $pos = view.state.doc.resolve(pos);
      const charOffset = $pos.textOffset;
      const node2 = view.state.doc.nodeAt(pos);
      const text = node2?.text;
      const charAtPos = text?.charAt(charOffset);
      cursorPos = node2?.isText && charAtPos !== " " ? pos - 1 : pos;
    }
    const transaction = view.state.tr.setSelection(TextSelection$1.create(view.state.doc, cursorPos));
    view.dispatch(transaction);
    view.focus();
  }
};
const checkNodeSpecificClicks = (editor, event, popoverControls) => {
  if (!editor) return;
  if (selectionHasNodeOrMark(editor.view.state, "link", { requireEnds: true })) {
    popoverControls.component = LinkInput;
    popoverControls.position = {
      left: `${event.clientX - editor.element.getBoundingClientRect().left}px`,
      top: `${event.clientY - editor.element.getBoundingClientRect().top + 15}px`
    };
    popoverControls.props = {
      showInput: true
    };
    popoverControls.visible = true;
  }
};
function selectionHasNodeOrMark(state2, name, options = {}) {
  const { requireEnds = false } = options;
  const $from = state2.selection.$from;
  const $to = state2.selection.$to;
  if (requireEnds) {
    for (let d2 = $from.depth; d2 > 0; d2--) {
      if ($from.node(d2).type.name === name) {
        return true;
      }
    }
    for (let d2 = $to.depth; d2 > 0; d2--) {
      if ($to.node(d2).type.name === name) {
        return true;
      }
    }
  } else {
    for (let d2 = $from.depth; d2 > 0; d2--) {
      if ($from.node(d2).type.name === name) {
        return true;
      }
    }
  }
  const markType = state2.schema.marks[name];
  if (markType) {
    const { from: from2, to, empty: empty2 } = state2.selection;
    if (requireEnds) {
      const fromMarks = markType.isInSet($from.marks());
      const toMarks = markType.isInSet($to.marks());
      if (fromMarks || toMarks) {
        return true;
      }
      if (empty2 && markType.isInSet(state2.storedMarks || $from.marks())) {
        return true;
      }
    } else {
      if (empty2) {
        if (markType.isInSet(state2.storedMarks || $from.marks())) {
          return true;
        }
      } else {
        let hasMark = false;
        state2.doc.nodesBetween(from2, to, (node2) => {
          if (markType.isInSet(node2.marks)) {
            hasMark = true;
            return false;
          }
        });
        if (hasMark) return true;
      }
    }
  }
  return false;
}
function moveCursorToMouseEvent(event, editor) {
  const { view } = editor;
  const coords = { left: event.clientX, top: event.clientY };
  const pos = view.posAtCoords(coords)?.pos;
  if (typeof pos === "number") {
    const tr = view.state.tr.setSelection(TextSelection$1.create(view.state.doc, pos));
    view.dispatch(tr);
    view.focus();
  }
}
const isModuleEnabled = (editorOptions, moduleName) => {
  switch (moduleName) {
    case "ai":
      return !!editorOptions?.isAiEnabled;
    // Example for future use cases
    // case 'comments':
    // return !!editorOptions?.isCommentsEnabled;
    default:
      return true;
  }
};
function getItems(context) {
  const { editor, selectedText, trigger: trigger2, clipboardContent } = context;
  const isInTable2 = selectionHasNodeOrMark(editor.view.state, "table", { requireEnds: true });
  const isInSectionNode = selectionHasNodeOrMark(editor.view.state, "documentSection", { requireEnds: true });
  const sections = [
    {
      id: "ai-content",
      items: [
        {
          id: "insert-text",
          label: selectedText ? TEXTS.replaceText : TEXTS.insertText,
          icon: ICONS.ai,
          component: AIWriter,
          action: (editor2) => {
            if (editor2?.commands && typeof editor2.commands?.insertAiMark === "function") {
              editor2.commands.insertAiMark();
            }
          },
          allowedTriggers: [TRIGGERS.slash, TRIGGERS.click],
          requiresModule: "ai"
        }
      ]
    },
    {
      id: "document-sections",
      items: [
        {
          id: "insert-document-section",
          label: TEXTS.createDocumentSection,
          icon: ICONS.addDocumentSection,
          action: (editor2) => {
            editor2.commands.createDocumentSection();
          },
          allowedTriggers: [TRIGGERS.click]
        },
        {
          id: "remove-section",
          label: TEXTS.removeDocumentSection,
          icon: ICONS.removeDocumentSection,
          action: (editor2) => {
            editor2.commands.removeSectionAtSelection();
          },
          allowedTriggers: [TRIGGERS.click],
          requiresSectionParent: true
        }
      ]
    },
    {
      id: "general",
      items: [
        {
          id: "insert-link",
          label: TEXTS.insertLink,
          icon: ICONS.link,
          component: LinkInput,
          allowedTriggers: [TRIGGERS.click]
        },
        {
          id: "insert-table",
          label: TEXTS.insertTable,
          icon: ICONS.table,
          component: TableGrid,
          allowedTriggers: [TRIGGERS.slash, TRIGGERS.click]
        },
        {
          id: "edit-table",
          label: TEXTS.editTable,
          icon: ICONS.table,
          component: TableActions,
          allowedTriggers: [TRIGGERS.slash, TRIGGERS.click],
          requiresTableParent: true
        }
      ]
    },
    {
      id: "clipboard",
      items: [
        {
          id: "cut",
          label: TEXTS.cut,
          icon: ICONS.cut,
          action: (editor2) => {
            editor2.view.focus();
            document.execCommand("cut");
          },
          allowedTriggers: [TRIGGERS.click],
          requiresSelection: true
        },
        {
          id: "copy",
          label: TEXTS.copy,
          icon: ICONS.copy,
          action: (editor2) => {
            editor2.view.focus();
            document.execCommand("copy");
          },
          allowedTriggers: [TRIGGERS.click],
          requiresSelection: true
        },
        {
          id: "paste",
          label: TEXTS.paste,
          icon: ICONS.paste,
          action: async (editor2) => {
            try {
              const clipboardItems = await navigator.clipboard.read();
              let html = "";
              let text = "";
              for (const item of clipboardItems) {
                if (!html && item.types.includes("text/html")) {
                  html = await (await item.getType("text/html")).text();
                }
                if (!text && item.types.includes("text/plain")) {
                  text = await (await item.getType("text/plain")).text();
                }
              }
              const handled = handleClipboardPaste({ editor: editor2, view: editor2.view }, html, text);
              if (!handled) {
                const dataTransfer = new DataTransfer();
                if (html) dataTransfer.setData("text/html", html);
                if (text) dataTransfer.setData("text/plain", text);
                const event = new ClipboardEvent("paste", {
                  clipboardData: dataTransfer,
                  bubbles: true,
                  cancelable: true
                });
                editor2.view.dom.dispatchEvent(event);
              }
            } catch (error) {
              console.warn("Failed to paste:", error);
            }
          },
          allowedTriggers: [TRIGGERS.click, TRIGGERS.slash],
          requiresClipboard: true
        }
      ]
    }
  ];
  const filteredSections = sections.map((section) => {
    const filteredItems = section.items.filter((item) => {
      if (item.requiresModule && !isModuleEnabled(editor?.options, item.requiresModule)) return false;
      if (item.requiresSelection && !selectedText) return false;
      if (!item.allowedTriggers.includes(trigger2)) return false;
      if (item.requiresClipboard && !clipboardContent) return false;
      if (item.requiresTableParent && !isInTable2 || item.id === "insert-table" && isInTable2) return false;
      if (item.requiresSectionParent && !isInSectionNode) return false;
      return true;
    });
    return {
      ...section,
      items: filteredItems
    };
  }).filter((section) => section.items.length > 0);
  return filteredSections;
}
const _hoisted_1$3 = { class: "slash-menu-items" };
const _hoisted_2$1 = {
  key: 0,
  class: "slash-menu-divider",
  tabindex: "0"
};
const _hoisted_3$1 = ["onClick"];
const _hoisted_4 = ["innerHTML"];
const _sfc_main$4 = {
  __name: "SlashMenu",
  props: {
    editor: {
      type: Object,
      required: true
    },
    openPopover: {
      type: Function,
      required: true
    },
    closePopover: {
      type: Function,
      required: true
    }
  },
  setup(__props) {
    const props = __props;
    const searchInput = vue.ref(null);
    const searchQuery = vue.ref("");
    const isOpen = vue.ref(false);
    const menuPosition = vue.ref({ left: "0px", top: "0px" });
    const menuRef = vue.ref(null);
    const sections = vue.ref([]);
    const selectedId = vue.ref(null);
    const handleEditorUpdate = () => {
      if (!props.editor?.isEditable && isOpen.value) {
        closeMenu({ restoreCursor: false });
      }
    };
    const flattenedItems = vue.computed(() => {
      const items = [];
      sections.value.forEach((section) => {
        section.items.forEach((item) => {
          items.push(item);
        });
      });
      return items;
    });
    const filteredItems = vue.computed(() => {
      if (!searchQuery.value) {
        return flattenedItems.value;
      }
      return flattenedItems.value.filter((item) => item.label?.toLowerCase().includes(searchQuery.value.toLowerCase()));
    });
    const filteredSections = vue.computed(() => {
      if (!searchQuery.value) {
        return sections.value;
      }
      return [
        {
          id: "search-results",
          items: filteredItems.value
        }
      ];
    });
    vue.watch(isOpen, (open) => {
      if (open) {
        vue.nextTick(() => {
          if (searchInput.value) {
            searchInput.value.focus();
          }
        });
      }
    });
    vue.watch(flattenedItems, (newItems) => {
      if (newItems.length > 0) {
        selectedId.value = newItems[0].id;
      }
    });
    const handleGlobalKeyDown = (event) => {
      if (event.key === "Escape") {
        event.preventDefault();
        event.stopPropagation();
        closeMenu();
        props.editor?.view?.focus();
        return;
      }
      if (isOpen.value && (event.target === searchInput.value || menuRef.value && menuRef.value.contains(event.target))) {
        const currentItems = filteredItems.value;
        const currentIndex = currentItems.findIndex((item) => item.id === selectedId.value);
        switch (event.key) {
          case "ArrowDown": {
            event.preventDefault();
            if (currentIndex < currentItems.length - 1) {
              selectedId.value = currentItems[currentIndex + 1].id;
            }
            break;
          }
          case "ArrowUp": {
            event.preventDefault();
            if (currentIndex > 0) {
              selectedId.value = currentItems[currentIndex - 1].id;
            }
            break;
          }
          case "Enter": {
            event.preventDefault();
            const selectedItem = currentItems.find((item) => item.id === selectedId.value);
            if (selectedItem) {
              executeCommand(selectedItem);
            }
            break;
          }
        }
      }
    };
    const handleGlobalOutsideClick = (event) => {
      if (isOpen.value && menuRef.value && !menuRef.value.contains(event.target)) {
        moveCursorToMouseEvent(event, props.editor);
        closeMenu({ restoreCursor: false });
      }
    };
    const handleRightClick = async (event) => {
      const readOnly = !props.editor?.isEditable;
      const isHoldingCtrl = event.ctrlKey;
      if (readOnly || isHoldingCtrl) {
        return;
      }
      event.preventDefault();
      props.editor.view.dispatch(
        props.editor.view.state.tr.setMeta(SlashMenuPluginKey, {
          type: "open",
          pos: props.editor.view.state.selection.from,
          clientX: event.clientX,
          clientY: event.clientY
        })
      );
      searchQuery.value = "";
      const context = await getEditorContext(props.editor, event);
      sections.value = getItems({ ...context, trigger: "click" });
      selectedId.value = flattenedItems.value[0]?.id || null;
    };
    const executeCommand = async (item) => {
      if (props.editor) {
        item.action ? await item.action(props.editor) : null;
        if (item.component) {
          menuRef.value;
          const componentProps = getPropsByItemId(item.id, props);
          props.openPopover(vue.markRaw(item.component), componentProps, {
            left: menuPosition.value.left,
            top: menuPosition.value.top
          });
          closeMenu({ restoreCursor: false });
        } else {
          const shouldRestoreCursor = item.id !== "paste";
          closeMenu({ restoreCursor: shouldRestoreCursor });
        }
      }
    };
    const closeMenu = (options = { restoreCursor: true }) => {
      if (props.editor?.view) {
        const pluginState = SlashMenuPluginKey.getState(props.editor.view.state);
        const { anchorPos } = pluginState;
        props.editor.view.dispatch(
          props.editor.view.state.tr.setMeta(SlashMenuPluginKey, {
            type: "close"
          })
        );
        if (options.restoreCursor && anchorPos !== null) {
          const tr = props.editor.view.state.tr.setSelection(
            props.editor.view.state.selection.constructor.near(props.editor.view.state.doc.resolve(anchorPos))
          );
          props.editor.view.dispatch(tr);
          props.editor.view.focus();
        }
        isOpen.value = false;
        searchQuery.value = "";
        sections.value = [];
      }
    };
    vue.onMounted(() => {
      if (!props.editor) return;
      document.addEventListener("keydown", handleGlobalKeyDown);
      document.addEventListener("mousedown", handleGlobalOutsideClick);
      props.editor.on("update", handleEditorUpdate);
      props.editor.on("slashMenu:open", async (event) => {
        const readOnly = !props.editor?.isEditable;
        if (readOnly) return;
        isOpen.value = true;
        menuPosition.value = event.menuPosition;
        searchQuery.value = "";
        const context = await getEditorContext(props.editor);
        sections.value = getItems({ ...context, trigger: "slash" });
        selectedId.value = flattenedItems.value[0]?.id || null;
      });
      props.editor.view.dom.addEventListener("contextmenu", handleRightClick);
      props.editor.on("slashMenu:close", () => {
        isOpen.value = false;
        searchQuery.value = "";
      });
    });
    vue.onBeforeUnmount(() => {
      document.removeEventListener("keydown", handleGlobalKeyDown);
      document.removeEventListener("mousedown", handleGlobalOutsideClick);
      if (props.editor) {
        try {
          props.editor.off("slashMenu:open");
          props.editor.off("slashMenu:close");
          props.editor.off("update", handleEditorUpdate);
          props.editor.view.dom.removeEventListener("contextmenu", handleRightClick);
        } catch (error) {
        }
      }
    });
    return (_ctx, _cache) => {
      return isOpen.value ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        ref_key: "menuRef",
        ref: menuRef,
        class: "slash-menu",
        style: vue.normalizeStyle(menuPosition.value),
        onMousedown: _cache[2] || (_cache[2] = vue.withModifiers(() => {
        }, ["stop"]))
      }, [
        vue.withDirectives(vue.createBaseVNode("input", {
          ref_key: "searchInput",
          ref: searchInput,
          "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => searchQuery.value = $event),
          type: "text",
          class: "slash-menu-hidden-input",
          onKeydown: [
            handleGlobalKeyDown,
            _cache[1] || (_cache[1] = vue.withModifiers(() => {
            }, ["stop"]))
          ]
        }, null, 544), [
          [vue.vModelText, searchQuery.value]
        ]),
        vue.createBaseVNode("div", _hoisted_1$3, [
          (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(filteredSections.value, (section, sectionIndex) => {
            return vue.openBlock(), vue.createElementBlock(vue.Fragment, {
              key: section.id
            }, [
              sectionIndex > 0 && section.items.length > 0 ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$1)) : vue.createCommentVNode("", true),
              (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(section.items, (item) => {
                return vue.openBlock(), vue.createElementBlock("div", {
                  key: item.id,
                  class: vue.normalizeClass(["slash-menu-item", { "is-selected": item.id === selectedId.value }]),
                  onClick: ($event) => executeCommand(item)
                }, [
                  item.icon ? (vue.openBlock(), vue.createElementBlock("span", {
                    key: 0,
                    class: "slash-menu-item-icon",
                    innerHTML: item.icon
                  }, null, 8, _hoisted_4)) : vue.createCommentVNode("", true),
                  vue.createBaseVNode("span", null, vue.toDisplayString(item.label), 1)
                ], 10, _hoisted_3$1);
              }), 128))
            ], 64);
          }), 128))
        ])
      ], 36)) : vue.createCommentVNode("", true);
    };
  }
};
function adjustPaginationBreaks(editorElem, editor) {
  if (!editorElem.value || !editor?.value?.options?.scale) return;
  const zoom = editor.value.options.scale;
  const bounds = editorElem.value.getBoundingClientRect();
  const breakNodes = editorElem.value.querySelectorAll(".pagination-break-wrapper");
  let firstLeft;
  breakNodes.forEach((node2) => {
    const nodeBounds = node2.getBoundingClientRect();
    const left2 = (nodeBounds.left - bounds.left) / zoom * -1 + 1;
    if (!firstLeft) firstLeft = left2;
    if (left2 !== firstLeft) {
      const diff = left2 - firstLeft;
      node2.style.transform = `translateX(${diff}px)`;
    }
  });
}
const _hoisted_1$2 = { class: "numbering" };
const MIN_WIDTH = 200;
const alignment = "flex-end";
const _sfc_main$3 = {
  __name: "Ruler",
  props: {
    orientation: {
      type: String,
      default: "horizontal"
    },
    length: {
      type: Number,
      default: 0
    },
    editor: {
      type: Object,
      required: true
    }
  },
  emits: ["margin-change"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const ruler = vue.ref(null);
    const rulerDefinition = vue.ref([]);
    const rulerHandleOriginalColor = vue.ref("#CCCCCC");
    const rulerHandleActiveColor = vue.ref("#2563EB66");
    const pageSize = vue.ref(null);
    const pageMargins = vue.ref(null);
    const isDragging = vue.ref(false);
    const currentHandle = vue.ref(null);
    const leftHandle = vue.reactive({ side: "left", x: 0 });
    const rightHandle = vue.reactive({ side: "right", x: 0 });
    const showVerticalIndicator = vue.ref(false);
    const initialX = vue.ref(0);
    let offsetX = 0;
    const initRuler = () => {
      if (props.editor.options.mode !== "docx") return;
      const rulerItems = [];
      const { pageMargins: docMargins, pageSize: docSize } = props.editor.getPageStyles();
      pageSize.value = docSize;
      pageMargins.value = docMargins;
      rightHandle.x = docSize.width * 96 - docMargins.right * 96;
      leftHandle.x = docMargins.left * 96;
      for (let i2 = 0; i2 < docSize.width; i2++) {
        const marginNum = 0.0625 * 96 - 0.5;
        const margin = `${marginNum}px`;
        const diff = docSize.width - i2;
        rulerItems.push(...generateSection(1, "main", "20%", margin, i2));
        rulerItems.push(...generateSection(3, "eighth", "10%", margin));
        rulerItems.push(...generateSection(1, "half", "40%", margin));
        if (diff <= 0.5) break;
        rulerItems.push(...generateSection(3, "eighth", "10%", margin));
      }
      return rulerItems;
    };
    const generateSection = (qty, size2, height, margin, index2) => {
      return Array.from({ length: qty }, (_2, i2) => {
        const item = {
          className: `${size2}-unit ruler-section`,
          height,
          margin
        };
        if (index2 !== void 0) item.numbering = index2;
        return item;
      });
    };
    const getStyle = vue.computed(() => (unit) => {
      return {
        width: "1px",
        minWidth: "1px",
        maxWidth: "1px",
        height: unit.height,
        backgroundColor: unit.color || "#666",
        marginLeft: unit.numbering === 0 ? null : unit.margin,
        marginRight: unit.margin
      };
    });
    const getHandlePosition = vue.computed(() => (side) => {
      const handle = side === "left" ? leftHandle : rightHandle;
      return {
        left: `${handle.x}px`
      };
    });
    const getVerticalIndicatorStyle = vue.computed(() => {
      if (!ruler.value) return;
      const parentElement = ruler.value.parentElement;
      const editor = parentElement.querySelector(".super-editor");
      const editorBounds = editor.getBoundingClientRect();
      return {
        left: `${currentHandle.value.x}px`,
        minHeight: `${editorBounds.height}px`
      };
    });
    const handleMouseDown3 = (event) => {
      isDragging.value = true;
      setRulerHandleActive();
      const itemId = event.currentTarget.id;
      currentHandle.value = itemId === "left-margin-handle" ? leftHandle : rightHandle;
      initialX.value = currentHandle.value.x;
      offsetX = event.clientX - currentHandle.value.x;
      showVerticalIndicator.value = true;
    };
    const handleMouseMove2 = (event) => {
      if (!isDragging.value) return;
      const newLeft = event.clientX - offsetX;
      currentHandle.value.x = newLeft;
      if (currentHandle.value.side === "left") {
        if (newLeft <= 0) {
          currentHandle.value.x = 0;
        } else if (newLeft >= rightHandle.x - MIN_WIDTH) {
          currentHandle.value.x = rightHandle.x - MIN_WIDTH;
        }
      } else {
        if (newLeft >= pageSize.value.width * 96) {
          currentHandle.value.x = pageSize.value.width * 96;
        } else if (newLeft <= leftHandle.x + MIN_WIDTH) {
          currentHandle.value.x = leftHandle.x + MIN_WIDTH;
        }
      }
    };
    const handleMouseUp = () => {
      isDragging.value = false;
      showVerticalIndicator.value = false;
      setRulerHandleInactive();
      if (currentHandle.value && currentHandle.value.x !== initialX.value) {
        const marginValue = getNewMarginValue();
        emit("margin-change", {
          side: currentHandle.value.side,
          value: marginValue
        });
      }
    };
    const setRulerHandleActive = () => {
      rulerHandleOriginalColor.value = rulerHandleActiveColor.value;
    };
    const setRulerHandleInactive = () => {
      rulerHandleOriginalColor.value = "#CCC";
    };
    const getNewMarginValue = () => {
      if (currentHandle.value.side === "left") return currentHandle.value.x / 96;
      else return (pageSize.value.width * 96 - currentHandle.value.x) / 96;
    };
    const getStyleVars = vue.computed(() => {
      return {
        "--alignment": alignment,
        "--ruler-handle-color": rulerHandleOriginalColor.value,
        "--ruler-handle-active-color": rulerHandleActiveColor.value
      };
    });
    vue.onMounted(() => {
      rulerDefinition.value = initRuler();
      window.addEventListener("mousemove", handleMouseMove2);
      window.addEventListener("mouseup", handleMouseUp);
    });
    vue.onUnmounted(() => {
      window.removeEventListener("mousemove", handleMouseMove2);
      window.removeEventListener("mouseup", handleMouseUp);
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: "ruler",
        ref_key: "ruler",
        ref: ruler,
        style: vue.normalizeStyle(getStyleVars.value)
      }, [
        vue.createBaseVNode("div", {
          class: "margin-handle handle-left",
          id: "left-margin-handle",
          onMousedown: handleMouseDown3,
          style: vue.normalizeStyle(getHandlePosition.value("left"))
        }, null, 36),
        vue.createBaseVNode("div", {
          class: "margin-handle handle-right",
          id: "right-margin-handle",
          onMousedown: handleMouseDown3,
          style: vue.normalizeStyle(getHandlePosition.value("right"))
        }, null, 36),
        showVerticalIndicator.value ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: "vertical-indicator",
          style: vue.normalizeStyle(getVerticalIndicatorStyle.value)
        }, null, 4)) : vue.createCommentVNode("", true),
        (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(rulerDefinition.value, (unit) => {
          return vue.openBlock(), vue.createElementBlock("div", {
            class: vue.normalizeClass(unit.className),
            style: vue.normalizeStyle(getStyle.value(unit))
          }, [
            vue.createBaseVNode("div", _hoisted_1$2, vue.toDisplayString(unit.numbering), 1),
            (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(unit.elements, (half) => {
              return vue.openBlock(), vue.createElementBlock("div", {
                class: vue.normalizeClass(half.className),
                style: vue.normalizeStyle(getStyle.value(half))
              }, [
                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(half.elements, (quarter) => {
                  return vue.openBlock(), vue.createElementBlock("div", {
                    class: vue.normalizeClass(quarter.className),
                    style: vue.normalizeStyle(getStyle.value(quarter))
                  }, null, 6);
                }), 256))
              ], 6);
            }), 256))
          ], 6);
        }), 256))
      ], 4);
    };
  }
};
const Ruler = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["__scopeId", "data-v-79f9a944"]]);
const _sfc_main$2 = {
  __name: "GenericPopover",
  props: {
    editor: { type: Object, required: true },
    styles: { type: Object, default: () => ({}) },
    visible: { type: Boolean, default: false },
    position: { type: Object, default: () => ({ left: "0px", top: "0px" }) }
  },
  emits: ["close"],
  setup(__props, { emit: __emit }) {
    const props = __props;
    const emit = __emit;
    const popover = vue.ref(null);
    function handleClickOutside2(event) {
      if (popover.value && !popover.value.contains(event.target)) {
        emit("close");
      }
      moveCursorToMouseEvent(event, props.editor);
    }
    function handleEscape(event) {
      if (event.key === "Escape") {
        emit("close");
      }
    }
    vue.watch(
      () => props.visible,
      (val) => {
        if (val) {
          document.addEventListener("mousedown", handleClickOutside2);
          document.addEventListener("keydown", handleEscape);
        } else {
          document.removeEventListener("mousedown", handleClickOutside2);
          document.removeEventListener("keydown", handleEscape);
        }
      }
    );
    vue.onMounted(() => {
      if (props.visible) {
        document.addEventListener("mousedown", handleClickOutside2);
        document.addEventListener("keydown", handleEscape);
      }
    });
    vue.onBeforeUnmount(() => {
      document.removeEventListener("mousedown", handleClickOutside2);
      document.removeEventListener("keydown", handleEscape);
    });
    const derivedStyles = vue.computed(() => ({
      left: props.position.left,
      top: props.position.top,
      ...props.styles
    }));
    return (_ctx, _cache) => {
      return __props.visible ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: "generic-popover",
        style: vue.normalizeStyle(derivedStyles.value),
        ref_key: "popover",
        ref: popover,
        onMousedown: _cache[0] || (_cache[0] = vue.withModifiers(() => {
        }, ["stop"])),
        onClick: _cache[1] || (_cache[1] = vue.withModifiers(() => {
        }, ["stop"]))
      }, [
        vue.renderSlot(_ctx.$slots, "default", {}, void 0, true)
      ], 36)) : vue.createCommentVNode("", true);
    };
  }
};
const GenericPopover = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["__scopeId", "data-v-cbddcc0f"]]);
const BlankDOCX = "data:application/octet-stream;base64,UEsDBBQABgAIAAAAIQAykW9XZgEAAKUFAAATAAgCW0NvbnRlbnRfVHlwZXNdLnhtbCCiBAIooAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC0lMtqwzAQRfeF/oPRtthKuiilxMmij2UbaPoBijRORPVCo7z+vuM4MaUkMTTJxiDP3HvPCDGD0dqabAkRtXcl6xc9loGTXmk3K9nX5C1/ZBkm4ZQw3kHJNoBsNLy9GUw2ATAjtcOSzVMKT5yjnIMVWPgAjiqVj1YkOsYZD0J+ixnw+17vgUvvEriUp9qDDQcvUImFSdnrmn43JBEMsuy5aayzSiZCMFqKRHW+dOpPSr5LKEi57cG5DnhHDYwfTKgrxwN2ug+6mqgVZGMR07uw1MVXPiquvFxYUhanbQ5w+qrSElp97Rail4BId25N0Vas0G7Pf5TDLewUIikvD9Jad0Jg2hjAyxM0vt3xkBIJrgGwc+5EWMH082oUv8w7QSrKnYipgctjtNadEInWADTf/tkcW5tTkdQ5jj4grZX4j7H3e6NW5zRwgJj06VfXJpL12fNBvZIUqAPZfLtkhz8AAAD//wMAUEsDBBQABgAIAAAAIQAekRq37wAAAE4CAAALAAgCX3JlbHMvLnJlbHMgogQCKKAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArJLBasMwDEDvg/2D0b1R2sEYo04vY9DbGNkHCFtJTBPb2GrX/v082NgCXelhR8vS05PQenOcRnXglF3wGpZVDYq9Cdb5XsNb+7x4AJWFvKUxeNZw4gyb5vZm/cojSSnKg4tZFYrPGgaR+IiYzcAT5SpE9uWnC2kiKc/UYySzo55xVdf3mH4zoJkx1dZqSFt7B6o9Rb6GHbrOGX4KZj+xlzMtkI/C3rJdxFTqk7gyjWop9SwabDAvJZyRYqwKGvC80ep6o7+nxYmFLAmhCYkv+3xmXBJa/ueK5hk/Nu8hWbRf4W8bnF1B8wEAAP//AwBQSwMEFAAGAAgAAAAhAJYWuCvkAgAAiAsAABEAAAB3b3JkL2RvY3VtZW50LnhtbKSW227cIBBA3yv1H1Z+T/Btb1Y2kZptozxUWiXtB7DA2laMQYD30q/v4HvrNvI6LwYG5jDMMGPuHs48mx2Z0qnIN4536zozlhNB0zzeOD9/fLtZOTNtcE5xJnK2cS5MOw/3nz/dnSIqSMFZbmaAyHV0kmTjJMbICCFNEsaxvuUpUUKLg7klgiNxOKSEoZNQFPmu55Y9qQRhWsN+jzg/Yu3UOHIeR6MKn0DZAkNEEqwMO3cM72rIHK3RagjyJ4DghL43RAVXoxbIWjUAhZNAYNWANJ9G+sfhFtNI/pC0nEYKhqTVNNLgOvHhBReS5TB5EIpjA0MVI47VWyFvACyxSfdplpoLMN1Fg8Fp/jbBItBqCTygVxOWiAvKsoA2FLFxCpVHtf5Nq29Njyr9umk1WDZuW9hujdjZZNo0umqM7yr1bV1YSq8hxTLwo8h1ksq2OvCpNJhMGsjxPQccedasO0lvZKr9r7RtqzB0wDHm17HjWWX5+0TPHRFNi2g1xpjw556NJRxucLfxJNf0nOuNLD4NwB8AFoSN/Fk0jFXNQKTLbstJR6ZVw6miYjlp51hvZA3825gegBZXIfygscM2Vr3H0tTQ5DpcEyNkdbHBCdZt0lgiu+6A8xZ34T1/y/hjSfWkRCE7Wvox2nNXXk/2oXMFq07OfsHQHzPmNcESqi4n0XOcC4X3GVgEqTaDbJmVEbBfuHS2KbvsXMptrG2HFjNbtZx7eKftBb3YVsJEGEms8DNc89BbL8LF0nNKKfzljJW64Xy9Wq7nII3gTUhfQATXK9guv7SinbLCwHPDx6+tcMsOuMjMcPmutxhZMzQjZqfG8kvD49dfMAkVy/P90LUL4UJ78xX0S6SMv2NLNAIKqxdWS1QaJ6Yb7oUxgnfjjB16swnDlMG+S78cHoQwvWFcmHJYb0dEpkGqJSasWlOK4T38pGxIoizN2S41BKwMFuUsas5ddquIoO4Jff8bAAD//wMAUEsDBBQABgAIAAAAIQCzvosdBQEAALYDAAAcAAgBd29yZC9fcmVscy9kb2N1bWVudC54bWwucmVscyCiBAEooAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKyTzWrDMBCE74W+g9h7LTttQwmRcymBXFv3AWR7/UP1Y6RNWr99RUoShwbTg44zYme+hdV6860VO6DzvTUCsiQFhqaydW9aAR/F9uEFmCdpaqmsQQEjetjk93frN1SSwpDv+sGzkGK8gI5oWHHuqw619Ikd0ISXxjotKUjX8kFWn7JFvkjTJXfTDMivMtmuFuB29SOwYhzwP9m2afoKX22112joRgX3SBQ28yFTuhZJwMlJQhbw2wiLqAg0KpwCHPVcfRaz3ux1iS5sfCE4W3MQy5gQFGbxAnCUv2Y2x/Ack6GxhgpZqgnH2ZqDeIoJ8YXl+5+TnJgnEH712/IfAAAA//8DAFBLAwQUAAYACAAAACEAZ4D8tM4GAADNIAAAFQAAAHdvcmQvdGhlbWUvdGhlbWUxLnhtbOxZzYsbNxS/F/o/iLk7Ho+/l3iDP7NNdpMl66TkKNvyjNaa0SDJuzEhUJJTL4VCWnop9NZDKQ000NBL/5iFhDb9IyppbM/I1nTzsaGh7BrWI+n3nn567+npWXP12oOQgBPEOKZRyyldcR2AojGd4MhvOXeHg0LDAVzAaAIJjVDLWSDuXNv99JOrcEcEKERAykd8B7acQIh4p1jkY9kN+RUao0iOTSkLoZBN5hcnDJ5KvSEpeq5bK4YQRw6IYCjV3p5O8RiBoVLp7K6U94n8FwmuOsaEHSnVyJDQ2MmspL74gncJAyeQtBw5z4SeDtED4QACuZADLcfVf05x92pxLUREjmxGbqD/lnJLgcnM03LMH60F3b7XqJTW+jWAiG1cv6E+a30aAMdjudKESxZbqtbchrfEZkDJo0V3s14qm/iM/vK2/mat41UMvAYlj5XtNQ6a/V7VwGtQ8ljdwrddr9MsG3gNSh5rW/hKv133+gZegwKCo9k2ulZvNGpL9BoypWTPCm/Wam69t4SnqGImuhL5SOTFWgiPKRtIgHYuFDgCYhGjKRxLXDsWlIMe5jGBCwfEMKJcdrteqSQDr+J664+2ONxBMCOddI35VpfiA/iY4Vi0nBtSq5OBvHzx4uzx87PHv509eXL2+Bewj/1AWOT2YORn5V7/+PXf338B/vr1h9dPv7HjeRb/6ucvX/3+x7+pFwatb5+9ev7s5Xdf/fnTUwu8zeAoCx/iEHFwC52COzSUC7RMgEbs7SSGAcRZiXbkcxhBJWNB90VgoG8tIIEWXAeZdrzHZLqwAa/Pjw3CRwGbC2wB3gxCA3hAKelQZl3TTTVX1grzyLdPzuZZ3B0IT2xzdze83J/HMu6xTWU3QAbNQyJdDn0UIQHUGJ0hZBG7j7Fh1wM8ZpTTqQD3MehAbDXJEI+MaEqF9nAo/bKwEZT+NmxzcA90KLGp76ETEyn3BiQ2lYgYZrwO5wKGVsYwJFnkPhSBjeTRgo0Ng3MhPe0jQkF/gji3ydxmC4PuTSjzltXtB2QRmkgm8MyG3IeUZpE9OusGMIytnHEUZLGf8ZkMUQgOqbCSoOYOUW3pBxjluvseRoa7z9/bd2UasgeIGpkz25ZA1NyPCzKFyKa8zUIjxbYZtkZHZ+4bob2PEIGncIIQuPuZDU9jw+Yp6RuBzCp7yGabG9CMVdWOEJe1kipuLI7F3AjZI+TTHD4Hi43Es4BRCFme5lszM2T6IyY3oy1eyXhmpFLM1Ka1k7jNQ2N9uVoPA2iElWpze7wumOG/N9ljUub4HWTQW8vIxP7GthlCYkyQBswQYrBvS7dSxHB/KqK2kxabW+Wm5qZN3VDcKHpCHJ1TAf03lY9F4mJqHjvwfaqdvISyWePk4TYrmy5lE/zxFzY9OI8OkTxLLNDLuuayrvnf1zV5+/mymrmsZi6rGbvIB6hm0gJGXwOtLnu0ljD35meKCTkSC4L2uS59uNz7k4Hs1A0ttL5oigP5uJzOwPkM6mfAqPgci+AogLGcpqRn8PlStc9BTLksn3S3VbcaIPPwgE6W93iqztJ3m1IAirTfra77Zakmkt5aPb0IXavXLV9ftq4IKNm3IZGZzCRRtpCorzrPIaFXdiEsmhYWDaU+l4X+WnpFHk4AqmvxaiVhJMNNhvRE+SmRX3n3wj2dZ0xz2Z5leU3F9WI8bZDIhJtJIhOGgTw8Nrsv2NfN1KUGPWWKbRr1xofwtUoiG7mBRGYLnMo9V65KNWMYt5yp/NkkH8NY6uMqU0HiRy1nLJaGfpfMEjMuepAHCUwPJesPsUAMEBzKWM+6gUQpt5JXV2v8SMk13Y/Pcvor62Q0naKxyOlJm3IsUWIdfU+watC5JH0UTE7BiMzZHSgNVa2XlAEnmIu1NSeYZYI7teJGulpuReMNULpFIYkDuDxRssk8gevnNZ3MOjTTzVWZ7eViRr5y0nufuucLqYFM0sw5QNSpac8fH+6Qz7BK877BKkndm7muucp1eafE+x8IGWrpZAY1xdhCLe01qV1gQZCZbh2aeWfERZ8Gm1GrDohVXalbWy+36ehYRn5PVqtzIrimKn+1MNhdvZZMMoHuXWWXBwLMGW45D91qu9L1qt2C26j2C5VyxS00qu1yoV2tlkv9asntdbxH0igiCEvVZO6B/LFPFst397p/6/19uCq1r4xpWKS6Di5qYf3+vuTlv78HWFrmYc0bNMvNTq3QLLcHhUqv0yg0u7VOoVfr1nuDXrfaaA4eOeBEgyvtcrdS6zcKtVK3W6jUXEW/0SzUK57XrtTbjX6l/Whpa7ny1ffKvJrX7j8AAAD//wMAUEsDBBQABgAIAAAAIQDK52WKOwQAAL4MAAARAAAAd29yZC9zZXR0aW5ncy54bWy0V9tu2zgQfV9g/8HQ8zq6WnaEOoWvmxTxdlGl2GdKom0ipCiQVBy32H/fISVa7kYo7BZ9sag5M2eGw5mh/O79K6ODFywk4eXU8W88Z4DLnBek3E2dz0/r4cQZSIXKAlFe4qlzxNJ5f/f7b+8OicRKgZocAEUpE5ZPnb1SVeK6Mt9jhuQNr3AJ4JYLhhS8ip3LkHiuq2HOWYUUyQgl6ugGnhc7LQ2fOrUok5ZiyEguuORbpU0Svt2SHLcPayEu8duYLHleM1wq49EVmEIMvJR7UknLxn6UDcC9JXn53iZeGLV6B9+7YLsHLoqTxSXhaYNK8BxLCQfEqA2QlJ3j6A3RyfcN+G63aKjA3PfM6jzy0XUEwRuCOMev13FMWg4XLM95SHEdT3ziIV1i/fjHgjkjKOqrKILQxqEf2vyMSxaq2F9HZ8/I1bZIoT2Sp4rUjPi6DY5OdEfW5VvSSyqwgR5JJpBo+rstP5YnD7uSC5RRCAfKcACVNDDR6V84EP0wS/xq5DoPegHZuYOp84VzNjgkFRY5tB6MrMBzXA1AwfNtqpACokRWmFIzw3KKEfg9JDuBGEwfKzE2Bd6imqonlKWKV6D0gmB7Y0uZ75FAucIirVAObAteKsGp1Sv4X1wtYJIJaLTWwsy1bpU2MxIsSsRgw9/MvQ0vsI6sFuTyk9EGxrs/Onf5f0ccZrogBX7SiU7VkeI1BJ+SL3hWFh9qqQgwmun3ExF8LwBcas8foTSejhVeY6RqSNMvcmZOYk1JtSFCcPFQFlAbv8wZ2W6xAAcEam0D5UMEP5g832NUwFX6i/zWEv8DytCZ4ROU5fOcK8XZ/bHaQ65/7iRNvbvn5QsfBIW0i0+cq5MqjK1wOZ43kWr0EiT0vWix6kVib+3328yi0At7kYW/9KN+ZDSZL/qQ6DaK/VkfEo+CVdQ207fIbB5MwkkfMp/741EvsliEi3Ddi6y8Zf9+VotgPO6NbX0beLcmb+7pTFiiPzX+FnalG3vAGosFYpkgaLDRHyOu1sjE85yUFs8wTGl8jqR1ZsHhsAEkQ5SuocQsYMqDJQWR1RJvzZpukNh1vK2G6JXClP1w4tJTG4s/Ba+rBj0IVDUNa1X8KGotSakeCbNyWWeptSrhXjmD6rL4+CJMnrr0HBIFDWAG3yMyjWR0cTn8nLaNRkWqmwRvUFU1vZbt/KlDyW6vfN0eCt4K+GY1L9kuaLHAYEGDmReU652BdrvoZIGVnemFVhZ2ssjKok42srJRJ4utLNayPUxXAVfdM7S9XWr5llPKD7i47/A3oiYJBc4JnHh6ZFl3t900GCUS5lAF16DiwmJ/GMyPkoLnD/q+jhp5OJuNljNv3MAjc30qM6ogtZ/wdo4kLlrMmo4a069x7MW+v5gMo8nqdrgaR9Fw4s9vh+OxN/bDtR+EE+/ftg/sH4+7/wAAAP//AwBQSwMEFAAGAAgAAAAhANuFbMOhBAAAlx0AABIAAAB3b3JkL251bWJlcmluZy54bWzMmN1u2zYUx+8H7B0MAbtMJMr6slGnSNJkSNEVRZth17REW0T4IVCUHd/2ZfYIe6y+wkjJku3IjUU53nwT2vz48ZzDc8h//O79MyWDBRI55mxigUvHGiAW8wSz+cT68/H+IrIGuYQsgYQzNLFWKLfeX/36y7vlmBV0ioSaOFAMlo+XWTyxUimzsW3ncYoozC8pjgXP+UxexpzafDbDMbKXXCS26wCn/JQJHqM8V5xbyBYwt9a4+LkbLRFwqRZroGfHKRQSPW8YwBji2yM7aoPcHiDloQvaqKExKrC1VS2Q1wukrGqR/H6kPc4F/UhumxT2Iw3bpKgfqZVOtJ3gPENMDc64oFCqr2JuUyieiuxCgTMo8RQTLFeK6QQ1BmL21MMitaoh0GFiTAhtyhNEhklN4ROrEGy8Xn/RrNemj6v166ZZgUi3bdV2Ixs9S5LLeq3oErtq+QceFxQxWUbNFoioOHKWpzhrbgfal6YG0xqyeC0AC0rqecsMdCy1n11tH6pj2AC7mL8+O0oqy18nAqfDaWpEs6KLCbt71pZQlcGbjXuFZiu4oOPlUwPcFiCIUcfHomZEa4Ydb6pbc3DHsqo51aloDt4EFnS8A18aswVICiOEO6zt0I1evsXKE5mkZrj6jGy9FkqYwrwpGk1EZg76DW5Ft+KdzY8rqt8FL7INDR9He9hcr0utdAxY6+LcvjDy44z5lsJM3bo0Hj/MGRdwSpRFqtQGqloG5QnovyrpdFN+RM9lvz5r/SEpBvrWsq6UUIPTXAoYy88FHex8e1DZrgSfYo4FUipP6M5K013PJBI3AsEnPUVTWK53Gy+gegJAANzgxgktW4/Qgkj8CS0QeVxlqJ6TrqYCJ3/oMaLHqrmSZqSe4YO7W+/OiaoRstADWDWVUWOZEfXeOp4zchwHlDaUNjZGVOuUDL2nTee0IATJhvio3qB66Mf3f5r+j3HdS9BsPT37InSDmXZTd0+s0C0tSSGbl4J4GDh6rt1MFuvmnjOZ6+DmMVZ5+G1Fp5yUS69V3HY6MFPgBM2giswaVlLs0rCXkQCtSAzLHvWeqUdxgfSMoyPDTeMCPK9fYG55ITASg89ouRWdF71x3p5oFjW3FTX/7aP24/vfpnFzQdAvbn+p2fp/snwrart9ZgGqkmi3wE4QIOOCc6Po/6447ywrTsXhrCuuqq/zqzhv2PMKf+uKC8604nyn51X+dhUXnmXF+WHPu/o/qrjoTCsu8Hpe4cdXnL2jbvUer0pfXYDG0tePQgcMb64r//tK37u7wAPhrdcEtznWtvS973iMCYoxhevNXpzjb+DS9BwPaN+OchWMeiYl4UskPiGpzmK/R66xR4dUa0ctCW6Ocekrp5Dt92i4zyOB56mBoARRB5fa6u++p0uv5pxnfEKH5F9HxXa6pPONXTok3DrKqZMlXWCedC1N1Snp2gLoJEkXGp/QIQXUUbScLukic5cOaJeOiuJkSTcyT7qWrPhJ0rU1ACvffrb15usfzsZJUf6sVnYqV71wFLilezsqoTau3ovtYeoXosX0It8HoQeqkO1llqGrmVVbKZCrfwEAAP//AwBQSwMEFAAGAAgAAAAhAD+v4WbrDwAADaYAAA8AAAB3b3JkL3N0eWxlcy54bWzsXdty20YSfd+q/QcUn5IHWxdKlKyKkpJke+1a23FCefM8BIbiRCDABUDLytfv3EAO2RgQPWjTimvLVRYJog9m5vRpTDcu89MvX+Zp9JkXpcizy8HR88NBxLM4T0R2dzn4dPv62fkgKiuWJSzNM345eOTl4Jef//mPnx4uyuox5WUkAbLyYh5fDmZVtbg4OCjjGZ+z8nm+4Jn8cZoXc1bJr8XdwZwV98vFszifL1glJiIV1ePB8eHhaGBhii4o+XQqYv4yj5dznlXa/qDgqUTMs3ImFmWN9tAF7SEvkkWRx7wsZafnqcGbM5GtYI5OANBcxEVe5tPqueyMbZGGkuZHh/rTPF0DnOIAjgHAKOZfcBjnFuNAWro4IsHhjFY4InFwwhrjACRLFMTxsG6H+qPMHawyqZIZDq7m6EDZsorNWDlzETmug6cruMe5Gu95fPH2LssLNkklkvSgSDpBpIHV/3Is1R/9kX/R21UX1AfZsZ+lupI8fsmnbJlWpfpafCzsV/tN/3mdZ1UZPVywMhbicnBVCCaH+OGCs7K6KgW7lS2Xh58L2ZI3V1kp1I8z9cHZOS4vB7diLqX8gT9Ev+dzlkU/XOfJY3Qz/nFwoA50z4tM7vmZpZeDY7Op/Gu14aTecqPasrEtZdldvY1nzz6N3dY5myYikU1ixbPxlTY8OrlIxR2rloVslvqmEUwgKpIb2W3+pVrK9sudD+x4mL/OKC1W38xeW0MqA4YMH2MTxeSvfPouj+95Mq7kD5eDQ9UuufHT24+FyAsZqS4HL17YjWM+F29EkvDM2TGbiYT/MePZp5In6+2/vdbRxm6I82UmPw/PRprmtExefYn5QsUu+WvGFF8flIHmZinWB9fm/63BjuwAN9nPOFMBPDrahtDNR0EcK4vS6W0z5nKr73ov1IGG+zrQyb4OdLqvA432daCzfR3ofF8H0jBf80AiS2R81/vDwwDUXTgeNaJxPGJD43i0hMbxSAWN41ECGsfj6Ggcjx+jcTxuisCp8tjnhY6zDz3e3o67+xwRhrv7lBCGu/sMEIa7O+CH4e6O72G4u8N5GO7u6B2GuztY43HNVCt6K2WWVb1VNs3zKssrHqnpaW80lkksndXS4KmTHi9IOkkAYyKbPRH3RouZ/r7bQ7RIw8/nlUroonwaTcWdSk56N5xnn3maL3jEkkTiEQIWXKZPnhEJ8emCT3nBs5hTOjYdaCoyHmXL+YTANxfsjgyLZwnx8NWIJEFh5dBsWc2USASBU89ZXOT9m5YzsvjwTpT9x0qBRNfLNOVEWB9oXExj9c8NNEz/1EDD9M8MNEz/xMDhjGqILBrRSFk0ogGzaETjZvyTatwsGtG4WTSicbNo/cftVlSpDvHurOOoe+3uJs3VdYje7RiLu0zXT3sj2Zpp9JEV7K5gi1mkys7NsG6fscfRJedbinPaColqXq9dRFWdRbbsP6AbaFTiWuERyWuFRySwFV5/ib2X02Q1QXtDk8+Ml5OqUbQaqZNoxyxdmgltf7Wxqr+HrQXwWhQlmQyaYQk8+IOazio6KSLfupX9G7bG6i+r7ahE2jwLSdDKNI/vacLwm8cFL2Radt8b6XWepvkDT+gQx1WRG19zJX+sKekk+VfzxYyVQudKGxDdT/X1HQzRe7bo3aGPKRMZDW+vns2ZSCO6GcSb2/fvott8odJMNTA0gNd5VeVzMkxbCfzhDz75kaaBVzIJzh6JentFVB7SYDeC4CRjkPKECElOM0UmSM6hGu/f/HGSsyKhQftYcHPTUMWJEMdsvjCTDgJtybj4IOMPwWxI4/2HFULVhahEdUsC5pQNy+XkTx73D3Uf8oikMvTrstL1Rz3V1dZ0cP2nCRtw/acImk15elD+S9DZDbj+nd2Ao+rsTcrKUngvoQbjUXW3xqPub//kz+LlaV5MlyndANaAZCNYA5INYZ4u51lJ2WONR9hhjUfdX0KX0XgEJTmN969CJGRkaDAqJjQYFQ0ajIoDDUZKQP87dByw/rfpOGD979UxYERTAAeMys9IT/9EV3kcMCo/02BUfqbBqPxMg1H52fBlxKdTOQmmO8U4kFQ+50DSnWiyis8XecGKRyLIVym/YwQFUoP2scin6mmSPDM3cRNAqhp1SjjZNnBUJP/BJ2RNU1iU7SKoiLI0zXOi2tr6hKMtN+9d22WmH+fo3YSPKYv5LE8TXnj65LeV+fJ4wWJbpgeX+zqVPd+Ju1kVjWerar8LMzrcaVkn7Btmuw/YNOYj+zBLo9l7nojlvG4ofJhiNOxurD16w7h+QKbFeD2T2LA87WgJjznabbmeJW9YnnW0hMc872ipdbph2aaHl6y4b3SEszb/WeV4Huc7a/OilXHjYdscaWXZ5IJnbV60IZXoKo7V1QLITjfN+O27icdvj1GRHwUjJz9KZ135IdoE9jv/LNSZHRM09fFWd0+AuK8n0Z0i52/L3NTtNy44dX+o662cOGUljxpxht0vXG1EGf84dg43fojOcccP0TkA+SE6RSKvOSok+VE6xyY/ROcg5YdARyt4RsBFK2iPi1bQPiRaQZSQaNVjFuCH6Dwd8EOghQoh0ELtMVPwQ6CECsyDhApR0EKFEGihQgi0UOEEDCdUaI8TKrQPESpECREqREELFUKghQoh0EKFEGihQgi0UAPn9l7zIKFCFLRQIQRaqBACLVQ9X+whVGiPEyq0DxEqRAkRKkRBCxVCoIUKIdBChRBooUIItFAhBEqowDxIqBAFLVQIgRYqhEAL1TxqGC5UaI8TKrQPESpECREqREELFUKghQoh0EKFEGihQgi0UCEESqjAPEioEAUtVAiBFiqEQAtVXyzsIVRojxMqtA8RKkQJESpEQQsVQqCFCiHQQoUQaKFCCLRQIQRKqMA8SKgQBS1UCIEWKoRo8097idJ3m/0RvurpvWO/+6Ur26jf3Ue5Xahhd6i6VX6s7s8iXOf5fdT44OFQ5xvdQMQkFbkuUXsuq7u4+pYI1IXPX2/an/Bx0Xu+dMk+C6GvmQLwk66WoKZy0ubyriVI8k7aPN21BLPOk7bo61qC0+BJW9DVuqxvSpGnI2DcFmYc4yOPeVu0dszhELfFaMcQjnBbZHYM4QC3xWPH8DRSwXnb+rTjOI1W95cChDZ3dBDO/Ahtbgm5qsMxFEZX0vwIXdnzI3Sl0Y+A4tMLgyfWD4Vm2A8VRjWUGZbqcKH6EbBUQ4QgqgFMONUQKphqCBVGNQyMWKohApbq8ODsRwiiGsCEUw2hgqmGUGFUw1MZlmqIgKUaImCp7nlC9sKEUw2hgqmGUGFUw8kdlmqIgKUaImCphghBVAOYcKohVDDVECqMapAlo6mGCFiqIQKWaogQRDWACacaQgVTDaHaqNZVlA2qUQw75rhJmGOIOyE7hrjg7BgGZEuOdWC25CAEZkuQq5pzXLbkkuZH6MqeH6ErjX4EFJ9eGDyxfig0w36oMKpx2VIT1eFC9SNgqcZlS16qcdlSK9W4bKmValy25Kcaly01UY3LlpqoDg/OfoQgqnHZUivVuGyplWpctuSnGpctNVGNy5aaqMZlS01U9zwhe2HCqcZlS61U47IlP9W4bKmJaly21EQ1LltqohqXLXmpxmVLrVTjsqVWqnHZkp9qXLbURDUuW2qiGpctNVGNy5a8VOOypVaqcdlSK9W4bOm9NBEEr4Aaz1lRRXTvi3vDylnF+r+c8FNW8DJPP/Mkou3qO1QvDx42lr9S2Ho5P7l/JcdMvQHdeVwpMW+AtYB6x7fJapkqZaxaEtl1vuxm3WB7udYcURvuONQK3F4rPgLw68Wt9BEmTPbqVzUa4OCZejFiw3blEPX2+jA3M1aYX9euWu9jxbjuy8NFUYqk/vnw8Hg4fHl2bfZamKXZ7jlffJDH19vUF8kPL/W30jxAK80n6p1icgSGI/3sFZtWvLgcnFvV5uatTe8+p6sjWersMRpXgauXfGN/Oku+ba8Hp358Zbep3/WScI2WcVk5m69FIkzjYqXyVbten5yNtG/onXUEuBwwrf/1ZnVTigS6fm0Q1gvI1Reb3QXkzDZnabcQ5zn2Oo8NQTTOc9zBedayNPttiPIru9dRR/eqI8N35l5DS7brXmZbT/caet3L3u5B417D78S96iH3uNcuJ9qHqxzbmdvGUpZ6W09XOfG6ir2/h8ZVTp64q5y7nlKHfegpWj70niLM/zemdX39pqdHnHo9wt63ReMRp9+HR2iVPL3Y0dMHzBKwTT5gs1gaHxg9cR/w066lsNdAcPpC/dt2ArXS0toFboVawfdKc9TTA868HmCrEDQecPa39YB6kL+m8PfM+bmXczv7oOH8/ElxDpnVDr5XbR+fqX9deH5JMed74eXZjj4Nzy+eOM/1UH5NBdMzG8tBZbF9obqn/mUXRlq92Ucvi7TNuWf1JA9ftqi1iy9/uytVhW1ps67SthbuTCHX61CdPaqapIZq+eFtphzqwa5hb1qafGEGSv5+w9P0PTN75wv/rimfKlnIX48O9Xs0t36fmCUhvPaFvnbgBTjYbIz52u4nZpFIYR5q8dZJVYG8Ybj1E1Z9R7qjD8fLUg7NWO2w3b6NGuh2K+2P0VG0jjNbgatRB75wZT3cG6r8wef/5U40paYy6aP0mIhSW1/revb5/hnuU3FEMmyKgz6Gh0QM23omPcPfKnF32epT9EOyZepzPrZOiNiyJcWnw9a+C29IVkyNzMfKKRErtqz3/WiInAdTp/LxMCLiwZbW/hbqoK9MICkxhSMfJWdElNha1xOVxjcnwVRyfCScE5Fgz4J/C1185Xx/NyWm6OKj5AURJXbkn6gu9lVOMy+22B5rs7VpiLF1NI20JqyhKGMTNlSNbF3k3rowHqvlK75US5baN+mboXkCN12sm6y79azu9z0vVoO7nizXW07tCdWdPpttdKpbU9ToBn3l5viSn/2nmbbun7Nmka4W0d4maPUDhVRrsFa12goTSq3Zcm4+iBTeD7X6EWha3frSKt9vMgEBXnFkc4/95rwbZPncoq90N93L7w1PfM74lSlr1qxZBmCbGbOVQq0aqU2qx3YeE3hibb4BzWry4eLPuMZRSSzXrQBKbZlknhyqf104pM6H1wPXSE5fzTgM+znZKZi9jlyzA6vLJ+t1NbbHSj+VsP55l0fDoRjaQhrKPYW+1KUuVKl35HWY83V0l1Wn7YvjVm+z2+42eN0dzlEaPAJ1Qt3tHXu8z8qORXOg21wNZZd7dAl47uHa4t4wJKFYXCf6r7lAqvcrpSfZdbX/UvfIqQ/Sv1Q80erTwx5YH19dSv3KR1IysD3b9WCE+mbcytHY+Ui3Rl/ZNd/0Ln2D/zethwI/anXdvqeDDZHs8Ngnp/vWGLl+t6ZvANd79I2S9TU/VJScmKPa0SplUElv2IJm7MCUsr6ZcmtE60/lz/8DAAD//wMAUEsDBBQABgAIAAAAIQC+fnZiXgEAANADAAAUAAAAd29yZC93ZWJTZXR0aW5ncy54bWyc01FPwjAQAOB3E//D0nfoQCGGMEiMwfhiTNQfUNoba2x7S1sc+Ou9TsAZXpgv67Xbfbnr2vlyZ032CT5odAUbDXOWgZOotNsU7P1tNbhjWYjCKWHQQcH2ENhycX01b2YNrF8hRvoyZKS4MLOyYFWM9YzzICuwIgyxBkcvS/RWRJr6DbfCf2zrgURbi6jX2ui45+M8n7ID4y9RsCy1hAeUWwsutvncgyERXah0HY5ac4nWoFe1RwkhUD/W/HhWaHdiRrdnkNXSY8AyDqmZQ0UtRemjvI2s+QUm/YDxGTCVsOtn3B0MTpldR6t+zvTkaNVx/ldMB1DbXsT45lhHGlJ6xwoqqqofd/xHPOWKKCoRqq4I/RqcnLi9Tftt5exp49CLtSGJTlBGhyBr4fSkvUxDG8KuXU8tpIAaW9AVwzpqq79ghf7eYxPA87QsjMHm5fmRJvzPPVx8AwAA//8DAFBLAwQUAAYACAAAACEAunZwPLMCAADYCwAAEgAAAHdvcmQvZm9udFRhYmxlLnhtbOSVW2/aMBSA3yftP0R52h7aXAiXokJFb9Je+rAy7dk4DrHmS2Q7QP79jh3SpoR2ZKq6hxFBzLH94fPl2Fxe7TjzNkRpKsXMj85D3yMCy5SK9cz/sbw/m/ieNkikiElBZn5FtH81//zpcjvNpDDag/lCTzme+bkxxTQINM4JR/pcFkRAZyYVRwa+qnXAkfpVFmdY8gIZuqKMmiqIw3Dk7zHqFIrMMorJrcQlJ8K4+YEiDIhS6JwWuqFtT6FtpUoLJTHRGnLmrOZxRMUTJko6IE6xklpm5hyS2a/IoWB6FLoWZ8+AYT9A3AGMMNn1Y0z2jABmtjk07ccZPXFo2uL83WJagLTshYgHzTrszU5vsXRq0rwfrnlGgZ2LDMqRzttE0i/B4ROu4tY3x9NvayEVWjEgQQV5UASeA9tPcGlvrkl2Lm5TsA1IbL7fXN52KhCH+Y8VX0nm4gUSUpMIujaIzfxwCFcU2qIbhyO4D8OxH9iBOEdKE8uoB8Z1OEOcsqqJpgTDGg3dkLq3oAbnTecGKWrXX3dpuoaOUq9CgO1ffh2J4OB4GYk7YwYvI9hxJi8jUWsM/GZQW+jYWFJOtPdAtt53yZE4qsU+4VE4AB0JvGNoJce1uF861KIct4+RO1hzfHd//2zkBiLjyfC6Y+TiLSPua1RzTjdyI0tFibJOXrExBgMXzoq1kfSywWVK1DEdGd2R9HQXyeAjXPyEU9z+e+lXtkvnddREcvv+26VJv53IoZBTtkvUT8gClnX87IjDa9gkiSuL+upTFnpLte6/SRb/qjAWhZHHi8J6CD/QQ2yXGk/GnXroenizHmoPFz09HByf3pdrmVbezeNX5wYx8wDDmiQOz9o6zXeto9ZhK6RZqpIsq4J0faYkQyUzf3zE3i3VBUPV//io9w09/w0AAP//AwBQSwMEFAAGAAgAAAAhAArzp/hsAQAA7QIAABEACAFkb2NQcm9wcy9jb3JlLnhtbCCiBAEooAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJySXU+DMBSG7038D6T3UGBqDAGWTLMrZ0yc0XhX27Otjn6k7cb27y0wmMRdeXc+nvP29G3z6UFUwR6M5UoWKIliFICkinG5LtDbch7eo8A6IhmplIQCHcGiaXl9lVOdUWXgxSgNxnGwgVeSNqO6QBvndIaxpRsQxEaekL65UkYQ51OzxprQLVkDTuP4DgtwhBFHcCMY6kERnSQZHST1zlStAKMYKhAgncVJlOAz68AIe3Gg7fwiBXdHDRfRvjnQB8sHsK7rqJ60qN8/wR+Lp9f2qiGXjVcUUJkzmjnuKihzfA59ZHdf30BdVx4SH1MDxClTPnO6DWZgJKlapq83jm/hWCvDrJ8eZR5jYKnh2vl37LRHBU9XxLqFf9gVBzY7jo/5224mDOx58y/KtCWGND+Z3K0GLPDmZJ2Vfed98vC4nKMyjdObMEnD5G6Zpll8m8XxZ7PdaP4sKE4L/FuxF+gMGn/Q8gcAAP//AwBQSwMEFAAGAAgAAAAhACEYr1lrAQAAxQIAABAACAFkb2NQcm9wcy9hcHAueG1sIKIEASigAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAnFJNT8MwDL0j8R+q3rd0HCY0eUFoCHHgY9IKnKPEbSPSJEqyif17nBVKEZzIye/Zfnl2AlfvvSkOGKJ2dl0u5lVZoJVOaduuy+f6dnZZFjEJq4RxFtflEWN5xc/PYBucx5A0xoIkbFyXXUp+xViUHfYiziltKdO40ItEMLTMNY2WeOPkvkeb2EVVLRm+J7QK1cyPguWguDqk/4oqJ7O/+FIfPelxqLH3RiTkj7nTzJVLPbCRhdolYWrdI6+IHgFsRYuRL4ANAby6oGKuGQLYdCIImWh/mZwguPbeaCkS7ZU/aBlcdE0qnk5mi9wNbFoCNMAO5T7odMxSUwj32uLpgiEgV0G0QfjuRE4Q7KQwuKHReSNMRGDfBGxc74UlOTZGpPcWn33tbvIWPlt+kpMRX3Xqdl7IwcufPOyIRUXuRwMjAXf0GMFkdeq1Laqvmt+JvL6X4VfyxXJe0Tnt64ujqcfvwj8AAAD//wMAUEsBAi0AFAAGAAgAAAAhADKRb1dmAQAApQUAABMAAAAAAAAAAAAAAAAAAAAAAFtDb250ZW50X1R5cGVzXS54bWxQSwECLQAUAAYACAAAACEAHpEat+8AAABOAgAACwAAAAAAAAAAAAAAAACfAwAAX3JlbHMvLnJlbHNQSwECLQAUAAYACAAAACEAlha4K+QCAACICwAAEQAAAAAAAAAAAAAAAAC/BgAAd29yZC9kb2N1bWVudC54bWxQSwECLQAUAAYACAAAACEAs76LHQUBAAC2AwAAHAAAAAAAAAAAAAAAAADSCQAAd29yZC9fcmVscy9kb2N1bWVudC54bWwucmVsc1BLAQItABQABgAIAAAAIQBngPy0zgYAAM0gAAAVAAAAAAAAAAAAAAAAABkMAAB3b3JkL3RoZW1lL3RoZW1lMS54bWxQSwECLQAUAAYACAAAACEAyudlijsEAAC+DAAAEQAAAAAAAAAAAAAAAAAaEwAAd29yZC9zZXR0aW5ncy54bWxQSwECLQAUAAYACAAAACEA24Vsw6EEAACXHQAAEgAAAAAAAAAAAAAAAACEFwAAd29yZC9udW1iZXJpbmcueG1sUEsBAi0AFAAGAAgAAAAhAD+v4WbrDwAADaYAAA8AAAAAAAAAAAAAAAAAVRwAAHdvcmQvc3R5bGVzLnhtbFBLAQItABQABgAIAAAAIQC+fnZiXgEAANADAAAUAAAAAAAAAAAAAAAAAG0sAAB3b3JkL3dlYlNldHRpbmdzLnhtbFBLAQItABQABgAIAAAAIQC6dnA8swIAANgLAAASAAAAAAAAAAAAAAAAAP0tAAB3b3JkL2ZvbnRUYWJsZS54bWxQSwECLQAUAAYACAAAACEACvOn+GwBAADtAgAAEQAAAAAAAAAAAAAAAADgMAAAZG9jUHJvcHMvY29yZS54bWxQSwECLQAUAAYACAAAACEAIRivWWsBAADFAgAAEAAAAAAAAAAAAAAAAACDMwAAZG9jUHJvcHMvYXBwLnhtbFBLBQYAAAAADAAMAAEDAAAkNgAAAAA=";
const _hoisted_1$1 = { class: "super-editor-container" };
const _hoisted_2 = {
  key: 1,
  class: "placeholder-editor"
};
const _hoisted_3 = { class: "placeholder-title" };
const DOCX = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
const _sfc_main$1 = {
  __name: "SuperEditor",
  props: {
    documentId: {
      type: String,
      required: false
    },
    fileSource: {
      type: File,
      required: false
    },
    state: {
      type: Object,
      required: false,
      default: () => null
    },
    options: {
      type: Object,
      required: false,
      default: () => ({})
    }
  },
  emits: ["editor-ready", "editor-click", "editor-keydown", "comments-loaded", "selection-update"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const editorReady = vue.ref(false);
    const editor = vue.shallowRef(null);
    const editorWrapper = vue.ref(null);
    const editorElem = vue.ref(null);
    const fileSource = vue.ref(null);
    const popoverControls = vue.reactive({
      visible: false,
      position: { left: "0px", top: "0px" },
      component: null,
      props: {}
    });
    const closePopover = () => {
      popoverControls.visible = false;
      popoverControls.component = null;
      popoverControls.props = {};
      editor.value.view.focus();
    };
    const openPopover = (component, props2, position) => {
      popoverControls.component = component;
      popoverControls.props = props2;
      popoverControls.position = position;
      popoverControls.visible = true;
    };
    let dataPollTimeout;
    const stopPolling = () => {
      clearTimeout(dataPollTimeout);
    };
    const pollForMetaMapData = (ydoc, retries = 10, interval = 500) => {
      const metaMap = ydoc.getMap("meta");
      const checkData = () => {
        const docx = metaMap.get("docx");
        if (docx) {
          stopPolling();
          initEditor({ content: docx });
        } else if (retries > 0) {
          console.debug(`Waiting for 'docx' data... retries left: ${retries}`);
          dataPollTimeout = setTimeout(checkData, interval);
          retries--;
        } else {
          console.warn("Failed to load docx data from meta map.");
        }
      };
      checkData();
    };
    const loadNewFileData = async () => {
      fileSource.value = props.fileSource;
      if (!fileSource.value || fileSource.value.type !== DOCX) {
        fileSource.value = await getFileObject(BlankDOCX, "blank.docx", DOCX);
      }
      try {
        const [docx, media, mediaFiles, fonts] = await Editor.loadXmlData(fileSource.value);
        return { content: docx, media, mediaFiles, fonts };
      } catch (err) {
        console.debug("Error loading new file data:", err);
      }
    };
    const initializeData = async () => {
      if (props.fileSource) {
        const fileData = await loadNewFileData();
        return initEditor(fileData);
      } else if (props.options.ydoc && props.options.collaborationProvider) {
        delete props.options.content;
        const ydoc = props.options.ydoc;
        const provider = props.options.collaborationProvider;
        const handleSynced = () => {
          pollForMetaMapData(ydoc);
          provider.off("synced", handleSynced);
        };
        provider.on("synced", handleSynced);
      }
    };
    const getExtensions = () => {
      const extensions = getStarterExtensions();
      if (!props.options.pagination) {
        return extensions.filter((ext) => ext.name !== "pagination");
      }
      return extensions;
    };
    const initEditor = async ({ content, media = {}, mediaFiles = {}, fonts = {} } = {}) => {
      editor.value = new Editor({
        mode: "docx",
        element: editorElem.value,
        fileSource: fileSource.value,
        extensions: getExtensions(),
        externalExtensions: props.options.externalExtensions,
        documentId: props.documentId,
        content,
        media,
        mediaFiles,
        fonts,
        ...props.options
      });
      editor.value.on("paginationUpdate", () => {
        adjustPaginationBreaks(editorElem, editor);
      });
      editor.value.on("collaborationReady", () => {
        setTimeout(() => {
          editorReady.value = true;
        }, 150);
      });
    };
    const handleSuperEditorKeydown = (event) => {
      if ((event.metaKey || event.ctrlKey) && event.altKey && event.shiftKey) {
        if (event.code === "KeyM") {
          const toolbar = document.querySelector(".superdoc-toolbar");
          if (toolbar) {
            toolbar.setAttribute("tabindex", "0");
            toolbar.focus();
          }
        }
      }
      if ((event.metaKey || event.ctrlKey) && !event.shiftKey && !event.altKey && (event.key === "k" || event.key === "K")) {
        event.preventDefault();
        if (!editor.value) return;
        const view = editor.value.view;
        const { state: state2 } = view;
        const container = editorWrapper.value;
        if (!container) return;
        const containerRect = container.getBoundingClientRect();
        const cursorCoords = view.coordsAtPos(state2.selection.head);
        const left2 = `${cursorCoords.left - containerRect.left}px`;
        const top2 = `${cursorCoords.bottom - containerRect.top + 6}px`;
        openPopover(vue.markRaw(LinkInput), {}, { left: left2, top: top2 });
      }
      emit("editor-keydown", { editor: editor.value });
    };
    const handleSuperEditorClick = (event) => {
      emit("editor-click", { editor: editor.value });
      let pmElement = editorElem.value?.querySelector(".ProseMirror");
      if (!pmElement || !editor.value) {
        return;
      }
      let isInsideEditor = pmElement.contains(event.target);
      if (!isInsideEditor && editor.value.isEditable) {
        editor.value.view?.focus();
      }
      if (isInsideEditor && editor.value.isEditable) {
        checkNodeSpecificClicks(editor.value, event, popoverControls);
      }
    };
    vue.onMounted(() => {
      initializeData();
      if (props.options?.suppressSkeletonLoader || !props.options?.collaborationProvider) editorReady.value = true;
    });
    const handleMarginClick = (event) => {
      if (event.target.classList.contains("ProseMirror")) return;
      onMarginClickCursorChange(event, editor.value);
    };
    const handleMarginChange = ({ side, value }) => {
      if (!editor.value) return;
      const pageStyles = editor.value.getPageStyles();
      const { pageMargins } = pageStyles;
      const update = { ...pageMargins, [side]: value };
      editor.value?.updatePageStyle({ pageMargins: update });
    };
    vue.onBeforeUnmount(() => {
      stopPolling();
      editor.value?.destroy();
      editor.value = null;
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1, [
        __props.options.rulers && !!editor.value ? (vue.openBlock(), vue.createBlock(Ruler, {
          key: 0,
          class: "ruler",
          editor: editor.value,
          onMarginChange: handleMarginChange
        }, null, 8, ["editor"])) : vue.createCommentVNode("", true),
        vue.createBaseVNode("div", {
          class: "super-editor",
          ref_key: "editorWrapper",
          ref: editorWrapper,
          onKeydown: handleSuperEditorKeydown,
          onClick: handleSuperEditorClick,
          onMousedown: handleMarginClick
        }, [
          vue.createBaseVNode("div", {
            ref_key: "editorElem",
            ref: editorElem,
            class: "editor-element super-editor__element",
            role: "presentation"
          }, null, 512),
          !props.options.disableContextMenu && editorReady.value && editor.value ? (vue.openBlock(), vue.createBlock(_sfc_main$4, {
            key: 0,
            editor: editor.value,
            popoverControls,
            openPopover,
            closePopover
          }, null, 8, ["editor", "popoverControls"])) : vue.createCommentVNode("", true)
        ], 544),
        !editorReady.value ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_2, [
          vue.createBaseVNode("div", _hoisted_3, [
            vue.createVNode(vue.unref(NSkeleton), {
              text: "",
              style: { "width": "60%" }
            })
          ]),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            repeat: 6
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            style: { "width": "60%" }
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            repeat: 6,
            style: { "width": "30%", "display": "block", "margin": "20px" }
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            style: { "width": "60%" }
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            repeat: 5
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            style: { "width": "30%" }
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            style: { "margin-top": "50px" }
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            repeat: 6
          }),
          vue.createVNode(vue.unref(NSkeleton), {
            text: "",
            style: { "width": "70%" }
          })
        ])) : vue.createCommentVNode("", true),
        editor.value ? (vue.openBlock(), vue.createBlock(GenericPopover, {
          key: 2,
          editor: editor.value,
          visible: popoverControls.visible,
          position: popoverControls.position,
          onClose: closePopover
        }, {
          default: vue.withCtx(() => [
            (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(popoverControls.component), vue.normalizeProps(vue.guardReactiveProps({ ...popoverControls.props, editor: editor.value, closePopover })), null, 16))
          ]),
          _: 1
        }, 8, ["editor", "visible", "position"])) : vue.createCommentVNode("", true)
      ]);
    };
  }
};
const SuperEditor = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["__scopeId", "data-v-d3499c76"]]);
const _hoisted_1 = ["innerHTML"];
const _sfc_main = {
  __name: "SuperInput",
  props: {
    modelValue: {
      type: String
    },
    placeholder: {
      type: String,
      required: false,
      default: "Type something..."
    },
    options: {
      type: Object,
      required: false,
      default: () => ({})
    },
    users: {
      type: Array,
      required: false,
      default: () => []
    }
  },
  emits: ["update:modelValue", "focus", "blur"],
  setup(__props, { emit: __emit }) {
    const emit = __emit;
    const props = __props;
    const editor = vue.shallowRef();
    const editorElem = vue.ref(null);
    const isFocused = vue.ref(false);
    const onTransaction = ({ editor: editor2, transaction }) => {
      const contents = editor2.getHTML();
      emit("update:modelValue", contents);
    };
    const onFocus = ({ editor: editor2, transaction }) => {
      isFocused.value = true;
      updateUsersState();
      emit("focus", { editor: editor2, transaction });
    };
    const onBlur = ({ editor: editor2, transaction }) => {
      isFocused.value = false;
      emit("blur", { editor: editor2, transaction });
    };
    const initEditor = async () => {
      Placeholder.options.placeholder = props.placeholder || "Type something...";
      props.options.onTransaction = onTransaction;
      props.options.onFocus = onFocus;
      props.options.onBlur = onBlur;
      editor.value = new Editor({
        mode: "text",
        content: document.getElementById("currentContent"),
        element: editorElem.value,
        extensions: getRichTextExtensions(),
        users: props.users,
        ...props.options
      });
    };
    const handleFocus = () => {
      isFocused.value = true;
      editor.value?.view?.focus();
    };
    const updateUsersState = () => {
      editor.value?.setOptions({ users: props.users });
    };
    vue.onMounted(() => {
      initEditor();
    });
    vue.onBeforeUnmount(() => {
      editor.value?.destroy();
      editor.value = null;
    });
    return (_ctx, _cache) => {
      return vue.openBlock(), vue.createElementBlock("div", {
        class: vue.normalizeClass(["super-editor super-input", { "super-input-active": isFocused.value }]),
        onClick: vue.withModifiers(handleFocus, ["stop", "prevent"])
      }, [
        vue.createBaseVNode("div", {
          id: "currentContent",
          style: { "display": "none" },
          innerHTML: __props.modelValue
        }, null, 8, _hoisted_1),
        vue.createBaseVNode("div", {
          ref_key: "editorElem",
          ref: editorElem,
          class: "editor-element super-editor__element"
        }, null, 512)
      ], 2);
    };
  }
};
const SuperInput = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-4d5cff52"]]);
const Extensions = {
  Node: Node$1,
  Attribute: Attribute2,
  Extension,
  Plugin,
  Mark: Mark2
};
exports.AIWriter = AIWriter;
exports.AnnotatorHelpers = AnnotatorHelpers;
exports.CommentsPluginKey = CommentsPluginKey;
exports.DocxZipper = DocxZipper;
exports.Editor = Editor;
exports.Extensions = Extensions;
exports.SectionHelpers = SectionHelpers;
exports.SuperConverter = SuperConverter;
exports.SuperEditor = SuperEditor;
exports.SuperInput = SuperInput;
exports.SuperToolbar = SuperToolbar;
exports.Toolbar = Toolbar;
exports.TrackChangesBasePluginKey = TrackChangesBasePluginKey;
exports._sfc_main = _sfc_main$h;
exports._sfc_main$4 = _sfc_main$4;
exports.createZip = createZip;
exports.getActiveFormatting = getActiveFormatting;
exports.getAllowedImageDimensions = getAllowedImageDimensions;
exports.getMarksFromSelection = getMarksFromSelection;
exports.getRichTextExtensions = getRichTextExtensions;
exports.getStarterExtensions = getStarterExtensions;
exports.helpers = helpers;
exports.index = index;
exports.index$1 = index$1;
